var zc = (e, t, n) => {
    if (!t.has(e))
        throw TypeError("Cannot " + n)
}
;
var pt = (e, t, n) => (zc(e, t, "read from private field"),
n ? n.call(e) : t.get(e))
  , mn = (e, t, n) => {
    if (t.has(e))
        throw TypeError("Cannot add the same private member more than once");
    t instanceof WeakSet ? t.add(e) : t.set(e, n)
}
  , xd = (e, t, n, a) => (zc(e, t, "write to private field"),
a ? a.call(e, n) : t.set(e, n),
n);
var Ii = (e, t, n) => (zc(e, t, "access private method"),
n);
(function() {
    const t = document.createElement("link").relList;
    if (t && t.supports && t.supports("modulepreload"))
        return;
    for (const r of document.querySelectorAll('link[rel="modulepreload"]'))
        a(r);
    new MutationObserver(r => {
        for (const o of r)
            if (o.type === "childList")
                for (const i of o.addedNodes)
                    i.tagName === "LINK" && i.rel === "modulepreload" && a(i)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function n(r) {
        const o = {};
        return r.integrity && (o.integrity = r.integrity),
        r.referrerPolicy && (o.referrerPolicy = r.referrerPolicy),
        r.crossOrigin === "use-credentials" ? o.credentials = "include" : r.crossOrigin === "anonymous" ? o.credentials = "omit" : o.credentials = "same-origin",
        o
    }
    function a(r) {
        if (r.ep)
            return;
        r.ep = !0;
        const o = n(r);
        fetch(r.href, o)
    }
}
)();
/**
* @vue/shared v3.4.8
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function Rs(e, t) {
    const n = new Set(e.split(","));
    return t ? a => n.has(a.toLowerCase()) : a => n.has(a)
}
const _t = {}
  , Qo = []
  , bn = () => {}
  , pm = () => !1
  , Ds = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97)
  , ju = e => e.startsWith("onUpdate:")
  , Ot = Object.assign
  , Uu = (e, t) => {
    const n = e.indexOf(t);
    n > -1 && e.splice(n, 1)
}
  , hm = Object.prototype.hasOwnProperty
  , Ct = (e, t) => hm.call(e, t)
  , Je = Array.isArray
  , ei = e => bi(e) === "[object Map]"
  , Eo = e => bi(e) === "[object Set]"
  , Td = e => bi(e) === "[object Date]"
  , mm = e => bi(e) === "[object RegExp]"
  , ot = e => typeof e == "function"
  , Pt = e => typeof e == "string"
  , zr = e => typeof e == "symbol"
  , kt = e => e !== null && typeof e == "object"
  , qu = e => (kt(e) || ot(e)) && ot(e.then) && ot(e.catch)
  , n0 = Object.prototype.toString
  , bi = e => n0.call(e)
  , gm = e => bi(e).slice(8, -1)
  , a0 = e => bi(e) === "[object Object]"
  , Wu = e => Pt(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e
  , as = Rs(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
const V1 = e => {
    const t = Object.create(null);
    return n => t[n] || (t[n] = e(n))
}
  , vm = /-(\w)/g
  , Cn = V1(e => e.replace(vm, (t, n) => n ? n.toUpperCase() : ""))
  , bm = /\B([A-Z])/g
  , Hn = V1(e => e.replace(bm, "-$1").toLowerCase())
  , Ns = V1(e => e.charAt(0).toUpperCase() + e.slice(1))
  , rs = V1(e => e ? `on${Ns(e)}` : "")
  , ya = (e, t) => !Object.is(e, t)
  , ti = (e, t) => {
    for (let n = 0; n < e.length; n++)
        e[n](t)
}
  , i1 = (e, t, n) => {
    Object.defineProperty(e, t, {
        configurable: !0,
        enumerable: !1,
        value: n
    })
}
  , s1 = e => {
    const t = parseFloat(e);
    return isNaN(t) ? e : t
}
  , l1 = e => {
    const t = Pt(e) ? Number(e) : NaN;
    return isNaN(t) ? e : t
}
;
let Md;
const Yu = () => Md || (Md = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
const ym = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error"
  , Cm = Rs(ym);
function Rt(e) {
    if (Je(e)) {
        const t = {};
        for (let n = 0; n < e.length; n++) {
            const a = e[n]
              , r = Pt(a) ? Sm(a) : Rt(a);
            if (r)
                for (const o in r)
                    t[o] = r[o]
        }
        return t
    } else if (Pt(e) || kt(e))
        return e
}
const wm = /;(?![^(]*\))/g
  , _m = /:([^]+)/
  , km = /\/\*[^]*?\*\//g;
function Sm(e) {
    const t = {};
    return e.replace(km, "").split(wm).forEach(n => {
        if (n) {
            const a = n.split(_m);
            a.length > 1 && (t[a[0].trim()] = a[1].trim())
        }
    }
    ),
    t
}
function Ae(e) {
    let t = "";
    if (Pt(e))
        t = e;
    else if (Je(e))
        for (let n = 0; n < e.length; n++) {
            const a = Ae(e[n]);
            a && (t += a + " ")
        }
    else if (kt(e))
        for (const n in e)
            e[n] && (t += n + " ");
    return t.trim()
}
function c1(e) {
    if (!e)
        return null;
    let {class: t, style: n} = e;
    return t && !Pt(t) && (e.class = Ae(t)),
    n && (e.style = Rt(n)),
    e
}
const r0 = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly"
  , $m = Rs(r0)
  , tU = Rs(r0 + ",async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected");
function o0(e) {
    return !!e || e === ""
}
function Em(e, t) {
    if (e.length !== t.length)
        return !1;
    let n = !0;
    for (let a = 0; n && a < e.length; a++)
        n = Ar(e[a], t[a]);
    return n
}
function Ar(e, t) {
    if (e === t)
        return !0;
    let n = Td(e)
      , a = Td(t);
    if (n || a)
        return n && a ? e.getTime() === t.getTime() : !1;
    if (n = zr(e),
    a = zr(t),
    n || a)
        return e === t;
    if (n = Je(e),
    a = Je(t),
    n || a)
        return n && a ? Em(e, t) : !1;
    if (n = kt(e),
    a = kt(t),
    n || a) {
        if (!n || !a)
            return !1;
        const r = Object.keys(e).length
          , o = Object.keys(t).length;
        if (r !== o)
            return !1;
        for (const i in e) {
            const s = e.hasOwnProperty(i)
              , l = t.hasOwnProperty(i);
            if (s && !l || !s && l || !Ar(e[i], t[i]))
                return !1
        }
    }
    return String(e) === String(t)
}
function F1(e, t) {
    return e.findIndex(n => Ar(n, t))
}
const Me = e => Pt(e) ? e : e == null ? "" : Je(e) || kt(e) && (e.toString === n0 || !ot(e.toString)) ? JSON.stringify(e, i0, 2) : String(e)
  , i0 = (e, t) => t && t.__v_isRef ? i0(e, t.value) : ei(t) ? {
    [`Map(${t.size})`]: [...t.entries()].reduce( (n, [a,r], o) => (n[Ac(a, o) + " =>"] = r,
    n), {})
} : Eo(t) ? {
    [`Set(${t.size})`]: [...t.values()].map(n => Ac(n))
} : zr(t) ? Ac(t) : kt(t) && !Je(t) && !a0(t) ? String(t) : t
  , Ac = (e, t="") => {
    var n;
    return zr(e) ? `Symbol(${(n = e.description) != null ? n : t})` : e
}
;
/**
* @vue/reactivity v3.4.8
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let Bn;
class Gu {
    constructor(t=!1) {
        this.detached = t,
        this._active = !0,
        this.effects = [],
        this.cleanups = [],
        this.parent = Bn,
        !t && Bn && (this.index = (Bn.scopes || (Bn.scopes = [])).push(this) - 1)
    }
    get active() {
        return this._active
    }
    run(t) {
        if (this._active) {
            const n = Bn;
            try {
                return Bn = this,
                t()
            } finally {
                Bn = n
            }
        }
    }
    on() {
        Bn = this
    }
    off() {
        Bn = this.parent
    }
    stop(t) {
        if (this._active) {
            let n, a;
            for (n = 0,
            a = this.effects.length; n < a; n++)
                this.effects[n].stop();
            for (n = 0,
            a = this.cleanups.length; n < a; n++)
                this.cleanups[n]();
            if (this.scopes)
                for (n = 0,
                a = this.scopes.length; n < a; n++)
                    this.scopes[n].stop(!0);
            if (!this.detached && this.parent && !t) {
                const r = this.parent.scopes.pop();
                r && r !== this && (this.parent.scopes[this.index] = r,
                r.index = this.index)
            }
            this.parent = void 0,
            this._active = !1
        }
    }
}
function Xu(e) {
    return new Gu(e)
}
function s0(e, t=Bn) {
    t && t.active && t.effects.push(e)
}
function Ku() {
    return Bn
}
function l0(e) {
    Bn && Bn.cleanups.push(e)
}
let lo;
class ui {
    constructor(t, n, a, r) {
        this.fn = t,
        this.trigger = n,
        this.scheduler = a,
        this.active = !0,
        this.deps = [],
        this._dirtyLevel = 3,
        this._trackId = 0,
        this._runnings = 0,
        this._queryings = 0,
        this._depsLength = 0,
        s0(this, r)
    }
    get dirty() {
        if (this._dirtyLevel === 1) {
            this._dirtyLevel = 0,
            this._queryings++,
            Vr();
            for (const t of this.deps)
                if (t.computed && (xm(t.computed),
                this._dirtyLevel >= 2))
                    break;
            Fr(),
            this._queryings--
        }
        return this._dirtyLevel >= 2
    }
    set dirty(t) {
        this._dirtyLevel = t ? 3 : 0
    }
    run() {
        if (this._dirtyLevel = 0,
        !this.active)
            return this.fn();
        let t = Mr
          , n = lo;
        try {
            return Mr = !0,
            lo = this,
            this._runnings++,
            zd(this),
            this.fn()
        } finally {
            Ad(this),
            this._runnings--,
            lo = n,
            Mr = t
        }
    }
    stop() {
        var t;
        this.active && (zd(this),
        Ad(this),
        (t = this.onStop) == null || t.call(this),
        this.active = !1)
    }
}
function xm(e) {
    return e.value
}
function zd(e) {
    e._trackId++,
    e._depsLength = 0
}
function Ad(e) {
    if (e.deps && e.deps.length > e._depsLength) {
        for (let t = e._depsLength; t < e.deps.length; t++)
            c0(e.deps[t], e);
        e.deps.length = e._depsLength
    }
}
function c0(e, t) {
    const n = e.get(t);
    n !== void 0 && t._trackId !== n && (e.delete(t),
    e.size === 0 && e.cleanup())
}
function Tm(e, t) {
    e.effect instanceof ui && (e = e.effect.fn);
    const n = new ui(e,bn, () => {
        n.dirty && n.run()
    }
    );
    t && (Ot(n, t),
    t.scope && s0(n, t.scope)),
    (!t || !t.lazy) && n.run();
    const a = n.run.bind(n);
    return a.effect = n,
    a
}
function Mm(e) {
    e.effect.stop()
}
let Mr = !0
  , _2 = 0;
const u0 = [];
function Vr() {
    u0.push(Mr),
    Mr = !1
}
function Fr() {
    const e = u0.pop();
    Mr = e === void 0 ? !0 : e
}
function Zu() {
    _2++
}
function Ju() {
    for (_2--; !_2 && k2.length; )
        k2.shift()()
}
function f0(e, t, n) {
    var a;
    if (t.get(e) !== e._trackId) {
        t.set(e, e._trackId);
        const r = e.deps[e._depsLength];
        r !== t ? (r && c0(r, e),
        e.deps[e._depsLength++] = t) : e._depsLength++
    }
}
const k2 = [];
function d0(e, t, n) {
    var a;
    Zu();
    for (const r of e.keys())
        if (!(!r.allowRecurse && r._runnings) && r._dirtyLevel < t && (!r._runnings || t !== 2)) {
            const o = r._dirtyLevel;
            r._dirtyLevel = t,
            o === 0 && (!r._queryings || t !== 2) && (r.trigger(),
            r.scheduler && k2.push(r.scheduler))
        }
    Ju()
}
const p0 = (e, t) => {
    const n = new Map;
    return n.cleanup = e,
    n.computed = t,
    n
}
  , u1 = new WeakMap
  , co = Symbol("")
  , S2 = Symbol("");
function Mn(e, t, n) {
    if (Mr && lo) {
        let a = u1.get(e);
        a || u1.set(e, a = new Map);
        let r = a.get(n);
        r || a.set(n, r = p0( () => a.delete(n))),
        f0(lo, r, void 0)
    }
}
function Qa(e, t, n, a, r, o) {
    const i = u1.get(e);
    if (!i)
        return;
    let s = [];
    if (t === "clear")
        s = [...i.values()];
    else if (n === "length" && Je(e)) {
        const l = Number(a);
        i.forEach( (c, u) => {
            (u === "length" || !zr(u) && u >= l) && s.push(c)
        }
        )
    } else
        switch (n !== void 0 && s.push(i.get(n)),
        t) {
        case "add":
            Je(e) ? Wu(n) && s.push(i.get("length")) : (s.push(i.get(co)),
            ei(e) && s.push(i.get(S2)));
            break;
        case "delete":
            Je(e) || (s.push(i.get(co)),
            ei(e) && s.push(i.get(S2)));
            break;
        case "set":
            ei(e) && s.push(i.get(co));
            break
        }
    Zu();
    for (const l of s)
        l && d0(l, 3, void 0);
    Ju()
}
function zm(e, t) {
    var n;
    return (n = u1.get(e)) == null ? void 0 : n.get(t)
}
const Am = Rs("__proto__,__v_isRef,__isVue")
  , h0 = new Set(Object.getOwnPropertyNames(Symbol).filter(e => e !== "arguments" && e !== "caller").map(e => Symbol[e]).filter(zr))
  , Od = Om();
function Om() {
    const e = {};
    return ["includes", "indexOf", "lastIndexOf"].forEach(t => {
        e[t] = function(...n) {
            const a = rt(this);
            for (let o = 0, i = this.length; o < i; o++)
                Mn(a, "get", o + "");
            const r = a[t](...n);
            return r === -1 || r === !1 ? a[t](...n.map(rt)) : r
        }
    }
    ),
    ["push", "pop", "shift", "unshift", "splice"].forEach(t => {
        e[t] = function(...n) {
            Vr(),
            Zu();
            const a = rt(this)[t].apply(this, n);
            return Ju(),
            Fr(),
            a
        }
    }
    ),
    e
}
function Pm(e) {
    const t = rt(this);
    return Mn(t, "has", e),
    t.hasOwnProperty(e)
}
class m0 {
    constructor(t=!1, n=!1) {
        this._isReadonly = t,
        this._shallow = n
    }
    get(t, n, a) {
        const r = this._isReadonly
          , o = this._shallow;
        if (n === "__v_isReactive")
            return !r;
        if (n === "__v_isReadonly")
            return r;
        if (n === "__v_isShallow")
            return o;
        if (n === "__v_raw")
            return a === (r ? o ? w0 : C0 : o ? y0 : b0).get(t) || Object.getPrototypeOf(t) === Object.getPrototypeOf(a) ? t : void 0;
        const i = Je(t);
        if (!r) {
            if (i && Ct(Od, n))
                return Reflect.get(Od, n, a);
            if (n === "hasOwnProperty")
                return Pm
        }
        const s = Reflect.get(t, n, a);
        return (zr(n) ? h0.has(n) : Am(n)) || (r || Mn(t, "get", n),
        o) ? s : Dt(s) ? i && Wu(n) ? s : s.value : kt(s) ? r ? tf(s) : Jn(s) : s
    }
}
class g0 extends m0 {
    constructor(t=!1) {
        super(!1, t)
    }
    set(t, n, a, r) {
        let o = t[n];
        if (!this._shallow) {
            const l = nr(o);
            if (!gs(a) && !nr(a) && (o = rt(o),
            a = rt(a)),
            !Je(t) && Dt(o) && !Dt(a))
                return l ? !1 : (o.value = a,
                !0)
        }
        const i = Je(t) && Wu(n) ? Number(n) < t.length : Ct(t, n)
          , s = Reflect.set(t, n, a, r);
        return t === rt(r) && (i ? ya(a, o) && Qa(t, "set", n, a, o) : Qa(t, "add", n, a)),
        s
    }
    deleteProperty(t, n) {
        const a = Ct(t, n)
          , r = t[n]
          , o = Reflect.deleteProperty(t, n);
        return o && a && Qa(t, "delete", n, void 0, r),
        o
    }
    has(t, n) {
        const a = Reflect.has(t, n);
        return (!zr(n) || !h0.has(n)) && Mn(t, "has", n),
        a
    }
    ownKeys(t) {
        return Mn(t, "iterate", Je(t) ? "length" : co),
        Reflect.ownKeys(t)
    }
}
class v0 extends m0 {
    constructor(t=!1) {
        super(!0, t)
    }
    set(t, n) {
        return !0
    }
    deleteProperty(t, n) {
        return !0
    }
}
const Lm = new g0
  , Im = new v0
  , Bm = new g0(!0)
  , Rm = new v0(!0)
  , Qu = e => e
  , j1 = e => Reflect.getPrototypeOf(e);
function hl(e, t, n=!1, a=!1) {
    e = e.__v_raw;
    const r = rt(e)
      , o = rt(t);
    n || (ya(t, o) && Mn(r, "get", t),
    Mn(r, "get", o));
    const {has: i} = j1(r)
      , s = a ? Qu : n ? af : vs;
    if (i.call(r, t))
        return s(e.get(t));
    if (i.call(r, o))
        return s(e.get(o));
    e !== r && e.get(t)
}
function ml(e, t=!1) {
    const n = this.__v_raw
      , a = rt(n)
      , r = rt(e);
    return t || (ya(e, r) && Mn(a, "has", e),
    Mn(a, "has", r)),
    e === r ? n.has(e) : n.has(e) || n.has(r)
}
function gl(e, t=!1) {
    return e = e.__v_raw,
    !t && Mn(rt(e), "iterate", co),
    Reflect.get(e, "size", e)
}
function Pd(e) {
    e = rt(e);
    const t = rt(this);
    return j1(t).has.call(t, e) || (t.add(e),
    Qa(t, "add", e, e)),
    this
}
function Ld(e, t) {
    t = rt(t);
    const n = rt(this)
      , {has: a, get: r} = j1(n);
    let o = a.call(n, e);
    o || (e = rt(e),
    o = a.call(n, e));
    const i = r.call(n, e);
    return n.set(e, t),
    o ? ya(t, i) && Qa(n, "set", e, t, i) : Qa(n, "add", e, t),
    this
}
function Id(e) {
    const t = rt(this)
      , {has: n, get: a} = j1(t);
    let r = n.call(t, e);
    r || (e = rt(e),
    r = n.call(t, e));
    const o = a ? a.call(t, e) : void 0
      , i = t.delete(e);
    return r && Qa(t, "delete", e, void 0, o),
    i
}
function Bd() {
    const e = rt(this)
      , t = e.size !== 0
      , n = void 0
      , a = e.clear();
    return t && Qa(e, "clear", void 0, void 0, n),
    a
}
function vl(e, t) {
    return function(a, r) {
        const o = this
          , i = o.__v_raw
          , s = rt(i)
          , l = t ? Qu : e ? af : vs;
        return !e && Mn(s, "iterate", co),
        i.forEach( (c, u) => a.call(r, l(c), l(u), o))
    }
}
function bl(e, t, n) {
    return function(...a) {
        const r = this.__v_raw
          , o = rt(r)
          , i = ei(o)
          , s = e === "entries" || e === Symbol.iterator && i
          , l = e === "keys" && i
          , c = r[e](...a)
          , u = n ? Qu : t ? af : vs;
        return !t && Mn(o, "iterate", l ? S2 : co),
        {
            next() {
                const {value: f, done: d} = c.next();
                return d ? {
                    value: f,
                    done: d
                } : {
                    value: s ? [u(f[0]), u(f[1])] : u(f),
                    done: d
                }
            },
            [Symbol.iterator]() {
                return this
            }
        }
    }
}
function gr(e) {
    return function(...t) {
        return e === "delete" ? !1 : e === "clear" ? void 0 : this
    }
}
function Dm() {
    const e = {
        get(o) {
            return hl(this, o)
        },
        get size() {
            return gl(this)
        },
        has: ml,
        add: Pd,
        set: Ld,
        delete: Id,
        clear: Bd,
        forEach: vl(!1, !1)
    }
      , t = {
        get(o) {
            return hl(this, o, !1, !0)
        },
        get size() {
            return gl(this)
        },
        has: ml,
        add: Pd,
        set: Ld,
        delete: Id,
        clear: Bd,
        forEach: vl(!1, !0)
    }
      , n = {
        get(o) {
            return hl(this, o, !0)
        },
        get size() {
            return gl(this, !0)
        },
        has(o) {
            return ml.call(this, o, !0)
        },
        add: gr("add"),
        set: gr("set"),
        delete: gr("delete"),
        clear: gr("clear"),
        forEach: vl(!0, !1)
    }
      , a = {
        get(o) {
            return hl(this, o, !0, !0)
        },
        get size() {
            return gl(this, !0)
        },
        has(o) {
            return ml.call(this, o, !0)
        },
        add: gr("add"),
        set: gr("set"),
        delete: gr("delete"),
        clear: gr("clear"),
        forEach: vl(!0, !0)
    };
    return ["keys", "values", "entries", Symbol.iterator].forEach(o => {
        e[o] = bl(o, !1, !1),
        n[o] = bl(o, !0, !1),
        t[o] = bl(o, !1, !0),
        a[o] = bl(o, !0, !0)
    }
    ),
    [e, n, t, a]
}
const [Nm,Hm,Vm,Fm] = Dm();
function U1(e, t) {
    const n = t ? e ? Fm : Vm : e ? Hm : Nm;
    return (a, r, o) => r === "__v_isReactive" ? !e : r === "__v_isReadonly" ? e : r === "__v_raw" ? a : Reflect.get(Ct(n, r) && r in a ? n : a, r, o)
}
const jm = {
    get: U1(!1, !1)
}
  , Um = {
    get: U1(!1, !0)
}
  , qm = {
    get: U1(!0, !1)
}
  , Wm = {
    get: U1(!0, !0)
};
const b0 = new WeakMap
  , y0 = new WeakMap
  , C0 = new WeakMap
  , w0 = new WeakMap;
function Ym(e) {
    switch (e) {
    case "Object":
    case "Array":
        return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
        return 2;
    default:
        return 0
    }
}
function Gm(e) {
    return e.__v_skip || !Object.isExtensible(e) ? 0 : Ym(gm(e))
}
function Jn(e) {
    return nr(e) ? e : q1(e, !1, Lm, jm, b0)
}
function ef(e) {
    return q1(e, !1, Bm, Um, y0)
}
function tf(e) {
    return q1(e, !0, Im, qm, C0)
}
function Xm(e) {
    return q1(e, !0, Rm, Wm, w0)
}
function q1(e, t, n, a, r) {
    if (!kt(e) || e.__v_raw && !(t && e.__v_isReactive))
        return e;
    const o = r.get(e);
    if (o)
        return o;
    const i = Gm(e);
    if (i === 0)
        return e;
    const s = new Proxy(e,i === 2 ? a : n);
    return r.set(e, s),
    s
}
function La(e) {
    return nr(e) ? La(e.__v_raw) : !!(e && e.__v_isReactive)
}
function nr(e) {
    return !!(e && e.__v_isReadonly)
}
function gs(e) {
    return !!(e && e.__v_isShallow)
}
function nf(e) {
    return La(e) || nr(e)
}
function rt(e) {
    const t = e && e.__v_raw;
    return t ? rt(t) : e
}
function ga(e) {
    return i1(e, "__v_skip", !0),
    e
}
const vs = e => kt(e) ? Jn(e) : e
  , af = e => kt(e) ? tf(e) : e;
class _0 {
    constructor(t, n, a, r) {
        this._setter = n,
        this.dep = void 0,
        this.__v_isRef = !0,
        this.__v_isReadonly = !1,
        this.effect = new ui( () => t(this._value), () => bs(this, 1)),
        this.effect.computed = this,
        this.effect.active = this._cacheable = !r,
        this.__v_isReadonly = a
    }
    get value() {
        const t = rt(this);
        return rf(t),
        (!t._cacheable || t.effect.dirty) && ya(t._value, t._value = t.effect.run()) && bs(t, 2),
        t._value
    }
    set value(t) {
        this._setter(t)
    }
    get _dirty() {
        return this.effect.dirty
    }
    set _dirty(t) {
        this.effect.dirty = t
    }
}
function Km(e, t, n=!1) {
    let a, r;
    const o = ot(e);
    return o ? (a = e,
    r = bn) : (a = e.get,
    r = e.set),
    new _0(a,r,o || !r,n)
}
function rf(e) {
    Mr && lo && (e = rt(e),
    f0(lo, e.dep || (e.dep = p0( () => e.dep = void 0, e instanceof _0 ? e : void 0)), void 0))
}
function bs(e, t=3, n) {
    e = rt(e);
    const a = e.dep;
    a && d0(a, t, void 0)
}
function Dt(e) {
    return !!(e && e.__v_isRef === !0)
}
function oe(e) {
    return k0(e, !1)
}
function Zm(e) {
    return k0(e, !0)
}
function k0(e, t) {
    return Dt(e) ? e : new Jm(e,t)
}
class Jm {
    constructor(t, n) {
        this.__v_isShallow = n,
        this.dep = void 0,
        this.__v_isRef = !0,
        this._rawValue = n ? t : rt(t),
        this._value = n ? t : vs(t)
    }
    get value() {
        return rf(this),
        this._value
    }
    set value(t) {
        const n = this.__v_isShallow || gs(t) || nr(t);
        t = n ? t : rt(t),
        ya(t, this._rawValue) && (this._rawValue = t,
        this._value = n ? t : vs(t),
        bs(this, 3, t))
    }
}
function Qm(e) {
    bs(e, 3, void 0)
}
function B(e) {
    return Dt(e) ? e.value : e
}
function e9(e) {
    return ot(e) ? e() : B(e)
}
const t9 = {
    get: (e, t, n) => B(Reflect.get(e, t, n)),
    set: (e, t, n, a) => {
        const r = e[t];
        return Dt(r) && !Dt(n) ? (r.value = n,
        !0) : Reflect.set(e, t, n, a)
    }
};
function of(e) {
    return La(e) ? e : new Proxy(e,t9)
}
class n9 {
    constructor(t) {
        this.dep = void 0,
        this.__v_isRef = !0;
        const {get: n, set: a} = t( () => rf(this), () => bs(this));
        this._get = n,
        this._set = a
    }
    get value() {
        return this._get()
    }
    set value(t) {
        this._set(t)
    }
}
function S0(e) {
    return new n9(e)
}
function $0(e) {
    const t = Je(e) ? new Array(e.length) : {};
    for (const n in e)
        t[n] = E0(e, n);
    return t
}
class a9 {
    constructor(t, n, a) {
        this._object = t,
        this._key = n,
        this._defaultValue = a,
        this.__v_isRef = !0
    }
    get value() {
        const t = this._object[this._key];
        return t === void 0 ? this._defaultValue : t
    }
    set value(t) {
        this._object[this._key] = t
    }
    get dep() {
        return zm(rt(this._object), this._key)
    }
}
class r9 {
    constructor(t) {
        this._getter = t,
        this.__v_isRef = !0,
        this.__v_isReadonly = !0
    }
    get value() {
        return this._getter()
    }
}
function o9(e, t, n) {
    return Dt(e) ? e : ot(e) ? new r9(e) : kt(e) && arguments.length > 1 ? E0(e, t, n) : oe(e)
}
function E0(e, t, n) {
    const a = e[t];
    return Dt(a) ? a : new a9(e,t,n)
}
const i9 = {
    GET: "get",
    HAS: "has",
    ITERATE: "iterate"
}
  , s9 = {
    SET: "set",
    ADD: "add",
    DELETE: "delete",
    CLEAR: "clear"
};
/**
* @vue/runtime-core v3.4.8
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const os = [];
function $a(e, ...t) {
    Vr();
    const n = os.length ? os[os.length - 1].component : null
      , a = n && n.appContext.config.warnHandler
      , r = l9();
    if (a)
        Ia(a, n, 11, [e + t.join(""), n && n.proxy, r.map( ({vnode: o}) => `at <${k5(n, o.type)}>`).join(`
`), r]);
    else {
        const o = [`[Vue warn]: ${e}`, ...t];
        r.length && o.push(`
`, ...c9(r)),
        console.warn(...o)
    }
    Fr()
}
function l9() {
    let e = os[os.length - 1];
    if (!e)
        return [];
    const t = [];
    for (; e; ) {
        const n = t[0];
        n && n.vnode === e ? n.recurseCount++ : t.push({
            vnode: e,
            recurseCount: 0
        });
        const a = e.component && e.component.parent;
        e = a && a.vnode
    }
    return t
}
function c9(e) {
    const t = [];
    return e.forEach( (n, a) => {
        t.push(...a === 0 ? [] : [`
`], ...u9(n))
    }
    ),
    t
}
function u9({vnode: e, recurseCount: t}) {
    const n = t > 0 ? `... (${t} recursive calls)` : ""
      , a = e.component ? e.component.parent == null : !1
      , r = ` at <${k5(e.component, e.type, a)}`
      , o = ">" + n;
    return e.props ? [r, ...f9(e.props), o] : [r + o]
}
function f9(e) {
    const t = []
      , n = Object.keys(e);
    return n.slice(0, 3).forEach(a => {
        t.push(...x0(a, e[a]))
    }
    ),
    n.length > 3 && t.push(" ..."),
    t
}
function x0(e, t, n) {
    return Pt(t) ? (t = JSON.stringify(t),
    n ? t : [`${e}=${t}`]) : typeof t == "number" || typeof t == "boolean" || t == null ? n ? t : [`${e}=${t}`] : Dt(t) ? (t = x0(e, rt(t.value), !0),
    n ? t : [`${e}=Ref<`, t, ">"]) : ot(t) ? [`${e}=fn${t.name ? `<${t.name}>` : ""}`] : (t = rt(t),
    n ? t : [`${e}=`, t])
}
function d9(e, t) {}
const p9 = {
    SETUP_FUNCTION: 0,
    0: "SETUP_FUNCTION",
    RENDER_FUNCTION: 1,
    1: "RENDER_FUNCTION",
    WATCH_GETTER: 2,
    2: "WATCH_GETTER",
    WATCH_CALLBACK: 3,
    3: "WATCH_CALLBACK",
    WATCH_CLEANUP: 4,
    4: "WATCH_CLEANUP",
    NATIVE_EVENT_HANDLER: 5,
    5: "NATIVE_EVENT_HANDLER",
    COMPONENT_EVENT_HANDLER: 6,
    6: "COMPONENT_EVENT_HANDLER",
    VNODE_HOOK: 7,
    7: "VNODE_HOOK",
    DIRECTIVE_HOOK: 8,
    8: "DIRECTIVE_HOOK",
    TRANSITION_HOOK: 9,
    9: "TRANSITION_HOOK",
    APP_ERROR_HANDLER: 10,
    10: "APP_ERROR_HANDLER",
    APP_WARN_HANDLER: 11,
    11: "APP_WARN_HANDLER",
    FUNCTION_REF: 12,
    12: "FUNCTION_REF",
    ASYNC_COMPONENT_LOADER: 13,
    13: "ASYNC_COMPONENT_LOADER",
    SCHEDULER: 14,
    14: "SCHEDULER"
}
  , h9 = {
    sp: "serverPrefetch hook",
    bc: "beforeCreate hook",
    c: "created hook",
    bm: "beforeMount hook",
    m: "mounted hook",
    bu: "beforeUpdate hook",
    u: "updated",
    bum: "beforeUnmount hook",
    um: "unmounted hook",
    a: "activated hook",
    da: "deactivated hook",
    ec: "errorCaptured hook",
    rtc: "renderTracked hook",
    rtg: "renderTriggered hook",
    [0]: "setup function",
    [1]: "render function",
    [2]: "watcher getter",
    [3]: "watcher callback",
    [4]: "watcher cleanup function",
    [5]: "native event handler",
    [6]: "component event handler",
    [7]: "vnode hook",
    [8]: "directive hook",
    [9]: "transition hook",
    [10]: "app errorHandler",
    [11]: "app warnHandler",
    [12]: "ref function",
    [13]: "async component loader",
    [14]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://github.com/vuejs/core ."
};
function Ia(e, t, n, a) {
    let r;
    try {
        r = a ? e(...a) : e()
    } catch (o) {
        xo(o, t, n)
    }
    return r
}
function Fn(e, t, n, a) {
    if (ot(e)) {
        const o = Ia(e, t, n, a);
        return o && qu(o) && o.catch(i => {
            xo(i, t, n)
        }
        ),
        o
    }
    const r = [];
    for (let o = 0; o < e.length; o++)
        r.push(Fn(e[o], t, n, a));
    return r
}
function xo(e, t, n, a=!0) {
    const r = t ? t.vnode : null;
    if (t) {
        let o = t.parent;
        const i = t.proxy
          , s = `https://vuejs.org/errors/#runtime-${n}`;
        for (; o; ) {
            const c = o.ec;
            if (c) {
                for (let u = 0; u < c.length; u++)
                    if (c[u](e, i, s) === !1)
                        return
            }
            o = o.parent
        }
        const l = t.appContext.config.errorHandler;
        if (l) {
            Ia(l, null, 10, [e, i, s]);
            return
        }
    }
    m9(e, n, r, a)
}
function m9(e, t, n, a=!0) {
    console.error(e)
}
let ys = !1
  , $2 = !1;
const vn = [];
let za = 0;
const ni = [];
let _r = null
  , to = 0;
const T0 = Promise.resolve();
let sf = null;
function Zn(e) {
    const t = sf || T0;
    return e ? t.then(this ? e.bind(this) : e) : t
}
function g9(e) {
    let t = za + 1
      , n = vn.length;
    for (; t < n; ) {
        const a = t + n >>> 1
          , r = vn[a]
          , o = Cs(r);
        o < e || o === e && r.pre ? t = a + 1 : n = a
    }
    return t
}
function W1(e) {
    (!vn.length || !vn.includes(e, ys && e.allowRecurse ? za + 1 : za)) && (e.id == null ? vn.push(e) : vn.splice(g9(e.id), 0, e),
    M0())
}
function M0() {
    !ys && !$2 && ($2 = !0,
    sf = T0.then(z0))
}
function v9(e) {
    const t = vn.indexOf(e);
    t > za && vn.splice(t, 1)
}
function f1(e) {
    Je(e) ? ni.push(...e) : (!_r || !_r.includes(e, e.allowRecurse ? to + 1 : to)) && ni.push(e),
    M0()
}
function Rd(e, t, n=ys ? za + 1 : 0) {
    for (; n < vn.length; n++) {
        const a = vn[n];
        if (a && a.pre) {
            if (e && a.id !== e.uid)
                continue;
            vn.splice(n, 1),
            n--,
            a()
        }
    }
}
function d1(e) {
    if (ni.length) {
        const t = [...new Set(ni)].sort( (n, a) => Cs(n) - Cs(a));
        if (ni.length = 0,
        _r) {
            _r.push(...t);
            return
        }
        for (_r = t,
        to = 0; to < _r.length; to++)
            _r[to]();
        _r = null,
        to = 0
    }
}
const Cs = e => e.id == null ? 1 / 0 : e.id
  , b9 = (e, t) => {
    const n = Cs(e) - Cs(t);
    if (n === 0) {
        if (e.pre && !t.pre)
            return -1;
        if (t.pre && !e.pre)
            return 1
    }
    return n
}
;
function z0(e) {
    $2 = !1,
    ys = !0,
    vn.sort(b9);
    const t = bn;
    try {
        for (za = 0; za < vn.length; za++) {
            const n = vn[za];
            n && n.active !== !1 && Ia(n, null, 14)
        }
    } finally {
        za = 0,
        vn.length = 0,
        d1(e),
        ys = !1,
        sf = null,
        (vn.length || ni.length) && z0(e)
    }
}
function y9(e, t, ...n) {
    if (e.isUnmounted)
        return;
    const a = e.vnode.props || _t;
    let r = n;
    const o = t.startsWith("update:")
      , i = o && t.slice(7);
    if (i && i in a) {
        const u = `${i === "modelValue" ? "model" : i}Modifiers`
          , {number: f, trim: d} = a[u] || _t;
        d && (r = n.map(p => Pt(p) ? p.trim() : p)),
        f && (r = n.map(s1))
    }
    let s, l = a[s = rs(t)] || a[s = rs(Cn(t))];
    !l && o && (l = a[s = rs(Hn(t))]),
    l && Fn(l, e, 6, r);
    const c = a[s + "Once"];
    if (c) {
        if (!e.emitted)
            e.emitted = {};
        else if (e.emitted[s])
            return;
        e.emitted[s] = !0,
        Fn(c, e, 6, r)
    }
}
function A0(e, t, n=!1) {
    const a = t.emitsCache
      , r = a.get(e);
    if (r !== void 0)
        return r;
    const o = e.emits;
    let i = {}
      , s = !1;
    if (!ot(e)) {
        const l = c => {
            const u = A0(c, t, !0);
            u && (s = !0,
            Ot(i, u))
        }
        ;
        !n && t.mixins.length && t.mixins.forEach(l),
        e.extends && l(e.extends),
        e.mixins && e.mixins.forEach(l)
    }
    return !o && !s ? (kt(e) && a.set(e, null),
    null) : (Je(o) ? o.forEach(l => i[l] = null) : Ot(i, o),
    kt(e) && a.set(e, i),
    i)
}
function Y1(e, t) {
    return !e || !Ds(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""),
    Ct(e, t[0].toLowerCase() + t.slice(1)) || Ct(e, Hn(t)) || Ct(e, t))
}
let Zt = null
  , G1 = null;
function ws(e) {
    const t = Zt;
    return Zt = e,
    G1 = e && e.type.__scopeId || null,
    t
}
function qt(e) {
    G1 = e
}
function Wt() {
    G1 = null
}
const O0 = e => k;
function k(e, t=Zt, n) {
    if (!t || e._n)
        return e;
    const a = (...r) => {
        a._d && P2(-1);
        const o = ws(t);
        let i;
        try {
            i = e(...r)
        } finally {
            ws(o),
            a._d && P2(1)
        }
        return i
    }
    ;
    return a._n = !0,
    a._c = !0,
    a._d = !0,
    a
}
function Fl(e) {
    const {type: t, vnode: n, proxy: a, withProxy: r, props: o, propsOptions: [i], slots: s, attrs: l, emit: c, render: u, renderCache: f, data: d, setupState: p, ctx: h, inheritAttrs: m} = e;
    let g, b;
    const v = ws(e);
    try {
        if (n.shapeFlag & 4) {
            const C = r || a
              , _ = C;
            g = Dn(u.call(_, C, f, o, p, d, h)),
            b = l
        } else {
            const C = t;
            g = Dn(C.length > 1 ? C(o, {
                attrs: l,
                slots: s,
                emit: c
            }) : C(o, null)),
            b = t.props ? l : w9(l)
        }
    } catch (C) {
        ls.length = 0,
        xo(C, e, 1),
        g = S(pn)
    }
    let y = g, w;
    if (b && m !== !1) {
        const C = Object.keys(b)
          , {shapeFlag: _} = y;
        C.length && _ & 7 && (i && C.some(ju) && (b = _9(b, i)),
        y = Da(y, b))
    }
    return n.dirs && (y = Da(y),
    y.dirs = y.dirs ? y.dirs.concat(n.dirs) : n.dirs),
    n.transition && (y.transition = n.transition),
    g = y,
    ws(v),
    g
}
function C9(e) {
    let t;
    for (let n = 0; n < e.length; n++) {
        const a = e[n];
        if (Or(a)) {
            if (a.type !== pn || a.children === "v-if") {
                if (t)
                    return;
                t = a
            }
        } else
            return
    }
    return t
}
const w9 = e => {
    let t;
    for (const n in e)
        (n === "class" || n === "style" || Ds(n)) && ((t || (t = {}))[n] = e[n]);
    return t
}
  , _9 = (e, t) => {
    const n = {};
    for (const a in e)
        (!ju(a) || !(a.slice(9)in t)) && (n[a] = e[a]);
    return n
}
;
function k9(e, t, n) {
    const {props: a, children: r, component: o} = e
      , {props: i, children: s, patchFlag: l} = t
      , c = o.emitsOptions;
    if (t.dirs || t.transition)
        return !0;
    if (n && l >= 0) {
        if (l & 1024)
            return !0;
        if (l & 16)
            return a ? Dd(a, i, c) : !!i;
        if (l & 8) {
            const u = t.dynamicProps;
            for (let f = 0; f < u.length; f++) {
                const d = u[f];
                if (i[d] !== a[d] && !Y1(c, d))
                    return !0
            }
        }
    } else
        return (r || s) && (!s || !s.$stable) ? !0 : a === i ? !1 : a ? i ? Dd(a, i, c) : !0 : !!i;
    return !1
}
function Dd(e, t, n) {
    const a = Object.keys(t);
    if (a.length !== Object.keys(e).length)
        return !0;
    for (let r = 0; r < a.length; r++) {
        const o = a[r];
        if (t[o] !== e[o] && !Y1(n, o))
            return !0
    }
    return !1
}
function lf({vnode: e, parent: t}, n) {
    for (; t; ) {
        const a = t.subTree;
        if (a.suspense && a.suspense.activeBranch === e && (a.el = e.el),
        a === e)
            (e = t.vnode).el = n,
            t = t.parent;
        else
            break
    }
}
const cf = "components"
  , S9 = "directives";
function P(e, t) {
    return uf(cf, e, !0, t) || e
}
const P0 = Symbol.for("v-ndc");
function jn(e) {
    return Pt(e) ? uf(cf, e, !1) || e : e || P0
}
function Hs(e) {
    return uf(S9, e)
}
function uf(e, t, n=!0, a=!1) {
    const r = Zt || nn;
    if (r) {
        const o = r.type;
        if (e === cf) {
            const s = v1(o, !1);
            if (s && (s === t || s === Cn(t) || s === Ns(Cn(t))))
                return o
        }
        const i = Nd(r[e] || o[e], t) || Nd(r.appContext[e], t);
        return !i && a ? o : i
    }
}
function Nd(e, t) {
    return e && (e[t] || e[Cn(t)] || e[Ns(Cn(t))])
}
const L0 = e => e.__isSuspense;
let E2 = 0;
const $9 = {
    name: "Suspense",
    __isSuspense: !0,
    process(e, t, n, a, r, o, i, s, l, c) {
        e == null ? x9(t, n, a, r, o, i, s, l, c) : T9(e, t, n, a, r, i, s, l, c)
    },
    hydrate: M9,
    create: ff,
    normalize: z9
}
  , E9 = $9;
function _s(e, t) {
    const n = e.props && e.props[t];
    ot(n) && n()
}
function x9(e, t, n, a, r, o, i, s, l) {
    const {p: c, o: {createElement: u}} = l
      , f = u("div")
      , d = e.suspense = ff(e, r, a, t, f, n, o, i, s, l);
    c(null, d.pendingBranch = e.ssContent, f, null, a, d, o, i),
    d.deps > 0 ? (_s(e, "onPending"),
    _s(e, "onFallback"),
    c(null, e.ssFallback, t, n, a, null, o, i),
    ai(d, e.ssFallback)) : d.resolve(!1, !0)
}
function T9(e, t, n, a, r, o, i, s, {p: l, um: c, o: {createElement: u}}) {
    const f = t.suspense = e.suspense;
    f.vnode = t,
    t.el = e.el;
    const d = t.ssContent
      , p = t.ssFallback
      , {activeBranch: h, pendingBranch: m, isInFallback: g, isHydrating: b} = f;
    if (m)
        f.pendingBranch = d,
        ha(d, m) ? (l(m, d, f.hiddenContainer, null, r, f, o, i, s),
        f.deps <= 0 ? f.resolve() : g && (b || (l(h, p, n, a, r, null, o, i, s),
        ai(f, p)))) : (f.pendingId = E2++,
        b ? (f.isHydrating = !1,
        f.activeBranch = m) : c(m, r, f),
        f.deps = 0,
        f.effects.length = 0,
        f.hiddenContainer = u("div"),
        g ? (l(null, d, f.hiddenContainer, null, r, f, o, i, s),
        f.deps <= 0 ? f.resolve() : (l(h, p, n, a, r, null, o, i, s),
        ai(f, p))) : h && ha(d, h) ? (l(h, d, n, a, r, f, o, i, s),
        f.resolve(!0)) : (l(null, d, f.hiddenContainer, null, r, f, o, i, s),
        f.deps <= 0 && f.resolve()));
    else if (h && ha(d, h))
        l(h, d, n, a, r, f, o, i, s),
        ai(f, d);
    else if (_s(t, "onPending"),
    f.pendingBranch = d,
    d.shapeFlag & 512 ? f.pendingId = d.component.suspenseId : f.pendingId = E2++,
    l(null, d, f.hiddenContainer, null, r, f, o, i, s),
    f.deps <= 0)
        f.resolve();
    else {
        const {timeout: v, pendingId: y} = f;
        v > 0 ? setTimeout( () => {
            f.pendingId === y && f.fallback(p)
        }
        , v) : v === 0 && f.fallback(p)
    }
}
function ff(e, t, n, a, r, o, i, s, l, c, u=!1) {
    const {p: f, m: d, um: p, n: h, o: {parentNode: m, remove: g}} = c;
    let b;
    const v = A9(e);
    v && t != null && t.pendingBranch && (b = t.pendingId,
    t.deps++);
    const y = e.props ? l1(e.props.timeout) : void 0
      , w = o
      , C = {
        vnode: e,
        parent: t,
        parentComponent: n,
        namespace: i,
        container: a,
        hiddenContainer: r,
        deps: 0,
        pendingId: E2++,
        timeout: typeof y == "number" ? y : -1,
        activeBranch: null,
        pendingBranch: null,
        isInFallback: !u,
        isHydrating: u,
        isUnmounted: !1,
        effects: [],
        resolve(_=!1, E=!1) {
            const {vnode: z, activeBranch: T, pendingBranch: A, pendingId: x, effects: M, parentComponent: L, container: U} = C;
            let Y = !1;
            C.isHydrating ? C.isHydrating = !1 : _ || (Y = T && A.transition && A.transition.mode === "out-in",
            Y && (T.transition.afterLeave = () => {
                x === C.pendingId && (d(A, U, o === w ? h(T) : o, 0),
                f1(M))
            }
            ),
            T && (m(T.el) !== C.hiddenContainer && (o = h(T)),
            p(T, L, C, !0)),
            Y || d(A, U, o, 0)),
            ai(C, A),
            C.pendingBranch = null,
            C.isInFallback = !1;
            let H = C.parent
              , W = !1;
            for (; H; ) {
                if (H.pendingBranch) {
                    H.effects.push(...M),
                    W = !0;
                    break
                }
                H = H.parent
            }
            !W && !Y && f1(M),
            C.effects = [],
            v && t && t.pendingBranch && b === t.pendingId && (t.deps--,
            t.deps === 0 && !E && t.resolve()),
            _s(z, "onResolve")
        },
        fallback(_) {
            if (!C.pendingBranch)
                return;
            const {vnode: E, activeBranch: z, parentComponent: T, container: A, namespace: x} = C;
            _s(E, "onFallback");
            const M = h(z)
              , L = () => {
                C.isInFallback && (f(null, _, A, M, T, null, x, s, l),
                ai(C, _))
            }
              , U = _.transition && _.transition.mode === "out-in";
            U && (z.transition.afterLeave = L),
            C.isInFallback = !0,
            p(z, T, null, !0),
            U || L()
        },
        move(_, E, z) {
            C.activeBranch && d(C.activeBranch, _, E, z),
            C.container = _
        },
        next() {
            return C.activeBranch && h(C.activeBranch)
        },
        registerDep(_, E) {
            const z = !!C.pendingBranch;
            z && C.deps++;
            const T = _.vnode.el;
            _.asyncDep.catch(A => {
                xo(A, _, 0)
            }
            ).then(A => {
                if (_.isUnmounted || C.isUnmounted || C.pendingId !== _.suspenseId)
                    return;
                _.asyncResolved = !0;
                const {vnode: x} = _;
                B2(_, A, !1),
                T && (x.el = T);
                const M = !T && _.subTree.el;
                E(_, x, m(T || _.subTree.el), T ? null : h(_.subTree), C, i, l),
                M && g(M),
                lf(_, x.el),
                z && --C.deps === 0 && C.resolve()
            }
            )
        },
        unmount(_, E) {
            C.isUnmounted = !0,
            C.activeBranch && p(C.activeBranch, n, _, E),
            C.pendingBranch && p(C.pendingBranch, n, _, E)
        }
    };
    return C
}
function M9(e, t, n, a, r, o, i, s, l) {
    const c = t.suspense = ff(t, a, n, e.parentNode, document.createElement("div"), null, r, o, i, s, !0)
      , u = l(e, c.pendingBranch = t.ssContent, n, c, o, i);
    return c.deps === 0 && c.resolve(!1, !0),
    u
}
function z9(e) {
    const {shapeFlag: t, children: n} = e
      , a = t & 32;
    e.ssContent = Hd(a ? n.default : n),
    e.ssFallback = a ? Hd(n.fallback) : S(pn)
}
function Hd(e) {
    let t;
    if (ot(e)) {
        const n = Co && e._c;
        n && (e._d = !1,
        O()),
        e = e(),
        n && (e._d = !0,
        t = En,
        m5())
    }
    return Je(e) && (e = C9(e)),
    e = Dn(e),
    t && !e.dynamicChildren && (e.dynamicChildren = t.filter(n => n !== e)),
    e
}
function I0(e, t) {
    t && t.pendingBranch ? Je(e) ? t.effects.push(...e) : t.effects.push(e) : f1(e)
}
function ai(e, t) {
    e.activeBranch = t;
    const {vnode: n, parentComponent: a} = e;
    let r = t.el;
    for (; !r && t.component; )
        t = t.component.subTree,
        r = t.el;
    n.el = r,
    a && a.subTree === n && (a.vnode.el = r,
    lf(a, r))
}
function A9(e) {
    var t;
    return ((t = e.props) == null ? void 0 : t.suspensible) != null && e.props.suspensible !== !1
}
const B0 = Symbol.for("v-scx")
  , R0 = () => {
    {
        const e = Qn(B0);
        return e
    }
}
;
function df(e, t) {
    return Vs(e, null, t)
}
function D0(e, t) {
    return Vs(e, null, {
        flush: "post"
    })
}
function N0(e, t) {
    return Vs(e, null, {
        flush: "sync"
    })
}
const yl = {};
function st(e, t, n) {
    return Vs(e, t, n)
}
function Vs(e, t, {immediate: n, deep: a, flush: r, once: o, onTrack: i, onTrigger: s}=_t) {
    if (t && o) {
        const E = t;
        t = (...z) => {
            E(...z),
            _()
        }
    }
    const l = E => {
        $a("Invalid watch source: ", E, "A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.")
    }
      , c = nn
      , u = E => a === !0 ? E : ao(E, a === !1 ? 1 : void 0);
    let f, d = !1, p = !1;
    if (Dt(e) ? (f = () => e.value,
    d = gs(e)) : La(e) ? (f = () => u(e),
    d = !0) : Je(e) ? (p = !0,
    d = e.some(E => La(E) || gs(E)),
    f = () => e.map(E => {
        if (Dt(E))
            return E.value;
        if (La(E))
            return u(E);
        if (ot(E))
            return Ia(E, c, 2)
    }
    )) : ot(e) ? t ? f = () => Ia(e, c, 2) : f = () => (h && h(),
    Fn(e, c, 3, [m])) : f = bn,
    t && a) {
        const E = f;
        f = () => ao(E())
    }
    let h, m = E => {
        h = w.onStop = () => {
            Ia(E, c, 4),
            h = w.onStop = void 0
        }
    }
    , g;
    if (Us)
        if (m = bn,
        t ? n && Fn(t, c, 3, [f(), p ? [] : void 0, m]) : f(),
        r === "sync") {
            const E = R0();
            g = E.__watcherHandles || (E.__watcherHandles = [])
        } else
            return bn;
    let b = p ? new Array(e.length).fill(yl) : yl;
    const v = () => {
        if (!(!w.active || !w.dirty))
            if (t) {
                const E = w.run();
                (a || d || (p ? E.some( (z, T) => ya(z, b[T])) : ya(E, b))) && (h && h(),
                Fn(t, c, 3, [E, b === yl ? void 0 : p && b[0] === yl ? [] : b, m]),
                b = E)
            } else
                w.run()
    }
    ;
    v.allowRecurse = !!t;
    let y;
    r === "sync" ? y = v : r === "post" ? y = () => dn(v, c && c.suspense) : (v.pre = !0,
    c && (v.id = c.uid),
    y = () => W1(v));
    const w = new ui(f,bn,y)
      , C = Ku()
      , _ = () => {
        w.stop(),
        C && Uu(C.effects, w)
    }
    ;
    return t ? n ? v() : b = w.run() : r === "post" ? dn(w.run.bind(w), c && c.suspense) : w.run(),
    g && g.push(_),
    _
}
function O9(e, t, n) {
    const a = this.proxy
      , r = Pt(e) ? e.includes(".") ? H0(a, e) : () => a[e] : e.bind(a, a);
    let o;
    ot(t) ? o = t : (o = t.handler,
    n = t);
    const i = wo(this)
      , s = Vs(r, o.bind(a), n);
    return i(),
    s
}
function H0(e, t) {
    const n = t.split(".");
    return () => {
        let a = e;
        for (let r = 0; r < n.length && a; r++)
            a = a[n[r]];
        return a
    }
}
function ao(e, t, n=0, a) {
    if (!kt(e) || e.__v_skip)
        return e;
    if (t && t > 0) {
        if (n >= t)
            return e;
        n++
    }
    if (a = a || new Set,
    a.has(e))
        return e;
    if (a.add(e),
    Dt(e))
        ao(e.value, t, n, a);
    else if (Je(e))
        for (let r = 0; r < e.length; r++)
            ao(e[r], t, n, a);
    else if (Eo(e) || ei(e))
        e.forEach(r => {
            ao(r, t, n, a)
        }
        );
    else if (a0(e))
        for (const r in e)
            ao(e[r], t, n, a);
    return e
}
function Fs(e, t) {
    if (Zt === null)
        return e;
    const n = ec(Zt) || Zt.proxy
      , a = e.dirs || (e.dirs = []);
    for (let r = 0; r < t.length; r++) {
        let[o,i,s,l=_t] = t[r];
        o && (ot(o) && (o = {
            mounted: o,
            updated: o
        }),
        o.deep && ao(i),
        a.push({
            dir: o,
            instance: n,
            value: i,
            oldValue: void 0,
            arg: s,
            modifiers: l
        }))
    }
    return e
}
function Ea(e, t, n, a) {
    const r = e.dirs
      , o = t && t.dirs;
    for (let i = 0; i < r.length; i++) {
        const s = r[i];
        o && (s.oldValue = o[i].value);
        let l = s.dir[a];
        l && (Vr(),
        Fn(l, n, 8, [e.el, s, e, t]),
        Fr())
    }
}
const kr = Symbol("_leaveCb")
  , Cl = Symbol("_enterCb");
function pf() {
    const e = {
        isMounted: !1,
        isLeaving: !1,
        isUnmounting: !1,
        leavingVNodes: new Map
    };
    return Xe( () => {
        e.isMounted = !0
    }
    ),
    lt( () => {
        e.isUnmounting = !0
    }
    ),
    e
}
const Gn = [Function, Array]
  , hf = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: Gn,
    onEnter: Gn,
    onAfterEnter: Gn,
    onEnterCancelled: Gn,
    onBeforeLeave: Gn,
    onLeave: Gn,
    onAfterLeave: Gn,
    onLeaveCancelled: Gn,
    onBeforeAppear: Gn,
    onAppear: Gn,
    onAfterAppear: Gn,
    onAppearCancelled: Gn
}
  , P9 = {
    name: "BaseTransition",
    props: hf,
    setup(e, {slots: t}) {
        const n = Ha()
          , a = pf();
        let r;
        return () => {
            const o = t.default && X1(t.default(), !0);
            if (!o || !o.length)
                return;
            let i = o[0];
            if (o.length > 1) {
                let m = !1;
                for (const g of o)
                    if (g.type !== pn) {
                        i = g,
                        m = !0;
                        break
                    }
            }
            const s = rt(e)
              , {mode: l} = s;
            if (a.isLeaving)
                return Oc(i);
            const c = Vd(i);
            if (!c)
                return Oc(i);
            const u = fi(c, s, a, n);
            bo(c, u);
            const f = n.subTree
              , d = f && Vd(f);
            let p = !1;
            const {getTransitionKey: h} = c.type;
            if (h) {
                const m = h();
                r === void 0 ? r = m : m !== r && (r = m,
                p = !0)
            }
            if (d && d.type !== pn && (!ha(c, d) || p)) {
                const m = fi(d, s, a, n);
                if (bo(d, m),
                l === "out-in")
                    return a.isLeaving = !0,
                    m.afterLeave = () => {
                        a.isLeaving = !1,
                        n.update.active !== !1 && (n.effect.dirty = !0,
                        n.update())
                    }
                    ,
                    Oc(i);
                l === "in-out" && c.type !== pn && (m.delayLeave = (g, b, v) => {
                    const y = F0(a, d);
                    y[String(d.key)] = d,
                    g[kr] = () => {
                        b(),
                        g[kr] = void 0,
                        delete u.delayedLeave
                    }
                    ,
                    u.delayedLeave = v
                }
                )
            }
            return i
        }
    }
}
  , V0 = P9;
function F0(e, t) {
    const {leavingVNodes: n} = e;
    let a = n.get(t.type);
    return a || (a = Object.create(null),
    n.set(t.type, a)),
    a
}
function fi(e, t, n, a) {
    const {appear: r, mode: o, persisted: i=!1, onBeforeEnter: s, onEnter: l, onAfterEnter: c, onEnterCancelled: u, onBeforeLeave: f, onLeave: d, onAfterLeave: p, onLeaveCancelled: h, onBeforeAppear: m, onAppear: g, onAfterAppear: b, onAppearCancelled: v} = t
      , y = String(e.key)
      , w = F0(n, e)
      , C = (z, T) => {
        z && Fn(z, a, 9, T)
    }
      , _ = (z, T) => {
        const A = T[1];
        C(z, T),
        Je(z) ? z.every(x => x.length <= 1) && A() : z.length <= 1 && A()
    }
      , E = {
        mode: o,
        persisted: i,
        beforeEnter(z) {
            let T = s;
            if (!n.isMounted)
                if (r)
                    T = m || s;
                else
                    return;
            z[kr] && z[kr](!0);
            const A = w[y];
            A && ha(e, A) && A.el[kr] && A.el[kr](),
            C(T, [z])
        },
        enter(z) {
            let T = l
              , A = c
              , x = u;
            if (!n.isMounted)
                if (r)
                    T = g || l,
                    A = b || c,
                    x = v || u;
                else
                    return;
            let M = !1;
            const L = z[Cl] = U => {
                M || (M = !0,
                U ? C(x, [z]) : C(A, [z]),
                E.delayedLeave && E.delayedLeave(),
                z[Cl] = void 0)
            }
            ;
            T ? _(T, [z, L]) : L()
        },
        leave(z, T) {
            const A = String(e.key);
            if (z[Cl] && z[Cl](!0),
            n.isUnmounting)
                return T();
            C(f, [z]);
            let x = !1;
            const M = z[kr] = L => {
                x || (x = !0,
                T(),
                L ? C(h, [z]) : C(p, [z]),
                z[kr] = void 0,
                w[A] === e && delete w[A])
            }
            ;
            w[A] = e,
            d ? _(d, [z, M]) : M()
        },
        clone(z) {
            return fi(z, t, n, a)
        }
    };
    return E
}
function Oc(e) {
    if (js(e))
        return e = Da(e),
        e.children = null,
        e
}
function Vd(e) {
    return js(e) ? e.children ? e.children[0] : void 0 : e
}
function bo(e, t) {
    e.shapeFlag & 6 && e.component ? bo(e.component.subTree, t) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent),
    e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t
}
function X1(e, t=!1, n) {
    let a = []
      , r = 0;
    for (let o = 0; o < e.length; o++) {
        let i = e[o];
        const s = n == null ? i.key : String(n) + String(i.key != null ? i.key : o);
        i.type === Be ? (i.patchFlag & 128 && r++,
        a = a.concat(X1(i.children, t, s))) : (t || i.type !== pn) && a.push(s != null ? Da(i, {
            key: s
        }) : i)
    }
    if (r > 1)
        for (let o = 0; o < a.length; o++)
            a[o].patchFlag = -2;
    return a
}
/*! #__NO_SIDE_EFFECTS__ */
function jr(e, t) {
    return ot(e) ? ( () => Ot({
        name: e.name
    }, t, {
        setup: e
    }))() : e
}
const uo = e => !!e.type.__asyncLoader;
/*! #__NO_SIDE_EFFECTS__ */
function L9(e) {
    ot(e) && (e = {
        loader: e
    });
    const {loader: t, loadingComponent: n, errorComponent: a, delay: r=200, timeout: o, suspensible: i=!0, onError: s} = e;
    let l = null, c, u = 0;
    const f = () => (u++,
    l = null,
    d())
      , d = () => {
        let p;
        return l || (p = l = t().catch(h => {
            if (h = h instanceof Error ? h : new Error(String(h)),
            s)
                return new Promise( (m, g) => {
                    s(h, () => m(f()), () => g(h), u + 1)
                }
                );
            throw h
        }
        ).then(h => p !== l && l ? l : (h && (h.__esModule || h[Symbol.toStringTag] === "Module") && (h = h.default),
        c = h,
        h)))
    }
    ;
    return jr({
        name: "AsyncComponentWrapper",
        __asyncLoader: d,
        get __asyncResolved() {
            return c
        },
        setup() {
            const p = nn;
            if (c)
                return () => Pc(c, p);
            const h = v => {
                l = null,
                xo(v, p, 13, !a)
            }
            ;
            if (i && p.suspense || Us)
                return d().then(v => () => Pc(v, p)).catch(v => (h(v),
                () => a ? S(a, {
                    error: v
                }) : null));
            const m = oe(!1)
              , g = oe()
              , b = oe(!!r);
            return r && setTimeout( () => {
                b.value = !1
            }
            , r),
            o != null && setTimeout( () => {
                if (!m.value && !g.value) {
                    const v = new Error(`Async component timed out after ${o}ms.`);
                    h(v),
                    g.value = v
                }
            }
            , o),
            d().then( () => {
                m.value = !0,
                p.parent && js(p.parent.vnode) && (p.parent.effect.dirty = !0,
                W1(p.parent.update))
            }
            ).catch(v => {
                h(v),
                g.value = v
            }
            ),
            () => {
                if (m.value && c)
                    return Pc(c, p);
                if (g.value && a)
                    return S(a, {
                        error: g.value
                    });
                if (n && !b.value)
                    return S(n)
            }
        }
    })
}
function Pc(e, t) {
    const {ref: n, props: a, children: r, ce: o} = t.vnode
      , i = S(e, a, r);
    return i.ref = n,
    i.ce = o,
    delete t.vnode.ce,
    i
}
const js = e => e.type.__isKeepAlive
  , I9 = {
    name: "KeepAlive",
    __isKeepAlive: !0,
    props: {
        include: [String, RegExp, Array],
        exclude: [String, RegExp, Array],
        max: [String, Number]
    },
    setup(e, {slots: t}) {
        const n = Ha()
          , a = n.ctx;
        if (!a.renderer)
            return () => {
                const v = t.default && t.default();
                return v && v.length === 1 ? v[0] : v
            }
            ;
        const r = new Map
          , o = new Set;
        let i = null;
        const s = n.suspense
          , {renderer: {p: l, m: c, um: u, o: {createElement: f}}} = a
          , d = f("div");
        a.activate = (v, y, w, C, _) => {
            const E = v.component;
            c(v, y, w, 0, s),
            l(E.vnode, v, y, w, E, s, C, v.slotScopeIds, _),
            dn( () => {
                E.isDeactivated = !1,
                E.a && ti(E.a);
                const z = v.props && v.props.onVnodeMounted;
                z && $n(z, E.parent, v)
            }
            , s)
        }
        ,
        a.deactivate = v => {
            const y = v.component;
            c(v, d, null, 1, s),
            dn( () => {
                y.da && ti(y.da);
                const w = v.props && v.props.onVnodeUnmounted;
                w && $n(w, y.parent, v),
                y.isDeactivated = !0
            }
            , s)
        }
        ;
        function p(v) {
            Lc(v),
            u(v, n, s, !0)
        }
        function h(v) {
            r.forEach( (y, w) => {
                const C = v1(y.type);
                C && (!v || !v(C)) && m(w)
            }
            )
        }
        function m(v) {
            const y = r.get(v);
            !i || !ha(y, i) ? p(y) : i && Lc(i),
            r.delete(v),
            o.delete(v)
        }
        st( () => [e.include, e.exclude], ([v,y]) => {
            v && h(w => Wi(v, w)),
            y && h(w => !Wi(y, w))
        }
        , {
            flush: "post",
            deep: !0
        });
        let g = null;
        const b = () => {
            g != null && r.set(g, Ic(n.subTree))
        }
        ;
        return Xe(b),
        On(b),
        lt( () => {
            r.forEach(v => {
                const {subTree: y, suspense: w} = n
                  , C = Ic(y);
                if (v.type === C.type && v.key === C.key) {
                    Lc(C);
                    const _ = C.component.da;
                    _ && dn(_, w);
                    return
                }
                p(v)
            }
            )
        }
        ),
        () => {
            if (g = null,
            !t.default)
                return null;
            const v = t.default()
              , y = v[0];
            if (v.length > 1)
                return i = null,
                v;
            if (!Or(y) || !(y.shapeFlag & 4) && !(y.shapeFlag & 128))
                return i = null,
                y;
            let w = Ic(y);
            const C = w.type
              , _ = v1(uo(w) ? w.type.__asyncResolved || {} : C)
              , {include: E, exclude: z, max: T} = e;
            if (E && (!_ || !Wi(E, _)) || z && _ && Wi(z, _))
                return i = w,
                y;
            const A = w.key == null ? C : w.key
              , x = r.get(A);
            return w.el && (w = Da(w),
            y.shapeFlag & 128 && (y.ssContent = w)),
            g = A,
            x ? (w.el = x.el,
            w.component = x.component,
            w.transition && bo(w, w.transition),
            w.shapeFlag |= 512,
            o.delete(A),
            o.add(A)) : (o.add(A),
            T && o.size > parseInt(T, 10) && m(o.values().next().value)),
            w.shapeFlag |= 256,
            i = w,
            L0(y.type) ? y : w
        }
    }
}
  , B9 = I9;
function Wi(e, t) {
    return Je(e) ? e.some(n => Wi(n, t)) : Pt(e) ? e.split(",").includes(t) : mm(e) ? e.test(t) : !1
}
function j0(e, t) {
    q0(e, "a", t)
}
function U0(e, t) {
    q0(e, "da", t)
}
function q0(e, t, n=nn) {
    const a = e.__wdc || (e.__wdc = () => {
        let r = n;
        for (; r; ) {
            if (r.isDeactivated)
                return;
            r = r.parent
        }
        return e()
    }
    );
    if (K1(t, a, n),
    n) {
        let r = n.parent;
        for (; r && r.parent; )
            js(r.parent.vnode) && R9(a, t, n, r),
            r = r.parent
    }
}
function R9(e, t, n, a) {
    const r = K1(t, e, a, !0);
    Ca( () => {
        Uu(a[t], r)
    }
    , n)
}
function Lc(e) {
    e.shapeFlag &= -257,
    e.shapeFlag &= -513
}
function Ic(e) {
    return e.shapeFlag & 128 ? e.ssContent : e
}
function K1(e, t, n=nn, a=!1) {
    if (n) {
        const r = n[e] || (n[e] = [])
          , o = t.__weh || (t.__weh = (...i) => {
            if (n.isUnmounted)
                return;
            Vr();
            const s = wo(n)
              , l = Fn(t, n, e, i);
            return s(),
            Fr(),
            l
        }
        );
        return a ? r.unshift(o) : r.push(o),
        o
    }
}
const sr = e => (t, n=nn) => (!Us || e === "sp") && K1(e, (...a) => t(...a), n)
  , W0 = sr("bm")
  , Xe = sr("m")
  , Z1 = sr("bu")
  , On = sr("u")
  , lt = sr("bum")
  , Ca = sr("um")
  , Y0 = sr("sp")
  , G0 = sr("rtg")
  , X0 = sr("rtc");
function K0(e, t=nn) {
    K1("ec", e, t)
}
function vt(e, t, n, a) {
    let r;
    const o = n && n[a];
    if (Je(e) || Pt(e)) {
        r = new Array(e.length);
        for (let i = 0, s = e.length; i < s; i++)
            r[i] = t(e[i], i, void 0, o && o[i])
    } else if (typeof e == "number") {
        r = new Array(e);
        for (let i = 0; i < e; i++)
            r[i] = t(i + 1, i, void 0, o && o[i])
    } else if (kt(e))
        if (e[Symbol.iterator])
            r = Array.from(e, (i, s) => t(i, s, void 0, o && o[s]));
        else {
            const i = Object.keys(e);
            r = new Array(i.length);
            for (let s = 0, l = i.length; s < l; s++) {
                const c = i[s];
                r[s] = t(e[c], c, s, o && o[s])
            }
        }
    else
        r = [];
    return n && (n[a] = r),
    r
}
function lr(e, t) {
    for (let n = 0; n < t.length; n++) {
        const a = t[n];
        if (Je(a))
            for (let r = 0; r < a.length; r++)
                e[a[r].name] = a[r].fn;
        else
            a && (e[a.name] = a.key ? (...r) => {
                const o = a.fn(...r);
                return o && (o.key = a.key),
                o
            }
            : a.fn)
    }
    return e
}
function ce(e, t, n={}, a, r) {
    if (Zt.isCE || Zt.parent && uo(Zt.parent) && Zt.parent.isCE)
        return t !== "default" && (n.name = t),
        S("slot", n, a && a());
    let o = e[t];
    o && o._c && (o._d = !1),
    O();
    const i = o && Z0(o(n))
      , s = K(Be, {
        key: n.key || i && i.key || `_${t}`
    }, i || (a ? a() : []), i && e._ === 1 ? 64 : -2);
    return !r && s.scopeId && (s.slotScopeIds = [s.scopeId + "-s"]),
    o && o._c && (o._d = !0),
    s
}
function Z0(e) {
    return e.some(t => Or(t) ? !(t.type === pn || t.type === Be && !Z0(t.children)) : !0) ? e : null
}
function J0(e, t) {
    const n = {};
    for (const a in e)
        n[t && /[A-Z]/.test(a) ? `on:${a}` : rs(a)] = e[a];
    return n
}
const x2 = e => e ? y5(e) ? ec(e) || e.proxy : x2(e.parent) : null
  , is = Ot(Object.create(null), {
    $: e => e,
    $el: e => e.vnode.el,
    $data: e => e.data,
    $props: e => e.props,
    $attrs: e => e.attrs,
    $slots: e => e.slots,
    $refs: e => e.refs,
    $parent: e => x2(e.parent),
    $root: e => x2(e.root),
    $emit: e => e.emit,
    $options: e => mf(e),
    $forceUpdate: e => e.f || (e.f = () => {
        e.effect.dirty = !0,
        W1(e.update)
    }
    ),
    $nextTick: e => e.n || (e.n = Zn.bind(e.proxy)),
    $watch: e => O9.bind(e)
});
const Bc = (e, t) => e !== _t && !e.__isScriptSetup && Ct(e, t)
  , T2 = {
    get({_: e}, t) {
        const {ctx: n, setupState: a, data: r, props: o, accessCache: i, type: s, appContext: l} = e;
        let c;
        if (t[0] !== "$") {
            const p = i[t];
            if (p !== void 0)
                switch (p) {
                case 1:
                    return a[t];
                case 2:
                    return r[t];
                case 4:
                    return n[t];
                case 3:
                    return o[t]
                }
            else {
                if (Bc(a, t))
                    return i[t] = 1,
                    a[t];
                if (r !== _t && Ct(r, t))
                    return i[t] = 2,
                    r[t];
                if ((c = e.propsOptions[0]) && Ct(c, t))
                    return i[t] = 3,
                    o[t];
                if (n !== _t && Ct(n, t))
                    return i[t] = 4,
                    n[t];
                M2 && (i[t] = 0)
            }
        }
        const u = is[t];
        let f, d;
        if (u)
            return t === "$attrs" && Mn(e, "get", t),
            u(e);
        if ((f = s.__cssModules) && (f = f[t]))
            return f;
        if (n !== _t && Ct(n, t))
            return i[t] = 4,
            n[t];
        if (d = l.config.globalProperties,
        Ct(d, t))
            return d[t]
    },
    set({_: e}, t, n) {
        const {data: a, setupState: r, ctx: o} = e;
        return Bc(r, t) ? (r[t] = n,
        !0) : a !== _t && Ct(a, t) ? (a[t] = n,
        !0) : Ct(e.props, t) || t[0] === "$" && t.slice(1)in e ? !1 : (o[t] = n,
        !0)
    },
    has({_: {data: e, setupState: t, accessCache: n, ctx: a, appContext: r, propsOptions: o}}, i) {
        let s;
        return !!n[i] || e !== _t && Ct(e, i) || Bc(t, i) || (s = o[0]) && Ct(s, i) || Ct(a, i) || Ct(is, i) || Ct(r.config.globalProperties, i)
    },
    defineProperty(e, t, n) {
        return n.get != null ? e._.accessCache[t] = 0 : Ct(n, "value") && this.set(e, t, n.value, null),
        Reflect.defineProperty(e, t, n)
    }
}
  , D9 = Ot({}, T2, {
    get(e, t) {
        if (t !== Symbol.unscopables)
            return T2.get(e, t, e)
    },
    has(e, t) {
        return t[0] !== "_" && !Cm(t)
    }
});
function N9() {
    return null
}
function H9() {
    return null
}
function V9(e) {}
function F9(e) {}
function j9() {
    return null
}
function U9() {}
function q9(e, t) {
    return null
}
function Q0() {
    return e5().slots
}
function W9() {
    return e5().attrs
}
function Y9(e, t, n=_t) {
    const a = Ha()
      , r = Cn(t)
      , o = Hn(t)
      , i = S0( (l, c) => {
        let u;
        return N0( () => {
            const f = e[t];
            ya(u, f) && (u = f,
            c())
        }
        ),
        {
            get() {
                return l(),
                n.get ? n.get(u) : u
            },
            set(f) {
                const d = a.vnode.props;
                !(d && (t in d || r in d || o in d) && (`onUpdate:${t}`in d || `onUpdate:${r}`in d || `onUpdate:${o}`in d)) && ya(f, u) && (u = f,
                c()),
                a.emit(`update:${t}`, n.set ? n.set(f) : f)
            }
        }
    }
    )
      , s = t === "modelValue" ? "modelModifiers" : `${t}Modifiers`;
    return i[Symbol.iterator] = () => {
        let l = 0;
        return {
            next() {
                return l < 2 ? {
                    value: l++ ? e[s] || {} : i,
                    done: !1
                } : {
                    done: !0
                }
            }
        }
    }
    ,
    i
}
function e5() {
    const e = Ha();
    return e.setupContext || (e.setupContext = _5(e))
}
function ks(e) {
    return Je(e) ? e.reduce( (t, n) => (t[n] = null,
    t), {}) : e
}
function G9(e, t) {
    const n = ks(e);
    for (const a in t) {
        if (a.startsWith("__skip"))
            continue;
        let r = n[a];
        r ? Je(r) || ot(r) ? r = n[a] = {
            type: r,
            default: t[a]
        } : r.default = t[a] : r === null && (r = n[a] = {
            default: t[a]
        }),
        r && t[`__skip_${a}`] && (r.skipFactory = !0)
    }
    return n
}
function X9(e, t) {
    return !e || !t ? e || t : Je(e) && Je(t) ? e.concat(t) : Ot({}, ks(e), ks(t))
}
function K9(e, t) {
    const n = {};
    for (const a in e)
        t.includes(a) || Object.defineProperty(n, a, {
            enumerable: !0,
            get: () => e[a]
        });
    return n
}
function Z9(e) {
    const t = Ha();
    let n = e();
    return I2(),
    qu(n) && (n = n.catch(a => {
        throw wo(t),
        a
    }
    )),
    [n, () => wo(t)]
}
let M2 = !0;
function J9(e) {
    const t = mf(e)
      , n = e.proxy
      , a = e.ctx;
    M2 = !1,
    t.beforeCreate && Fd(t.beforeCreate, e, "bc");
    const {data: r, computed: o, methods: i, watch: s, provide: l, inject: c, created: u, beforeMount: f, mounted: d, beforeUpdate: p, updated: h, activated: m, deactivated: g, beforeDestroy: b, beforeUnmount: v, destroyed: y, unmounted: w, render: C, renderTracked: _, renderTriggered: E, errorCaptured: z, serverPrefetch: T, expose: A, inheritAttrs: x, components: M, directives: L, filters: U} = t;
    if (c && Q9(c, a, null),
    i)
        for (const W in i) {
            const j = i[W];
            ot(j) && (a[W] = j.bind(n))
        }
    if (r) {
        const W = r.call(n, n);
        kt(W) && (e.data = Jn(W))
    }
    if (M2 = !0,
    o)
        for (const W in o) {
            const j = o[W]
              , Q = ot(j) ? j.bind(n, n) : ot(j.get) ? j.get.bind(n, n) : bn
              , ne = !ot(j) && ot(j.set) ? j.set.bind(n) : bn
              , re = ae({
                get: Q,
                set: ne
            });
            Object.defineProperty(a, W, {
                enumerable: !0,
                configurable: !0,
                get: () => re.value,
                set: ve => re.value = ve
            })
        }
    if (s)
        for (const W in s)
            t5(s[W], a, n, W);
    if (l) {
        const W = ot(l) ? l.call(n) : l;
        Reflect.ownKeys(W).forEach(j => {
            To(j, W[j])
        }
        )
    }
    u && Fd(u, e, "c");
    function H(W, j) {
        Je(j) ? j.forEach(Q => W(Q.bind(n))) : j && W(j.bind(n))
    }
    if (H(W0, f),
    H(Xe, d),
    H(Z1, p),
    H(On, h),
    H(j0, m),
    H(U0, g),
    H(K0, z),
    H(X0, _),
    H(G0, E),
    H(lt, v),
    H(Ca, w),
    H(Y0, T),
    Je(A))
        if (A.length) {
            const W = e.exposed || (e.exposed = {});
            A.forEach(j => {
                Object.defineProperty(W, j, {
                    get: () => n[j],
                    set: Q => n[j] = Q
                })
            }
            )
        } else
            e.exposed || (e.exposed = {});
    C && e.render === bn && (e.render = C),
    x != null && (e.inheritAttrs = x),
    M && (e.components = M),
    L && (e.directives = L)
}
function Q9(e, t, n=bn) {
    Je(e) && (e = z2(e));
    for (const a in e) {
        const r = e[a];
        let o;
        kt(r) ? "default"in r ? o = Qn(r.from || a, r.default, !0) : o = Qn(r.from || a) : o = Qn(r),
        Dt(o) ? Object.defineProperty(t, a, {
            enumerable: !0,
            configurable: !0,
            get: () => o.value,
            set: i => o.value = i
        }) : t[a] = o
    }
}
function Fd(e, t, n) {
    Fn(Je(e) ? e.map(a => a.bind(t.proxy)) : e.bind(t.proxy), t, n)
}
function t5(e, t, n, a) {
    const r = a.includes(".") ? H0(n, a) : () => n[a];
    if (Pt(e)) {
        const o = t[e];
        ot(o) && st(r, o)
    } else if (ot(e))
        st(r, e.bind(n));
    else if (kt(e))
        if (Je(e))
            e.forEach(o => t5(o, t, n, a));
        else {
            const o = ot(e.handler) ? e.handler.bind(n) : t[e.handler];
            ot(o) && st(r, o, e)
        }
}
function mf(e) {
    const t = e.type
      , {mixins: n, extends: a} = t
      , {mixins: r, optionsCache: o, config: {optionMergeStrategies: i}} = e.appContext
      , s = o.get(t);
    let l;
    return s ? l = s : !r.length && !n && !a ? l = t : (l = {},
    r.length && r.forEach(c => p1(l, c, i, !0)),
    p1(l, t, i)),
    kt(t) && o.set(t, l),
    l
}
function p1(e, t, n, a=!1) {
    const {mixins: r, extends: o} = t;
    o && p1(e, o, n, !0),
    r && r.forEach(i => p1(e, i, n, !0));
    for (const i in t)
        if (!(a && i === "expose")) {
            const s = eg[i] || n && n[i];
            e[i] = s ? s(e[i], t[i]) : t[i]
        }
    return e
}
const eg = {
    data: jd,
    props: Ud,
    emits: Ud,
    methods: Yi,
    computed: Yi,
    beforeCreate: yn,
    created: yn,
    beforeMount: yn,
    mounted: yn,
    beforeUpdate: yn,
    updated: yn,
    beforeDestroy: yn,
    beforeUnmount: yn,
    destroyed: yn,
    unmounted: yn,
    activated: yn,
    deactivated: yn,
    errorCaptured: yn,
    serverPrefetch: yn,
    components: Yi,
    directives: Yi,
    watch: ng,
    provide: jd,
    inject: tg
};
function jd(e, t) {
    return t ? e ? function() {
        return Ot(ot(e) ? e.call(this, this) : e, ot(t) ? t.call(this, this) : t)
    }
    : t : e
}
function tg(e, t) {
    return Yi(z2(e), z2(t))
}
function z2(e) {
    if (Je(e)) {
        const t = {};
        for (let n = 0; n < e.length; n++)
            t[e[n]] = e[n];
        return t
    }
    return e
}
function yn(e, t) {
    return e ? [...new Set([].concat(e, t))] : t
}
function Yi(e, t) {
    return e ? Ot(Object.create(null), e, t) : t
}
function Ud(e, t) {
    return e ? Je(e) && Je(t) ? [...new Set([...e, ...t])] : Ot(Object.create(null), ks(e), ks(t ?? {})) : t
}
function ng(e, t) {
    if (!e)
        return t;
    if (!t)
        return e;
    const n = Ot(Object.create(null), e);
    for (const a in t)
        n[a] = yn(e[a], t[a]);
    return n
}
function n5() {
    return {
        app: null,
        config: {
            isNativeTag: pm,
            performance: !1,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap,
        propsCache: new WeakMap,
        emitsCache: new WeakMap
    }
}
let ag = 0;
function rg(e, t) {
    return function(a, r=null) {
        ot(a) || (a = Ot({}, a)),
        r != null && !kt(r) && (r = null);
        const o = n5()
          , i = new WeakSet;
        let s = !1;
        const l = o.app = {
            _uid: ag++,
            _component: a,
            _props: r,
            _container: null,
            _context: o,
            _instance: null,
            version: $5,
            get config() {
                return o.config
            },
            set config(c) {},
            use(c, ...u) {
                return i.has(c) || (c && ot(c.install) ? (i.add(c),
                c.install(l, ...u)) : ot(c) && (i.add(c),
                c(l, ...u))),
                l
            },
            mixin(c) {
                return o.mixins.includes(c) || o.mixins.push(c),
                l
            },
            component(c, u) {
                return u ? (o.components[c] = u,
                l) : o.components[c]
            },
            directive(c, u) {
                return u ? (o.directives[c] = u,
                l) : o.directives[c]
            },
            mount(c, u, f) {
                if (!s) {
                    const d = S(a, r);
                    return d.appContext = o,
                    f === !0 ? f = "svg" : f === !1 && (f = void 0),
                    u && t ? t(d, c) : e(d, c, f),
                    s = !0,
                    l._container = c,
                    c.__vue_app__ = l,
                    ec(d.component) || d.component.proxy
                }
            },
            unmount() {
                s && (e(null, l._container),
                delete l._container.__vue_app__)
            },
            provide(c, u) {
                return o.provides[c] = u,
                l
            },
            runWithContext(c) {
                Ss = l;
                try {
                    return c()
                } finally {
                    Ss = null
                }
            }
        };
        return l
    }
}
let Ss = null;
function To(e, t) {
    if (nn) {
        let n = nn.provides;
        const a = nn.parent && nn.parent.provides;
        a === n && (n = nn.provides = Object.create(a)),
        n[e] = t
    }
}
function Qn(e, t, n=!1) {
    const a = nn || Zt;
    if (a || Ss) {
        const r = a ? a.parent == null ? a.vnode.appContext && a.vnode.appContext.provides : a.parent.provides : Ss._context.provides;
        if (r && e in r)
            return r[e];
        if (arguments.length > 1)
            return n && ot(t) ? t.call(a && a.proxy) : t
    }
}
function og() {
    return !!(nn || Zt || Ss)
}
function ig(e, t, n, a=!1) {
    const r = {}
      , o = {};
    i1(o, J1, 1),
    e.propsDefaults = Object.create(null),
    a5(e, t, r, o);
    for (const i in e.propsOptions[0])
        i in r || (r[i] = void 0);
    n ? e.props = a ? r : ef(r) : e.type.props ? e.props = r : e.props = o,
    e.attrs = o
}
function sg(e, t, n, a) {
    const {props: r, attrs: o, vnode: {patchFlag: i}} = e
      , s = rt(r)
      , [l] = e.propsOptions;
    let c = !1;
    if ((a || i > 0) && !(i & 16)) {
        if (i & 8) {
            const u = e.vnode.dynamicProps;
            for (let f = 0; f < u.length; f++) {
                let d = u[f];
                if (Y1(e.emitsOptions, d))
                    continue;
                const p = t[d];
                if (l)
                    if (Ct(o, d))
                        p !== o[d] && (o[d] = p,
                        c = !0);
                    else {
                        const h = Cn(d);
                        r[h] = A2(l, s, h, p, e, !1)
                    }
                else
                    p !== o[d] && (o[d] = p,
                    c = !0)
            }
        }
    } else {
        a5(e, t, r, o) && (c = !0);
        let u;
        for (const f in s)
            (!t || !Ct(t, f) && ((u = Hn(f)) === f || !Ct(t, u))) && (l ? n && (n[f] !== void 0 || n[u] !== void 0) && (r[f] = A2(l, s, f, void 0, e, !0)) : delete r[f]);
        if (o !== s)
            for (const f in o)
                (!t || !Ct(t, f)) && (delete o[f],
                c = !0)
    }
    c && Qa(e, "set", "$attrs")
}
function a5(e, t, n, a) {
    const [r,o] = e.propsOptions;
    let i = !1, s;
    if (t)
        for (let l in t) {
            if (as(l))
                continue;
            const c = t[l];
            let u;
            r && Ct(r, u = Cn(l)) ? !o || !o.includes(u) ? n[u] = c : (s || (s = {}))[u] = c : Y1(e.emitsOptions, l) || (!(l in a) || c !== a[l]) && (a[l] = c,
            i = !0)
        }
    if (o) {
        const l = rt(n)
          , c = s || _t;
        for (let u = 0; u < o.length; u++) {
            const f = o[u];
            n[f] = A2(r, l, f, c[f], e, !Ct(c, f))
        }
    }
    return i
}
function A2(e, t, n, a, r, o) {
    const i = e[n];
    if (i != null) {
        const s = Ct(i, "default");
        if (s && a === void 0) {
            const l = i.default;
            if (i.type !== Function && !i.skipFactory && ot(l)) {
                const {propsDefaults: c} = r;
                if (n in c)
                    a = c[n];
                else {
                    const u = wo(r);
                    a = c[n] = l.call(null, t),
                    u()
                }
            } else
                a = l
        }
        i[0] && (o && !s ? a = !1 : i[1] && (a === "" || a === Hn(n)) && (a = !0))
    }
    return a
}
function r5(e, t, n=!1) {
    const a = t.propsCache
      , r = a.get(e);
    if (r)
        return r;
    const o = e.props
      , i = {}
      , s = [];
    let l = !1;
    if (!ot(e)) {
        const u = f => {
            l = !0;
            const [d,p] = r5(f, t, !0);
            Ot(i, d),
            p && s.push(...p)
        }
        ;
        !n && t.mixins.length && t.mixins.forEach(u),
        e.extends && u(e.extends),
        e.mixins && e.mixins.forEach(u)
    }
    if (!o && !l)
        return kt(e) && a.set(e, Qo),
        Qo;
    if (Je(o))
        for (let u = 0; u < o.length; u++) {
            const f = Cn(o[u]);
            qd(f) && (i[f] = _t)
        }
    else if (o)
        for (const u in o) {
            const f = Cn(u);
            if (qd(f)) {
                const d = o[u]
                  , p = i[f] = Je(d) || ot(d) ? {
                    type: d
                } : Ot({}, d);
                if (p) {
                    const h = Gd(Boolean, p.type)
                      , m = Gd(String, p.type);
                    p[0] = h > -1,
                    p[1] = m < 0 || h < m,
                    (h > -1 || Ct(p, "default")) && s.push(f)
                }
            }
        }
    const c = [i, s];
    return kt(e) && a.set(e, c),
    c
}
function qd(e) {
    return e[0] !== "$"
}
function Wd(e) {
    const t = e && e.toString().match(/^\s*(function|class) (\w+)/);
    return t ? t[2] : e === null ? "null" : ""
}
function Yd(e, t) {
    return Wd(e) === Wd(t)
}
function Gd(e, t) {
    return Je(t) ? t.findIndex(n => Yd(n, e)) : ot(t) && Yd(t, e) ? 0 : -1
}
const o5 = e => e[0] === "_" || e === "$stable"
  , gf = e => Je(e) ? e.map(Dn) : [Dn(e)]
  , lg = (e, t, n) => {
    if (t._n)
        return t;
    const a = k( (...r) => gf(t(...r)), n);
    return a._c = !1,
    a
}
  , i5 = (e, t, n) => {
    const a = e._ctx;
    for (const r in e) {
        if (o5(r))
            continue;
        const o = e[r];
        if (ot(o))
            t[r] = lg(r, o, a);
        else if (o != null) {
            const i = gf(o);
            t[r] = () => i
        }
    }
}
  , s5 = (e, t) => {
    const n = gf(t);
    e.slots.default = () => n
}
  , cg = (e, t) => {
    if (e.vnode.shapeFlag & 32) {
        const n = t._;
        n ? (e.slots = rt(t),
        i1(t, "_", n)) : i5(t, e.slots = {})
    } else
        e.slots = {},
        t && s5(e, t);
    i1(e.slots, J1, 1)
}
  , ug = (e, t, n) => {
    const {vnode: a, slots: r} = e;
    let o = !0
      , i = _t;
    if (a.shapeFlag & 32) {
        const s = t._;
        s ? n && s === 1 ? o = !1 : (Ot(r, t),
        !n && s === 1 && delete r._) : (o = !t.$stable,
        i5(t, r)),
        i = t
    } else
        t && (s5(e, t),
        i = {
            default: 1
        });
    if (o)
        for (const s in r)
            !o5(s) && i[s] == null && delete r[s]
}
;
function h1(e, t, n, a, r=!1) {
    if (Je(e)) {
        e.forEach( (d, p) => h1(d, t && (Je(t) ? t[p] : t), n, a, r));
        return
    }
    if (uo(a) && !r)
        return;
    const o = a.shapeFlag & 4 ? ec(a.component) || a.component.proxy : a.el
      , i = r ? null : o
      , {i: s, r: l} = e
      , c = t && t.r
      , u = s.refs === _t ? s.refs = {} : s.refs
      , f = s.setupState;
    if (c != null && c !== l && (Pt(c) ? (u[c] = null,
    Ct(f, c) && (f[c] = null)) : Dt(c) && (c.value = null)),
    ot(l))
        Ia(l, s, 12, [i, u]);
    else {
        const d = Pt(l)
          , p = Dt(l);
        if (d || p) {
            const h = () => {
                if (e.f) {
                    const m = d ? Ct(f, l) ? f[l] : u[l] : l.value;
                    r ? Je(m) && Uu(m, o) : Je(m) ? m.includes(o) || m.push(o) : d ? (u[l] = [o],
                    Ct(f, l) && (f[l] = u[l])) : (l.value = [o],
                    e.k && (u[e.k] = l.value))
                } else
                    d ? (u[l] = i,
                    Ct(f, l) && (f[l] = i)) : p && (l.value = i,
                    e.k && (u[e.k] = i))
            }
            ;
            i ? (h.id = -1,
            dn(h, n)) : h()
        }
    }
}
let vr = !1;
const fg = e => e.namespaceURI.includes("svg") && e.tagName !== "foreignObject"
  , dg = e => e.namespaceURI.includes("MathML")
  , wl = e => {
    if (fg(e))
        return "svg";
    if (dg(e))
        return "mathml"
}
  , Bi = e => e.nodeType === 8;
function pg(e) {
    const {mt: t, p: n, o: {patchProp: a, createText: r, nextSibling: o, parentNode: i, remove: s, insert: l, createComment: c}} = e
      , u = (y, w) => {
        if (!w.hasChildNodes()) {
            __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ && $a("Attempting to hydrate existing markup but container is empty. Performing full mount instead."),
            n(null, y, w),
            d1(),
            w._vnode = y;
            return
        }
        vr = !1,
        f(w.firstChild, y, null, null, null),
        d1(),
        w._vnode = y,
        vr && console.error("Hydration completed but contains mismatches.")
    }
      , f = (y, w, C, _, E, z=!1) => {
        const T = Bi(y) && y.data === "["
          , A = () => m(y, w, C, _, E, T)
          , {type: x, ref: M, shapeFlag: L, patchFlag: U} = w;
        let Y = y.nodeType;
        w.el = y,
        U === -2 && (z = !1,
        w.dynamicChildren = null);
        let H = null;
        switch (x) {
        case yo:
            Y !== 3 ? w.children === "" ? (l(w.el = r(""), i(y), y),
            H = y) : H = A() : (y.data !== w.children && (vr = !0,
            __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ && $a("Hydration text mismatch in", y.parentNode, `
  - rendered on server: ${JSON.stringify(y.data)}
  - expected on client: ${JSON.stringify(w.children)}`),
            y.data = w.children),
            H = o(y));
            break;
        case pn:
            v(y) ? (H = o(y),
            b(w.el = y.content.firstChild, y, C)) : Y !== 8 || T ? H = A() : H = o(y);
            break;
        case fo:
            if (T && (y = o(y),
            Y = y.nodeType),
            Y === 1 || Y === 3) {
                H = y;
                const W = !w.children.length;
                for (let j = 0; j < w.staticCount; j++)
                    W && (w.children += H.nodeType === 1 ? H.outerHTML : H.data),
                    j === w.staticCount - 1 && (w.anchor = H),
                    H = o(H);
                return T ? o(H) : H
            } else
                A();
            break;
        case Be:
            T ? H = h(y, w, C, _, E, z) : H = A();
            break;
        default:
            if (L & 1)
                (Y !== 1 || w.type.toLowerCase() !== y.tagName.toLowerCase()) && !v(y) ? H = A() : H = d(y, w, C, _, E, z);
            else if (L & 6) {
                w.slotScopeIds = E;
                const W = i(y);
                if (T ? H = g(y) : Bi(y) && y.data === "teleport start" ? H = g(y, y.data, "teleport end") : H = o(y),
                t(w, W, null, C, _, wl(W), z),
                uo(w)) {
                    let j;
                    T ? (j = S(Be),
                    j.anchor = H ? H.previousSibling : W.lastChild) : j = y.nodeType === 3 ? J("") : S("div"),
                    j.el = y,
                    w.component.subTree = j
                }
            } else
                L & 64 ? Y !== 8 ? H = A() : H = w.type.hydrate(y, w, C, _, E, z, e, p) : L & 128 ? H = w.type.hydrate(y, w, C, _, wl(i(y)), E, z, e, f) : __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ && $a("Invalid HostVNode type:", x, `(${typeof x})`)
        }
        return M != null && h1(M, null, _, w),
        H
    }
      , d = (y, w, C, _, E, z) => {
        z = z || !!w.dynamicChildren;
        const {type: T, props: A, patchFlag: x, shapeFlag: M, dirs: L, transition: U} = w
          , Y = T === "input" || T === "option";
        if (Y || x !== -1) {
            L && Ea(w, null, C, "created");
            let H = !1;
            if (v(y)) {
                H = f5(_, U) && C && C.vnode.props && C.vnode.props.appear;
                const j = y.content.firstChild;
                H && U.beforeEnter(j),
                b(j, y, C),
                w.el = y = j
            }
            if (M & 16 && !(A && (A.innerHTML || A.textContent))) {
                let j = p(y.firstChild, w, y, C, _, E, z)
                  , Q = !1;
                for (; j; ) {
                    vr = !0,
                    __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ && !Q && ($a("Hydration children mismatch on", y, `
Server rendered element contains more child nodes than client vdom.`),
                    Q = !0);
                    const ne = j;
                    j = j.nextSibling,
                    s(ne)
                }
            } else
                M & 8 && y.textContent !== w.children && (vr = !0,
                __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ && $a("Hydration text content mismatch on", y, `
  - rendered on server: ${y.textContent}
  - expected on client: ${w.children}`),
                y.textContent = w.children);
            if (A)
                if (Y || !z || x & 48)
                    for (const j in A)
                        (Y && (j.endsWith("value") || j === "indeterminate") || Ds(j) && !as(j) || j[0] === ".") && a(y, j, null, A[j], void 0, void 0, C);
                else
                    A.onClick && a(y, "onClick", null, A.onClick, void 0, void 0, C);
            let W;
            (W = A && A.onVnodeBeforeMount) && $n(W, C, w),
            L && Ea(w, null, C, "beforeMount"),
            ((W = A && A.onVnodeMounted) || L || H) && I0( () => {
                W && $n(W, C, w),
                H && U.enter(y),
                L && Ea(w, null, C, "mounted")
            }
            , _)
        }
        return y.nextSibling
    }
      , p = (y, w, C, _, E, z, T) => {
        T = T || !!w.dynamicChildren;
        const A = w.children
          , x = A.length;
        let M = !1;
        for (let L = 0; L < x; L++) {
            const U = T ? A[L] : A[L] = Dn(A[L]);
            if (y)
                y = f(y, U, _, E, z, T);
            else {
                if (U.type === yo && !U.children)
                    continue;
                vr = !0,
                __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ && !M && ($a("Hydration children mismatch on", C, `
Server rendered element contains fewer child nodes than client vdom.`),
                M = !0),
                n(null, U, C, null, _, E, wl(C), z)
            }
        }
        return y
    }
      , h = (y, w, C, _, E, z) => {
        const {slotScopeIds: T} = w;
        T && (E = E ? E.concat(T) : T);
        const A = i(y)
          , x = p(o(y), w, A, C, _, E, z);
        return x && Bi(x) && x.data === "]" ? o(w.anchor = x) : (vr = !0,
        l(w.anchor = c("]"), A, x),
        x)
    }
      , m = (y, w, C, _, E, z) => {
        if (vr = !0,
        __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ && $a(`Hydration node mismatch:
- rendered on server:`, y, y.nodeType === 3 ? "(text)" : Bi(y) && y.data === "[" ? "(start of fragment)" : "", `
- expected on client:`, w.type),
        w.el = null,
        z) {
            const x = g(y);
            for (; ; ) {
                const M = o(y);
                if (M && M !== x)
                    s(M);
                else
                    break
            }
        }
        const T = o(y)
          , A = i(y);
        return s(y),
        n(null, w, A, T, C, _, wl(A), E),
        T
    }
      , g = (y, w="[", C="]") => {
        let _ = 0;
        for (; y; )
            if (y = o(y),
            y && Bi(y) && (y.data === w && _++,
            y.data === C)) {
                if (_ === 0)
                    return o(y);
                _--
            }
        return y
    }
      , b = (y, w, C) => {
        const _ = w.parentNode;
        _ && _.replaceChild(y, w);
        let E = C;
        for (; E; )
            E.vnode.el === w && (E.vnode.el = E.subTree.el = y),
            E = E.parent
    }
      , v = y => y.nodeType === 1 && y.tagName.toLowerCase() === "template";
    return [u, f]
}
function hg() {
    const e = [];
    typeof __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ != "boolean" && (Yu().__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ = !1)
}
const dn = I0;
function l5(e) {
    return u5(e)
}
function c5(e) {
    return u5(e, pg)
}
function u5(e, t) {
    hg();
    const n = Yu();
    n.__VUE__ = !0;
    const {insert: a, remove: r, patchProp: o, createElement: i, createText: s, createComment: l, setText: c, setElementText: u, parentNode: f, nextSibling: d, setScopeId: p=bn, insertStaticContent: h} = e
      , m = (q, Z, de, me=null, ge=null, ie=null, Ee=void 0, $e=null, xe=!!Z.dynamicChildren) => {
        if (q === Z)
            return;
        q && !ha(q, Z) && (me = ye(q),
        Ne(q, ge, ie, !0),
        q = null),
        Z.patchFlag === -2 && (xe = !1,
        Z.dynamicChildren = null);
        const {type: he, ref: We, shapeFlag: Te} = Z;
        switch (he) {
        case yo:
            g(q, Z, de, me);
            break;
        case pn:
            b(q, Z, de, me);
            break;
        case fo:
            q == null && v(Z, de, me, Ee);
            break;
        case Be:
            L(q, Z, de, me, ge, ie, Ee, $e, xe);
            break;
        default:
            Te & 1 ? _(q, Z, de, me, ge, ie, Ee, $e, xe) : Te & 6 ? U(q, Z, de, me, ge, ie, Ee, $e, xe) : (Te & 64 || Te & 128) && he.process(q, Z, de, me, ge, ie, Ee, $e, xe, Re)
        }
        We != null && ge && h1(We, q && q.ref, ie, Z || q, !Z)
    }
      , g = (q, Z, de, me) => {
        if (q == null)
            a(Z.el = s(Z.children), de, me);
        else {
            const ge = Z.el = q.el;
            Z.children !== q.children && c(ge, Z.children)
        }
    }
      , b = (q, Z, de, me) => {
        q == null ? a(Z.el = l(Z.children || ""), de, me) : Z.el = q.el
    }
      , v = (q, Z, de, me) => {
        [q.el,q.anchor] = h(q.children, Z, de, me, q.el, q.anchor)
    }
      , y = (q, Z, de, me) => {
        if (Z.children !== q.children) {
            const ge = d(q.anchor);
            C(q),
            [Z.el,Z.anchor] = h(Z.children, de, ge, me)
        } else
            Z.el = q.el,
            Z.anchor = q.anchor
    }
      , w = ({el: q, anchor: Z}, de, me) => {
        let ge;
        for (; q && q !== Z; )
            ge = d(q),
            a(q, de, me),
            q = ge;
        a(Z, de, me)
    }
      , C = ({el: q, anchor: Z}) => {
        let de;
        for (; q && q !== Z; )
            de = d(q),
            r(q),
            q = de;
        r(Z)
    }
      , _ = (q, Z, de, me, ge, ie, Ee, $e, xe) => {
        Z.type === "svg" ? Ee = "svg" : Z.type === "math" && (Ee = "mathml"),
        q == null ? E(Z, de, me, ge, ie, Ee, $e, xe) : A(q, Z, ge, ie, Ee, $e, xe)
    }
      , E = (q, Z, de, me, ge, ie, Ee, $e) => {
        let xe, he;
        const {props: We, shapeFlag: Te, transition: Fe, dirs: at} = q;
        if (xe = q.el = i(q.type, ie, We && We.is, We),
        Te & 8 ? u(xe, q.children) : Te & 16 && T(q.children, xe, null, me, ge, Rc(q, ie), Ee, $e),
        at && Ea(q, null, me, "created"),
        z(xe, q, q.scopeId, Ee, me),
        We) {
            for (const St in We)
                St !== "value" && !as(St) && o(xe, St, null, We[St], ie, q.children, me, ge, ee);
            "value"in We && o(xe, "value", null, We.value, ie),
            (he = We.onVnodeBeforeMount) && $n(he, me, q)
        }
        at && Ea(q, null, me, "beforeMount");
        const dt = f5(ge, Fe);
        dt && Fe.beforeEnter(xe),
        a(xe, Z, de),
        ((he = We && We.onVnodeMounted) || dt || at) && dn( () => {
            he && $n(he, me, q),
            dt && Fe.enter(xe),
            at && Ea(q, null, me, "mounted")
        }
        , ge)
    }
      , z = (q, Z, de, me, ge) => {
        if (de && p(q, de),
        me)
            for (let ie = 0; ie < me.length; ie++)
                p(q, me[ie]);
        if (ge) {
            let ie = ge.subTree;
            if (Z === ie) {
                const Ee = ge.vnode;
                z(q, Ee, Ee.scopeId, Ee.slotScopeIds, ge.parent)
            }
        }
    }
      , T = (q, Z, de, me, ge, ie, Ee, $e, xe=0) => {
        for (let he = xe; he < q.length; he++) {
            const We = q[he] = $e ? Sr(q[he]) : Dn(q[he]);
            m(null, We, Z, de, me, ge, ie, Ee, $e)
        }
    }
      , A = (q, Z, de, me, ge, ie, Ee) => {
        const $e = Z.el = q.el;
        let {patchFlag: xe, dynamicChildren: he, dirs: We} = Z;
        xe |= q.patchFlag & 16;
        const Te = q.props || _t
          , Fe = Z.props || _t;
        let at;
        if (de && Gr(de, !1),
        (at = Fe.onVnodeBeforeUpdate) && $n(at, de, Z, q),
        We && Ea(Z, q, de, "beforeUpdate"),
        de && Gr(de, !0),
        he ? x(q.dynamicChildren, he, $e, de, me, Rc(Z, ge), ie) : Ee || Q(q, Z, $e, null, de, me, Rc(Z, ge), ie, !1),
        xe > 0) {
            if (xe & 16)
                M($e, Z, Te, Fe, de, me, ge);
            else if (xe & 2 && Te.class !== Fe.class && o($e, "class", null, Fe.class, ge),
            xe & 4 && o($e, "style", Te.style, Fe.style, ge),
            xe & 8) {
                const dt = Z.dynamicProps;
                for (let St = 0; St < dt.length; St++) {
                    const Tt = dt[St]
                      , Ft = Te[Tt]
                      , wn = Fe[Tt];
                    (wn !== Ft || Tt === "value") && o($e, Tt, Ft, wn, ge, q.children, de, me, ee)
                }
            }
            xe & 1 && q.children !== Z.children && u($e, Z.children)
        } else
            !Ee && he == null && M($e, Z, Te, Fe, de, me, ge);
        ((at = Fe.onVnodeUpdated) || We) && dn( () => {
            at && $n(at, de, Z, q),
            We && Ea(Z, q, de, "updated")
        }
        , me)
    }
      , x = (q, Z, de, me, ge, ie, Ee) => {
        for (let $e = 0; $e < Z.length; $e++) {
            const xe = q[$e]
              , he = Z[$e]
              , We = xe.el && (xe.type === Be || !ha(xe, he) || xe.shapeFlag & 70) ? f(xe.el) : de;
            m(xe, he, We, null, me, ge, ie, Ee, !0)
        }
    }
      , M = (q, Z, de, me, ge, ie, Ee) => {
        if (de !== me) {
            if (de !== _t)
                for (const $e in de)
                    !as($e) && !($e in me) && o(q, $e, de[$e], null, Ee, Z.children, ge, ie, ee);
            for (const $e in me) {
                if (as($e))
                    continue;
                const xe = me[$e]
                  , he = de[$e];
                xe !== he && $e !== "value" && o(q, $e, he, xe, Ee, Z.children, ge, ie, ee)
            }
            "value"in me && o(q, "value", de.value, me.value, Ee)
        }
    }
      , L = (q, Z, de, me, ge, ie, Ee, $e, xe) => {
        const he = Z.el = q ? q.el : s("")
          , We = Z.anchor = q ? q.anchor : s("");
        let {patchFlag: Te, dynamicChildren: Fe, slotScopeIds: at} = Z;
        at && ($e = $e ? $e.concat(at) : at),
        q == null ? (a(he, de, me),
        a(We, de, me),
        T(Z.children || [], de, We, ge, ie, Ee, $e, xe)) : Te > 0 && Te & 64 && Fe && q.dynamicChildren ? (x(q.dynamicChildren, Fe, de, ge, ie, Ee, $e),
        (Z.key != null || ge && Z === ge.subTree) && vf(q, Z, !0)) : Q(q, Z, de, We, ge, ie, Ee, $e, xe)
    }
      , U = (q, Z, de, me, ge, ie, Ee, $e, xe) => {
        Z.slotScopeIds = $e,
        q == null ? Z.shapeFlag & 512 ? ge.ctx.activate(Z, de, me, Ee, xe) : Y(Z, de, me, ge, ie, Ee, xe) : H(q, Z, xe)
    }
      , Y = (q, Z, de, me, ge, ie, Ee) => {
        const $e = q.component = b5(q, me, ge);
        if (js(q) && ($e.ctx.renderer = Re),
        C5($e),
        $e.asyncDep) {
            if (ge && ge.registerDep($e, W),
            !q.el) {
                const xe = $e.subTree = S(pn);
                b(null, xe, Z, de)
            }
        } else
            W($e, q, Z, de, ge, ie, Ee)
    }
      , H = (q, Z, de) => {
        const me = Z.component = q.component;
        if (k9(q, Z, de))
            if (me.asyncDep && !me.asyncResolved) {
                j(me, Z, de);
                return
            } else
                me.next = Z,
                v9(me.update),
                me.effect.dirty = !0,
                me.update();
        else
            Z.el = q.el,
            me.vnode = Z
    }
      , W = (q, Z, de, me, ge, ie, Ee) => {
        const $e = () => {
            if (q.isMounted) {
                let {next: We, bu: Te, u: Fe, parent: at, vnode: dt} = q;
                {
                    const dr = d5(q);
                    if (dr) {
                        We && (We.el = dt.el,
                        j(q, We, Ee)),
                        dr.asyncDep.then( () => {
                            q.isUnmounted || $e()
                        }
                        );
                        return
                    }
                }
                let St = We, Tt;
                Gr(q, !1),
                We ? (We.el = dt.el,
                j(q, We, Ee)) : We = dt,
                Te && ti(Te),
                (Tt = We.props && We.props.onVnodeBeforeUpdate) && $n(Tt, at, We, dt),
                Gr(q, !0);
                const Ft = Fl(q)
                  , wn = q.subTree;
                q.subTree = Ft,
                m(wn, Ft, f(wn.el), ye(wn), q, ge, ie),
                We.el = Ft.el,
                St === null && lf(q, Ft.el),
                Fe && dn(Fe, ge),
                (Tt = We.props && We.props.onVnodeUpdated) && dn( () => $n(Tt, at, We, dt), ge)
            } else {
                let We;
                const {el: Te, props: Fe} = Z
                  , {bm: at, m: dt, parent: St} = q
                  , Tt = uo(Z);
                if (Gr(q, !1),
                at && ti(at),
                !Tt && (We = Fe && Fe.onVnodeBeforeMount) && $n(We, St, Z),
                Gr(q, !0),
                Te && Ze) {
                    const Ft = () => {
                        q.subTree = Fl(q),
                        Ze(Te, q.subTree, q, ge, null)
                    }
                    ;
                    Tt ? Z.type.__asyncLoader().then( () => !q.isUnmounted && Ft()) : Ft()
                } else {
                    const Ft = q.subTree = Fl(q);
                    m(null, Ft, de, me, q, ge, ie),
                    Z.el = Ft.el
                }
                if (dt && dn(dt, ge),
                !Tt && (We = Fe && Fe.onVnodeMounted)) {
                    const Ft = Z;
                    dn( () => $n(We, St, Ft), ge)
                }
                (Z.shapeFlag & 256 || St && uo(St.vnode) && St.vnode.shapeFlag & 256) && q.a && dn(q.a, ge),
                q.isMounted = !0,
                Z = de = me = null
            }
        }
          , xe = q.effect = new ui($e,bn, () => W1(he),q.scope)
          , he = q.update = () => {
            xe.dirty && xe.run()
        }
        ;
        he.id = q.uid,
        Gr(q, !0),
        he()
    }
      , j = (q, Z, de) => {
        Z.component = q;
        const me = q.vnode.props;
        q.vnode = Z,
        q.next = null,
        sg(q, Z.props, me, de),
        ug(q, Z.children, de),
        Vr(),
        Rd(q),
        Fr()
    }
      , Q = (q, Z, de, me, ge, ie, Ee, $e, xe=!1) => {
        const he = q && q.children
          , We = q ? q.shapeFlag : 0
          , Te = Z.children
          , {patchFlag: Fe, shapeFlag: at} = Z;
        if (Fe > 0) {
            if (Fe & 128) {
                re(he, Te, de, me, ge, ie, Ee, $e, xe);
                return
            } else if (Fe & 256) {
                ne(he, Te, de, me, ge, ie, Ee, $e, xe);
                return
            }
        }
        at & 8 ? (We & 16 && ee(he, ge, ie),
        Te !== he && u(de, Te)) : We & 16 ? at & 16 ? re(he, Te, de, me, ge, ie, Ee, $e, xe) : ee(he, ge, ie, !0) : (We & 8 && u(de, ""),
        at & 16 && T(Te, de, me, ge, ie, Ee, $e, xe))
    }
      , ne = (q, Z, de, me, ge, ie, Ee, $e, xe) => {
        q = q || Qo,
        Z = Z || Qo;
        const he = q.length
          , We = Z.length
          , Te = Math.min(he, We);
        let Fe;
        for (Fe = 0; Fe < Te; Fe++) {
            const at = Z[Fe] = xe ? Sr(Z[Fe]) : Dn(Z[Fe]);
            m(q[Fe], at, de, null, ge, ie, Ee, $e, xe)
        }
        he > We ? ee(q, ge, ie, !0, !1, Te) : T(Z, de, me, ge, ie, Ee, $e, xe, Te)
    }
      , re = (q, Z, de, me, ge, ie, Ee, $e, xe) => {
        let he = 0;
        const We = Z.length;
        let Te = q.length - 1
          , Fe = We - 1;
        for (; he <= Te && he <= Fe; ) {
            const at = q[he]
              , dt = Z[he] = xe ? Sr(Z[he]) : Dn(Z[he]);
            if (ha(at, dt))
                m(at, dt, de, null, ge, ie, Ee, $e, xe);
            else
                break;
            he++
        }
        for (; he <= Te && he <= Fe; ) {
            const at = q[Te]
              , dt = Z[Fe] = xe ? Sr(Z[Fe]) : Dn(Z[Fe]);
            if (ha(at, dt))
                m(at, dt, de, null, ge, ie, Ee, $e, xe);
            else
                break;
            Te--,
            Fe--
        }
        if (he > Te) {
            if (he <= Fe) {
                const at = Fe + 1
                  , dt = at < We ? Z[at].el : me;
                for (; he <= Fe; )
                    m(null, Z[he] = xe ? Sr(Z[he]) : Dn(Z[he]), de, dt, ge, ie, Ee, $e, xe),
                    he++
            }
        } else if (he > Fe)
            for (; he <= Te; )
                Ne(q[he], ge, ie, !0),
                he++;
        else {
            const at = he
              , dt = he
              , St = new Map;
            for (he = dt; he <= Fe; he++) {
                const fn = Z[he] = xe ? Sr(Z[he]) : Dn(Z[he]);
                fn.key != null && St.set(fn.key, he)
            }
            let Tt, Ft = 0;
            const wn = Fe - dt + 1;
            let dr = !1
              , ul = 0;
            const ft = new Array(wn);
            for (he = 0; he < wn; he++)
                ft[he] = 0;
            for (he = at; he <= Te; he++) {
                const fn = q[he];
                if (Ft >= wn) {
                    Ne(fn, ge, ie, !0);
                    continue
                }
                let on;
                if (fn.key != null)
                    on = St.get(fn.key);
                else
                    for (Tt = dt; Tt <= Fe; Tt++)
                        if (ft[Tt - dt] === 0 && ha(fn, Z[Tt])) {
                            on = Tt;
                            break
                        }
                on === void 0 ? Ne(fn, ge, ie, !0) : (ft[on - dt] = he + 1,
                on >= ul ? ul = on : dr = !0,
                m(fn, Z[on], de, null, ge, ie, Ee, $e, xe),
                Ft++)
            }
            const Oi = dr ? mg(ft) : Qo;
            for (Tt = Oi.length - 1,
            he = wn - 1; he >= 0; he--) {
                const fn = dt + he
                  , on = Z[fn]
                  , fl = fn + 1 < We ? Z[fn + 1].el : me;
                ft[he] === 0 ? m(null, on, de, fl, ge, ie, Ee, $e, xe) : dr && (Tt < 0 || he !== Oi[Tt] ? ve(on, de, fl, 2) : Tt--)
            }
        }
    }
      , ve = (q, Z, de, me, ge=null) => {
        const {el: ie, type: Ee, transition: $e, children: xe, shapeFlag: he} = q;
        if (he & 6) {
            ve(q.component.subTree, Z, de, me);
            return
        }
        if (he & 128) {
            q.suspense.move(Z, de, me);
            return
        }
        if (he & 64) {
            Ee.move(q, Z, de, Re);
            return
        }
        if (Ee === Be) {
            a(ie, Z, de);
            for (let Te = 0; Te < xe.length; Te++)
                ve(xe[Te], Z, de, me);
            a(q.anchor, Z, de);
            return
        }
        if (Ee === fo) {
            w(q, Z, de);
            return
        }
        if (me !== 2 && he & 1 && $e)
            if (me === 0)
                $e.beforeEnter(ie),
                a(ie, Z, de),
                dn( () => $e.enter(ie), ge);
            else {
                const {leave: Te, delayLeave: Fe, afterLeave: at} = $e
                  , dt = () => a(ie, Z, de)
                  , St = () => {
                    Te(ie, () => {
                        dt(),
                        at && at()
                    }
                    )
                }
                ;
                Fe ? Fe(ie, dt, St) : St()
            }
        else
            a(ie, Z, de)
    }
      , Ne = (q, Z, de, me=!1, ge=!1) => {
        const {type: ie, props: Ee, ref: $e, children: xe, dynamicChildren: he, shapeFlag: We, patchFlag: Te, dirs: Fe} = q;
        if ($e != null && h1($e, null, de, q, !0),
        We & 256) {
            Z.ctx.deactivate(q);
            return
        }
        const at = We & 1 && Fe
          , dt = !uo(q);
        let St;
        if (dt && (St = Ee && Ee.onVnodeBeforeUnmount) && $n(St, Z, q),
        We & 6)
            tt(q.component, de, me);
        else {
            if (We & 128) {
                q.suspense.unmount(de, me);
                return
            }
            at && Ea(q, null, Z, "beforeUnmount"),
            We & 64 ? q.type.remove(q, Z, de, ge, Re, me) : he && (ie !== Be || Te > 0 && Te & 64) ? ee(he, Z, de, !1, !0) : (ie === Be && Te & 384 || !ge && We & 16) && ee(xe, Z, de),
            me && Ge(q)
        }
        (dt && (St = Ee && Ee.onVnodeUnmounted) || at) && dn( () => {
            St && $n(St, Z, q),
            at && Ea(q, null, Z, "unmounted")
        }
        , de)
    }
      , Ge = q => {
        const {type: Z, el: de, anchor: me, transition: ge} = q;
        if (Z === Be) {
            Ye(de, me);
            return
        }
        if (Z === fo) {
            C(q);
            return
        }
        const ie = () => {
            r(de),
            ge && !ge.persisted && ge.afterLeave && ge.afterLeave()
        }
        ;
        if (q.shapeFlag & 1 && ge && !ge.persisted) {
            const {leave: Ee, delayLeave: $e} = ge
              , xe = () => Ee(de, ie);
            $e ? $e(q.el, ie, xe) : xe()
        } else
            ie()
    }
      , Ye = (q, Z) => {
        let de;
        for (; q !== Z; )
            de = d(q),
            r(q),
            q = de;
        r(Z)
    }
      , tt = (q, Z, de) => {
        const {bum: me, scope: ge, update: ie, subTree: Ee, um: $e} = q;
        me && ti(me),
        ge.stop(),
        ie && (ie.active = !1,
        Ne(Ee, q, Z, de)),
        $e && dn($e, Z),
        dn( () => {
            q.isUnmounted = !0
        }
        , Z),
        Z && Z.pendingBranch && !Z.isUnmounted && q.asyncDep && !q.asyncResolved && q.suspenseId === Z.pendingId && (Z.deps--,
        Z.deps === 0 && Z.resolve())
    }
      , ee = (q, Z, de, me=!1, ge=!1, ie=0) => {
        for (let Ee = ie; Ee < q.length; Ee++)
            Ne(q[Ee], Z, de, me, ge)
    }
      , ye = q => q.shapeFlag & 6 ? ye(q.component.subTree) : q.shapeFlag & 128 ? q.suspense.next() : d(q.anchor || q.el);
    let Le = !1;
    const Se = (q, Z, de) => {
        q == null ? Z._vnode && Ne(Z._vnode, null, null, !0) : m(Z._vnode || null, q, Z, null, null, null, de),
        Le || (Le = !0,
        Rd(),
        d1(),
        Le = !1),
        Z._vnode = q
    }
      , Re = {
        p: m,
        um: Ne,
        m: ve,
        r: Ge,
        mt: Y,
        mc: T,
        pc: Q,
        pbc: x,
        n: ye,
        o: e
    };
    let Ve, Ze;
    return t && ([Ve,Ze] = t(Re)),
    {
        render: Se,
        hydrate: Ve,
        createApp: rg(Se, Ve)
    }
}
function Rc({type: e, props: t}, n) {
    return n === "svg" && e === "foreignObject" || n === "mathml" && e === "annotation-xml" && t && t.encoding && t.encoding.includes("html") ? void 0 : n
}
function Gr({effect: e, update: t}, n) {
    e.allowRecurse = t.allowRecurse = n
}
function f5(e, t) {
    return (!e || e && !e.pendingBranch) && t && !t.persisted
}
function vf(e, t, n=!1) {
    const a = e.children
      , r = t.children;
    if (Je(a) && Je(r))
        for (let o = 0; o < a.length; o++) {
            const i = a[o];
            let s = r[o];
            s.shapeFlag & 1 && !s.dynamicChildren && ((s.patchFlag <= 0 || s.patchFlag === 32) && (s = r[o] = Sr(r[o]),
            s.el = i.el),
            n || vf(i, s)),
            s.type === yo && (s.el = i.el)
        }
}
function mg(e) {
    const t = e.slice()
      , n = [0];
    let a, r, o, i, s;
    const l = e.length;
    for (a = 0; a < l; a++) {
        const c = e[a];
        if (c !== 0) {
            if (r = n[n.length - 1],
            e[r] < c) {
                t[a] = r,
                n.push(a);
                continue
            }
            for (o = 0,
            i = n.length - 1; o < i; )
                s = o + i >> 1,
                e[n[s]] < c ? o = s + 1 : i = s;
            c < e[n[o]] && (o > 0 && (t[a] = n[o - 1]),
            n[o] = a)
        }
    }
    for (o = n.length,
    i = n[o - 1]; o-- > 0; )
        n[o] = i,
        i = t[i];
    return n
}
function d5(e) {
    const t = e.subTree.component;
    if (t)
        return t.asyncDep && !t.asyncResolved ? t : d5(t)
}
const gg = e => e.__isTeleport
  , ss = e => e && (e.disabled || e.disabled === "")
  , Xd = e => typeof SVGElement < "u" && e instanceof SVGElement
  , Kd = e => typeof MathMLElement == "function" && e instanceof MathMLElement
  , O2 = (e, t) => {
    const n = e && e.to;
    if (Pt(n))
        if (t) {
            const a = t(n);
            return a
        } else
            return null;
    else
        return n
}
  , vg = {
    name: "Teleport",
    __isTeleport: !0,
    process(e, t, n, a, r, o, i, s, l, c) {
        const {mc: u, pc: f, pbc: d, o: {insert: p, querySelector: h, createText: m, createComment: g}} = c
          , b = ss(t.props);
        let {shapeFlag: v, children: y, dynamicChildren: w} = t;
        if (e == null) {
            const C = t.el = m("")
              , _ = t.anchor = m("");
            p(C, n, a),
            p(_, n, a);
            const E = t.target = O2(t.props, h)
              , z = t.targetAnchor = m("");
            E && (p(z, E),
            i === "svg" || Xd(E) ? i = "svg" : (i === "mathml" || Kd(E)) && (i = "mathml"));
            const T = (A, x) => {
                v & 16 && u(y, A, x, r, o, i, s, l)
            }
            ;
            b ? T(n, _) : E && T(E, z)
        } else {
            t.el = e.el;
            const C = t.anchor = e.anchor
              , _ = t.target = e.target
              , E = t.targetAnchor = e.targetAnchor
              , z = ss(e.props)
              , T = z ? n : _
              , A = z ? C : E;
            if (i === "svg" || Xd(_) ? i = "svg" : (i === "mathml" || Kd(_)) && (i = "mathml"),
            w ? (d(e.dynamicChildren, w, T, r, o, i, s),
            vf(e, t, !0)) : l || f(e, t, T, A, r, o, i, s, !1),
            b)
                z ? t.props && e.props && t.props.to !== e.props.to && (t.props.to = e.props.to) : _l(t, n, C, c, 1);
            else if ((t.props && t.props.to) !== (e.props && e.props.to)) {
                const x = t.target = O2(t.props, h);
                x && _l(t, x, null, c, 0)
            } else
                z && _l(t, _, E, c, 1)
        }
        h5(t)
    },
    remove(e, t, n, a, {um: r, o: {remove: o}}, i) {
        const {shapeFlag: s, children: l, anchor: c, targetAnchor: u, target: f, props: d} = e;
        if (f && o(u),
        i && o(c),
        s & 16) {
            const p = i || !ss(d);
            for (let h = 0; h < l.length; h++) {
                const m = l[h];
                r(m, t, n, p, !!m.dynamicChildren)
            }
        }
    },
    move: _l,
    hydrate: bg
};
function _l(e, t, n, {o: {insert: a}, m: r}, o=2) {
    o === 0 && a(e.targetAnchor, t, n);
    const {el: i, anchor: s, shapeFlag: l, children: c, props: u} = e
      , f = o === 2;
    if (f && a(i, t, n),
    (!f || ss(u)) && l & 16)
        for (let d = 0; d < c.length; d++)
            r(c[d], t, n, 2);
    f && a(s, t, n)
}
function bg(e, t, n, a, r, o, {o: {nextSibling: i, parentNode: s, querySelector: l}}, c) {
    const u = t.target = O2(t.props, l);
    if (u) {
        const f = u._lpa || u.firstChild;
        if (t.shapeFlag & 16)
            if (ss(t.props))
                t.anchor = c(i(e), t, s(e), n, a, r, o),
                t.targetAnchor = f;
            else {
                t.anchor = i(e);
                let d = f;
                for (; d; )
                    if (d = i(d),
                    d && d.nodeType === 8 && d.data === "teleport anchor") {
                        t.targetAnchor = d,
                        u._lpa = t.targetAnchor && i(t.targetAnchor);
                        break
                    }
                c(f, t, u, n, a, r, o)
            }
        h5(t)
    }
    return t.anchor && i(t.anchor)
}
const p5 = vg;
function h5(e) {
    const t = e.ctx;
    if (t && t.ut) {
        let n = e.children[0].el;
        for (; n && n !== e.targetAnchor; )
            n.nodeType === 1 && n.setAttribute("data-v-owner", t.uid),
            n = n.nextSibling;
        t.ut()
    }
}
const Be = Symbol.for("v-fgt")
  , yo = Symbol.for("v-txt")
  , pn = Symbol.for("v-cmt")
  , fo = Symbol.for("v-stc")
  , ls = [];
let En = null;
function O(e=!1) {
    ls.push(En = e ? null : [])
}
function m5() {
    ls.pop(),
    En = ls[ls.length - 1] || null
}
let Co = 1;
function P2(e) {
    Co += e
}
function g5(e) {
    return e.dynamicChildren = Co > 0 ? En || Qo : null,
    m5(),
    Co > 0 && En && En.push(e),
    e
}
function G(e, t, n, a, r, o) {
    return g5(V(e, t, n, a, r, o, !0))
}
function K(e, t, n, a, r) {
    return g5(S(e, t, n, a, r, !0))
}
function Or(e) {
    return e ? e.__v_isVNode === !0 : !1
}
function ha(e, t) {
    return e.type === t.type && e.key === t.key
}
let yg;
function Cg(e) {
    yg = e
}
const J1 = "__vInternal"
  , v5 = ({key: e}) => e ?? null
  , jl = ({ref: e, ref_key: t, ref_for: n}) => (typeof e == "number" && (e = "" + e),
e != null ? Pt(e) || Dt(e) || ot(e) ? {
    i: Zt,
    r: e,
    k: t,
    f: !!n
} : e : null);
function V(e, t=null, n=null, a=0, r=null, o=e === Be ? 0 : 1, i=!1, s=!1) {
    const l = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: e,
        props: t,
        key: t && v5(t),
        ref: t && jl(t),
        scopeId: G1,
        slotScopeIds: null,
        children: n,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag: o,
        patchFlag: a,
        dynamicProps: r,
        dynamicChildren: null,
        appContext: null,
        ctx: Zt
    };
    return s ? (yf(l, n),
    o & 128 && e.normalize(l)) : n && (l.shapeFlag |= Pt(n) ? 8 : 16),
    Co > 0 && !i && En && (l.patchFlag > 0 || o & 6) && l.patchFlag !== 32 && En.push(l),
    l
}
const S = wg;
function wg(e, t=null, n=null, a=0, r=null, o=!1) {
    if ((!e || e === P0) && (e = pn),
    Or(e)) {
        const s = Da(e, t, !0);
        return n && yf(s, n),
        Co > 0 && !o && En && (s.shapeFlag & 6 ? En[En.indexOf(e)] = s : En.push(s)),
        s.patchFlag |= -2,
        s
    }
    if (zg(e) && (e = e.__vccOpts),
    t) {
        t = Q1(t);
        let {class: s, style: l} = t;
        s && !Pt(s) && (t.class = Ae(s)),
        kt(l) && (nf(l) && !Je(l) && (l = Ot({}, l)),
        t.style = Rt(l))
    }
    const i = Pt(e) ? 1 : L0(e) ? 128 : gg(e) ? 64 : kt(e) ? 4 : ot(e) ? 2 : 0;
    return V(e, t, n, a, r, i, o, !0)
}
function Q1(e) {
    return e ? nf(e) || J1 in e ? Ot({}, e) : e : null
}
function Da(e, t, n=!1) {
    const {props: a, ref: r, patchFlag: o, children: i} = e
      , s = t ? Un(a || {}, t) : a;
    return {
        __v_isVNode: !0,
        __v_skip: !0,
        type: e.type,
        props: s,
        key: s && v5(s),
        ref: t && t.ref ? n && r ? Je(r) ? r.concat(jl(t)) : [r, jl(t)] : jl(t) : r,
        scopeId: e.scopeId,
        slotScopeIds: e.slotScopeIds,
        children: i,
        target: e.target,
        targetAnchor: e.targetAnchor,
        staticCount: e.staticCount,
        shapeFlag: e.shapeFlag,
        patchFlag: t && e.type !== Be ? o === -1 ? 16 : o | 16 : o,
        dynamicProps: e.dynamicProps,
        dynamicChildren: e.dynamicChildren,
        appContext: e.appContext,
        dirs: e.dirs,
        transition: e.transition,
        component: e.component,
        suspense: e.suspense,
        ssContent: e.ssContent && Da(e.ssContent),
        ssFallback: e.ssFallback && Da(e.ssFallback),
        el: e.el,
        anchor: e.anchor,
        ctx: e.ctx,
        ce: e.ce
    }
}
function J(e=" ", t=0) {
    return S(yo, null, e, t)
}
function bf(e, t) {
    const n = S(fo, null, e);
    return n.staticCount = t,
    n
}
function pe(e="", t=!1) {
    return t ? (O(),
    K(pn, null, e)) : S(pn, null, e)
}
function Dn(e) {
    return e == null || typeof e == "boolean" ? S(pn) : Je(e) ? S(Be, null, e.slice()) : typeof e == "object" ? Sr(e) : S(yo, null, String(e))
}
function Sr(e) {
    return e.el === null && e.patchFlag !== -1 || e.memo ? e : Da(e)
}
function yf(e, t) {
    let n = 0;
    const {shapeFlag: a} = e;
    if (t == null)
        t = null;
    else if (Je(t))
        n = 16;
    else if (typeof t == "object")
        if (a & 65) {
            const r = t.default;
            r && (r._c && (r._d = !1),
            yf(e, r()),
            r._c && (r._d = !0));
            return
        } else {
            n = 32;
            const r = t._;
            !r && !(J1 in t) ? t._ctx = Zt : r === 3 && Zt && (Zt.slots._ === 1 ? t._ = 1 : (t._ = 2,
            e.patchFlag |= 1024))
        }
    else
        ot(t) ? (t = {
            default: t,
            _ctx: Zt
        },
        n = 32) : (t = String(t),
        a & 64 ? (n = 16,
        t = [J(t)]) : n = 8);
    e.children = t,
    e.shapeFlag |= n
}
function Un(...e) {
    const t = {};
    for (let n = 0; n < e.length; n++) {
        const a = e[n];
        for (const r in a)
            if (r === "class")
                t.class !== a.class && (t.class = Ae([t.class, a.class]));
            else if (r === "style")
                t.style = Rt([t.style, a.style]);
            else if (Ds(r)) {
                const o = t[r]
                  , i = a[r];
                i && o !== i && !(Je(o) && o.includes(i)) && (t[r] = o ? [].concat(o, i) : i)
            } else
                r !== "" && (t[r] = a[r])
    }
    return t
}
function $n(e, t, n, a=null) {
    Fn(e, t, 7, [n, a])
}
const _g = n5();
let kg = 0;
function b5(e, t, n) {
    const a = e.type
      , r = (t ? t.appContext : e.appContext) || _g
      , o = {
        uid: kg++,
        vnode: e,
        type: a,
        parent: t,
        appContext: r,
        root: null,
        next: null,
        subTree: null,
        effect: null,
        update: null,
        scope: new Gu(!0),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: t ? t.provides : Object.create(r.provides),
        accessCache: null,
        renderCache: [],
        components: null,
        directives: null,
        propsOptions: r5(a, r),
        emitsOptions: A0(a, r),
        emit: null,
        emitted: null,
        propsDefaults: _t,
        inheritAttrs: a.inheritAttrs,
        ctx: _t,
        data: _t,
        props: _t,
        attrs: _t,
        slots: _t,
        refs: _t,
        setupState: _t,
        setupContext: null,
        attrsProxy: null,
        slotsProxy: null,
        suspense: n,
        suspenseId: n ? n.pendingId : 0,
        asyncDep: null,
        asyncResolved: !1,
        isMounted: !1,
        isUnmounted: !1,
        isDeactivated: !1,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
    };
    return o.ctx = {
        _: o
    },
    o.root = t ? t.root : o,
    o.emit = y9.bind(null, o),
    e.ce && e.ce(o),
    o
}
let nn = null;
const Ha = () => nn || Zt;
let m1, L2;
{
    const e = Yu()
      , t = (n, a) => {
        let r;
        return (r = e[n]) || (r = e[n] = []),
        r.push(a),
        o => {
            r.length > 1 ? r.forEach(i => i(o)) : r[0](o)
        }
    }
    ;
    m1 = t("__VUE_INSTANCE_SETTERS__", n => nn = n),
    L2 = t("__VUE_SSR_SETTERS__", n => Us = n)
}
const wo = e => {
    const t = nn;
    return m1(e),
    e.scope.on(),
    () => {
        e.scope.off(),
        m1(t)
    }
}
  , I2 = () => {
    nn && nn.scope.off(),
    m1(null)
}
;
function y5(e) {
    return e.vnode.shapeFlag & 4
}
let Us = !1;
function C5(e, t=!1) {
    t && L2(t);
    const {props: n, children: a} = e.vnode
      , r = y5(e);
    ig(e, n, r, t),
    cg(e, a);
    const o = r ? Sg(e, t) : void 0;
    return t && L2(!1),
    o
}
function Sg(e, t) {
    var n;
    const a = e.type;
    e.accessCache = Object.create(null),
    e.proxy = ga(new Proxy(e.ctx,T2));
    const {setup: r} = a;
    if (r) {
        const o = e.setupContext = r.length > 1 ? _5(e) : null
          , i = wo(e);
        Vr();
        const s = Ia(r, e, 0, [e.props, o]);
        if (Fr(),
        i(),
        qu(s)) {
            if (s.then(I2, I2),
            t)
                return s.then(l => {
                    B2(e, l, t)
                }
                ).catch(l => {
                    xo(l, e, 0)
                }
                );
            e.asyncDep = s
        } else
            B2(e, s, t)
    } else
        w5(e, t)
}
function B2(e, t, n) {
    ot(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : kt(t) && (e.setupState = of(t)),
    w5(e, n)
}
let g1, R2;
function $g(e) {
    g1 = e,
    R2 = t => {
        t.render._rc && (t.withProxy = new Proxy(t.ctx,D9))
    }
}
const Eg = () => !g1;
function w5(e, t, n) {
    const a = e.type;
    if (!e.render) {
        if (!t && g1 && !a.render) {
            const r = a.template || mf(e).template;
            if (r) {
                const {isCustomElement: o, compilerOptions: i} = e.appContext.config
                  , {delimiters: s, compilerOptions: l} = a
                  , c = Ot(Ot({
                    isCustomElement: o,
                    delimiters: s
                }, i), l);
                a.render = g1(r, c)
            }
        }
        e.render = a.render || bn,
        R2 && R2(e)
    }
    {
        const r = wo(e);
        Vr();
        try {
            J9(e)
        } finally {
            Fr(),
            r()
        }
    }
}
function xg(e) {
    return e.attrsProxy || (e.attrsProxy = new Proxy(e.attrs,{
        get(t, n) {
            return Mn(e, "get", "$attrs"),
            t[n]
        }
    }))
}
function _5(e) {
    const t = n => {
        e.exposed = n || {}
    }
    ;
    return {
        get attrs() {
            return xg(e)
        },
        slots: e.slots,
        emit: e.emit,
        expose: t
    }
}
function ec(e) {
    if (e.exposed)
        return e.exposeProxy || (e.exposeProxy = new Proxy(of(ga(e.exposed)),{
            get(t, n) {
                if (n in t)
                    return t[n];
                if (n in is)
                    return is[n](e)
            },
            has(t, n) {
                return n in t || n in is
            }
        }))
}
const Tg = /(?:^|[-_])(\w)/g
  , Mg = e => e.replace(Tg, t => t.toUpperCase()).replace(/[-_]/g, "");
function v1(e, t=!0) {
    return ot(e) ? e.displayName || e.name : e.name || t && e.__name
}
function k5(e, t, n=!1) {
    let a = v1(t);
    if (!a && t.__file) {
        const r = t.__file.match(/([^/\\]+)\.\w+$/);
        r && (a = r[1])
    }
    if (!a && e && e.parent) {
        const r = o => {
            for (const i in o)
                if (o[i] === t)
                    return i
        }
        ;
        a = r(e.components || e.parent.type.components) || r(e.appContext.components)
    }
    return a ? Mg(a) : n ? "App" : "Anonymous"
}
function zg(e) {
    return ot(e) && "__vccOpts"in e
}
const ae = (e, t) => Km(e, t, Us);
function Pe(e, t, n) {
    const a = arguments.length;
    return a === 2 ? kt(t) && !Je(t) ? Or(t) ? S(e, null, [t]) : S(e, t) : S(e, null, t) : (a > 3 ? n = Array.prototype.slice.call(arguments, 2) : a === 3 && Or(n) && (n = [n]),
    S(e, t, n))
}
function Dc(e) {
    return !!(e && e.__v_isShallow)
}
function Ag() {
    return;
    function o(f) {
        const d = [];
        f.type.props && f.props && d.push(i("props", rt(f.props))),
        f.setupState !== _t && d.push(i("setup", f.setupState)),
        f.data !== _t && d.push(i("data", rt(f.data)));
        const p = l(f, "computed");
        p && d.push(i("computed", p));
        const h = l(f, "inject");
        return h && d.push(i("injected", h)),
        d.push(["div", {}, ["span", {
            style: a.style + ";opacity:0.66"
        }, "$ (internal): "], ["object", {
            object: f
        }]]),
        d
    }
    function i(f, d) {
        return d = Ot({}, d),
        Object.keys(d).length ? ["div", {
            style: "line-height:1.25em;margin-bottom:0.6em"
        }, ["div", {
            style: "color:#476582"
        }, f], ["div", {
            style: "padding-left:1.25em"
        }, ...Object.keys(d).map(p => ["div", {}, ["span", a, p + ": "], s(d[p], !1)])]] : ["span", {}]
    }
    function s(f, d=!0) {
        return typeof f == "number" ? ["span", t, f] : typeof f == "string" ? ["span", n, JSON.stringify(f)] : typeof f == "boolean" ? ["span", a, f] : kt(f) ? ["object", {
            object: d ? rt(f) : f
        }] : ["span", n, String(f)]
    }
    function l(f, d) {
        const p = f.type;
        if (ot(p))
            return;
        const h = {};
        for (const m in f.ctx)
            c(p, m, d) && (h[m] = f.ctx[m]);
        return h
    }
    function c(f, d, p) {
        const h = f[p];
        if (Je(h) && h.includes(d) || kt(h) && d in h || f.extends && c(f.extends, d, p) || f.mixins && f.mixins.some(m => c(m, d, p)))
            return !0
    }
    function u(f) {
        return Dc(f) ? "ShallowRef" : f.effect ? "ComputedRef" : "Ref"
    }
}
function Og(e, t, n, a) {
    const r = n[a];
    if (r && S5(r, e))
        return r;
    const o = t();
    return o.memo = e.slice(),
    n[a] = o
}
function S5(e, t) {
    const n = e.memo;
    if (n.length != t.length)
        return !1;
    for (let a = 0; a < n.length; a++)
        if (ya(n[a], t[a]))
            return !1;
    return Co > 0 && En && En.push(e),
    !0
}
const $5 = "3.4.8"
  , Pg = bn
  , Lg = h9
  , Ig = void 0
  , Bg = bn
  , Rg = {
    createComponentInstance: b5,
    setupComponent: C5,
    renderComponentRoot: Fl,
    setCurrentRenderingInstance: ws,
    isVNode: Or,
    normalizeVNode: Dn
}
  , Dg = Rg
  , Ng = null
  , Hg = null
  , Vg = null;
/**
* @vue/runtime-dom v3.4.8
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const Fg = "http://www.w3.org/2000/svg"
  , jg = "http://www.w3.org/1998/Math/MathML"
  , $r = typeof document < "u" ? document : null
  , Zd = $r && $r.createElement("template")
  , Ug = {
    insert: (e, t, n) => {
        t.insertBefore(e, n || null)
    }
    ,
    remove: e => {
        const t = e.parentNode;
        t && t.removeChild(e)
    }
    ,
    createElement: (e, t, n, a) => {
        const r = t === "svg" ? $r.createElementNS(Fg, e) : t === "mathml" ? $r.createElementNS(jg, e) : $r.createElement(e, n ? {
            is: n
        } : void 0);
        return e === "select" && a && a.multiple != null && r.setAttribute("multiple", a.multiple),
        r
    }
    ,
    createText: e => $r.createTextNode(e),
    createComment: e => $r.createComment(e),
    setText: (e, t) => {
        e.nodeValue = t
    }
    ,
    setElementText: (e, t) => {
        e.textContent = t
    }
    ,
    parentNode: e => e.parentNode,
    nextSibling: e => e.nextSibling,
    querySelector: e => $r.querySelector(e),
    setScopeId(e, t) {
        e.setAttribute(t, "")
    },
    insertStaticContent(e, t, n, a, r, o) {
        const i = n ? n.previousSibling : t.lastChild;
        if (r && (r === o || r.nextSibling))
            for (; t.insertBefore(r.cloneNode(!0), n),
            !(r === o || !(r = r.nextSibling)); )
                ;
        else {
            Zd.innerHTML = a === "svg" ? `<svg>${e}</svg>` : a === "mathml" ? `<math>${e}</math>` : e;
            const s = Zd.content;
            if (a === "svg" || a === "mathml") {
                const l = s.firstChild;
                for (; l.firstChild; )
                    s.appendChild(l.firstChild);
                s.removeChild(l)
            }
            t.insertBefore(s, n)
        }
        return [i ? i.nextSibling : t.firstChild, n ? n.previousSibling : t.lastChild]
    }
}
  , br = "transition"
  , Ri = "animation"
  , di = Symbol("_vtc")
  , Cf = (e, {slots: t}) => Pe(V0, x5(e), t);
Cf.displayName = "Transition";
const E5 = {
    name: String,
    type: String,
    css: {
        type: Boolean,
        default: !0
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
}
  , qg = Cf.props = Ot({}, hf, E5)
  , Xr = (e, t=[]) => {
    Je(e) ? e.forEach(n => n(...t)) : e && e(...t)
}
  , Jd = e => e ? Je(e) ? e.some(t => t.length > 1) : e.length > 1 : !1;
function x5(e) {
    const t = {};
    for (const M in e)
        M in E5 || (t[M] = e[M]);
    if (e.css === !1)
        return t;
    const {name: n="v", type: a, duration: r, enterFromClass: o=`${n}-enter-from`, enterActiveClass: i=`${n}-enter-active`, enterToClass: s=`${n}-enter-to`, appearFromClass: l=o, appearActiveClass: c=i, appearToClass: u=s, leaveFromClass: f=`${n}-leave-from`, leaveActiveClass: d=`${n}-leave-active`, leaveToClass: p=`${n}-leave-to`} = e
      , h = Wg(r)
      , m = h && h[0]
      , g = h && h[1]
      , {onBeforeEnter: b, onEnter: v, onEnterCancelled: y, onLeave: w, onLeaveCancelled: C, onBeforeAppear: _=b, onAppear: E=v, onAppearCancelled: z=y} = t
      , T = (M, L, U) => {
        wr(M, L ? u : s),
        wr(M, L ? c : i),
        U && U()
    }
      , A = (M, L) => {
        M._isLeaving = !1,
        wr(M, f),
        wr(M, p),
        wr(M, d),
        L && L()
    }
      , x = M => (L, U) => {
        const Y = M ? E : v
          , H = () => T(L, M, U);
        Xr(Y, [L, H]),
        Qd( () => {
            wr(L, M ? l : o),
            Ya(L, M ? u : s),
            Jd(Y) || e3(L, a, m, H)
        }
        )
    }
    ;
    return Ot(t, {
        onBeforeEnter(M) {
            Xr(b, [M]),
            Ya(M, o),
            Ya(M, i)
        },
        onBeforeAppear(M) {
            Xr(_, [M]),
            Ya(M, l),
            Ya(M, c)
        },
        onEnter: x(!1),
        onAppear: x(!0),
        onLeave(M, L) {
            M._isLeaving = !0;
            const U = () => A(M, L);
            Ya(M, f),
            M5(),
            Ya(M, d),
            Qd( () => {
                M._isLeaving && (wr(M, f),
                Ya(M, p),
                Jd(w) || e3(M, a, g, U))
            }
            ),
            Xr(w, [M, U])
        },
        onEnterCancelled(M) {
            T(M, !1),
            Xr(y, [M])
        },
        onAppearCancelled(M) {
            T(M, !0),
            Xr(z, [M])
        },
        onLeaveCancelled(M) {
            A(M),
            Xr(C, [M])
        }
    })
}
function Wg(e) {
    if (e == null)
        return null;
    if (kt(e))
        return [Nc(e.enter), Nc(e.leave)];
    {
        const t = Nc(e);
        return [t, t]
    }
}
function Nc(e) {
    return l1(e)
}
function Ya(e, t) {
    t.split(/\s+/).forEach(n => n && e.classList.add(n)),
    (e[di] || (e[di] = new Set)).add(t)
}
function wr(e, t) {
    t.split(/\s+/).forEach(a => a && e.classList.remove(a));
    const n = e[di];
    n && (n.delete(t),
    n.size || (e[di] = void 0))
}
function Qd(e) {
    requestAnimationFrame( () => {
        requestAnimationFrame(e)
    }
    )
}
let Yg = 0;
function e3(e, t, n, a) {
    const r = e._endId = ++Yg
      , o = () => {
        r === e._endId && a()
    }
    ;
    if (n)
        return setTimeout(o, n);
    const {type: i, timeout: s, propCount: l} = T5(e, t);
    if (!i)
        return a();
    const c = i + "end";
    let u = 0;
    const f = () => {
        e.removeEventListener(c, d),
        o()
    }
      , d = p => {
        p.target === e && ++u >= l && f()
    }
    ;
    setTimeout( () => {
        u < l && f()
    }
    , s + 1),
    e.addEventListener(c, d)
}
function T5(e, t) {
    const n = window.getComputedStyle(e)
      , a = h => (n[h] || "").split(", ")
      , r = a(`${br}Delay`)
      , o = a(`${br}Duration`)
      , i = t3(r, o)
      , s = a(`${Ri}Delay`)
      , l = a(`${Ri}Duration`)
      , c = t3(s, l);
    let u = null
      , f = 0
      , d = 0;
    t === br ? i > 0 && (u = br,
    f = i,
    d = o.length) : t === Ri ? c > 0 && (u = Ri,
    f = c,
    d = l.length) : (f = Math.max(i, c),
    u = f > 0 ? i > c ? br : Ri : null,
    d = u ? u === br ? o.length : l.length : 0);
    const p = u === br && /\b(transform|all)(,|$)/.test(a(`${br}Property`).toString());
    return {
        type: u,
        timeout: f,
        propCount: d,
        hasTransform: p
    }
}
function t3(e, t) {
    for (; e.length < t.length; )
        e = e.concat(e);
    return Math.max(...t.map( (n, a) => n3(n) + n3(e[a])))
}
function n3(e) {
    return e === "auto" ? 0 : Number(e.slice(0, -1).replace(",", ".")) * 1e3
}
function M5() {
    return document.body.offsetHeight
}
function Gg(e, t, n) {
    const a = e[di];
    a && (t = (t ? [t, ...a] : [...a]).join(" ")),
    t == null ? e.removeAttribute("class") : n ? e.setAttribute("class", t) : e.className = t
}
const wf = Symbol("_vod")
  , z5 = {
    beforeMount(e, {value: t}, {transition: n}) {
        e[wf] = e.style.display === "none" ? "" : e.style.display,
        n && t ? n.beforeEnter(e) : Di(e, t)
    },
    mounted(e, {value: t}, {transition: n}) {
        n && t && n.enter(e)
    },
    updated(e, {value: t, oldValue: n}, {transition: a}) {
        !t != !n && (a ? t ? (a.beforeEnter(e),
        Di(e, !0),
        a.enter(e)) : a.leave(e, () => {
            Di(e, !1)
        }
        ) : Di(e, t))
    },
    beforeUnmount(e, {value: t}) {
        Di(e, t)
    }
};
function Di(e, t) {
    e.style.display = t ? e[wf] : "none"
}
function Xg() {
    z5.getSSRProps = ({value: e}) => {
        if (!e)
            return {
                style: {
                    display: "none"
                }
            }
    }
}
const A5 = Symbol("");
function Kg(e) {
    const t = Ha();
    if (!t)
        return;
    const n = t.ut = (r=e(t.proxy)) => {
        Array.from(document.querySelectorAll(`[data-v-owner="${t.uid}"]`)).forEach(o => N2(o, r))
    }
      , a = () => {
        const r = e(t.proxy);
        D2(t.subTree, r),
        n(r)
    }
    ;
    D0(a),
    Xe( () => {
        const r = new MutationObserver(a);
        r.observe(t.subTree.el.parentNode, {
            childList: !0
        }),
        Ca( () => r.disconnect())
    }
    )
}
function D2(e, t) {
    if (e.shapeFlag & 128) {
        const n = e.suspense;
        e = n.activeBranch,
        n.pendingBranch && !n.isHydrating && n.effects.push( () => {
            D2(n.activeBranch, t)
        }
        )
    }
    for (; e.component; )
        e = e.component.subTree;
    if (e.shapeFlag & 1 && e.el)
        N2(e.el, t);
    else if (e.type === Be)
        e.children.forEach(n => D2(n, t));
    else if (e.type === fo) {
        let {el: n, anchor: a} = e;
        for (; n && (N2(n, t),
        n !== a); )
            n = n.nextSibling
    }
}
function N2(e, t) {
    if (e.nodeType === 1) {
        const n = e.style;
        let a = "";
        for (const r in t)
            n.setProperty(`--${r}`, t[r]),
            a += `--${r}: ${t[r]};`;
        n[A5] = a
    }
}
function Zg(e, t, n) {
    const a = e.style
      , r = Pt(n);
    if (n && !r) {
        if (t && !Pt(t))
            for (const o in t)
                n[o] == null && H2(a, o, "");
        for (const o in n)
            H2(a, o, n[o])
    } else {
        const o = a.display;
        if (r) {
            if (t !== n) {
                const i = a[A5];
                i && (n += ";" + i),
                a.cssText = n
            }
        } else
            t && e.removeAttribute("style");
        wf in e && (a.display = o)
    }
}
const a3 = /\s*!important$/;
function H2(e, t, n) {
    if (Je(n))
        n.forEach(a => H2(e, t, a));
    else if (n == null && (n = ""),
    t.startsWith("--"))
        e.setProperty(t, n);
    else {
        const a = Jg(e, t);
        a3.test(n) ? e.setProperty(Hn(a), n.replace(a3, ""), "important") : e[a] = n
    }
}
const r3 = ["Webkit", "Moz", "ms"]
  , Hc = {};
function Jg(e, t) {
    const n = Hc[t];
    if (n)
        return n;
    let a = Cn(t);
    if (a !== "filter" && a in e)
        return Hc[t] = a;
    a = Ns(a);
    for (let r = 0; r < r3.length; r++) {
        const o = r3[r] + a;
        if (o in e)
            return Hc[t] = o
    }
    return t
}
const o3 = "http://www.w3.org/1999/xlink";
function Qg(e, t, n, a, r) {
    if (a && t.startsWith("xlink:"))
        n == null ? e.removeAttributeNS(o3, t.slice(6, t.length)) : e.setAttributeNS(o3, t, n);
    else {
        const o = $m(t);
        n == null || o && !o0(n) ? e.removeAttribute(t) : e.setAttribute(t, o ? "" : n)
    }
}
function ev(e, t, n, a, r, o, i) {
    if (t === "innerHTML" || t === "textContent") {
        a && i(a, r, o),
        e[t] = n ?? "";
        return
    }
    const s = e.tagName;
    if (t === "value" && s !== "PROGRESS" && !s.includes("-")) {
        e._value = n;
        const c = s === "OPTION" ? e.getAttribute("value") : e.value
          , u = n ?? "";
        c !== u && (e.value = u),
        n == null && e.removeAttribute(t);
        return
    }
    let l = !1;
    if (n === "" || n == null) {
        const c = typeof e[t];
        c === "boolean" ? n = o0(n) : n == null && c === "string" ? (n = "",
        l = !0) : c === "number" && (n = 0,
        l = !0)
    }
    try {
        e[t] = n
    } catch {}
    l && e.removeAttribute(t)
}
function Za(e, t, n, a) {
    e.addEventListener(t, n, a)
}
function tv(e, t, n, a) {
    e.removeEventListener(t, n, a)
}
const i3 = Symbol("_vei");
function nv(e, t, n, a, r=null) {
    const o = e[i3] || (e[i3] = {})
      , i = o[t];
    if (a && i)
        i.value = a;
    else {
        const [s,l] = av(t);
        if (a) {
            const c = o[t] = iv(a, r);
            Za(e, s, c, l)
        } else
            i && (tv(e, s, i, l),
            o[t] = void 0)
    }
}
const s3 = /(?:Once|Passive|Capture)$/;
function av(e) {
    let t;
    if (s3.test(e)) {
        t = {};
        let a;
        for (; a = e.match(s3); )
            e = e.slice(0, e.length - a[0].length),
            t[a[0].toLowerCase()] = !0
    }
    return [e[2] === ":" ? e.slice(3) : Hn(e.slice(2)), t]
}
let Vc = 0;
const rv = Promise.resolve()
  , ov = () => Vc || (rv.then( () => Vc = 0),
Vc = Date.now());
function iv(e, t) {
    const n = a => {
        if (!a._vts)
            a._vts = Date.now();
        else if (a._vts <= n.attached)
            return;
        Fn(sv(a, n.value), t, 5, [a])
    }
    ;
    return n.value = e,
    n.attached = ov(),
    n
}
function sv(e, t) {
    if (Je(t)) {
        const n = e.stopImmediatePropagation;
        return e.stopImmediatePropagation = () => {
            n.call(e),
            e._stopped = !0
        }
        ,
        t.map(a => r => !r._stopped && a && a(r))
    } else
        return t
}
const l3 = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123
  , lv = (e, t, n, a, r, o, i, s, l) => {
    const c = r === "svg";
    t === "class" ? Gg(e, a, c) : t === "style" ? Zg(e, n, a) : Ds(t) ? ju(t) || nv(e, t, n, a, i) : (t[0] === "." ? (t = t.slice(1),
    !0) : t[0] === "^" ? (t = t.slice(1),
    !1) : cv(e, t, a, c)) ? ev(e, t, a, o, i, s, l) : (t === "true-value" ? e._trueValue = a : t === "false-value" && (e._falseValue = a),
    Qg(e, t, a, c))
}
;
function cv(e, t, n, a) {
    if (a)
        return !!(t === "innerHTML" || t === "textContent" || t in e && l3(t) && ot(n));
    if (t === "spellcheck" || t === "draggable" || t === "translate" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA")
        return !1;
    if (t === "width" || t === "height") {
        const r = e.tagName;
        if (r === "IMG" || r === "VIDEO" || r === "CANVAS" || r === "SOURCE")
            return !1
    }
    return l3(t) && Pt(n) ? !1 : t in e
}
/*! #__NO_SIDE_EFFECTS__ */
function O5(e, t) {
    const n = jr(e);
    class a extends tc {
        constructor(o) {
            super(n, o, t)
        }
    }
    return a.def = n,
    a
}
/*! #__NO_SIDE_EFFECTS__ */
const uv = e => O5(e, U5)
  , fv = typeof HTMLElement < "u" ? HTMLElement : class {
}
;
class tc extends fv {
    constructor(t, n={}, a) {
        super(),
        this._def = t,
        this._props = n,
        this._instance = null,
        this._connected = !1,
        this._resolved = !1,
        this._numberProps = null,
        this._ob = null,
        this.shadowRoot && a ? a(this._createVNode(), this.shadowRoot) : (this.attachShadow({
            mode: "open"
        }),
        this._def.__asyncLoader || this._resolveProps(this._def))
    }
    connectedCallback() {
        this._connected = !0,
        this._instance || (this._resolved ? this._update() : this._resolveDef())
    }
    disconnectedCallback() {
        this._connected = !1,
        this._ob && (this._ob.disconnect(),
        this._ob = null),
        Zn( () => {
            this._connected || (V2(null, this.shadowRoot),
            this._instance = null)
        }
        )
    }
    _resolveDef() {
        this._resolved = !0;
        for (let a = 0; a < this.attributes.length; a++)
            this._setAttr(this.attributes[a].name);
        this._ob = new MutationObserver(a => {
            for (const r of a)
                this._setAttr(r.attributeName)
        }
        ),
        this._ob.observe(this, {
            attributes: !0
        });
        const t = (a, r=!1) => {
            const {props: o, styles: i} = a;
            let s;
            if (o && !Je(o))
                for (const l in o) {
                    const c = o[l];
                    (c === Number || c && c.type === Number) && (l in this._props && (this._props[l] = l1(this._props[l])),
                    (s || (s = Object.create(null)))[Cn(l)] = !0)
                }
            this._numberProps = s,
            r && this._resolveProps(a),
            this._applyStyles(i),
            this._update()
        }
          , n = this._def.__asyncLoader;
        n ? n().then(a => t(a, !0)) : t(this._def)
    }
    _resolveProps(t) {
        const {props: n} = t
          , a = Je(n) ? n : Object.keys(n || {});
        for (const r of Object.keys(this))
            r[0] !== "_" && a.includes(r) && this._setProp(r, this[r], !0, !1);
        for (const r of a.map(Cn))
            Object.defineProperty(this, r, {
                get() {
                    return this._getProp(r)
                },
                set(o) {
                    this._setProp(r, o)
                }
            })
    }
    _setAttr(t) {
        let n = this.getAttribute(t);
        const a = Cn(t);
        this._numberProps && this._numberProps[a] && (n = l1(n)),
        this._setProp(a, n, !1)
    }
    _getProp(t) {
        return this._props[t]
    }
    _setProp(t, n, a=!0, r=!0) {
        n !== this._props[t] && (this._props[t] = n,
        r && this._instance && this._update(),
        a && (n === !0 ? this.setAttribute(Hn(t), "") : typeof n == "string" || typeof n == "number" ? this.setAttribute(Hn(t), n + "") : n || this.removeAttribute(Hn(t))))
    }
    _update() {
        V2(this._createVNode(), this.shadowRoot)
    }
    _createVNode() {
        const t = S(this._def, Ot({}, this._props));
        return this._instance || (t.ce = n => {
            this._instance = n,
            n.isCE = !0;
            const a = (o, i) => {
                this.dispatchEvent(new CustomEvent(o,{
                    detail: i
                }))
            }
            ;
            n.emit = (o, ...i) => {
                a(o, i),
                Hn(o) !== o && a(Hn(o), i)
            }
            ;
            let r = this;
            for (; r = r && (r.parentNode || r.host); )
                if (r instanceof tc) {
                    n.parent = r._instance,
                    n.provides = r._instance.provides;
                    break
                }
        }
        ),
        t
    }
    _applyStyles(t) {
        t && t.forEach(n => {
            const a = document.createElement("style");
            a.textContent = n,
            this.shadowRoot.appendChild(a)
        }
        )
    }
}
function dv(e="$style") {
    {
        const t = Ha();
        if (!t)
            return _t;
        const n = t.type.__cssModules;
        if (!n)
            return _t;
        const a = n[e];
        return a || _t
    }
}
const P5 = new WeakMap
  , L5 = new WeakMap
  , b1 = Symbol("_moveCb")
  , c3 = Symbol("_enterCb")
  , I5 = {
    name: "TransitionGroup",
    props: Ot({}, qg, {
        tag: String,
        moveClass: String
    }),
    setup(e, {slots: t}) {
        const n = Ha()
          , a = pf();
        let r, o;
        return On( () => {
            if (!r.length)
                return;
            const i = e.moveClass || `${e.name || "v"}-move`;
            if (!bv(r[0].el, n.vnode.el, i))
                return;
            r.forEach(mv),
            r.forEach(gv);
            const s = r.filter(vv);
            M5(),
            s.forEach(l => {
                const c = l.el
                  , u = c.style;
                Ya(c, i),
                u.transform = u.webkitTransform = u.transitionDuration = "";
                const f = c[b1] = d => {
                    d && d.target !== c || (!d || /transform$/.test(d.propertyName)) && (c.removeEventListener("transitionend", f),
                    c[b1] = null,
                    wr(c, i))
                }
                ;
                c.addEventListener("transitionend", f)
            }
            )
        }
        ),
        () => {
            const i = rt(e)
              , s = x5(i);
            let l = i.tag || Be;
            r = o,
            o = t.default ? X1(t.default()) : [];
            for (let c = 0; c < o.length; c++) {
                const u = o[c];
                u.key != null && bo(u, fi(u, s, a, n))
            }
            if (r)
                for (let c = 0; c < r.length; c++) {
                    const u = r[c];
                    bo(u, fi(u, s, a, n)),
                    P5.set(u, u.el.getBoundingClientRect())
                }
            return S(l, null, o)
        }
    }
}
  , pv = e => delete e.mode;
I5.props;
const hv = I5;
function mv(e) {
    const t = e.el;
    t[b1] && t[b1](),
    t[c3] && t[c3]()
}
function gv(e) {
    L5.set(e, e.el.getBoundingClientRect())
}
function vv(e) {
    const t = P5.get(e)
      , n = L5.get(e)
      , a = t.left - n.left
      , r = t.top - n.top;
    if (a || r) {
        const o = e.el.style;
        return o.transform = o.webkitTransform = `translate(${a}px,${r}px)`,
        o.transitionDuration = "0s",
        e
    }
}
function bv(e, t, n) {
    const a = e.cloneNode()
      , r = e[di];
    r && r.forEach(s => {
        s.split(/\s+/).forEach(l => l && a.classList.remove(l))
    }
    ),
    n.split(/\s+/).forEach(s => s && a.classList.add(s)),
    a.style.display = "none";
    const o = t.nodeType === 1 ? t : t.parentNode;
    o.appendChild(a);
    const {hasTransform: i} = T5(a);
    return o.removeChild(a),
    i
}
const Pr = e => {
    const t = e.props["onUpdate:modelValue"] || !1;
    return Je(t) ? n => ti(t, n) : t
}
;
function yv(e) {
    e.target.composing = !0
}
function u3(e) {
    const t = e.target;
    t.composing && (t.composing = !1,
    t.dispatchEvent(new Event("input")))
}
const ea = Symbol("_assign")
  , y1 = {
    created(e, {modifiers: {lazy: t, trim: n, number: a}}, r) {
        e[ea] = Pr(r);
        const o = a || r.props && r.props.type === "number";
        Za(e, t ? "change" : "input", i => {
            if (i.target.composing)
                return;
            let s = e.value;
            n && (s = s.trim()),
            o && (s = s1(s)),
            e[ea](s)
        }
        ),
        n && Za(e, "change", () => {
            e.value = e.value.trim()
        }
        ),
        t || (Za(e, "compositionstart", yv),
        Za(e, "compositionend", u3),
        Za(e, "change", u3))
    },
    mounted(e, {value: t}) {
        e.value = t ?? ""
    },
    beforeUpdate(e, {value: t, modifiers: {lazy: n, trim: a, number: r}}, o) {
        if (e[ea] = Pr(o),
        e.composing)
            return;
        const i = r || e.type === "number" ? s1(e.value) : e.value
          , s = t ?? "";
        i !== s && (document.activeElement === e && e.type !== "range" && (n || a && e.value.trim() === s) || (e.value = s))
    }
}
  , _f = {
    deep: !0,
    created(e, t, n) {
        e[ea] = Pr(n),
        Za(e, "change", () => {
            const a = e._modelValue
              , r = pi(e)
              , o = e.checked
              , i = e[ea];
            if (Je(a)) {
                const s = F1(a, r)
                  , l = s !== -1;
                if (o && !l)
                    i(a.concat(r));
                else if (!o && l) {
                    const c = [...a];
                    c.splice(s, 1),
                    i(c)
                }
            } else if (Eo(a)) {
                const s = new Set(a);
                o ? s.add(r) : s.delete(r),
                i(s)
            } else
                i(R5(e, o))
        }
        )
    },
    mounted: f3,
    beforeUpdate(e, t, n) {
        e[ea] = Pr(n),
        f3(e, t, n)
    }
};
function f3(e, {value: t, oldValue: n}, a) {
    e._modelValue = t,
    Je(t) ? e.checked = F1(t, a.props.value) > -1 : Eo(t) ? e.checked = t.has(a.props.value) : t !== n && (e.checked = Ar(t, R5(e, !0)))
}
const kf = {
    created(e, {value: t}, n) {
        e.checked = Ar(t, n.props.value),
        e[ea] = Pr(n),
        Za(e, "change", () => {
            e[ea](pi(e))
        }
        )
    },
    beforeUpdate(e, {value: t, oldValue: n}, a) {
        e[ea] = Pr(a),
        t !== n && (e.checked = Ar(t, a.props.value))
    }
}
  , B5 = {
    deep: !0,
    created(e, {value: t, modifiers: {number: n}}, a) {
        const r = Eo(t);
        Za(e, "change", () => {
            const o = Array.prototype.filter.call(e.options, i => i.selected).map(i => n ? s1(pi(i)) : pi(i));
            e[ea](e.multiple ? r ? new Set(o) : o : o[0])
        }
        ),
        e[ea] = Pr(a)
    },
    mounted(e, {value: t}) {
        d3(e, t)
    },
    beforeUpdate(e, t, n) {
        e[ea] = Pr(n)
    },
    updated(e, {value: t}) {
        d3(e, t)
    }
};
function d3(e, t) {
    const n = e.multiple;
    if (!(n && !Je(t) && !Eo(t))) {
        for (let a = 0, r = e.options.length; a < r; a++) {
            const o = e.options[a]
              , i = pi(o);
            if (n)
                Je(t) ? o.selected = F1(t, i) > -1 : o.selected = t.has(i);
            else if (Ar(pi(o), t)) {
                e.selectedIndex !== a && (e.selectedIndex = a);
                return
            }
        }
        !n && e.selectedIndex !== -1 && (e.selectedIndex = -1)
    }
}
function pi(e) {
    return "_value"in e ? e._value : e.value
}
function R5(e, t) {
    const n = t ? "_trueValue" : "_falseValue";
    return n in e ? e[n] : t
}
const D5 = {
    created(e, t, n) {
        kl(e, t, n, null, "created")
    },
    mounted(e, t, n) {
        kl(e, t, n, null, "mounted")
    },
    beforeUpdate(e, t, n, a) {
        kl(e, t, n, a, "beforeUpdate")
    },
    updated(e, t, n, a) {
        kl(e, t, n, a, "updated")
    }
};
function N5(e, t) {
    switch (e) {
    case "SELECT":
        return B5;
    case "TEXTAREA":
        return y1;
    default:
        switch (t) {
        case "checkbox":
            return _f;
        case "radio":
            return kf;
        default:
            return y1
        }
    }
}
function kl(e, t, n, a, r) {
    const i = N5(e.tagName, n.props && n.props.type)[r];
    i && i(e, t, n, a)
}
function Cv() {
    y1.getSSRProps = ({value: e}) => ({
        value: e
    }),
    kf.getSSRProps = ({value: e}, t) => {
        if (t.props && Ar(t.props.value, e))
            return {
                checked: !0
            }
    }
    ,
    _f.getSSRProps = ({value: e}, t) => {
        if (Je(e)) {
            if (t.props && F1(e, t.props.value) > -1)
                return {
                    checked: !0
                }
        } else if (Eo(e)) {
            if (t.props && e.has(t.props.value))
                return {
                    checked: !0
                }
        } else if (e)
            return {
                checked: !0
            }
    }
    ,
    D5.getSSRProps = (e, t) => {
        if (typeof t.type != "string")
            return;
        const n = N5(t.type.toUpperCase(), t.props && t.props.type);
        if (n.getSSRProps)
            return n.getSSRProps(e, t)
    }
}
const wv = ["ctrl", "shift", "alt", "meta"]
  , _v = {
    stop: e => e.stopPropagation(),
    prevent: e => e.preventDefault(),
    self: e => e.target !== e.currentTarget,
    ctrl: e => !e.ctrlKey,
    shift: e => !e.shiftKey,
    alt: e => !e.altKey,
    meta: e => !e.metaKey,
    left: e => "button"in e && e.button !== 0,
    middle: e => "button"in e && e.button !== 1,
    right: e => "button"in e && e.button !== 2,
    exact: (e, t) => wv.some(n => e[`${n}Key`] && !t.includes(n))
}
  , H5 = (e, t) => {
    const n = e._withMods || (e._withMods = {})
      , a = t.join(".");
    return n[a] || (n[a] = (r, ...o) => {
        for (let i = 0; i < t.length; i++) {
            const s = _v[t[i]];
            if (s && s(r, t))
                return
        }
        return e(r, ...o)
    }
    )
}
  , kv = {
    esc: "escape",
    space: " ",
    up: "arrow-up",
    left: "arrow-left",
    right: "arrow-right",
    down: "arrow-down",
    delete: "backspace"
}
  , Sv = (e, t) => {
    const n = e._withKeys || (e._withKeys = {})
      , a = t.join(".");
    return n[a] || (n[a] = r => {
        if (!("key"in r))
            return;
        const o = Hn(r.key);
        if (t.some(i => i === o || kv[i] === o))
            return e(r)
    }
    )
}
  , V5 = Ot({
    patchProp: lv
}, Ug);
let cs, p3 = !1;
function F5() {
    return cs || (cs = l5(V5))
}
function j5() {
    return cs = p3 ? cs : c5(V5),
    p3 = !0,
    cs
}
const V2 = (...e) => {
    F5().render(...e)
}
  , U5 = (...e) => {
    j5().hydrate(...e)
}
  , q5 = (...e) => {
    const t = F5().createApp(...e)
      , {mount: n} = t;
    return t.mount = a => {
        const r = Y5(a);
        if (!r)
            return;
        const o = t._component;
        !ot(o) && !o.render && !o.template && (o.template = r.innerHTML),
        r.innerHTML = "";
        const i = n(r, !1, W5(r));
        return r instanceof Element && (r.removeAttribute("v-cloak"),
        r.setAttribute("data-v-app", "")),
        i
    }
    ,
    t
}
  , $v = (...e) => {
    const t = j5().createApp(...e)
      , {mount: n} = t;
    return t.mount = a => {
        const r = Y5(a);
        if (r)
            return n(r, !0, W5(r))
    }
    ,
    t
}
;
function W5(e) {
    if (e instanceof SVGElement)
        return "svg";
    if (typeof MathMLElement == "function" && e instanceof MathMLElement)
        return "mathml"
}
function Y5(e) {
    return Pt(e) ? document.querySelector(e) : e
}
let h3 = !1;
const Ev = () => {
    h3 || (h3 = !0,
    Cv(),
    Xg())
}
;
/**
* vue v3.4.8
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const xv = () => {}
  , Tv = Object.freeze(Object.defineProperty({
    __proto__: null,
    BaseTransition: V0,
    BaseTransitionPropsValidators: hf,
    Comment: pn,
    DeprecationTypes: Vg,
    EffectScope: Gu,
    ErrorCodes: p9,
    ErrorTypeStrings: Lg,
    Fragment: Be,
    KeepAlive: B9,
    ReactiveEffect: ui,
    Static: fo,
    Suspense: E9,
    Teleport: p5,
    Text: yo,
    TrackOpTypes: i9,
    Transition: Cf,
    TransitionGroup: hv,
    TriggerOpTypes: s9,
    VueElement: tc,
    assertNumber: d9,
    callWithAsyncErrorHandling: Fn,
    callWithErrorHandling: Ia,
    camelize: Cn,
    capitalize: Ns,
    cloneVNode: Da,
    compatUtils: Hg,
    compile: xv,
    computed: ae,
    createApp: q5,
    createBlock: K,
    createCommentVNode: pe,
    createElementBlock: G,
    createElementVNode: V,
    createHydrationRenderer: c5,
    createPropsRestProxy: K9,
    createRenderer: l5,
    createSSRApp: $v,
    createSlots: lr,
    createStaticVNode: bf,
    createTextVNode: J,
    createVNode: S,
    customRef: S0,
    defineAsyncComponent: L9,
    defineComponent: jr,
    defineCustomElement: O5,
    defineEmits: H9,
    defineExpose: V9,
    defineModel: U9,
    defineOptions: F9,
    defineProps: N9,
    defineSSRCustomElement: uv,
    defineSlots: j9,
    devtools: Ig,
    effect: Tm,
    effectScope: Xu,
    getCurrentInstance: Ha,
    getCurrentScope: Ku,
    getTransitionRawChildren: X1,
    guardReactiveProps: Q1,
    h: Pe,
    handleError: xo,
    hasInjectionContext: og,
    hydrate: U5,
    initCustomFormatter: Ag,
    initDirectivesForSSR: Ev,
    inject: Qn,
    isMemoSame: S5,
    isProxy: nf,
    isReactive: La,
    isReadonly: nr,
    isRef: Dt,
    isRuntimeOnly: Eg,
    isShallow: gs,
    isVNode: Or,
    markRaw: ga,
    mergeDefaults: G9,
    mergeModels: X9,
    mergeProps: Un,
    nextTick: Zn,
    normalizeClass: Ae,
    normalizeProps: c1,
    normalizeStyle: Rt,
    onActivated: j0,
    onBeforeMount: W0,
    onBeforeUnmount: lt,
    onBeforeUpdate: Z1,
    onDeactivated: U0,
    onErrorCaptured: K0,
    onMounted: Xe,
    onRenderTracked: X0,
    onRenderTriggered: G0,
    onScopeDispose: l0,
    onServerPrefetch: Y0,
    onUnmounted: Ca,
    onUpdated: On,
    openBlock: O,
    popScopeId: Wt,
    provide: To,
    proxyRefs: of,
    pushScopeId: qt,
    queuePostFlushCb: f1,
    reactive: Jn,
    readonly: tf,
    ref: oe,
    registerRuntimeCompiler: $g,
    render: V2,
    renderList: vt,
    renderSlot: ce,
    resolveComponent: P,
    resolveDirective: Hs,
    resolveDynamicComponent: jn,
    resolveFilter: Ng,
    resolveTransitionHooks: fi,
    setBlockTracking: P2,
    setDevtoolsHook: Bg,
    setTransitionHooks: bo,
    shallowReactive: ef,
    shallowReadonly: Xm,
    shallowRef: Zm,
    ssrContextKey: B0,
    ssrUtils: Dg,
    stop: Mm,
    toDisplayString: Me,
    toHandlerKey: rs,
    toHandlers: J0,
    toRaw: rt,
    toRef: o9,
    toRefs: $0,
    toValue: e9,
    transformVNodeArgs: Cg,
    triggerRef: Qm,
    unref: B,
    useAttrs: W9,
    useCssModule: dv,
    useCssVars: Kg,
    useModel: Y9,
    useSSRContext: R0,
    useSlots: Q0,
    useTransitionState: pf,
    vModelCheckbox: _f,
    vModelDynamic: D5,
    vModelRadio: kf,
    vModelSelect: B5,
    vModelText: y1,
    vShow: z5,
    version: $5,
    warn: Pg,
    watch: st,
    watchEffect: df,
    watchPostEffect: D0,
    watchSyncEffect: N0,
    withAsyncContext: Z9,
    withCtx: k,
    withDefaults: q9,
    withDirectives: Fs,
    withKeys: Sv,
    withMemo: Og,
    withModifiers: H5,
    withScopeId: O0
}, Symbol.toStringTag, {
    value: "Module"
}));
var da = !1;
function Gi(e, t, n) {
    return Array.isArray(e) ? (e.length = Math.max(e.length, t),
    e.splice(t, 1, n),
    n) : (e[t] = n,
    n)
}
function Mv() {
    return G5().__VUE_DEVTOOLS_GLOBAL_HOOK__
}
function G5() {
    return typeof navigator < "u" && typeof window < "u" ? window : typeof global < "u" ? global : {}
}
const zv = typeof Proxy == "function"
  , Av = "devtools-plugin:setup"
  , Ov = "plugin:settings:set";
let No, F2;
function Pv() {
    var e;
    return No !== void 0 || (typeof window < "u" && window.performance ? (No = !0,
    F2 = window.performance) : typeof global < "u" && (!((e = global.perf_hooks) === null || e === void 0) && e.performance) ? (No = !0,
    F2 = global.perf_hooks.performance) : No = !1),
    No
}
function Lv() {
    return Pv() ? F2.now() : Date.now()
}
class Iv {
    constructor(t, n) {
        this.target = null,
        this.targetQueue = [],
        this.onQueue = [],
        this.plugin = t,
        this.hook = n;
        const a = {};
        if (t.settings)
            for (const i in t.settings) {
                const s = t.settings[i];
                a[i] = s.defaultValue
            }
        const r = `__vue-devtools-plugin-settings__${t.id}`;
        let o = Object.assign({}, a);
        try {
            const i = localStorage.getItem(r)
              , s = JSON.parse(i);
            Object.assign(o, s)
        } catch {}
        this.fallbacks = {
            getSettings() {
                return o
            },
            setSettings(i) {
                try {
                    localStorage.setItem(r, JSON.stringify(i))
                } catch {}
                o = i
            },
            now() {
                return Lv()
            }
        },
        n && n.on(Ov, (i, s) => {
            i === this.plugin.id && this.fallbacks.setSettings(s)
        }
        ),
        this.proxiedOn = new Proxy({},{
            get: (i, s) => this.target ? this.target.on[s] : (...l) => {
                this.onQueue.push({
                    method: s,
                    args: l
                })
            }
        }),
        this.proxiedTarget = new Proxy({},{
            get: (i, s) => this.target ? this.target[s] : s === "on" ? this.proxiedOn : Object.keys(this.fallbacks).includes(s) ? (...l) => (this.targetQueue.push({
                method: s,
                args: l,
                resolve: () => {}
            }),
            this.fallbacks[s](...l)) : (...l) => new Promise(c => {
                this.targetQueue.push({
                    method: s,
                    args: l,
                    resolve: c
                })
            }
            )
        })
    }
    async setRealTarget(t) {
        this.target = t;
        for (const n of this.onQueue)
            this.target.on[n.method](...n.args);
        for (const n of this.targetQueue)
            n.resolve(await this.target[n.method](...n.args))
    }
}
function X5(e, t) {
    const n = e
      , a = G5()
      , r = Mv()
      , o = zv && n.enableEarlyProxy;
    if (r && (a.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !o))
        r.emit(Av, e, t);
    else {
        const i = o ? new Iv(n,r) : null;
        (a.__VUE_DEVTOOLS_PLUGINS__ = a.__VUE_DEVTOOLS_PLUGINS__ || []).push({
            pluginDescriptor: n,
            setupFn: t,
            proxy: i
        }),
        i && t(i.proxiedTarget)
    }
}
/*!
  * pinia v2.0.33
  * (c) 2023 Eduardo San Martin Morote
  * @license MIT
  */
let K5;
const nc = e => K5 = e;
const Z5 = Symbol();
function j2(e) {
    return e && typeof e == "object" && Object.prototype.toString.call(e) === "[object Object]" && typeof e.toJSON != "function"
}
var Ba;
(function(e) {
    e.direct = "direct",
    e.patchObject = "patch object",
    e.patchFunction = "patch function"
}
)(Ba || (Ba = {}));
const Bv = typeof window < "u"
  , us = !1
  , m3 = ( () => typeof window == "object" && window.window === window ? window : typeof self == "object" && self.self === self ? self : typeof global == "object" && global.global === global ? global : typeof globalThis == "object" ? globalThis : {
    HTMLElement: null
})();
function Rv(e, {autoBom: t=!1}={}) {
    return t && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e.type) ? new Blob([String.fromCharCode(65279), e],{
        type: e.type
    }) : e
}
function Sf(e, t, n) {
    const a = new XMLHttpRequest;
    a.open("GET", e),
    a.responseType = "blob",
    a.onload = function() {
        e7(a.response, t, n)
    }
    ,
    a.onerror = function() {
        console.error("could not download file")
    }
    ,
    a.send()
}
function J5(e) {
    const t = new XMLHttpRequest;
    t.open("HEAD", e, !1);
    try {
        t.send()
    } catch {}
    return t.status >= 200 && t.status <= 299
}
function Ul(e) {
    try {
        e.dispatchEvent(new MouseEvent("click"))
    } catch {
        const n = document.createEvent("MouseEvents");
        n.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null),
        e.dispatchEvent(n)
    }
}
const ql = typeof navigator == "object" ? navigator : {
    userAgent: ""
}
  , Q5 = ( () => /Macintosh/.test(ql.userAgent) && /AppleWebKit/.test(ql.userAgent) && !/Safari/.test(ql.userAgent))()
  , e7 = Bv ? typeof HTMLAnchorElement < "u" && "download"in HTMLAnchorElement.prototype && !Q5 ? Dv : "msSaveOrOpenBlob"in ql ? Nv : Hv : () => {}
;
function Dv(e, t="download", n) {
    const a = document.createElement("a");
    a.download = t,
    a.rel = "noopener",
    typeof e == "string" ? (a.href = e,
    a.origin !== location.origin ? J5(a.href) ? Sf(e, t, n) : (a.target = "_blank",
    Ul(a)) : Ul(a)) : (a.href = URL.createObjectURL(e),
    setTimeout(function() {
        URL.revokeObjectURL(a.href)
    }, 4e4),
    setTimeout(function() {
        Ul(a)
    }, 0))
}
function Nv(e, t="download", n) {
    if (typeof e == "string")
        if (J5(e))
            Sf(e, t, n);
        else {
            const a = document.createElement("a");
            a.href = e,
            a.target = "_blank",
            setTimeout(function() {
                Ul(a)
            })
        }
    else
        navigator.msSaveOrOpenBlob(Rv(e, n), t)
}
function Hv(e, t, n, a) {
    if (a = a || open("", "_blank"),
    a && (a.document.title = a.document.body.innerText = "downloading..."),
    typeof e == "string")
        return Sf(e, t, n);
    const r = e.type === "application/octet-stream"
      , o = /constructor/i.test(String(m3.HTMLElement)) || "safari"in m3
      , i = /CriOS\/[\d]+/.test(navigator.userAgent);
    if ((i || r && o || Q5) && typeof FileReader < "u") {
        const s = new FileReader;
        s.onloadend = function() {
            let l = s.result;
            if (typeof l != "string")
                throw a = null,
                new Error("Wrong reader.result type");
            l = i ? l : l.replace(/^data:[^;]*;/, "data:attachment/file;"),
            a ? a.location.href = l : location.assign(l),
            a = null
        }
        ,
        s.readAsDataURL(e)
    } else {
        const s = URL.createObjectURL(e);
        a ? a.location.assign(s) : location.href = s,
        a = null,
        setTimeout(function() {
            URL.revokeObjectURL(s)
        }, 4e4)
    }
}
function cn(e, t) {
    const n = " " + e;
    typeof __VUE_DEVTOOLS_TOAST__ == "function" ? __VUE_DEVTOOLS_TOAST__(n, t) : t === "error" ? console.error(n) : t === "warn" ? console.warn(n) : console.log(n)
}
function $f(e) {
    return "_a"in e && "install"in e
}
function t7() {
    if (!("clipboard"in navigator))
        return cn("Your browser doesn't support the Clipboard API", "error"),
        !0
}
function n7(e) {
    return e instanceof Error && e.message.toLowerCase().includes("document is not focused") ? (cn('You need to activate the "Emulate a focused page" setting in the "Rendering" panel of devtools.', "warn"),
    !0) : !1
}
async function Vv(e) {
    if (!t7())
        try {
            await navigator.clipboard.writeText(JSON.stringify(e.state.value)),
            cn("Global state copied to clipboard.")
        } catch (t) {
            if (n7(t))
                return;
            cn("Failed to serialize the state. Check the console for more details.", "error"),
            console.error(t)
        }
}
async function Fv(e) {
    if (!t7())
        try {
            e.state.value = JSON.parse(await navigator.clipboard.readText()),
            cn("Global state pasted from clipboard.")
        } catch (t) {
            if (n7(t))
                return;
            cn("Failed to deserialize the state from clipboard. Check the console for more details.", "error"),
            console.error(t)
        }
}
async function jv(e) {
    try {
        e7(new Blob([JSON.stringify(e.state.value)],{
            type: "text/plain;charset=utf-8"
        }), "pinia-state.json")
    } catch (t) {
        cn("Failed to export the state as JSON. Check the console for more details.", "error"),
        console.error(t)
    }
}
let qa;
function Uv() {
    qa || (qa = document.createElement("input"),
    qa.type = "file",
    qa.accept = ".json");
    function e() {
        return new Promise( (t, n) => {
            qa.onchange = async () => {
                const a = qa.files;
                if (!a)
                    return t(null);
                const r = a.item(0);
                return t(r ? {
                    text: await r.text(),
                    file: r
                } : null)
            }
            ,
            qa.oncancel = () => t(null),
            qa.onerror = n,
            qa.click()
        }
        )
    }
    return e
}
async function qv(e) {
    try {
        const n = await (await Uv())();
        if (!n)
            return;
        const {text: a, file: r} = n;
        e.state.value = JSON.parse(a),
        cn(`Global state imported from "${r.name}".`)
    } catch (t) {
        cn("Failed to export the state as JSON. Check the console for more details.", "error"),
        console.error(t)
    }
}
function ua(e) {
    return {
        _custom: {
            display: e
        }
    }
}
const a7 = " Pinia (root)"
  , U2 = "_root";
function Wv(e) {
    return $f(e) ? {
        id: U2,
        label: a7
    } : {
        id: e.$id,
        label: e.$id
    }
}
function Yv(e) {
    if ($f(e)) {
        const n = Array.from(e._s.keys())
          , a = e._s;
        return {
            state: n.map(o => ({
                editable: !0,
                key: o,
                value: e.state.value[o]
            })),
            getters: n.filter(o => a.get(o)._getters).map(o => {
                const i = a.get(o);
                return {
                    editable: !1,
                    key: o,
                    value: i._getters.reduce( (s, l) => (s[l] = i[l],
                    s), {})
                }
            }
            )
        }
    }
    const t = {
        state: Object.keys(e.$state).map(n => ({
            editable: !0,
            key: n,
            value: e.$state[n]
        }))
    };
    return e._getters && e._getters.length && (t.getters = e._getters.map(n => ({
        editable: !1,
        key: n,
        value: e[n]
    }))),
    e._customProperties.size && (t.customProperties = Array.from(e._customProperties).map(n => ({
        editable: !0,
        key: n,
        value: e[n]
    }))),
    t
}
function Gv(e) {
    return e ? Array.isArray(e) ? e.reduce( (t, n) => (t.keys.push(n.key),
    t.operations.push(n.type),
    t.oldValue[n.key] = n.oldValue,
    t.newValue[n.key] = n.newValue,
    t), {
        oldValue: {},
        keys: [],
        operations: [],
        newValue: {}
    }) : {
        operation: ua(e.type),
        key: ua(e.key),
        oldValue: e.oldValue,
        newValue: e.newValue
    } : {}
}
function Xv(e) {
    switch (e) {
    case Ba.direct:
        return "mutation";
    case Ba.patchFunction:
        return "$patch";
    case Ba.patchObject:
        return "$patch";
    default:
        return "unknown"
    }
}
let Wo = !0;
const Wl = []
  , Jr = "pinia:mutations"
  , gn = "pinia"
  , {assign: Kv} = Object
  , C1 = e => " " + e;
function Zv(e, t) {
    X5({
        id: "dev.esm.pinia",
        label: "Pinia ",
        logo: "https://pinia.vuejs.org/logo.svg",
        packageName: "pinia",
        homepage: "https://pinia.vuejs.org",
        componentStateTypes: Wl,
        app: e
    }, n => {
        typeof n.now != "function" && cn("You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html."),
        n.addTimelineLayer({
            id: Jr,
            label: "Pinia ",
            color: 15064968
        }),
        n.addInspector({
            id: gn,
            label: "Pinia ",
            icon: "storage",
            treeFilterPlaceholder: "Search stores",
            actions: [{
                icon: "content_copy",
                action: () => {
                    Vv(t)
                }
                ,
                tooltip: "Serialize and copy the state"
            }, {
                icon: "content_paste",
                action: async () => {
                    await Fv(t),
                    n.sendInspectorTree(gn),
                    n.sendInspectorState(gn)
                }
                ,
                tooltip: "Replace the state with the content of your clipboard"
            }, {
                icon: "save",
                action: () => {
                    jv(t)
                }
                ,
                tooltip: "Save the state as a JSON file"
            }, {
                icon: "folder_open",
                action: async () => {
                    await qv(t),
                    n.sendInspectorTree(gn),
                    n.sendInspectorState(gn)
                }
                ,
                tooltip: "Import the state from a JSON file"
            }],
            nodeActions: [{
                icon: "restore",
                tooltip: "Reset the state (option store only)",
                action: a => {
                    const r = t._s.get(a);
                    r ? r._isOptionsAPI ? (r.$reset(),
                    cn(`Store "${a}" reset.`)) : cn(`Cannot reset "${a}" store because it's a setup store.`, "warn") : cn(`Cannot reset "${a}" store because it wasn't found.`, "warn")
                }
            }]
        }),
        n.on.inspectComponent( (a, r) => {
            const o = a.componentInstance && a.componentInstance.proxy;
            if (o && o._pStores) {
                const i = a.componentInstance.proxy._pStores;
                Object.values(i).forEach(s => {
                    a.instanceData.state.push({
                        type: C1(s.$id),
                        key: "state",
                        editable: !0,
                        value: s._isOptionsAPI ? {
                            _custom: {
                                value: rt(s.$state),
                                actions: [{
                                    icon: "restore",
                                    tooltip: "Reset the state of this store",
                                    action: () => s.$reset()
                                }]
                            }
                        } : Object.keys(s.$state).reduce( (l, c) => (l[c] = s.$state[c],
                        l), {})
                    }),
                    s._getters && s._getters.length && a.instanceData.state.push({
                        type: C1(s.$id),
                        key: "getters",
                        editable: !1,
                        value: s._getters.reduce( (l, c) => {
                            try {
                                l[c] = s[c]
                            } catch (u) {
                                l[c] = u
                            }
                            return l
                        }
                        , {})
                    })
                }
                )
            }
        }
        ),
        n.on.getInspectorTree(a => {
            if (a.app === e && a.inspectorId === gn) {
                let r = [t];
                r = r.concat(Array.from(t._s.values())),
                a.rootNodes = (a.filter ? r.filter(o => "$id"in o ? o.$id.toLowerCase().includes(a.filter.toLowerCase()) : a7.toLowerCase().includes(a.filter.toLowerCase())) : r).map(Wv)
            }
        }
        ),
        n.on.getInspectorState(a => {
            if (a.app === e && a.inspectorId === gn) {
                const r = a.nodeId === U2 ? t : t._s.get(a.nodeId);
                if (!r)
                    return;
                r && (a.state = Yv(r))
            }
        }
        ),
        n.on.editInspectorState( (a, r) => {
            if (a.app === e && a.inspectorId === gn) {
                const o = a.nodeId === U2 ? t : t._s.get(a.nodeId);
                if (!o)
                    return cn(`store "${a.nodeId}" not found`, "error");
                const {path: i} = a;
                $f(o) ? i.unshift("state") : (i.length !== 1 || !o._customProperties.has(i[0]) || i[0]in o.$state) && i.unshift("$state"),
                Wo = !1,
                a.set(o, i, a.state.value),
                Wo = !0
            }
        }
        ),
        n.on.editComponentState(a => {
            if (a.type.startsWith("")) {
                const r = a.type.replace(/^\s*/, "")
                  , o = t._s.get(r);
                if (!o)
                    return cn(`store "${r}" not found`, "error");
                const {path: i} = a;
                if (i[0] !== "state")
                    return cn(`Invalid path for store "${r}":
${i}
Only state can be modified.`);
                i[0] = "$state",
                Wo = !1,
                a.set(o, i, a.state.value),
                Wo = !0
            }
        }
        )
    }
    )
}
function Jv(e, t) {
    Wl.includes(C1(t.$id)) || Wl.push(C1(t.$id)),
    X5({
        id: "dev.esm.pinia",
        label: "Pinia ",
        logo: "https://pinia.vuejs.org/logo.svg",
        packageName: "pinia",
        homepage: "https://pinia.vuejs.org",
        componentStateTypes: Wl,
        app: e,
        settings: {
            logStoreChanges: {
                label: "Notify about new/deleted stores",
                type: "boolean",
                defaultValue: !0
            }
        }
    }, n => {
        const a = typeof n.now == "function" ? n.now.bind(n) : Date.now;
        t.$onAction( ({after: i, onError: s, name: l, args: c}) => {
            const u = r7++;
            n.addTimelineEvent({
                layerId: Jr,
                event: {
                    time: a(),
                    title: " " + l,
                    subtitle: "start",
                    data: {
                        store: ua(t.$id),
                        action: ua(l),
                        args: c
                    },
                    groupId: u
                }
            }),
            i(f => {
                no = void 0,
                n.addTimelineEvent({
                    layerId: Jr,
                    event: {
                        time: a(),
                        title: " " + l,
                        subtitle: "end",
                        data: {
                            store: ua(t.$id),
                            action: ua(l),
                            args: c,
                            result: f
                        },
                        groupId: u
                    }
                })
            }
            ),
            s(f => {
                no = void 0,
                n.addTimelineEvent({
                    layerId: Jr,
                    event: {
                        time: a(),
                        logType: "error",
                        title: " " + l,
                        subtitle: "end",
                        data: {
                            store: ua(t.$id),
                            action: ua(l),
                            args: c,
                            error: f
                        },
                        groupId: u
                    }
                })
            }
            )
        }
        , !0),
        t._customProperties.forEach(i => {
            st( () => B(t[i]), (s, l) => {
                n.notifyComponentUpdate(),
                n.sendInspectorState(gn),
                Wo && n.addTimelineEvent({
                    layerId: Jr,
                    event: {
                        time: a(),
                        title: "Change",
                        subtitle: i,
                        data: {
                            newValue: s,
                            oldValue: l
                        },
                        groupId: no
                    }
                })
            }
            , {
                deep: !0
            })
        }
        ),
        t.$subscribe( ({events: i, type: s}, l) => {
            if (n.notifyComponentUpdate(),
            n.sendInspectorState(gn),
            !Wo)
                return;
            const c = {
                time: a(),
                title: Xv(s),
                data: Kv({
                    store: ua(t.$id)
                }, Gv(i)),
                groupId: no
            };
            no = void 0,
            s === Ba.patchFunction ? c.subtitle = "" : s === Ba.patchObject ? c.subtitle = "" : i && !Array.isArray(i) && (c.subtitle = i.type),
            i && (c.data["rawEvent(s)"] = {
                _custom: {
                    display: "DebuggerEvent",
                    type: "object",
                    tooltip: "raw DebuggerEvent[]",
                    value: i
                }
            }),
            n.addTimelineEvent({
                layerId: Jr,
                event: c
            })
        }
        , {
            detached: !0,
            flush: "sync"
        });
        const r = t._hotUpdate;
        t._hotUpdate = ga(i => {
            r(i),
            n.addTimelineEvent({
                layerId: Jr,
                event: {
                    time: a(),
                    title: " " + t.$id,
                    subtitle: "HMR update",
                    data: {
                        store: ua(t.$id),
                        info: ua("HMR update")
                    }
                }
            }),
            n.notifyComponentUpdate(),
            n.sendInspectorTree(gn),
            n.sendInspectorState(gn)
        }
        );
        const {$dispose: o} = t;
        t.$dispose = () => {
            o(),
            n.notifyComponentUpdate(),
            n.sendInspectorTree(gn),
            n.sendInspectorState(gn),
            n.getSettings().logStoreChanges && cn(`Disposed "${t.$id}" store `)
        }
        ,
        n.notifyComponentUpdate(),
        n.sendInspectorTree(gn),
        n.sendInspectorState(gn),
        n.getSettings().logStoreChanges && cn(`"${t.$id}" store installed `)
    }
    )
}
let r7 = 0, no;
function g3(e, t) {
    const n = t.reduce( (a, r) => (a[r] = rt(e)[r],
    a), {});
    for (const a in n)
        e[a] = function() {
            const r = r7
              , o = new Proxy(e,{
                get(...i) {
                    return no = r,
                    Reflect.get(...i)
                },
                set(...i) {
                    return no = r,
                    Reflect.set(...i)
                }
            });
            return n[a].apply(o, arguments)
        }
}
function Qv({app: e, store: t, options: n}) {
    if (!t.$id.startsWith("__hot:")) {
        if (n.state && (t._isOptionsAPI = !0),
        typeof n.state == "function") {
            g3(t, Object.keys(n.actions));
            const a = t._hotUpdate;
            rt(t)._hotUpdate = function(r) {
                a.apply(this, arguments),
                g3(t, Object.keys(r._hmrPayload.actions))
            }
        }
        Jv(e, t)
    }
}
function eb() {
    const e = Xu(!0)
      , t = e.run( () => oe({}));
    let n = []
      , a = [];
    const r = ga({
        install(o) {
            nc(r),
            da || (r._a = o,
            o.provide(Z5, r),
            o.config.globalProperties.$pinia = r,
            us && Zv(o, r),
            a.forEach(i => n.push(i)),
            a = [])
        },
        use(o) {
            return !this._a && !da ? a.push(o) : n.push(o),
            this
        },
        _p: n,
        _a: null,
        _e: e,
        _s: new Map,
        state: t
    });
    return us && typeof Proxy < "u" && r.use(Qv),
    r
}
const o7 = () => {}
;
function v3(e, t, n, a=o7) {
    e.push(t);
    const r = () => {
        const o = e.indexOf(t);
        o > -1 && (e.splice(o, 1),
        a())
    }
    ;
    return !n && Ku() && l0(r),
    r
}
function Ho(e, ...t) {
    e.slice().forEach(n => {
        n(...t)
    }
    )
}
function q2(e, t) {
    e instanceof Map && t instanceof Map && t.forEach( (n, a) => e.set(a, n)),
    e instanceof Set && t instanceof Set && t.forEach(e.add, e);
    for (const n in t) {
        if (!t.hasOwnProperty(n))
            continue;
        const a = t[n]
          , r = e[n];
        j2(r) && j2(a) && e.hasOwnProperty(n) && !Dt(a) && !La(a) ? e[n] = q2(r, a) : e[n] = a
    }
    return e
}
const tb = Symbol()
  , nb = new WeakMap;
function ab(e) {
    return da ? !nb.has(e) : !j2(e) || !e.hasOwnProperty(tb)
}
const {assign: ca} = Object;
function rb(e) {
    return !!(Dt(e) && e.effect)
}
function ob(e, t, n, a) {
    const {state: r, actions: o, getters: i} = t
      , s = n.state.value[e];
    let l;
    function c() {
        s || (da ? Gi(n.state.value, e, r ? r() : {}) : n.state.value[e] = r ? r() : {});
        const u = $0(n.state.value[e]);
        return ca(u, o, Object.keys(i || {}).reduce( (f, d) => (f[d] = ga(ae( () => {
            nc(n);
            const p = n._s.get(e);
            if (!(da && !p._r))
                return i[d].call(p, p)
        }
        )),
        f), {}))
    }
    return l = i7(e, c, t, n, a, !0),
    l
}
function i7(e, t, n={}, a, r, o) {
    let i;
    const s = ca({
        actions: {}
    }, n)
      , l = {
        deep: !0
    };
    let c, u, f = ga([]), d = ga([]), p;
    const h = a.state.value[e];
    !o && !h && (da ? Gi(a.state.value, e, {}) : a.state.value[e] = {});
    const m = oe({});
    let g;
    function b(T) {
        let A;
        c = u = !1,
        typeof T == "function" ? (T(a.state.value[e]),
        A = {
            type: Ba.patchFunction,
            storeId: e,
            events: p
        }) : (q2(a.state.value[e], T),
        A = {
            type: Ba.patchObject,
            payload: T,
            storeId: e,
            events: p
        });
        const x = g = Symbol();
        Zn().then( () => {
            g === x && (c = !0)
        }
        ),
        u = !0,
        Ho(f, A, a.state.value[e])
    }
    const v = o ? function() {
        const {state: A} = n
          , x = A ? A() : {};
        this.$patch(M => {
            ca(M, x)
        }
        )
    }
    : o7;
    function y() {
        i.stop(),
        f = [],
        d = [],
        a._s.delete(e)
    }
    function w(T, A) {
        return function() {
            nc(a);
            const x = Array.from(arguments)
              , M = []
              , L = [];
            function U(W) {
                M.push(W)
            }
            function Y(W) {
                L.push(W)
            }
            Ho(d, {
                args: x,
                name: T,
                store: E,
                after: U,
                onError: Y
            });
            let H;
            try {
                H = A.apply(this && this.$id === e ? this : E, x)
            } catch (W) {
                throw Ho(L, W),
                W
            }
            return H instanceof Promise ? H.then(W => (Ho(M, W),
            W)).catch(W => (Ho(L, W),
            Promise.reject(W))) : (Ho(M, H),
            H)
        }
    }
    const C = ga({
        actions: {},
        getters: {},
        state: [],
        hotState: m
    })
      , _ = {
        _p: a,
        $id: e,
        $onAction: v3.bind(null, d),
        $patch: b,
        $reset: v,
        $subscribe(T, A={}) {
            const x = v3(f, T, A.detached, () => M())
              , M = i.run( () => st( () => a.state.value[e], L => {
                (A.flush === "sync" ? u : c) && T({
                    storeId: e,
                    type: Ba.direct,
                    events: p
                }, L)
            }
            , ca({}, l, A)));
            return x
        },
        $dispose: y
    };
    da && (_._r = !1);
    const E = Jn(us ? ca({
        _hmrPayload: C,
        _customProperties: ga(new Set)
    }, _) : _);
    a._s.set(e, E);
    const z = a._e.run( () => (i = Xu(),
    i.run( () => t())));
    for (const T in z) {
        const A = z[T];
        if (Dt(A) && !rb(A) || La(A))
            o || (h && ab(A) && (Dt(A) ? A.value = h[T] : q2(A, h[T])),
            da ? Gi(a.state.value[e], T, A) : a.state.value[e][T] = A);
        else if (typeof A == "function") {
            const x = w(T, A);
            da ? Gi(z, T, x) : z[T] = x,
            s.actions[T] = A
        }
    }
    if (da ? Object.keys(z).forEach(T => {
        Gi(E, T, z[T])
    }
    ) : (ca(E, z),
    ca(rt(E), z)),
    Object.defineProperty(E, "$state", {
        get: () => a.state.value[e],
        set: T => {
            b(A => {
                ca(A, T)
            }
            )
        }
    }),
    us) {
        const T = {
            writable: !0,
            configurable: !0,
            enumerable: !1
        };
        ["_p", "_hmrPayload", "_getters", "_customProperties"].forEach(A => {
            Object.defineProperty(E, A, ca({
                value: E[A]
            }, T))
        }
        )
    }
    return da && (E._r = !0),
    a._p.forEach(T => {
        if (us) {
            const A = i.run( () => T({
                store: E,
                app: a._a,
                pinia: a,
                options: s
            }));
            Object.keys(A || {}).forEach(x => E._customProperties.add(x)),
            ca(E, A)
        } else
            ca(E, i.run( () => T({
                store: E,
                app: a._a,
                pinia: a,
                options: s
            })))
    }
    ),
    h && o && n.hydrate && n.hydrate(E.$state, h),
    c = !0,
    u = !0,
    E
}
function oa(e, t, n) {
    let a, r;
    const o = typeof t == "function";
    typeof e == "string" ? (a = e,
    r = o ? n : t) : (r = e,
    a = e.id);
    function i(s, l) {
        const c = Ha();
        return s = s || c && Qn(Z5, null),
        s && nc(s),
        s = K5,
        s._s.has(a) || (o ? i7(a, t, r, s) : ob(a, r, s)),
        s._s.get(a)
    }
    return i.$id = a,
    i
}
var s7 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function ib(e) {
    if (e.__esModule)
        return e;
    var t = e.default;
    if (typeof t == "function") {
        var n = function a() {
            if (this instanceof a) {
                var r = [null];
                r.push.apply(r, arguments);
                var o = Function.bind.apply(t, r);
                return new o
            }
            return t.apply(this, arguments)
        };
        n.prototype = t.prototype
    } else
        n = {};
    return Object.defineProperty(n, "__esModule", {
        value: !0
    }),
    Object.keys(e).forEach(function(a) {
        var r = Object.getOwnPropertyDescriptor(e, a);
        Object.defineProperty(n, a, r.get ? r : {
            enumerable: !0,
            get: function() {
                return e[a]
            }
        })
    }),
    n
}
var W2 = {}
  , sb = {
    get exports() {
        return W2
    },
    set exports(e) {
        W2 = e
    }
};
/*! iNoBounce - v0.2.0
* https://github.com/lazd/iNoBounce/
* Copyright (c) 2013 Larry Davis <lazdnet@gmail.com>; Licensed BSD */
(function(e) {
    (function(t) {
        var n = 0
          , a = !1
          , r = !1;
        try {
            var o = Object.defineProperty({}, "passive", {
                get: function() {
                    r = !0
                }
            });
            window.addEventListener("test", null, o)
        } catch {}
        var i = function(h) {
            var m = h.target
              , g = window.innerWidth / window.document.documentElement.clientWidth;
            if (!(h.touches.length > 1 || g !== 1)) {
                for (; m !== document.body && m !== document; ) {
                    var b = window.getComputedStyle(m);
                    if (!b)
                        break;
                    if (m.nodeName === "INPUT" && m.getAttribute("type") === "range")
                        return;
                    var v = b.getPropertyValue("-webkit-overflow-scrolling")
                      , y = b.getPropertyValue("overflow-y")
                      , w = parseInt(b.getPropertyValue("height"), 10)
                      , C = v === "touch" && (y === "auto" || y === "scroll")
                      , _ = m.scrollHeight > m.offsetHeight;
                    if (C && _) {
                        var E = h.touches ? h.touches[0].screenY : h.screenY
                          , z = n <= E && m.scrollTop === 0
                          , T = n >= E && m.scrollHeight - m.scrollTop === w;
                        (z || T) && h.preventDefault();
                        return
                    }
                    m = m.parentNode
                }
                h.preventDefault()
            }
        }
          , s = function(h) {
            n = h.touches ? h.touches[0].screenY : h.screenY
        }
          , l = function() {
            window.addEventListener("touchstart", s, r ? {
                passive: !1
            } : !1),
            window.addEventListener("touchmove", i, r ? {
                passive: !1
            } : !1),
            a = !0
        }
          , c = function() {
            window.removeEventListener("touchstart", s, !1),
            window.removeEventListener("touchmove", i, !1),
            a = !1
        }
          , u = function() {
            return a
        }
          , f = document.createElement("div");
        document.documentElement.appendChild(f),
        f.style.WebkitOverflowScrolling = "touch";
        var d = "getComputedStyle"in window && window.getComputedStyle(f)["-webkit-overflow-scrolling"] === "touch";
        document.documentElement.removeChild(f),
        d && l();
        var p = {
            enable: l,
            disable: c,
            isEnabled: u,
            isScrollSupported: d
        };
        e.exports && (e.exports = p),
        typeof t.define == "function" ? function(h) {
            h("iNoBounce", [], function() {
                return p
            })
        }(t.define) : t.iNoBounce = p
    }
    )(s7)
}
)(sb);
const b3 = W2;
function y3(e) {
    return e !== null && typeof e == "object" && "constructor"in e && e.constructor === Object
}
function Ef(e={}, t={}) {
    Object.keys(t).forEach(n => {
        typeof e[n] > "u" ? e[n] = t[n] : y3(t[n]) && y3(e[n]) && Object.keys(t[n]).length > 0 && Ef(e[n], t[n])
    }
    )
}
const l7 = {
    body: {},
    addEventListener() {},
    removeEventListener() {},
    activeElement: {
        blur() {},
        nodeName: ""
    },
    querySelector() {
        return null
    },
    querySelectorAll() {
        return []
    },
    getElementById() {
        return null
    },
    createEvent() {
        return {
            initEvent() {}
        }
    },
    createElement() {
        return {
            children: [],
            childNodes: [],
            style: {},
            setAttribute() {},
            getElementsByTagName() {
                return []
            }
        }
    },
    createElementNS() {
        return {}
    },
    importNode() {
        return null
    },
    location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: ""
    }
};
function Qe() {
    const e = typeof document < "u" ? document : {};
    return Ef(e, l7),
    e
}
const lb = {
    document: l7,
    navigator: {
        userAgent: ""
    },
    location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: ""
    },
    history: {
        replaceState() {},
        pushState() {},
        go() {},
        back() {}
    },
    CustomEvent: function() {
        return this
    },
    addEventListener() {},
    removeEventListener() {},
    getComputedStyle() {
        return {
            getPropertyValue() {
                return ""
            }
        }
    },
    Image() {},
    Date() {},
    screen: {},
    setTimeout() {},
    clearTimeout() {},
    matchMedia() {
        return {}
    },
    requestAnimationFrame(e) {
        return typeof setTimeout > "u" ? (e(),
        null) : setTimeout(e, 0)
    },
    cancelAnimationFrame(e) {
        typeof setTimeout > "u" || clearTimeout(e)
    }
};
function He() {
    const e = typeof window < "u" ? window : {};
    return Ef(e, lb),
    e
}
function cb(e) {
    const t = e.__proto__;
    Object.defineProperty(e, "__proto__", {
        get() {
            return t
        },
        set(n) {
            t.__proto__ = n
        }
    })
}
class xr extends Array {
    constructor(t) {
        typeof t == "number" ? super(t) : (super(...t || []),
        cb(this))
    }
}
function qs(e=[]) {
    const t = [];
    return e.forEach(n => {
        Array.isArray(n) ? t.push(...qs(n)) : t.push(n)
    }
    ),
    t
}
function c7(e, t) {
    return Array.prototype.filter.call(e, t)
}
function ub(e) {
    const t = [];
    for (let n = 0; n < e.length; n += 1)
        t.indexOf(e[n]) === -1 && t.push(e[n]);
    return t
}
function fb(e) {
    return e.toLowerCase().replace(/-(.)/g, (t, n) => n.toUpperCase())
}
function db(e, t) {
    if (typeof e != "string")
        return [e];
    const n = []
      , a = t.querySelectorAll(e);
    for (let r = 0; r < a.length; r += 1)
        n.push(a[r]);
    return n
}
function _e(e, t) {
    const n = He()
      , a = Qe();
    let r = [];
    if (!t && e instanceof xr)
        return e;
    if (!e)
        return new xr(r);
    if (typeof e == "string") {
        const o = e.trim();
        if (o.indexOf("<") >= 0 && o.indexOf(">") >= 0) {
            let i = "div";
            o.indexOf("<li") === 0 && (i = "ul"),
            o.indexOf("<tr") === 0 && (i = "tbody"),
            (o.indexOf("<td") === 0 || o.indexOf("<th") === 0) && (i = "tr"),
            o.indexOf("<tbody") === 0 && (i = "table"),
            o.indexOf("<option") === 0 && (i = "select");
            const s = a.createElement(i);
            s.innerHTML = o;
            for (let l = 0; l < s.childNodes.length; l += 1)
                r.push(s.childNodes[l])
        } else
            r = db(e.trim(), t || a)
    } else if (e.nodeType || e === n || e === a)
        r.push(e);
    else if (Array.isArray(e)) {
        if (e instanceof xr)
            return e;
        r = e
    }
    return new xr(ub(r))
}
_e.fn = xr.prototype;
function u7(...e) {
    const t = qs(e.map(n => n.split(" ")));
    return this.forEach(n => {
        n.classList.add(...t)
    }
    ),
    this
}
function f7(...e) {
    const t = qs(e.map(n => n.split(" ")));
    return this.forEach(n => {
        n.classList.remove(...t)
    }
    ),
    this
}
function d7(...e) {
    const t = qs(e.map(n => n.split(" ")));
    this.forEach(n => {
        t.forEach(a => {
            n.classList.toggle(a)
        }
        )
    }
    )
}
function p7(...e) {
    const t = qs(e.map(n => n.split(" ")));
    return c7(this, n => t.filter(a => n.classList.contains(a)).length > 0).length > 0
}
function h7(e, t) {
    if (arguments.length === 1 && typeof e == "string")
        return this[0] ? this[0].getAttribute(e) : void 0;
    for (let n = 0; n < this.length; n += 1)
        if (arguments.length === 2)
            this[n].setAttribute(e, t);
        else
            for (const a in e)
                this[n][a] = e[a],
                this[n].setAttribute(a, e[a]);
    return this
}
function m7(e) {
    for (let t = 0; t < this.length; t += 1)
        this[t].removeAttribute(e);
    return this
}
function pb(e, t) {
    if (arguments.length === 1 && typeof e == "string") {
        if (this[0])
            return this[0][e]
    } else {
        for (let n = 0; n < this.length; n += 1)
            if (arguments.length === 2)
                this[n][e] = t;
            else
                for (const a in e)
                    this[n][a] = e[a];
        return this
    }
    return this
}
function hb(e, t) {
    let n;
    if (typeof t > "u") {
        if (n = this[0],
        !n)
            return;
        if (n.dom7ElementDataStorage && e in n.dom7ElementDataStorage)
            return n.dom7ElementDataStorage[e];
        const a = n.getAttribute(`data-${e}`);
        return a || void 0
    }
    for (let a = 0; a < this.length; a += 1)
        n = this[a],
        n.dom7ElementDataStorage || (n.dom7ElementDataStorage = {}),
        n.dom7ElementDataStorage[e] = t;
    return this
}
function mb(e) {
    for (let t = 0; t < this.length; t += 1) {
        const n = this[t];
        n.dom7ElementDataStorage && n.dom7ElementDataStorage[e] && (n.dom7ElementDataStorage[e] = null,
        delete n.dom7ElementDataStorage[e])
    }
}
function gb() {
    const e = this[0];
    if (!e)
        return;
    const t = {};
    if (e.dataset)
        for (const n in e.dataset)
            t[n] = e.dataset[n];
    else
        for (let n = 0; n < e.attributes.length; n += 1) {
            const a = e.attributes[n];
            a.name.indexOf("data-") >= 0 && (t[fb(a.name.split("data-")[1])] = a.value)
        }
    for (const n in t)
        t[n] === "false" ? t[n] = !1 : t[n] === "true" ? t[n] = !0 : parseFloat(t[n]) === t[n] * 1 && (t[n] *= 1);
    return t
}
function vb(e) {
    if (typeof e > "u") {
        const t = this[0];
        if (!t)
            return;
        if (t.multiple && t.nodeName.toLowerCase() === "select") {
            const n = [];
            for (let a = 0; a < t.selectedOptions.length; a += 1)
                n.push(t.selectedOptions[a].value);
            return n
        }
        return t.value
    }
    for (let t = 0; t < this.length; t += 1) {
        const n = this[t];
        if (Array.isArray(e) && n.multiple && n.nodeName.toLowerCase() === "select")
            for (let a = 0; a < n.options.length; a += 1)
                n.options[a].selected = e.indexOf(n.options[a].value) >= 0;
        else
            n.value = e
    }
    return this
}
function bb(e) {
    return this.val(e)
}
function g7(e) {
    for (let t = 0; t < this.length; t += 1)
        this[t].style.transform = e;
    return this
}
function v7(e) {
    for (let t = 0; t < this.length; t += 1)
        this[t].style.transitionDuration = typeof e != "string" ? `${e}ms` : e;
    return this
}
function b7(...e) {
    let[t,n,a,r] = e;
    typeof e[1] == "function" && ([t,a,r] = e,
    n = void 0),
    r || (r = !1);
    function o(c) {
        const u = c.target;
        if (!u)
            return;
        const f = c.target.dom7EventData || [];
        if (f.indexOf(c) < 0 && f.unshift(c),
        _e(u).is(n))
            a.apply(u, f);
        else {
            const d = _e(u).parents();
            for (let p = 0; p < d.length; p += 1)
                _e(d[p]).is(n) && a.apply(d[p], f)
        }
    }
    function i(c) {
        const u = c && c.target ? c.target.dom7EventData || [] : [];
        u.indexOf(c) < 0 && u.unshift(c),
        a.apply(this, u)
    }
    const s = t.split(" ");
    let l;
    for (let c = 0; c < this.length; c += 1) {
        const u = this[c];
        if (n)
            for (l = 0; l < s.length; l += 1) {
                const f = s[l];
                u.dom7LiveListeners || (u.dom7LiveListeners = {}),
                u.dom7LiveListeners[f] || (u.dom7LiveListeners[f] = []),
                u.dom7LiveListeners[f].push({
                    listener: a,
                    proxyListener: o
                }),
                u.addEventListener(f, o, r)
            }
        else
            for (l = 0; l < s.length; l += 1) {
                const f = s[l];
                u.dom7Listeners || (u.dom7Listeners = {}),
                u.dom7Listeners[f] || (u.dom7Listeners[f] = []),
                u.dom7Listeners[f].push({
                    listener: a,
                    proxyListener: i
                }),
                u.addEventListener(f, i, r)
            }
    }
    return this
}
function y7(...e) {
    let[t,n,a,r] = e;
    typeof e[1] == "function" && ([t,a,r] = e,
    n = void 0),
    r || (r = !1);
    const o = t.split(" ");
    for (let i = 0; i < o.length; i += 1) {
        const s = o[i];
        for (let l = 0; l < this.length; l += 1) {
            const c = this[l];
            let u;
            if (!n && c.dom7Listeners ? u = c.dom7Listeners[s] : n && c.dom7LiveListeners && (u = c.dom7LiveListeners[s]),
            u && u.length)
                for (let f = u.length - 1; f >= 0; f -= 1) {
                    const d = u[f];
                    a && d.listener === a || a && d.listener && d.listener.dom7proxy && d.listener.dom7proxy === a ? (c.removeEventListener(s, d.proxyListener, r),
                    u.splice(f, 1)) : a || (c.removeEventListener(s, d.proxyListener, r),
                    u.splice(f, 1))
                }
        }
    }
    return this
}
function yb(...e) {
    const t = this;
    let[n,a,r,o] = e;
    typeof e[1] == "function" && ([n,r,o] = e,
    a = void 0);
    function i(...s) {
        r.apply(this, s),
        t.off(n, a, i, o),
        i.dom7proxy && delete i.dom7proxy
    }
    return i.dom7proxy = r,
    t.on(n, a, i, o)
}
function C7(...e) {
    const t = He()
      , n = e[0].split(" ")
      , a = e[1];
    for (let r = 0; r < n.length; r += 1) {
        const o = n[r];
        for (let i = 0; i < this.length; i += 1) {
            const s = this[i];
            if (t.CustomEvent) {
                const l = new t.CustomEvent(o,{
                    detail: a,
                    bubbles: !0,
                    cancelable: !0
                });
                s.dom7EventData = e.filter( (c, u) => u > 0),
                s.dispatchEvent(l),
                s.dom7EventData = [],
                delete s.dom7EventData
            }
        }
    }
    return this
}
function Cb(e) {
    const t = this;
    function n(a) {
        a.target === this && (e.call(this, a),
        t.off("transitionstart", n))
    }
    return e && t.on("transitionstart", n),
    this
}
function w7(e) {
    const t = this;
    function n(a) {
        a.target === this && (e.call(this, a),
        t.off("transitionend", n))
    }
    return e && t.on("transitionend", n),
    this
}
function wb(e) {
    const t = this;
    function n(a) {
        a.target === this && (e.call(this, a),
        t.off("animationend", n))
    }
    return e && t.on("animationend", n),
    this
}
function _b() {
    const e = He();
    return this[0] === e ? e.innerWidth : this.length > 0 ? parseFloat(this.css("width")) : null
}
function _7(e) {
    if (this.length > 0) {
        if (e) {
            const t = this.styles();
            return this[0].offsetWidth + parseFloat(t.getPropertyValue("margin-right")) + parseFloat(t.getPropertyValue("margin-left"))
        }
        return this[0].offsetWidth
    }
    return null
}
function kb() {
    const e = He();
    return this[0] === e ? e.innerHeight : this.length > 0 ? parseFloat(this.css("height")) : null
}
function k7(e) {
    if (this.length > 0) {
        if (e) {
            const t = this.styles();
            return this[0].offsetHeight + parseFloat(t.getPropertyValue("margin-top")) + parseFloat(t.getPropertyValue("margin-bottom"))
        }
        return this[0].offsetHeight
    }
    return null
}
function S7() {
    if (this.length > 0) {
        const e = He()
          , t = Qe()
          , n = this[0]
          , a = n.getBoundingClientRect()
          , r = t.body
          , o = n.clientTop || r.clientTop || 0
          , i = n.clientLeft || r.clientLeft || 0
          , s = n === e ? e.scrollY : n.scrollTop
          , l = n === e ? e.scrollX : n.scrollLeft;
        return {
            top: a.top + s - o,
            left: a.left + l - i
        }
    }
    return null
}
function Sb() {
    for (let e = 0; e < this.length; e += 1)
        this[e].style.display = "none";
    return this
}
function $b() {
    const e = He();
    for (let t = 0; t < this.length; t += 1) {
        const n = this[t];
        n.style.display === "none" && (n.style.display = ""),
        e.getComputedStyle(n, null).getPropertyValue("display") === "none" && (n.style.display = "block")
    }
    return this
}
function $7() {
    const e = He();
    return this[0] ? e.getComputedStyle(this[0], null) : {}
}
function E7(e, t) {
    const n = He();
    let a;
    if (arguments.length === 1)
        if (typeof e == "string") {
            if (this[0])
                return n.getComputedStyle(this[0], null).getPropertyValue(e)
        } else {
            for (a = 0; a < this.length; a += 1)
                for (const r in e)
                    this[a].style[r] = e[r];
            return this
        }
    if (arguments.length === 2 && typeof e == "string") {
        for (a = 0; a < this.length; a += 1)
            this[a].style[e] = t;
        return this
    }
    return this
}
function x7(e) {
    return e ? (this.forEach( (t, n) => {
        e.apply(t, [t, n])
    }
    ),
    this) : this
}
function T7(e) {
    const t = c7(this, e);
    return _e(t)
}
function M7(e) {
    if (typeof e > "u")
        return this[0] ? this[0].innerHTML : null;
    for (let t = 0; t < this.length; t += 1)
        this[t].innerHTML = e;
    return this
}
function z7(e) {
    if (typeof e > "u")
        return this[0] ? this[0].textContent.trim() : null;
    for (let t = 0; t < this.length; t += 1)
        this[t].textContent = e;
    return this
}
function A7(e) {
    const t = He()
      , n = Qe()
      , a = this[0];
    let r, o;
    if (!a || typeof e > "u")
        return !1;
    if (typeof e == "string") {
        if (a.matches)
            return a.matches(e);
        if (a.webkitMatchesSelector)
            return a.webkitMatchesSelector(e);
        if (a.msMatchesSelector)
            return a.msMatchesSelector(e);
        for (r = _e(e),
        o = 0; o < r.length; o += 1)
            if (r[o] === a)
                return !0;
        return !1
    }
    if (e === n)
        return a === n;
    if (e === t)
        return a === t;
    if (e.nodeType || e instanceof xr) {
        for (r = e.nodeType ? [e] : e,
        o = 0; o < r.length; o += 1)
            if (r[o] === a)
                return !0;
        return !1
    }
    return !1
}
function O7() {
    let e = this[0], t;
    if (e) {
        for (t = 0; (e = e.previousSibling) !== null; )
            e.nodeType === 1 && (t += 1);
        return t
    }
}
function P7(e) {
    if (typeof e > "u")
        return this;
    const t = this.length;
    if (e > t - 1)
        return _e([]);
    if (e < 0) {
        const n = t + e;
        return n < 0 ? _e([]) : _e([this[n]])
    }
    return _e([this[e]])
}
function L7(...e) {
    let t;
    const n = Qe();
    for (let a = 0; a < e.length; a += 1) {
        t = e[a];
        for (let r = 0; r < this.length; r += 1)
            if (typeof t == "string") {
                const o = n.createElement("div");
                for (o.innerHTML = t; o.firstChild; )
                    this[r].appendChild(o.firstChild)
            } else if (t instanceof xr)
                for (let o = 0; o < t.length; o += 1)
                    this[r].appendChild(t[o]);
            else
                this[r].appendChild(t)
    }
    return this
}
function Eb(e) {
    return _e(e).append(this),
    this
}
function I7(e) {
    const t = Qe();
    let n, a;
    for (n = 0; n < this.length; n += 1)
        if (typeof e == "string") {
            const r = t.createElement("div");
            for (r.innerHTML = e,
            a = r.childNodes.length - 1; a >= 0; a -= 1)
                this[n].insertBefore(r.childNodes[a], this[n].childNodes[0])
        } else if (e instanceof xr)
            for (a = 0; a < e.length; a += 1)
                this[n].insertBefore(e[a], this[n].childNodes[0]);
        else
            this[n].insertBefore(e, this[n].childNodes[0]);
    return this
}
function xb(e) {
    return _e(e).prepend(this),
    this
}
function Tb(e) {
    const t = _e(e);
    for (let n = 0; n < this.length; n += 1)
        if (t.length === 1)
            t[0].parentNode.insertBefore(this[n], t[0]);
        else if (t.length > 1)
            for (let a = 0; a < t.length; a += 1)
                t[a].parentNode.insertBefore(this[n].cloneNode(!0), t[a])
}
function Mb(e) {
    const t = _e(e);
    for (let n = 0; n < this.length; n += 1)
        if (t.length === 1)
            t[0].parentNode.insertBefore(this[n], t[0].nextSibling);
        else if (t.length > 1)
            for (let a = 0; a < t.length; a += 1)
                t[a].parentNode.insertBefore(this[n].cloneNode(!0), t[a].nextSibling)
}
function B7(e) {
    return this.length > 0 ? e ? this[0].nextElementSibling && _e(this[0].nextElementSibling).is(e) ? _e([this[0].nextElementSibling]) : _e([]) : this[0].nextElementSibling ? _e([this[0].nextElementSibling]) : _e([]) : _e([])
}
function R7(e) {
    const t = [];
    let n = this[0];
    if (!n)
        return _e([]);
    for (; n.nextElementSibling; ) {
        const a = n.nextElementSibling;
        e ? _e(a).is(e) && t.push(a) : t.push(a),
        n = a
    }
    return _e(t)
}
function D7(e) {
    if (this.length > 0) {
        const t = this[0];
        return e ? t.previousElementSibling && _e(t.previousElementSibling).is(e) ? _e([t.previousElementSibling]) : _e([]) : t.previousElementSibling ? _e([t.previousElementSibling]) : _e([])
    }
    return _e([])
}
function N7(e) {
    const t = [];
    let n = this[0];
    if (!n)
        return _e([]);
    for (; n.previousElementSibling; ) {
        const a = n.previousElementSibling;
        e ? _e(a).is(e) && t.push(a) : t.push(a),
        n = a
    }
    return _e(t)
}
function zb(e) {
    return this.nextAll(e).add(this.prevAll(e))
}
function H7(e) {
    const t = [];
    for (let n = 0; n < this.length; n += 1)
        this[n].parentNode !== null && (e ? _e(this[n].parentNode).is(e) && t.push(this[n].parentNode) : t.push(this[n].parentNode));
    return _e(t)
}
function V7(e) {
    const t = [];
    for (let n = 0; n < this.length; n += 1) {
        let a = this[n].parentNode;
        for (; a; )
            e ? _e(a).is(e) && t.push(a) : t.push(a),
            a = a.parentNode
    }
    return _e(t)
}
function F7(e) {
    let t = this;
    return typeof e > "u" ? _e([]) : (t.is(e) || (t = t.parents(e).eq(0)),
    t)
}
function j7(e) {
    const t = [];
    for (let n = 0; n < this.length; n += 1) {
        const a = this[n].querySelectorAll(e);
        for (let r = 0; r < a.length; r += 1)
            t.push(a[r])
    }
    return _e(t)
}
function U7(e) {
    const t = [];
    for (let n = 0; n < this.length; n += 1) {
        const a = this[n].children;
        for (let r = 0; r < a.length; r += 1)
            (!e || _e(a[r]).is(e)) && t.push(a[r])
    }
    return _e(t)
}
function q7() {
    for (let e = 0; e < this.length; e += 1)
        this[e].parentNode && this[e].parentNode.removeChild(this[e]);
    return this
}
function Ab() {
    return this.remove()
}
function Ob(...e) {
    const t = this;
    let n, a;
    for (n = 0; n < e.length; n += 1) {
        const r = _e(e[n]);
        for (a = 0; a < r.length; a += 1)
            t.push(r[a])
    }
    return t
}
function Pb() {
    for (let e = 0; e < this.length; e += 1) {
        const t = this[e];
        if (t.nodeType === 1) {
            for (let n = 0; n < t.childNodes.length; n += 1)
                t.childNodes[n].parentNode && t.childNodes[n].parentNode.removeChild(t.childNodes[n]);
            t.textContent = ""
        }
    }
    return this
}
function Lb(...e) {
    const t = He();
    let[n,a,r,o,i] = e;
    return e.length === 4 && typeof o == "function" && (i = o,
    [n,a,r,i,o] = e),
    typeof o > "u" && (o = "swing"),
    this.each(function() {
        const l = this;
        let c, u, f, d, p, h, m, g, b = a > 0 || a === 0, v = n > 0 || n === 0;
        if (typeof o > "u" && (o = "swing"),
        b && (c = l.scrollTop,
        r || (l.scrollTop = a)),
        v && (u = l.scrollLeft,
        r || (l.scrollLeft = n)),
        !r)
            return;
        b && (f = l.scrollHeight - l.offsetHeight,
        p = Math.max(Math.min(a, f), 0)),
        v && (d = l.scrollWidth - l.offsetWidth,
        h = Math.max(Math.min(n, d), 0));
        let y = null;
        b && p === c && (b = !1),
        v && h === u && (v = !1);
        function w(C=new Date().getTime()) {
            y === null && (y = C);
            const _ = Math.max(Math.min((C - y) / r, 1), 0)
              , E = o === "linear" ? _ : .5 - Math.cos(_ * Math.PI) / 2;
            let z;
            if (b && (m = c + E * (p - c)),
            v && (g = u + E * (h - u)),
            b && p > c && m >= p && (l.scrollTop = p,
            z = !0),
            b && p < c && m <= p && (l.scrollTop = p,
            z = !0),
            v && h > u && g >= h && (l.scrollLeft = h,
            z = !0),
            v && h < u && g <= h && (l.scrollLeft = h,
            z = !0),
            z) {
                i && i();
                return
            }
            b && (l.scrollTop = m),
            v && (l.scrollLeft = g),
            t.requestAnimationFrame(w)
        }
        t.requestAnimationFrame(w)
    })
}
function Ib(...e) {
    let[t,n,a,r] = e;
    e.length === 3 && typeof a == "function" && ([t,n,r,a] = e);
    const o = this;
    return typeof t > "u" ? o.length > 0 ? o[0].scrollTop : null : o.scrollTo(void 0, t, n, a, r)
}
function Bb(...e) {
    let[t,n,a,r] = e;
    e.length === 3 && typeof a == "function" && ([t,n,r,a] = e);
    const o = this;
    return typeof t > "u" ? o.length > 0 ? o[0].scrollLeft : null : o.scrollTo(t, void 0, n, a, r)
}
function Rb(e, t) {
    const n = He()
      , a = this
      , r = {
        props: Object.assign({}, e),
        params: Object.assign({
            duration: 300,
            easing: "swing"
        }, t),
        elements: a,
        animating: !1,
        que: [],
        easingProgress(i, s) {
            return i === "swing" ? .5 - Math.cos(s * Math.PI) / 2 : typeof i == "function" ? i(s) : s
        },
        stop() {
            r.frameId && n.cancelAnimationFrame(r.frameId),
            r.animating = !1,
            r.elements.each(i => {
                const s = i;
                delete s.dom7AnimateInstance
            }
            ),
            r.que = []
        },
        done(i) {
            if (r.animating = !1,
            r.elements.each(s => {
                const l = s;
                delete l.dom7AnimateInstance
            }
            ),
            i && i(a),
            r.que.length > 0) {
                const s = r.que.shift();
                r.animate(s[0], s[1])
            }
        },
        animate(i, s) {
            if (r.animating)
                return r.que.push([i, s]),
                r;
            const l = [];
            r.elements.each( (g, b) => {
                let v, y, w, C, _;
                g.dom7AnimateInstance || (r.elements[b].dom7AnimateInstance = r),
                l[b] = {
                    container: g
                },
                Object.keys(i).forEach(E => {
                    v = n.getComputedStyle(g, null).getPropertyValue(E).replace(",", "."),
                    y = parseFloat(v),
                    w = v.replace(y, ""),
                    C = parseFloat(i[E]),
                    _ = i[E] + w,
                    l[b][E] = {
                        initialFullValue: v,
                        initialValue: y,
                        unit: w,
                        finalValue: C,
                        finalFullValue: _,
                        currentValue: y
                    }
                }
                )
            }
            );
            let c = null, u, f = 0, d = 0, p, h = !1;
            r.animating = !0;
            function m() {
                u = new Date().getTime();
                let g, b;
                h || (h = !0,
                s.begin && s.begin(a)),
                c === null && (c = u),
                s.progress && s.progress(a, Math.max(Math.min((u - c) / s.duration, 1), 0), c + s.duration - u < 0 ? 0 : c + s.duration - u, c),
                l.forEach(v => {
                    const y = v;
                    p || y.done || Object.keys(i).forEach(w => {
                        if (p || y.done)
                            return;
                        g = Math.max(Math.min((u - c) / s.duration, 1), 0),
                        b = r.easingProgress(s.easing, g);
                        const {initialValue: C, finalValue: _, unit: E} = y[w];
                        y[w].currentValue = C + b * (_ - C);
                        const z = y[w].currentValue;
                        if ((_ > C && z >= _ || _ < C && z <= _) && (y.container.style[w] = _ + E,
                        d += 1,
                        d === Object.keys(i).length && (y.done = !0,
                        f += 1),
                        f === l.length && (p = !0)),
                        p) {
                            r.done(s.complete);
                            return
                        }
                        y.container.style[w] = z + E
                    }
                    )
                }
                ),
                !p && (r.frameId = n.requestAnimationFrame(m))
            }
            return r.frameId = n.requestAnimationFrame(m),
            r
        }
    };
    if (r.elements.length === 0)
        return a;
    let o;
    for (let i = 0; i < r.elements.length; i += 1)
        r.elements[i].dom7AnimateInstance ? o = r.elements[i].dom7AnimateInstance : r.elements[i].dom7AnimateInstance = r;
    return o || (o = r),
    e === "stop" ? o.stop() : o.animate(r.props, r.params),
    a
}
function Db() {
    const e = this;
    for (let t = 0; t < e.length; t += 1)
        e[t].dom7AnimateInstance && e[t].dom7AnimateInstance.stop()
}
const Nb = "resize scroll".split(" ");
function Vt(e) {
    function t(...n) {
        if (typeof n[0] > "u") {
            for (let a = 0; a < this.length; a += 1)
                Nb.indexOf(e) < 0 && (e in this[a] ? this[a][e]() : _e(this[a]).trigger(e));
            return this
        }
        return this.on(e, ...n)
    }
    return t
}
const Hb = Vt("click")
  , Vb = Vt("blur")
  , Fb = Vt("focus")
  , jb = Vt("focusin")
  , Ub = Vt("focusout")
  , qb = Vt("keyup")
  , Wb = Vt("keydown")
  , Yb = Vt("keypress")
  , Gb = Vt("submit")
  , Xb = Vt("change")
  , Kb = Vt("mousedown")
  , Zb = Vt("mousemove")
  , Jb = Vt("mouseup")
  , Qb = Vt("mouseenter")
  , ey = Vt("mouseleave")
  , ty = Vt("mouseout")
  , ny = Vt("mouseover")
  , ay = Vt("touchstart")
  , ry = Vt("touchend")
  , oy = Vt("touchmove")
  , iy = Vt("resize")
  , sy = Vt("scroll")
  , C3 = Object.freeze(Object.defineProperty({
    __proto__: null,
    $: _e,
    add: Ob,
    addClass: u7,
    animate: Rb,
    animationEnd: wb,
    append: L7,
    appendTo: Eb,
    attr: h7,
    blur: Vb,
    change: Xb,
    children: U7,
    click: Hb,
    closest: F7,
    css: E7,
    data: hb,
    dataset: gb,
    default: _e,
    detach: Ab,
    each: x7,
    empty: Pb,
    eq: P7,
    filter: T7,
    find: j7,
    focus: Fb,
    focusin: jb,
    focusout: Ub,
    hasClass: p7,
    height: kb,
    hide: Sb,
    html: M7,
    index: O7,
    insertAfter: Mb,
    insertBefore: Tb,
    is: A7,
    keydown: Wb,
    keypress: Yb,
    keyup: qb,
    mousedown: Kb,
    mouseenter: Qb,
    mouseleave: ey,
    mousemove: Zb,
    mouseout: ty,
    mouseover: ny,
    mouseup: Jb,
    next: B7,
    nextAll: R7,
    off: y7,
    offset: S7,
    on: b7,
    once: yb,
    outerHeight: k7,
    outerWidth: _7,
    parent: H7,
    parents: V7,
    prepend: I7,
    prependTo: xb,
    prev: D7,
    prevAll: N7,
    prop: pb,
    remove: q7,
    removeAttr: m7,
    removeClass: f7,
    removeData: mb,
    resize: iy,
    scroll: sy,
    scrollLeft: Bb,
    scrollTo: Lb,
    scrollTop: Ib,
    show: $b,
    siblings: zb,
    stop: Db,
    styles: $7,
    submit: Gb,
    text: z7,
    toggleClass: d7,
    touchend: ry,
    touchmove: oy,
    touchstart: ay,
    transform: g7,
    transition: v7,
    transitionEnd: w7,
    transitionStart: Cb,
    trigger: C7,
    val: vb,
    value: bb,
    width: _b
}, Symbol.toStringTag, {
    value: "Module"
}));
Object.keys(C3).forEach(e => {
    e !== "$" && (_e.fn[e] = C3[e])
}
);
const $ = _e;
let w3 = 0;
function ly() {
    return w3 += 1,
    w3
}
function ac(e, t) {
    e === void 0 && (e = "xxxxxxxxxx"),
    t === void 0 && (t = "0123456789abcdef");
    const n = t.length;
    return e.replace(/x/g, () => t[Math.floor(Math.random() * n)])
}
const po = `
  <span class="preloader-inner">
    <svg viewBox="0 0 36 36">
      <circle cx="18" cy="18" r="16"></circle>
    </svg>
  </span>
`.trim()
  , ho = `
  <span class="preloader-inner">
    ${[0, 1, 2, 3, 4, 5, 6, 7].map( () => '<span class="preloader-inner-line"></span>').join("")}
  </span>
`.trim()
  , mo = `
  <span class="preloader-inner">
    <span class="preloader-inner-circle"></span>
  </span>
`;
function Xi(e) {
    let t;
    return e.split("").map( (n, a) => n.match(/[A-Z]/) && a !== 0 && !t ? (t = !0,
    `:${n.toLowerCase()}`) : n.toLowerCase()).join("")
}
function Yt(e) {
    const t = e;
    Object.keys(t).forEach(n => {
        try {
            t[n] = null
        } catch {}
        try {
            delete t[n]
        } catch {}
    }
    )
}
function Y2(e) {
    return He().requestAnimationFrame(e)
}
function cy(e) {
    return He().cancelAnimationFrame(e)
}
function un(e, t) {
    return t === void 0 && (t = 0),
    setTimeout(e, t)
}
function xn(e) {
    return Y2( () => {
        Y2(e)
    }
    )
}
function zn() {
    return Date.now()
}
function $s(e) {
    const t = He()
      , n = {};
    let a = e || t.location.href, r, o, i, s;
    if (typeof a == "string" && a.length)
        for (a = a.indexOf("?") > -1 ? a.replace(/\S*\?/, "") : "",
        o = a.split("&").filter(l => l !== ""),
        s = o.length,
        r = 0; r < s; r += 1)
            i = o[r].replace(/#\S+/g, "").split("="),
            n[decodeURIComponent(i[0])] = typeof i[1] > "u" ? void 0 : decodeURIComponent(i.slice(1).join("=")) || "";
    return n
}
function w1(e, t) {
    t === void 0 && (t = "x");
    const n = He();
    let a, r, o;
    const i = n.getComputedStyle(e, null);
    return n.WebKitCSSMatrix ? (r = i.transform || i.webkitTransform,
    r.split(",").length > 6 && (r = r.split(", ").map(s => s.replace(",", ".")).join(", ")),
    o = new n.WebKitCSSMatrix(r === "none" ? "" : r)) : (o = i.MozTransform || i.OTransform || i.MsTransform || i.msTransform || i.transform || i.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"),
    a = o.toString().split(",")),
    t === "x" && (n.WebKitCSSMatrix ? r = o.m41 : a.length === 16 ? r = parseFloat(a[12]) : r = parseFloat(a[4])),
    t === "y" && (n.WebKitCSSMatrix ? r = o.m42 : a.length === 16 ? r = parseFloat(a[13]) : r = parseFloat(a[5])),
    r || 0
}
function er(e, t) {
    if (t === void 0 && (t = []),
    typeof e == "string")
        return e;
    const n = []
      , a = "&";
    let r;
    function o(s) {
        if (t.length > 0) {
            let l = "";
            for (let c = 0; c < t.length; c += 1)
                c === 0 ? l += t[c] : l += `[${encodeURIComponent(t[c])}]`;
            return `${l}[${encodeURIComponent(s)}]`
        }
        return encodeURIComponent(s)
    }
    function i(s) {
        return encodeURIComponent(s)
    }
    return Object.keys(e).forEach(s => {
        let l;
        if (Array.isArray(e[s])) {
            l = [];
            for (let c = 0; c < e[s].length; c += 1)
                !Array.isArray(e[s][c]) && typeof e[s][c] == "object" ? (r = t.slice(),
                r.push(s),
                r.push(String(c)),
                l.push(er(e[s][c], r))) : l.push(`${o(s)}[]=${i(e[s][c])}`);
            l.length > 0 && n.push(l.join(a))
        } else
            e[s] === null || e[s] === "" ? n.push(`${o(s)}=`) : typeof e[s] == "object" ? (r = t.slice(),
            r.push(s),
            l = er(e[s], r),
            l !== "" && n.push(l)) : typeof e[s] < "u" && e[s] !== "" ? n.push(`${o(s)}=${i(e[s])}`) : e[s] === "" && n.push(o(s))
    }
    ),
    n.join(a)
}
function Yo(e) {
    return typeof e == "object" && e !== null && e.constructor && e.constructor === Object
}
function uy() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
        t[n] = arguments[n];
    const a = t[0];
    t.splice(0, 1);
    const r = t;
    for (let o = 0; o < r.length; o += 1) {
        const i = t[o];
        if (i != null) {
            const s = Object.keys(Object(i));
            for (let l = 0, c = s.length; l < c; l += 1) {
                const u = s[l]
                  , f = Object.getOwnPropertyDescriptor(i, u);
                f !== void 0 && f.enumerable && (a[u] = i[u])
            }
        }
    }
    return a
}
function se() {
    let e = !0, t, n;
    for (var a = arguments.length, r = new Array(a), o = 0; o < a; o++)
        r[o] = arguments[o];
    typeof r[0] == "boolean" ? (e = r[0],
    t = r[1],
    r.splice(0, 2),
    n = r) : (t = r[0],
    r.splice(0, 1),
    n = r);
    for (let i = 0; i < n.length; i += 1) {
        const s = r[i];
        if (s != null) {
            const l = Object.keys(Object(s));
            for (let c = 0, u = l.length; c < u; c += 1) {
                const f = l[c]
                  , d = Object.getOwnPropertyDescriptor(s, f);
                d !== void 0 && d.enumerable && (e ? Yo(t[f]) && Yo(s[f]) ? se(t[f], s[f]) : !Yo(t[f]) && Yo(s[f]) ? (t[f] = {},
                se(t[f], s[f])) : t[f] = s[f] : t[f] = s[f])
            }
        }
    }
    return t
}
function xf(e) {
    const t = e.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, (a, r, o, i) => r + r + o + o + i + i)
      , n = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);
    return n ? n.slice(1).map(a => parseInt(a, 16)) : null
}
function Ja(e, t, n) {
    return `#${[e, t, n].map(r => {
        const o = r.toString(16);
        return o.length === 1 ? `0${o}` : o
    }
    ).join("")}`
}
function _1(e, t, n) {
    e /= 255,
    t /= 255,
    n /= 255;
    const a = Math.max(e, t, n)
      , r = Math.min(e, t, n)
      , o = a - r;
    let i;
    o === 0 ? i = 0 : a === e ? i = (t - n) / o % 6 : a === t ? i = (n - e) / o + 2 : a === n && (i = (e - t) / o + 4);
    const s = (r + a) / 2
      , l = o === 0 ? 0 : o / (1 - Math.abs(2 * s - 1));
    return i < 0 && (i = 360 / 60 + i),
    [i * 60, l, s]
}
function ri(e, t, n) {
    const a = (1 - Math.abs(2 * n - 1)) * t
      , r = e / 60
      , o = a * (1 - Math.abs(r % 2 - 1));
    let i;
    Number.isNaN(e) || typeof e > "u" ? i = [0, 0, 0] : r <= 1 ? i = [a, o, 0] : r <= 2 ? i = [o, a, 0] : r <= 3 ? i = [0, a, o] : r <= 4 ? i = [0, o, a] : r <= 5 ? i = [o, 0, a] : r <= 6 && (i = [a, 0, o]);
    const s = n - a / 2;
    return i.map(l => Math.max(0, Math.min(255, Math.round(255 * (l + s)))))
}
function tr(e, t, n) {
    const a = {
        h: e,
        s: 0,
        l: 0
    }
      , r = {
        h: e,
        s: t,
        b: n
    };
    return a.l = (2 - r.s) * r.b / 2,
    a.s = a.l && a.l < 1 ? r.s * r.b / (a.l < .5 ? a.l * 2 : 2 - a.l * 2) : a.s,
    [a.h, a.s, a.l]
}
function Ki(e, t, n) {
    const a = {
        h: e,
        s: 0,
        b: 0
    }
      , r = {
        h: e,
        s: t,
        l: n
    }
      , o = r.s * (r.l < .5 ? r.l : 1 - r.l);
    return a.b = r.l + o,
    a.s = r.l > 0 ? 2 * o / a.b : a.s,
    [a.h, a.s, a.b]
}
function fy() {
    let e, t;
    for (var n = arguments.length, a = new Array(n), r = 0; r < n; r++)
        a[r] = arguments[r];
    if (a.length === 1 ? (e = a[0],
    t = xf(e)) : a.length === 3 && (t = a,
    e = Ja(...t)),
    !t)
        return {};
    const o = _1(...t)
      , i = [o[0], o[1], Math.max(0, o[2] - .08)]
      , s = [o[0], o[1], Math.max(0, o[2] + .08)]
      , l = Ja(...ri(...i))
      , c = Ja(...ri(...s));
    return {
        "--f7-theme-color": e,
        "--f7-theme-color-rgb": t.join(", "),
        "--f7-theme-color-shade": l,
        "--f7-theme-color-tint": c
    }
}
function hn(e, t) {
    Object.keys(t).forEach(n => {
        Yo(t[n]) && Object.keys(t[n]).forEach(a => {
            typeof t[n][a] == "function" && (t[n][a] = t[n][a].bind(e))
        }
        ),
        e[n] = t[n]
    }
    )
}
function W7() {
    const e = [];
    for (var t = arguments.length, n = new Array(t), a = 0; a < t; a++)
        n[a] = arguments[a];
    return n.forEach(r => {
        Array.isArray(r) ? e.push(...W7(...r)) : e.push(r)
    }
    ),
    e
}
const _3 = Object.freeze(Object.defineProperty({
    __proto__: null,
    auroraPreloaderContent: mo,
    bindMethods: hn,
    cancelAnimationFrame: cy,
    colorHexToRgb: xf,
    colorHsbToHsl: tr,
    colorHslToHsb: Ki,
    colorHslToRgb: ri,
    colorRgbToHex: Ja,
    colorRgbToHsl: _1,
    colorThemeCSSProperties: fy,
    deleteProps: Yt,
    eventNameToColonCase: Xi,
    extend: se,
    flattenArray: W7,
    getTranslate: w1,
    id: ac,
    iosPreloaderContent: ho,
    isObject: Yo,
    mdPreloaderContent: po,
    merge: uy,
    nextFrame: xn,
    nextTick: un,
    now: zn,
    parseUrlQuery: $s,
    requestAnimationFrame: Y2,
    serializeObject: er,
    uniqueNumber: ly
}, Symbol.toStringTag, {
    value: "Module"
}));
let Fc;
function dy() {
    const e = He()
      , t = Qe();
    return {
        touch: !!("ontouchstart"in e || e.DocumentTouch && t instanceof e.DocumentTouch),
        pointerEvents: !!e.PointerEvent && "maxTouchPoints"in e.navigator && e.navigator.maxTouchPoints >= 0,
        passiveListener: function() {
            let a = !1;
            try {
                const r = Object.defineProperty({}, "passive", {
                    get() {
                        a = !0
                    }
                });
                e.addEventListener("testPassiveListener", null, r)
            } catch {}
            return a
        }(),
        intersectionObserver: function() {
            return "IntersectionObserver"in e
        }()
    }
}
function Mt() {
    return Fc || (Fc = dy()),
    Fc
}
let jc;
function py(e) {
    let {userAgent: t} = e === void 0 ? {} : e;
    const n = Mt()
      , a = He()
      , r = a.navigator.platform
      , o = t || a.navigator.userAgent
      , i = {
        ios: !1,
        android: !1,
        androidChrome: !1,
        desktop: !1,
        iphone: !1,
        ipod: !1,
        ipad: !1,
        edge: !1,
        ie: !1,
        firefox: !1,
        macos: !1,
        windows: !1,
        cordova: !!a.cordova,
        electron: !1,
        capacitor: !!a.Capacitor,
        nwjs: !1
    }
      , s = a.screen.width
      , l = a.screen.height
      , c = o.match(/(Android);?[\s\/]+([\d.]+)?/);
    let u = o.match(/(iPad).*OS\s([\d_]+)/);
    const f = o.match(/(iPod)(.*OS\s([\d_]+))?/)
      , d = !u && o.match(/(iPhone\sOS|iOS|iPhone;\sCPU\sOS)\s([\d_]+)/)
      , p = o.indexOf("MSIE ") >= 0 || o.indexOf("Trident/") >= 0
      , h = o.indexOf("Edge/") >= 0
      , m = o.indexOf("Gecko/") >= 0 && o.indexOf("Firefox/") >= 0
      , g = r === "Win32"
      , b = o.toLowerCase().indexOf("electron") >= 0
      , v = typeof nw < "u" && typeof process < "u" && typeof process.versions < "u" && typeof process.versions.nw < "u";
    let y = r === "MacIntel";
    const w = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
    !u && y && n.touch && w.indexOf(`${s}x${l}`) >= 0 && (u = o.match(/(Version)\/([\d.]+)/),
    u || (u = [0, 1, "13_0_0"]),
    y = !1),
    i.ie = p,
    i.edge = h,
    i.firefox = m,
    c && (i.os = "android",
    i.osVersion = c[2],
    i.android = !0,
    i.androidChrome = o.toLowerCase().indexOf("chrome") >= 0),
    (u || d || f) && (i.os = "ios",
    i.ios = !0),
    d && !f && (i.osVersion = d[2].replace(/_/g, "."),
    i.iphone = !0),
    u && (i.osVersion = u[2].replace(/_/g, "."),
    i.ipad = !0),
    f && (i.osVersion = f[3] ? f[3].replace(/_/g, ".") : null,
    i.ipod = !0),
    i.ios && i.osVersion && o.indexOf("Version/") >= 0 && i.osVersion.split(".")[0] === "10" && (i.osVersion = o.toLowerCase().split("version/")[1].split(" ")[0]),
    i.webView = !!((d || u || f) && (o.match(/.*AppleWebKit(?!.*Safari)/i) || a.navigator.standalone)) || a.matchMedia && a.matchMedia("(display-mode: standalone)").matches,
    i.webview = i.webView,
    i.standalone = i.webView,
    i.desktop = !(i.ios || i.android) || b || v,
    i.desktop && (i.electron = b,
    i.nwjs = v,
    i.macos = y,
    i.windows = g,
    i.macos && (i.os = "macos"),
    i.windows && (i.os = "windows")),
    i.pixelRatio = a.devicePixelRatio || 1;
    const C = "(prefers-color-scheme: dark)"
      , _ = "(prefers-color-scheme: light)";
    return i.prefersColorScheme = function() {
        let z;
        return a.matchMedia && a.matchMedia(_).matches && (z = "light"),
        a.matchMedia && a.matchMedia(C).matches && (z = "dark"),
        z
    }
    ,
    i
}
function yt(e, t) {
    return e === void 0 && (e = {}),
    (!jc || t) && (jc = py(e)),
    jc
}
class Y7 {
    constructor(t) {
        t === void 0 && (t = []);
        const n = this;
        n.eventsParents = t,
        n.eventsListeners = {}
    }
    on(t, n, a) {
        const r = this;
        if (typeof n != "function")
            return r;
        const o = a ? "unshift" : "push";
        return t.split(" ").forEach(i => {
            r.eventsListeners[i] || (r.eventsListeners[i] = []),
            r.eventsListeners[i][o](n)
        }
        ),
        r
    }
    once(t, n, a) {
        const r = this;
        if (typeof n != "function")
            return r;
        function o() {
            r.off(t, o),
            o.f7proxy && delete o.f7proxy;
            for (var i = arguments.length, s = new Array(i), l = 0; l < i; l++)
                s[l] = arguments[l];
            n.apply(r, s)
        }
        return o.f7proxy = n,
        r.on(t, o, a)
    }
    off(t, n) {
        const a = this;
        return a.eventsListeners && t.split(" ").forEach(r => {
            typeof n > "u" ? a.eventsListeners[r] = [] : a.eventsListeners[r] && a.eventsListeners[r].forEach( (o, i) => {
                (o === n || o.f7proxy && o.f7proxy === n) && a.eventsListeners[r].splice(i, 1)
            }
            )
        }
        ),
        a
    }
    emit() {
        const t = this;
        if (!t.eventsListeners)
            return t;
        let n, a, r, o;
        for (var i = arguments.length, s = new Array(i), l = 0; l < i; l++)
            s[l] = arguments[l];
        typeof s[0] == "string" || Array.isArray(s[0]) ? (n = s[0],
        a = s.slice(1, s.length),
        r = t,
        o = t.eventsParents) : (n = s[0].events,
        a = s[0].data,
        r = s[0].context || t,
        o = s[0].local ? [] : s[0].parents || t.eventsParents);
        const c = Array.isArray(n) ? n : n.split(" ")
          , u = c.map(d => d.replace("local::", ""))
          , f = c.filter(d => d.indexOf("local::") < 0);
        return u.forEach(d => {
            if (t.eventsListeners && t.eventsListeners[d]) {
                const p = [];
                t.eventsListeners[d].forEach(h => {
                    p.push(h)
                }
                ),
                p.forEach(h => {
                    h.apply(r, a)
                }
                )
            }
        }
        ),
        o && o.length > 0 && o.forEach(d => {
            d.emit(f, ...a)
        }
        ),
        t
    }
}
class Bt extends Y7 {
    constructor(t, n) {
        t === void 0 && (t = {}),
        n === void 0 && (n = []),
        super(n);
        const a = this;
        a.params = t,
        a.params && a.params.on && Object.keys(a.params.on).forEach(r => {
            a.on(r, a.params.on[r])
        }
        )
    }
    useModuleParams(t, n) {
        if (t.params) {
            const a = {};
            Object.keys(t.params).forEach(r => {
                typeof n[r] > "u" || (a[r] = se({}, n[r]))
            }
            ),
            se(n, t.params),
            Object.keys(a).forEach(r => {
                se(n[r], a[r])
            }
            )
        }
    }
    useModulesParams(t) {
        const n = this;
        n.modules && Object.keys(n.modules).forEach(a => {
            const r = n.modules[a];
            r.params && se(t, r.params)
        }
        )
    }
    useModule(t, n) {
        t === void 0 && (t = ""),
        n === void 0 && (n = {});
        const a = this;
        if (!a.modules)
            return;
        const r = typeof t == "string" ? a.modules[t] : t;
        r && (r.instance && Object.keys(r.instance).forEach(o => {
            const i = r.instance[o];
            typeof i == "function" ? a[o] = i.bind(a) : a[o] = i
        }
        ),
        r.on && a.on && Object.keys(r.on).forEach(o => {
            a.on(o, r.on[o])
        }
        ),
        r.vnode && (a.vnodeHooks || (a.vnodeHooks = {}),
        Object.keys(r.vnode).forEach(o => {
            Object.keys(r.vnode[o]).forEach(i => {
                const s = r.vnode[o][i];
                a.vnodeHooks[i] || (a.vnodeHooks[i] = {}),
                a.vnodeHooks[i][o] || (a.vnodeHooks[i][o] = []),
                a.vnodeHooks[i][o].push(s.bind(a))
            }
            )
        }
        )),
        r.create && r.create.bind(a)(n))
    }
    useModules(t) {
        t === void 0 && (t = {});
        const n = this;
        n.modules && Object.keys(n.modules).forEach(a => {
            const r = t[a] || {};
            n.useModule(a, r)
        }
        )
    }
    static set components(t) {
        const n = this;
        n.use && n.use(t)
    }
    static installModule(t) {
        const n = this;
        n.prototype.modules || (n.prototype.modules = {});
        const a = t.name || `${Object.keys(n.prototype.modules).length}_${zn()}`;
        if (n.prototype.modules[a] = t,
        t.proto && Object.keys(t.proto).forEach(s => {
            n.prototype[s] = t.proto[s]
        }
        ),
        t.static && Object.keys(t.static).forEach(s => {
            n[s] = t.static[s]
        }
        ),
        t.install) {
            for (var r = arguments.length, o = new Array(r > 1 ? r - 1 : 0), i = 1; i < r; i++)
                o[i - 1] = arguments[i];
            t.install.apply(n, o)
        }
        return n
    }
    static use(t) {
        const n = this;
        if (Array.isArray(t))
            return t.forEach(i => n.installModule(i)),
            n;
        for (var a = arguments.length, r = new Array(a > 1 ? a - 1 : 0), o = 1; o < a; o++)
            r[o - 1] = arguments[o];
        return n.installModule(t, ...r)
    }
}
function Gt(e) {
    e === void 0 && (e = {});
    const {defaultSelector: t, constructor: n, domProp: a, app: r, addMethods: o} = e
      , i = {
        create() {
            for (var s = arguments.length, l = new Array(s), c = 0; c < s; c++)
                l[c] = arguments[c];
            return r ? new n(r,...l) : new n(...l)
        },
        get(s) {
            if (s === void 0 && (s = t),
            s instanceof n)
                return s;
            const l = $(s);
            if (l.length !== 0)
                return l[0][a]
        },
        destroy(s) {
            const l = i.get(s);
            if (l && l.destroy)
                return l.destroy()
        }
    };
    return o && Array.isArray(o) && o.forEach(s => {
        i[s] = function(l) {
            l === void 0 && (l = t);
            const c = i.get(l);
            for (var u = arguments.length, f = new Array(u > 1 ? u - 1 : 0), d = 1; d < u; d++)
                f[d - 1] = arguments[d];
            if (c && c[s])
                return c[s](...f)
        }
    }
    ),
    i
}
function cr(e) {
    e === void 0 && (e = {});
    const {defaultSelector: t, constructor: n, app: a} = e;
    return se(Gt({
        defaultSelector: t,
        constructor: n,
        app: a,
        domProp: "f7Modal"
    }), {
        open(o, i, s) {
            let l = $(o);
            if (l.length > 1 && s) {
                const u = $(s).parents(".page");
                u.length && l.each(f => {
                    const d = $(f);
                    d.parents(u)[0] === u[0] && (l = d)
                }
                )
            }
            if (l.length > 1 && (l = l.eq(l.length - 1)),
            !l.length)
                return;
            let c = l[0].f7Modal;
            if (!c) {
                const u = l.dataset();
                c = new n(a,{
                    el: l,
                    ...u
                })
            }
            return c.open(i)
        },
        close(o, i, s) {
            o === void 0 && (o = t);
            let l = $(o);
            if (!l.length)
                return;
            if (l.length > 1) {
                let u;
                if (s) {
                    const f = $(s);
                    f.length && (u = f.parents(l))
                }
                u && u.length > 0 ? l = u : l = l.eq(l.length - 1)
            }
            let c = l[0].f7Modal;
            if (!c) {
                const u = l.dataset();
                c = new n(a,{
                    el: l,
                    ...u
                })
            }
            return c.close(i)
        }
    })
}
const k3 = [];
function hy(e) {
    const t = this
      , n = He()
      , a = Qe();
    return new Promise( (r, o) => {
        const i = t.instance;
        let s, l, c;
        if (!e) {
            o(new Error("Framework7: Lazy module must be specified"));
            return
        }
        function u(f) {
            t.use(f),
            i && (i.useModuleParams(f, i.params),
            i.useModule(f))
        }
        if (typeof e == "string") {
            const f = e.match(/([a-z0-9-]*)/i);
            if (e.indexOf(".") < 0 && f && f[0].length === e.length) {
                if (!i || i && !i.params.lazyModulesPath) {
                    o(new Error('Framework7: "lazyModulesPath" app parameter must be specified to fetch module by name'));
                    return
                }
                s = `${i.params.lazyModulesPath}/${e}/${e}.lazy.js`
            } else
                s = e
        } else
            typeof e == "function" ? c = e : l = e;
        if (c) {
            const f = c(t, !1);
            if (!f) {
                o(new Error("Framework7: Can't find Framework7 component in specified component function"));
                return
            }
            if (t.prototype.modules && t.prototype.modules[f.name]) {
                r();
                return
            }
            u(f),
            r()
        }
        if (l) {
            const f = l;
            if (!f) {
                o(new Error("Framework7: Can't find Framework7 component in specified component"));
                return
            }
            if (t.prototype.modules && t.prototype.modules[f.name]) {
                r();
                return
            }
            u(f),
            r()
        }
        if (s) {
            if (k3.indexOf(s) >= 0) {
                r();
                return
            }
            k3.push(s);
            const f = new Promise( (p, h) => {
                t.request.get(s, m => {
                    const b = `f7_component_loader_callback_${ac()}`
                      , v = a.createElement("script");
                    v.innerHTML = `window.${b} = function (Framework7, Framework7AutoInstallComponent) {return ${m.trim()}}`,
                    $("head").append(v);
                    const y = n[b];
                    delete n[b],
                    $(v).remove();
                    const w = y(t, !1);
                    if (!w) {
                        h(new Error(`Framework7: Can't find Framework7 component in ${s} file`));
                        return
                    }
                    if (t.prototype.modules && t.prototype.modules[w.name]) {
                        p();
                        return
                    }
                    u(w),
                    p()
                }
                , (m, g) => {
                    h(m, g)
                }
                )
            }
            )
              , d = new Promise(p => {
                t.request.get(s.replace(".lazy.js", i.rtl ? ".rtl.css" : ".css").replace(".js", i.rtl ? ".rtl.css" : ".css"), h => {
                    const m = a.createElement("style");
                    m.innerHTML = h,
                    $("head").append(m),
                    p()
                }
                , () => {
                    p()
                }
                )
            }
            );
            Promise.all([f, d]).then( () => {
                r()
            }
            ).catch(p => {
                o(p)
            }
            )
        }
    }
    )
}
const R = function(e, t) {
    const n = t || {};
    for (var a = arguments.length, r = new Array(a > 2 ? a - 2 : 0), o = 2; o < a; o++)
        r[o - 2] = arguments[o];
    const i = r || []
      , s = Object.keys(n).map(c => c[0] === "_" ? n[c] ? c.replace("_", "") : "" : `${c}="${n[c]}"`).filter(c => !!c).join(" ");
    if (["path", "img", "circle", "polygon", "line", "input"].indexOf(e) >= 0)
        return `<${e} ${s} />`.trim();
    const l = i.filter(c => !!c).map(c => Array.isArray(c) ? c.join("") : c).join("");
    return `<${e} ${s}>${l}</${e}>`.trim()
};
class an extends Bt {
    constructor(t) {
        if (t === void 0 && (t = {}),
        super(t),
        an.instance && typeof window < "u")
            throw new Error("Framework7 is already initialized and can't be initialized more than once");
        const n = yt({
            userAgent: t.userAgent || void 0
        })
          , a = Mt()
          , r = se({}, t)
          , o = this;
        o.device = n,
        o.support = a;
        const i = He()
          , s = Qe();
        an.instance = o;
        const l = {
            version: "1.0.0",
            id: "io.framework7.myapp",
            el: "body",
            theme: "auto",
            language: i.navigator.language,
            routes: [],
            name: "Framework7",
            lazyModulesPath: null,
            initOnDeviceReady: !0,
            init: !0,
            autoDarkMode: !1,
            iosTranslucentBars: !0,
            iosTranslucentModals: !0,
            component: void 0,
            componentUrl: void 0,
            userAgent: null,
            url: null
        };
        return o.useModulesParams(l),
        o.params = se(l, t),
        se(o, {
            id: o.params.id,
            name: o.params.name,
            version: o.params.version,
            routes: o.params.routes,
            language: o.params.language,
            theme: function() {
                return o.params.theme === "auto" ? n.ios ? "ios" : n.desktop && n.electron ? "aurora" : "md" : o.params.theme
            }(),
            passedParams: r,
            online: i.navigator.onLine
        }),
        t.store && (o.params.store = t.store),
        o.$el && o.$el[0] && (o.$el[0].f7 = o),
        o.useModules(),
        o.initStore(),
        o.params.init && (n.cordova && o.params.initOnDeviceReady ? $(s).on("deviceready", () => {
            o.init()
        }
        ) : o.init()),
        o
    }
    mount(t) {
        const n = this
          , a = He()
          , r = Qe()
          , o = $(t || n.params.el).eq(0);
        n.$el = o,
        n.$el && n.$el[0] && (n.el = n.$el[0],
        n.el.f7 = n,
        n.rtl = o.css("direction") === "rtl");
        const i = "(prefers-color-scheme: dark)"
          , s = "(prefers-color-scheme: light)";
        n.mq = {},
        a.matchMedia && (n.mq.dark = a.matchMedia(i),
        n.mq.light = a.matchMedia(s)),
        n.colorSchemeListener = function(c) {
            let {matches: u, media: f} = c;
            if (!u)
                return;
            const d = r.querySelector("html");
            f === i ? (d.classList.add("dark"),
            n.darkMode = !0,
            n.emit("darkModeChange", !0)) : f === s && (d.classList.remove("dark"),
            n.darkMode = !1,
            n.emit("darkModeChange", !1))
        }
        ,
        n.emit("mount")
    }
    initStore() {
        const t = this;
        typeof t.params.store < "u" && t.params.store.__store ? t.store = t.params.store : t.store = t.createStore(t.params.store)
    }
    enableAutoDarkMode() {
        const t = He()
          , n = Qe();
        if (!t.matchMedia)
            return;
        const a = this
          , r = n.querySelector("html");
        a.mq.dark && a.mq.light && (a.mq.dark.addListener(a.colorSchemeListener),
        a.mq.light.addListener(a.colorSchemeListener)),
        a.mq.dark && a.mq.dark.matches ? (r.classList.add("dark"),
        a.darkMode = !0,
        a.emit("darkModeChange", !0)) : a.mq.light && a.mq.light.matches && (r.classList.remove("dark"),
        a.darkMode = !1,
        a.emit("darkModeChange", !1))
    }
    disableAutoDarkMode() {
        if (!He().matchMedia)
            return;
        const n = this;
        n.mq.dark && n.mq.dark.removeListener(n.colorSchemeListener),
        n.mq.light && n.mq.light.removeListener(n.colorSchemeListener)
    }
    initAppComponent(t) {
        const n = this;
        n.router.componentLoader(n.params.component, n.params.componentUrl, {
            componentOptions: {
                el: n.$el[0]
            }
        }, a => {
            n.$el = $(a),
            n.$el[0].f7 = n,
            n.$elComponent = a.f7Component,
            n.el = n.$el[0],
            t && t()
        }
        , () => {}
        )
    }
    init(t) {
        const n = this;
        n.mount(t);
        const a = () => {
            if (n.initialized)
                return;
            n.$el.addClass("framework7-initializing"),
            n.rtl && $("html").attr("dir", "rtl"),
            n.params.autoDarkMode && n.enableAutoDarkMode();
            const r = He();
            r.addEventListener("offline", () => {
                n.online = !1,
                n.emit("offline"),
                n.emit("connection", !1)
            }
            ),
            r.addEventListener("online", () => {
                n.online = !0,
                n.emit("online"),
                n.emit("connection", !0)
            }
            ),
            n.$el.addClass("framework7-root"),
            $("html").removeClass("ios md aurora").addClass(n.theme);
            const o = n.device;
            n.params.iosTranslucentBars && n.theme === "ios" && o.ios && $("html").addClass("ios-translucent-bars"),
            n.params.iosTranslucentModals && n.theme === "ios" && o.ios && $("html").addClass("ios-translucent-modals"),
            xn( () => {
                n.$el.removeClass("framework7-initializing")
            }
            ),
            n.initialized = !0,
            n.emit("init")
        }
        ;
        return n.params.component || n.params.componentUrl ? n.initAppComponent( () => {
            a()
        }
        ) : a(),
        n
    }
    loadModule() {
        return an.loadModule(...arguments)
    }
    loadModules() {
        return an.loadModules(...arguments)
    }
    getVnodeHooks(t, n) {
        const a = this;
        return !a.vnodeHooks || !a.vnodeHooks[t] ? [] : a.vnodeHooks[t][n] || []
    }
    get $() {
        return $
    }
    static get Dom7() {
        return $
    }
    static get $() {
        return $
    }
    static get device() {
        return yt()
    }
    static get support() {
        return Mt()
    }
    static get Class() {
        return Bt
    }
    static get Events() {
        return Y7
    }
}
an.$jsx = R;
an.ModalMethods = cr;
an.ConstructorMethods = Gt;
an.loadModule = hy;
an.loadModules = function(t) {
    return Promise.all(t.map(n => an.loadModule(n)))
}
;
const Qr = {};
let my = 0;
class Uc {
    constructor(t) {
        Object.assign(this, t)
    }
}
class la extends Error {
    constructor(t) {
        super(),
        Object.assign(this, t)
    }
}
const hi = e => new Promise( (t, n) => {
    const a = He()
      , r = Qe()
      , o = se({}, Qr);
    "beforeCreate beforeOpen beforeSend error complete success statusCode".split(" ").forEach(h => {
        delete o[h]
    }
    );
    const i = se({
        url: a.location.toString(),
        method: "GET",
        data: !1,
        async: !0,
        cache: !0,
        user: "",
        password: "",
        headers: {},
        xhrFields: {},
        statusCode: {},
        processData: !0,
        dataType: "text",
        contentType: "application/x-www-form-urlencoded",
        timeout: 0
    }, o);
    let s;
    const l = se({}, i, e);
    if (e.abortController && (l.abortController = e.abortController),
    l.abortController && l.abortController.canceled) {
        n(new la({
            options: l,
            status: "canceled",
            message: "canceled"
        }));
        return
    }
    function c(h) {
        let m, g;
        for (var b = arguments.length, v = new Array(b > 1 ? b - 1 : 0), y = 1; y < b; y++)
            v[y - 1] = arguments[y];
        return Qr[h] && (m = Qr[h](...v)),
        l[h] && (g = l[h](...v)),
        typeof m != "boolean" && (m = !0),
        typeof g != "boolean" && (g = !0),
        l.abortController && l.abortController.canceled && (h === "beforeCreate" || h === "beforeOpen" || h === "beforeSend") ? !1 : m && g
    }
    if (s = c("beforeCreate", l),
    s === !1) {
        n(new la({
            options: l,
            status: "canceled",
            message: "canceled"
        }));
        return
    }
    l.type && (l.method = l.type);
    let u = l.url.indexOf("?") >= 0 ? "&" : "?";
    const f = l.method.toUpperCase();
    if ((f === "GET" || f === "HEAD" || f === "OPTIONS" || f === "DELETE") && l.data) {
        let h;
        typeof l.data == "string" ? l.data.indexOf("?") >= 0 ? h = l.data.split("?")[1] : h = l.data : h = er(l.data),
        h.length && (l.url += u + h,
        u === "?" && (u = "&"))
    }
    if (l.dataType === "json" && l.url.indexOf("callback=") >= 0) {
        const h = `f7jsonp_${Date.now() + (my += 1)}`;
        let m;
        const g = l.url.split("callback=");
        let b = `${g[0]}callback=${h}`;
        if (g[1].indexOf("&") >= 0) {
            const y = g[1].split("&").filter(w => w.indexOf("=") > 0).join("&");
            y.length > 0 && (b += `&${y}`)
        }
        let v = r.createElement("script");
        v.type = "text/javascript",
        v.onerror = function() {
            clearTimeout(m),
            c("error", null, "scripterror", "scripterror"),
            n(new la({
                options: l,
                status: "scripterror",
                message: "scripterror"
            })),
            c("complete", null, "scripterror")
        }
        ,
        v.src = b,
        a[h] = function(w) {
            clearTimeout(m),
            c("success", w),
            v.parentNode.removeChild(v),
            v = null,
            delete a[h],
            t(new Uc({
                options: l,
                data: w
            }))
        }
        ,
        r.querySelector("head").appendChild(v),
        l.timeout > 0 && (m = setTimeout( () => {
            v.parentNode.removeChild(v),
            v = null,
            c("error", null, "timeout", "timeout"),
            n(new la({
                options: l,
                status: "timeout",
                message: "timeout"
            }))
        }
        , l.timeout));
        return
    }
    (f === "GET" || f === "HEAD" || f === "OPTIONS" || f === "DELETE") && l.cache === !1 && (l.url += `${u}_nocache${Date.now()}`);
    const d = new XMLHttpRequest;
    if (l.abortController) {
        let h = !1;
        l.abortController.onAbort = () => {
            h || (h = !0,
            d.abort(),
            n(new la({
                options: l,
                xhr: d,
                status: "canceled",
                message: "canceled"
            })))
        }
    }
    if (d.requestUrl = l.url,
    d.requestParameters = l,
    s = c("beforeOpen", d, l),
    s === !1) {
        n(new la({
            options: l,
            xhr: d,
            status: "canceled",
            message: "canceled"
        }));
        return
    }
    d.open(f, l.url, l.async, l.user, l.password);
    let p = null;
    if ((f === "POST" || f === "PUT" || f === "PATCH") && l.data)
        if (l.processData)
            if ([ArrayBuffer, Blob, Document, FormData].indexOf(l.data.constructor) >= 0)
                p = l.data;
            else {
                const m = `---------------------------${Date.now().toString(16)}`;
                l.contentType === "multipart/form-data" ? d.setRequestHeader("Content-Type", `multipart/form-data; boundary=${m}`) : d.setRequestHeader("Content-Type", l.contentType),
                p = "";
                let g = er(l.data);
                if (l.contentType === "multipart/form-data") {
                    g = g.split("&");
                    const b = [];
                    for (let v = 0; v < g.length; v += 1)
                        b.push(`Content-Disposition: form-data; name="${g[v].split("=")[0]}"\r
\r
${g[v].split("=")[1]}\r
`);
                    p = `--${m}\r
${b.join(`--${m}\r
`)}--${m}--\r
`
                } else
                    l.contentType === "application/json" ? p = JSON.stringify(l.data) : p = g
            }
        else
            p = l.data,
            d.setRequestHeader("Content-Type", l.contentType);
    if (l.dataType === "json" && (!l.headers || !l.headers.Accept) && d.setRequestHeader("Accept", "application/json"),
    l.headers && Object.keys(l.headers).forEach(h => {
        typeof l.headers[h] > "u" || d.setRequestHeader(h, l.headers[h])
    }
    ),
    typeof l.crossDomain > "u" && (l.crossDomain = /^([\w-]+:)?\/\/([^\/]+)/.test(l.url) && RegExp.$2 !== a.location.host),
    l.crossDomain || d.setRequestHeader("X-Requested-With", "XMLHttpRequest"),
    l.xhrFields && se(d, l.xhrFields),
    d.onload = function() {
        if (d.status >= 200 && d.status < 300 || d.status === 0) {
            let m;
            if (l.dataType === "json") {
                let g;
                try {
                    m = JSON.parse(d.responseText)
                } catch {
                    g = !0
                }
                g ? (c("error", d, "parseerror", "parseerror"),
                n(new la({
                    options: l,
                    xhr: d,
                    status: "parseerror",
                    message: "parseerror"
                }))) : (c("success", m, d.status, d),
                t(new Uc({
                    options: l,
                    data: m,
                    status: d.status,
                    xhr: d
                })))
            } else
                m = d.responseType === "text" || d.responseType === "" ? d.responseText : d.response,
                c("success", m, d.status, d),
                t(new Uc({
                    options: l,
                    data: m,
                    status: d.status,
                    xhr: d
                }))
        } else
            c("error", d, d.status, d.statusText),
            n(new la({
                options: l,
                xhr: d,
                status: d.status,
                message: d.statusText
            }));
        l.statusCode && (Qr.statusCode && Qr.statusCode[d.status] && Qr.statusCode[d.status](d),
        l.statusCode[d.status] && l.statusCode[d.status](d)),
        c("complete", d, d.status)
    }
    ,
    d.onerror = function() {
        c("error", d, d.status, d.status),
        n(new la({
            options: l,
            xhr: d,
            status: d.status,
            message: d.statusText
        })),
        c("complete", d, "error")
    }
    ,
    l.timeout > 0 && (d.timeout = l.timeout,
    d.ontimeout = () => {
        c("error", d, "timeout", "timeout"),
        n(new la({
            options: l,
            xhr: d,
            status: "timeout",
            message: "timeout"
        })),
        c("complete", d, "timeout")
    }
    ),
    s = c("beforeSend", d, l),
    s === !1) {
        n(new la({
            options: l,
            xhr: d,
            status: "canceled",
            message: "canceled"
        }));
        return
    }
    d.send(p)
}
);
function Ni(e) {
    let[t,n,a,r,o] = [];
    for (var i = arguments.length, s = new Array(i > 1 ? i - 1 : 0), l = 1; l < i; l++)
        s[l - 1] = arguments[l];
    typeof s[1] == "function" ? [t,a,r,o] = s : [t,n,a,r,o] = s,
    [a, r].forEach(u => {
        typeof u == "string" && (o = u,
        u === a ? a = void 0 : r = void 0)
    }
    ),
    o = o || (e === "json" || e === "postJSON" ? "json" : void 0);
    const c = {
        url: t,
        method: e === "post" || e === "postJSON" ? "POST" : "GET",
        data: n,
        success: a,
        error: r,
        dataType: o
    };
    return e === "postJSON" && se(c, {
        contentType: "application/json",
        processData: !1,
        crossDomain: !0,
        data: typeof n == "string" ? n : JSON.stringify(n)
    }),
    hi(c)
}
Object.assign(hi, {
    get: function() {
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
        return Ni("get", ...t)
    },
    post: function() {
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
        return Ni("post", ...t)
    },
    json: function() {
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
        return Ni("json", ...t)
    },
    getJSON: function() {
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
        return Ni("json", ...t)
    },
    postJSON: function() {
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
        return Ni("postJSON", ...t)
    }
});
hi.abortController = () => {
    const e = {
        canceled: !1,
        onAbort: null,
        abort() {
            e.canceled = !0,
            e.onAbort && e.onAbort()
        }
    };
    return e
}
;
hi.setup = function(t) {
    t.type && !t.method && se(t, {
        method: t.type
    }),
    se(Qr, t)
}
;
const gy = {
    name: "device",
    static: {
        getDevice: yt
    },
    on: {
        init() {
            const e = Qe()
              , t = yt()
              , n = []
              , a = e.querySelector("html")
              , r = e.querySelector('meta[name="apple-mobile-web-app-status-bar-style"]');
            a && (t.standalone && t.ios && r && r.content === "black-translucent" && n.push("device-full-viewport"),
            n.push(`device-pixel-ratio-${Math.floor(t.pixelRatio)}`),
            t.os && !t.desktop ? n.push(`device-${t.os}`) : t.desktop && (n.push("device-desktop"),
            t.os && n.push(`device-${t.os}`)),
            t.cordova && n.push("device-cordova"),
            t.capacitor && n.push("device-capacitor"),
            n.forEach(o => {
                a.classList.add(o)
            }
            ))
        }
    }
}
  , vy = {
    name: "support",
    static: {
        getSupport: Mt
    }
}
  , by = {
    name: "utils",
    proto: {
        utils: _3
    },
    static: {
        utils: _3
    }
}
  , yy = {
    name: "resize",
    create() {
        const e = this;
        e.getSize = () => {
            if (!e.el)
                return {
                    width: 0,
                    height: 0,
                    left: 0,
                    top: 0
                };
            const t = e.$el.offset()
              , [n,a,r,o] = [e.el.offsetWidth, e.el.offsetHeight, t.left, t.top];
            return e.width = n,
            e.height = a,
            e.left = r,
            e.top = o,
            {
                width: n,
                height: a,
                left: r,
                top: o
            }
        }
    },
    on: {
        init() {
            const e = this
              , t = He();
            e.getSize(),
            t.addEventListener("resize", () => {
                e.emit("resize")
            }
            , !1),
            t.addEventListener("orientationchange", () => {
                e.emit("orientationchange")
            }
            )
        },
        orientationchange() {
            const e = Qe();
            yt().ipad && (e.body.scrollLeft = 0,
            setTimeout( () => {
                e.body.scrollLeft = 0
            }
            , 0))
        },
        resize() {
            this.getSize()
        }
    }
}
  , Cy = {
    name: "request",
    proto: {
        request: hi
    },
    static: {
        request: hi
    }
};
function wy() {
    const e = this
      , t = yt()
      , n = Mt()
      , a = He()
      , r = Qe()
      , o = e.params.touch
      , i = o[`${e.theme}TouchRipple`];
    t.ios && t.webView && a.addEventListener("touchstart", () => {}
    );
    let s, l, c, u, f, d, p, h, m, g, b, v;
    function y(ie) {
        const Ee = $(ie)
          , $e = Ee.parents(o.activeStateElements);
        if (Ee.closest(".no-active-state").length)
            return null;
        let xe;
        if (Ee.is(o.activeStateElements) && (xe = Ee),
        $e.length > 0 && (xe = xe ? xe.add($e) : $e),
        xe && xe.length > 1) {
            const he = [];
            let We;
            for (let Te = 0; Te < xe.length; Te += 1)
                We || (he.push(xe[Te]),
                (xe.eq(Te).hasClass("prevent-active-state-propagation") || xe.eq(Te).hasClass("no-active-state-propagation")) && (We = !0));
            xe = $(he)
        }
        return xe || Ee
    }
    function w(ie) {
        return ie.parents(".page-content").length > 0
    }
    function C() {
        h && h.addClass("active-state")
    }
    function _() {
        h && (h.removeClass("active-state"),
        h = null)
    }
    function E(ie) {
        const Ee = o.touchRippleElements
          , $e = $(ie);
        if ($e.is(Ee))
            return $e.hasClass("no-ripple") ? !1 : $e;
        if ($e.parents(Ee).length > 0) {
            const xe = $e.parents(Ee).eq(0);
            return xe.hasClass("no-ripple") ? !1 : xe
        }
        return !1
    }
    function z(ie, Ee, $e) {
        ie && (g = e.touchRipple.create(e, ie, Ee, $e))
    }
    function T() {
        g && (g.remove(),
        g = void 0,
        b = void 0)
    }
    function A(ie) {
        if (b = E(ie),
        !b || b.length === 0) {
            b = void 0;
            return
        }
        w(b) ? (clearTimeout(v),
        v = setTimeout( () => {
            T(),
            z(b, s, l)
        }
        , 80)) : (T(),
        z(b, s, l))
    }
    function x() {
        clearTimeout(v),
        T()
    }
    function M() {
        !g && b && !u ? (clearTimeout(v),
        z(b, s, l),
        setTimeout(T, 0)) : T()
    }
    function L(ie) {
        const Ee = y(ie.target);
        Ee && (Ee.addClass("active-state"),
        "which"in ie && ie.which === 3 && setTimeout( () => {
            $(".active-state").removeClass("active-state")
        }
        , 0)),
        i && (s = ie.pageX,
        l = ie.pageY,
        A(ie.target, ie.pageX, ie.pageY))
    }
    function U() {
        o.activeStateOnMouseMove || $(".active-state").removeClass("active-state"),
        i && x()
    }
    function Y() {
        $(".active-state").removeClass("active-state"),
        i && M()
    }
    function H() {
        c = null,
        clearTimeout(m),
        clearTimeout(d),
        o.activeState && _(),
        i && M()
    }
    let W, j = !1, Q = null;
    const ne = ".dialog-button, .actions-button";
    let re = !1
      , ve = null;
    function Ne(ie) {
        return u = !1,
        f = !1,
        p = !1,
        W = void 0,
        ie.targetTouches.length > 1 ? (h && _(),
        !0) : (ie.touches.length > 1 && h && _(),
        o.tapHold && (d && clearTimeout(d),
        d = setTimeout( () => {
            ie && ie.touches && ie.touches.length > 1 || (f = !0,
            ie.preventDefault(),
            p = !0,
            $(ie.target).trigger("taphold", ie),
            e.emit("taphold", ie))
        }
        , o.tapHoldDelay)),
        c = ie.target,
        s = ie.targetTouches[0].pageX,
        l = ie.targetTouches[0].pageY,
        j = ie.target.closest(".segmented-strong .button-active, .segmented-strong .tab-link-active"),
        re = e.theme === "ios" && ie.target.closest(ne),
        j && (Q = j.closest(".segmented-strong")),
        o.activeState && (h = y(c),
        h && !w(h) ? C() : h && (m = setTimeout(C, 80))),
        i && A(c, s, l),
        !0)
    }
    function Ge(ie) {
        let Ee, $e, xe = !0;
        ie.type === "touchmove" && (Ee = ie.targetTouches[0],
        $e = o.touchClicksDistanceThreshold);
        const he = ie.targetTouches[0].pageX
          , We = ie.targetTouches[0].pageY;
        if (typeof W > "u" && (W = !!(W || Math.abs(We - l) > Math.abs(he - s))),
        (re || !W && j && Q) && ie.cancelable && ie.preventDefault(),
        !W && j && Q) {
            const Fe = r.elementFromPoint(ie.targetTouches[0].clientX, ie.targetTouches[0].clientY).closest(".segmented-strong .button:not(.button-active):not(.tab-link-active)");
            Fe && Q.contains(Fe) && ($(Fe).trigger("click", "f7Segmented"),
            c = Fe)
        }
        if ($e && Ee) {
            const Te = Ee.pageX
              , Fe = Ee.pageY;
            (Math.abs(Te - s) > $e || Math.abs(Fe - l) > $e) && (u = !0)
        } else
            u = !0;
        u && (p = !0,
        re && (ve = r.elementFromPoint(ie.targetTouches[0].clientX, ie.targetTouches[0].clientY).closest(ne),
        ve && h && h[0] === ve ? xe = !1 : ve && setTimeout( () => {
            h = y(ve),
            C()
        }
        )),
        o.tapHold && clearTimeout(d),
        o.activeState && xe && (clearTimeout(m),
        _()),
        i && x())
    }
    function Ye(ie) {
        return W = void 0,
        j = !1,
        Q = null,
        re = !1,
        clearTimeout(m),
        clearTimeout(d),
        ve && ($(ve).trigger("click", "f7TouchMoveActivable"),
        ve = null),
        r.activeElement === ie.target ? (o.activeState && _(),
        i && M(),
        !0) : (o.activeState && (C(),
        setTimeout(_, 0)),
        i && M(),
        o.tapHoldPreventClicks && f || p ? (ie.cancelable && ie.preventDefault(),
        p = !0,
        !1) : !0)
    }
    function tt(ie) {
        const Ee = ie && ie.detail && ie.detail === "f7Overswipe"
          , $e = ie && ie.detail && ie.detail === "f7Segmented"
          , xe = ie && ie.detail && ie.detail === "f7TouchMoveActivable";
        let he = p;
        return c && ie.target !== c ? Ee || $e || xe ? he = !1 : he = !0 : xe && (he = !1),
        o.tapHold && o.tapHoldPreventClicks && f && (he = !0),
        he && (ie.stopImmediatePropagation(),
        ie.stopPropagation(),
        ie.preventDefault()),
        o.tapHold && (d = setTimeout( () => {
            f = !1
        }
        , t.ios || t.androidChrome ? 100 : 400)),
        p = !1,
        c = null,
        !he
    }
    function ee(ie, Ee) {
        e.emit({
            events: ie,
            data: [Ee]
        })
    }
    function ye(ie) {
        ee("click", ie)
    }
    function Le(ie) {
        ee("touchstart touchstart:active", ie)
    }
    function Se(ie) {
        ee("touchmove touchmove:active", ie)
    }
    function Re(ie) {
        ee("touchend touchend:active", ie)
    }
    function Ve(ie) {
        ee("touchstart:passive", ie)
    }
    function Ze(ie) {
        ee("touchmove:passive", ie)
    }
    function q(ie) {
        ee("touchend:passive", ie)
    }
    const Z = n.passiveListener ? {
        passive: !0
    } : !1
      , de = n.passiveListener ? {
        passive: !0,
        capture: !0
    } : !0
      , me = n.passiveListener ? {
        passive: !1
    } : !1
      , ge = n.passiveListener ? {
        passive: !1,
        capture: !0
    } : !0;
    r.addEventListener("click", ye, !0),
    n.passiveListener ? (r.addEventListener(e.touchEvents.start, Le, ge),
    r.addEventListener(e.touchEvents.move, Se, me),
    r.addEventListener(e.touchEvents.end, Re, me),
    r.addEventListener(e.touchEvents.start, Ve, de),
    r.addEventListener(e.touchEvents.move, Ze, Z),
    r.addEventListener(e.touchEvents.end, q, Z)) : (r.addEventListener(e.touchEvents.start, ie => {
        Le(ie),
        Ve(ie)
    }
    , !0),
    r.addEventListener(e.touchEvents.move, ie => {
        Se(ie),
        Ze(ie)
    }
    , !1),
    r.addEventListener(e.touchEvents.end, ie => {
        Re(ie),
        q(ie)
    }
    , !1)),
    n.touch ? (e.on("click", tt),
    e.on("touchstart", Ne),
    e.on("touchmove", Ge),
    e.on("touchend", Ye),
    r.addEventListener("touchcancel", H, {
        passive: !0
    })) : o.activeState && (e.on("touchstart", L),
    e.on("touchmove", U),
    e.on("touchend", Y),
    r.addEventListener("pointercancel", Y, {
        passive: !0
    })),
    r.addEventListener("contextmenu", ie => {
        o.disableContextMenu && (t.ios || t.android || t.cordova || a.Capacitor && a.Capacitor.isNative) && ie.preventDefault(),
        i && (h && _(),
        M())
    }
    )
}
const _y = {
    name: "touch",
    params: {
        touch: {
            touchClicksDistanceThreshold: 5,
            disableContextMenu: !1,
            tapHold: !1,
            tapHoldDelay: 750,
            tapHoldPreventClicks: !0,
            activeState: !0,
            activeStateElements: "a, button, label, span, .actions-button, .stepper-button, .stepper-button-plus, .stepper-button-minus, .card-expandable, .menu-item, .link, .item-link, .accordion-item-toggle",
            activeStateOnMouseMove: !1,
            mdTouchRipple: !0,
            iosTouchRipple: !1,
            auroraTouchRipple: !1,
            touchRippleElements: ".ripple, .link, .item-link, .list-button, .links-list a, .button, button, .input-clear-button, .dialog-button, .tab-link, .item-radio, .item-checkbox, .actions-button, .searchbar-disable-button, .fab a, .checkbox, .radio, .data-table .sortable-cell:not(.input-cell), .notification-close-button, .stepper-button, .stepper-button-minus, .stepper-button-plus, .menu-item-content, .list.accordion-list .accordion-item-toggle",
            touchRippleInsetElements: ".ripple-inset, .icon-only, .searchbar-disable-button, .input-clear-button, .notification-close-button, .md .navbar .link.back"
        }
    },
    create() {
        const e = this
          , t = Mt();
        se(e, {
            touchEvents: {
                start: t.touch ? "touchstart" : t.pointerEvents ? "pointerdown" : "mousedown",
                move: t.touch ? "touchmove" : t.pointerEvents ? "pointermove" : "mousemove",
                end: t.touch ? "touchend" : t.pointerEvents ? "pointerup" : "mouseup"
            }
        })
    },
    on: {
        init: wy
    }
};
function ky(e) {
    for (var t = [], n = 0; n < e.length; ) {
        var a = e[n];
        if (a === "*" || a === "+" || a === "?") {
            t.push({
                type: "MODIFIER",
                index: n,
                value: e[n++]
            });
            continue
        }
        if (a === "\\") {
            t.push({
                type: "ESCAPED_CHAR",
                index: n++,
                value: e[n++]
            });
            continue
        }
        if (a === "{") {
            t.push({
                type: "OPEN",
                index: n,
                value: e[n++]
            });
            continue
        }
        if (a === "}") {
            t.push({
                type: "CLOSE",
                index: n,
                value: e[n++]
            });
            continue
        }
        if (a === ":") {
            for (var r = "", o = n + 1; o < e.length; ) {
                var i = e.charCodeAt(o);
                if (i >= 48 && i <= 57 || i >= 65 && i <= 90 || i >= 97 && i <= 122 || i === 95) {
                    r += e[o++];
                    continue
                }
                break
            }
            if (!r)
                throw new TypeError("Missing parameter name at ".concat(n));
            t.push({
                type: "NAME",
                index: n,
                value: r
            }),
            n = o;
            continue
        }
        if (a === "(") {
            var s = 1
              , l = ""
              , o = n + 1;
            if (e[o] === "?")
                throw new TypeError('Pattern cannot start with "?" at '.concat(o));
            for (; o < e.length; ) {
                if (e[o] === "\\") {
                    l += e[o++] + e[o++];
                    continue
                }
                if (e[o] === ")") {
                    if (s--,
                    s === 0) {
                        o++;
                        break
                    }
                } else if (e[o] === "(" && (s++,
                e[o + 1] !== "?"))
                    throw new TypeError("Capturing groups are not allowed at ".concat(o));
                l += e[o++]
            }
            if (s)
                throw new TypeError("Unbalanced pattern at ".concat(n));
            if (!l)
                throw new TypeError("Missing pattern at ".concat(n));
            t.push({
                type: "PATTERN",
                index: n,
                value: l
            }),
            n = o;
            continue
        }
        t.push({
            type: "CHAR",
            index: n,
            value: e[n++]
        })
    }
    return t.push({
        type: "END",
        index: n,
        value: ""
    }),
    t
}
function G7(e, t) {
    t === void 0 && (t = {});
    for (var n = ky(e), a = t.prefixes, r = a === void 0 ? "./" : a, o = "[^".concat(jo(t.delimiter || "/#?"), "]+?"), i = [], s = 0, l = 0, c = "", u = function(_) {
        if (l < n.length && n[l].type === _)
            return n[l++].value
    }, f = function(_) {
        var E = u(_);
        if (E !== void 0)
            return E;
        var z = n[l]
          , T = z.type
          , A = z.index;
        throw new TypeError("Unexpected ".concat(T, " at ").concat(A, ", expected ").concat(_))
    }, d = function() {
        for (var _ = "", E; E = u("CHAR") || u("ESCAPED_CHAR"); )
            _ += E;
        return _
    }; l < n.length; ) {
        var p = u("CHAR")
          , h = u("NAME")
          , m = u("PATTERN");
        if (h || m) {
            var g = p || "";
            r.indexOf(g) === -1 && (c += g,
            g = ""),
            c && (i.push(c),
            c = ""),
            i.push({
                name: h || s++,
                prefix: g,
                suffix: "",
                pattern: m || o,
                modifier: u("MODIFIER") || ""
            });
            continue
        }
        var b = p || u("ESCAPED_CHAR");
        if (b) {
            c += b;
            continue
        }
        c && (i.push(c),
        c = "");
        var v = u("OPEN");
        if (v) {
            var g = d()
              , y = u("NAME") || ""
              , w = u("PATTERN") || ""
              , C = d();
            f("CLOSE"),
            i.push({
                name: y || (w ? s++ : ""),
                pattern: y && !w ? o : w,
                prefix: g,
                suffix: C,
                modifier: u("MODIFIER") || ""
            });
            continue
        }
        f("END")
    }
    return i
}
function Sy(e, t) {
    return $y(G7(e, t), t)
}
function $y(e, t) {
    t === void 0 && (t = {});
    var n = Tf(t)
      , a = t.encode
      , r = a === void 0 ? function(l) {
        return l
    }
    : a
      , o = t.validate
      , i = o === void 0 ? !0 : o
      , s = e.map(function(l) {
        if (typeof l == "object")
            return new RegExp("^(?:".concat(l.pattern, ")$"),n)
    });
    return function(l) {
        for (var c = "", u = 0; u < e.length; u++) {
            var f = e[u];
            if (typeof f == "string") {
                c += f;
                continue
            }
            var d = l ? l[f.name] : void 0
              , p = f.modifier === "?" || f.modifier === "*"
              , h = f.modifier === "*" || f.modifier === "+";
            if (Array.isArray(d)) {
                if (!h)
                    throw new TypeError('Expected "'.concat(f.name, '" to not repeat, but got an array'));
                if (d.length === 0) {
                    if (p)
                        continue;
                    throw new TypeError('Expected "'.concat(f.name, '" to not be empty'))
                }
                for (var m = 0; m < d.length; m++) {
                    var g = r(d[m], f);
                    if (i && !s[u].test(g))
                        throw new TypeError('Expected all "'.concat(f.name, '" to match "').concat(f.pattern, '", but got "').concat(g, '"'));
                    c += f.prefix + g + f.suffix
                }
                continue
            }
            if (typeof d == "string" || typeof d == "number") {
                var g = r(String(d), f);
                if (i && !s[u].test(g))
                    throw new TypeError('Expected "'.concat(f.name, '" to match "').concat(f.pattern, '", but got "').concat(g, '"'));
                c += f.prefix + g + f.suffix;
                continue
            }
            if (!p) {
                var b = h ? "an array" : "a string";
                throw new TypeError('Expected "'.concat(f.name, '" to be ').concat(b))
            }
        }
        return c
    }
}
function jo(e) {
    return e.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1")
}
function Tf(e) {
    return e && e.sensitive ? "" : "i"
}
function Ey(e, t) {
    if (!t)
        return e;
    for (var n = /\((?:\?<(.*?)>)?(?!\?)/g, a = 0, r = n.exec(e.source); r; )
        t.push({
            name: r[1] || a++,
            prefix: "",
            suffix: "",
            modifier: "",
            pattern: ""
        }),
        r = n.exec(e.source);
    return e
}
function xy(e, t, n) {
    var a = e.map(function(r) {
        return X7(r, t, n).source
    });
    return new RegExp("(?:".concat(a.join("|"), ")"),Tf(n))
}
function Ty(e, t, n) {
    return My(G7(e, n), t, n)
}
function My(e, t, n) {
    n === void 0 && (n = {});
    for (var a = n.strict, r = a === void 0 ? !1 : a, o = n.start, i = o === void 0 ? !0 : o, s = n.end, l = s === void 0 ? !0 : s, c = n.encode, u = c === void 0 ? function(A) {
        return A
    }
    : c, f = n.delimiter, d = f === void 0 ? "/#?" : f, p = n.endsWith, h = p === void 0 ? "" : p, m = "[".concat(jo(h), "]|$"), g = "[".concat(jo(d), "]"), b = i ? "^" : "", v = 0, y = e; v < y.length; v++) {
        var w = y[v];
        if (typeof w == "string")
            b += jo(u(w));
        else {
            var C = jo(u(w.prefix))
              , _ = jo(u(w.suffix));
            if (w.pattern)
                if (t && t.push(w),
                C || _)
                    if (w.modifier === "+" || w.modifier === "*") {
                        var E = w.modifier === "*" ? "?" : "";
                        b += "(?:".concat(C, "((?:").concat(w.pattern, ")(?:").concat(_).concat(C, "(?:").concat(w.pattern, "))*)").concat(_, ")").concat(E)
                    } else
                        b += "(?:".concat(C, "(").concat(w.pattern, ")").concat(_, ")").concat(w.modifier);
                else
                    w.modifier === "+" || w.modifier === "*" ? b += "((?:".concat(w.pattern, ")").concat(w.modifier, ")") : b += "(".concat(w.pattern, ")").concat(w.modifier);
            else
                b += "(?:".concat(C).concat(_, ")").concat(w.modifier)
        }
    }
    if (l)
        r || (b += "".concat(g, "?")),
        b += n.endsWith ? "(?=".concat(m, ")") : "$";
    else {
        var z = e[e.length - 1]
          , T = typeof z == "string" ? g.indexOf(z[z.length - 1]) > -1 : z === void 0;
        r || (b += "(?:".concat(g, "(?=").concat(m, "))?")),
        T || (b += "(?=".concat(g, "|").concat(m, ")"))
    }
    return new RegExp(b,Tf(n))
}
function X7(e, t, n) {
    return e instanceof RegExp ? Ey(e, t) : Array.isArray(e) ? xy(e, t, n) : Ty(e, t, n)
}
const nt = {
    queue: [],
    clearQueue() {
        if (nt.queue.length === 0)
            return;
        nt.queue.shift()()
    },
    routerQueue: [],
    clearRouterQueue() {
        if (nt.routerQueue.length === 0)
            return;
        const e = nt.routerQueue.pop()
          , {router: t, stateUrl: n, action: a} = e;
        let r = t.params.animate;
        t.params.browserHistoryAnimate === !1 && (r = !1),
        a === "back" && t.back({
            animate: r,
            browserHistory: !1
        }),
        a === "load" && t.navigate(n, {
            animate: r,
            browserHistory: !1
        })
    },
    handle(e) {
        if (nt.blockPopstate)
            return;
        const t = this;
        let n = e.state;
        nt.previousState = nt.state,
        nt.state = n,
        nt.allowChange = !0,
        nt.clearQueue(),
        n = nt.state,
        n || (n = {}),
        t.views.forEach(a => {
            const r = a.router;
            let o = n[a.id];
            if (!o && a.params.browserHistory && (o = {
                url: a.router.history[0]
            }),
            !o)
                return;
            const i = o.url || void 0;
            let s = r.params.animate;
            r.params.browserHistoryAnimate === !1 && (s = !1),
            i !== r.url && (r.history.indexOf(i) >= 0 ? r.allowPageChange ? r.back({
                animate: s,
                browserHistory: !1
            }) : nt.routerQueue.push({
                action: "back",
                router: r
            }) : r.allowPageChange ? r.navigate(i, {
                animate: s,
                browserHistory: !1
            }) : nt.routerQueue.unshift({
                action: "load",
                stateUrl: i,
                router: r
            }))
        }
        )
    },
    initViewState(e, t) {
        const n = He()
          , a = se({}, nt.state || {}, {
            [e]: t
        });
        nt.state = a,
        n.history.replaceState(a, "")
    },
    push(e, t, n) {
        const a = He()
          , r = Qe();
        if (n.substr(-3) === "#!/" && (n = n.replace("#!/", ""),
        n === "" && (n = r.location.href,
        n.includes("#!/") && (n = r.location.href.split("#!/")[0]))),
        !nt.allowChange) {
            nt.queue.push( () => {
                nt.push(e, t, n)
            }
            );
            return
        }
        nt.previousState = nt.state;
        const o = se({}, nt.previousState || {}, {
            [e]: t
        });
        nt.state = o,
        a.history.pushState(o, "", n)
    },
    replace(e, t, n) {
        const a = He();
        if (n.substr(-3) === "#!/" && (n = n.replace("#!/", "")),
        !nt.allowChange) {
            nt.queue.push( () => {
                nt.replace(e, t, n)
            }
            );
            return
        }
        nt.previousState = nt.state;
        const r = se({}, nt.previousState || {}, {
            [e]: t
        });
        nt.state = r,
        a.history.replaceState(r, "", n)
    },
    go(e) {
        const t = He();
        nt.allowChange = !1,
        t.history.go(e)
    },
    back() {
        const e = He();
        nt.allowChange = !1,
        e.history.back()
    },
    allowChange: !0,
    previousState: {},
    state: {},
    blockPopstate: !0,
    init(e) {
        const t = He()
          , n = Qe();
        nt.state = t.history.state,
        $(t).on("load", () => {
            setTimeout( () => {
                nt.blockPopstate = !1
            }
            , 0)
        }
        ),
        n.readyState && n.readyState === "complete" && (nt.blockPopstate = !1),
        $(t).on("popstate", nt.handle.bind(e))
    }
};
function zy(e) {
    const t = e
      , {$el: n, $navbarsEl: a, app: r, params: o} = t
      , i = Mt()
      , s = yt();
    let l = !1
      , c = !1;
    const u = {};
    let f, d = [], p = [], h, m, g = !0, b, v = [], y = [], w, C, _, E;
    const z = o[`${r.theme}SwipeBackAnimateShadow`]
      , T = o[`${r.theme}SwipeBackAnimateOpacity`]
      , A = o[`${r.theme}SwipeBackActiveArea`]
      , x = o[`${r.theme}SwipeBackThreshold`]
      , M = r.rtl ? "right center" : "left center"
      , L = r.rtl ? "calc(100% - var(--f7-navbar-large-title-padding-left) - var(--f7-safe-area-left)) center" : "calc(var(--f7-navbar-large-title-padding-left) + var(--f7-safe-area-left)) center";
    function U() {
        const re = []
          , ve = r.rtl ? -1 : 1
          , Ne = v.hasClass("navbar-transparent") && !v.hasClass("navbar-large") && !v.hasClass("navbar-transparent-visible")
          , Ge = v.hasClass("navbar-large")
          , Ye = v.hasClass("navbar-large-collapsed")
          , tt = v.hasClass("navbar-large-transparent") || v.hasClass("navbar-large") && v.hasClass("navbar-transparent")
          , ee = y.hasClass("navbar-transparent") && !y.hasClass("navbar-large") && !y.hasClass("navbar-transparent-visible")
          , ye = y.hasClass("navbar-large")
          , Le = y.hasClass("navbar-large-collapsed")
          , Se = y.hasClass("navbar-large-transparent") || y.hasClass("navbar-large") && y.hasClass("navbar-transparent")
          , Re = Ge && !Ye
          , Ve = ye && !Le
          , Ze = v.find(".left, .title, .right, .subnavbar, .fading, .title-large, .navbar-bg")
          , q = y.find(".left, .title, .right, .subnavbar, .fading, .title-large, .navbar-bg");
        let Z, de;
        return o.iosAnimateNavbarBackIcon && (v.hasClass("sliding") || v.find(".navbar-inner.sliding").length ? Z = v.find(".left").find(".back .icon + span").eq(0) : Z = v.find(".left.sliding").find(".back .icon + span").eq(0),
        y.hasClass("sliding") || y.find(".navbar-inner.sliding").length ? de = y.find(".left").find(".back .icon + span").eq(0) : de = y.find(".left.sliding").find(".back .icon + span").eq(0),
        Z.length && q.each(me => {
            $(me).hasClass("title") && (me.f7NavbarLeftOffset += Z.prev(".icon")[0].offsetWidth)
        }
        )),
        Ze.each(me => {
            const ge = $(me)
              , ie = ge.hasClass("subnavbar")
              , Ee = ge.hasClass("left")
              , $e = ge.hasClass("title")
              , xe = ge.hasClass("navbar-bg");
            if (($e || xe) && Ne || !Re && ge.hasClass(".title-large"))
                return;
            const he = {
                el: me
            };
            if (Re) {
                if ($e)
                    return;
                if (ge.hasClass("title-large")) {
                    re.indexOf(he) < 0 && re.push(he),
                    he.overflow = "visible",
                    ge.find(".title-large-text").each(Te => {
                        re.push({
                            el: Te,
                            transform: Fe => `translateX(${Fe * 100 * ve}%)`
                        })
                    }
                    );
                    return
                }
            }
            if (Ve && (Re || ge.hasClass("title-large") && (re.indexOf(he) < 0 && re.push(he),
            he.opacity = 0),
            Ee)) {
                re.indexOf(he) < 0 && re.push(he),
                he.opacity = Te => 1 - Te ** .33,
                ge.find(".back span").each(Te => {
                    re.push({
                        el: Te,
                        "transform-origin": M,
                        transform: Fe => `translateX(calc(${Fe} * (var(--f7-navbarTitleLargeOffset) - var(--f7-navbarLeftTextOffset)))) translateY(calc(${Fe} * (var(--f7-navbar-large-title-height) - var(--f7-navbar-large-title-padding-vertical) / 2))) scale(${1 + 1 * Fe})`
                    })
                }
                );
                return
            }
            if (xe) {
                re.indexOf(he) < 0 && re.push(he),
                !Re && !Ve && (Ye ? (tt && (he.className = "ios-swipeback-navbar-bg-large"),
                he.transform = Te => `translateX(${100 * Te * ve}%) translateY(calc(-1 * var(--f7-navbar-large-title-height)))`) : he.transform = Te => `translateX(${100 * Te * ve}%)`),
                !Re && Ve && (he.className = "ios-swipeback-navbar-bg-large",
                he.transform = Te => `translateX(${100 * Te * ve}%) translateY(calc(-1 * ${1 - Te} * var(--f7-navbar-large-title-height)))`),
                Re && Ve && (he.transform = Te => `translateX(${100 * Te * ve}%)`),
                Re && !Ve && (he.transform = Te => `translateX(${100 * Te * ve}%) translateY(calc(-${Te} * var(--f7-navbar-large-title-height)))`);
                return
            }
            if (ge.hasClass("title-large"))
                return;
            const We = ge.hasClass("sliding") || ge.parents(".navbar-inner.sliding").length;
            if (re.indexOf(he) < 0 && re.push(he),
            (!ie || ie && !We) && (he.opacity = Te => 1 - Te ** .33),
            We) {
                let Te = he;
                if (Ee && Z.length && o.iosAnimateNavbarBackIcon) {
                    const Fe = {
                        el: Z[0]
                    };
                    Te = Fe,
                    re.push(Fe)
                }
                Te.transform = Fe => {
                    let at = Fe * Te.el.f7NavbarRightOffset;
                    return s.pixelRatio === 1 && (at = Math.round(at)),
                    ie && Ge ? `translate3d(${at}px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0)` : `translate3d(${at}px,0,0)`
                }
            }
        }
        ),
        q.each(me => {
            const ge = $(me)
              , ie = ge.hasClass("subnavbar")
              , Ee = ge.hasClass("left")
              , $e = ge.hasClass("title")
              , xe = ge.hasClass("navbar-bg");
            if (($e || xe) && ee)
                return;
            const he = {
                el: me
            };
            if (Ve) {
                if ($e)
                    return;
                if (re.indexOf(he) < 0 && re.push(he),
                ge.hasClass("title-large")) {
                    he.opacity = 1,
                    he.overflow = "visible",
                    ge.find(".title-large-text").each(Te => {
                        re.push({
                            el: Te,
                            "transform-origin": L,
                            opacity: Fe => Fe ** 3,
                            transform: Fe => `translateX(calc(${1 - Fe} * (var(--f7-navbarLeftTextOffset) - var(--f7-navbarTitleLargeOffset)))) translateY(calc(${Fe - 1} * var(--f7-navbar-large-title-height) + ${1 - Fe} * var(--f7-navbar-large-title-padding-vertical))) scale(${.5 + Fe * .5})`
                        })
                    }
                    );
                    return
                }
            }
            if (xe) {
                re.indexOf(he) < 0 && re.push(he),
                !Re && !Ve && (Le ? (Se && (he.className = "ios-swipeback-navbar-bg-large"),
                he.transform = Te => `translateX(${(-100 + 100 * Te) * ve}%) translateY(calc(-1 * var(--f7-navbar-large-title-height)))`) : he.transform = Te => `translateX(${(-100 + 100 * Te) * ve}%)`),
                !Re && Ve && (he.transform = Te => `translateX(${(-100 + 100 * Te) * ve}%) translateY(calc(-1 * ${1 - Te} * var(--f7-navbar-large-title-height)))`),
                Re && !Ve && (he.className = "ios-swipeback-navbar-bg-large",
                he.transform = Te => `translateX(${(-100 + 100 * Te) * ve}%) translateY(calc(-${Te} * var(--f7-navbar-large-title-height)))`),
                Re && Ve && (he.transform = Te => `translateX(${(-100 + 100 * Te) * ve}%)`);
                return
            }
            if (ge.hasClass("title-large"))
                return;
            const We = ge.hasClass("sliding") || y.children(".navbar-inner.sliding").length;
            if (re.indexOf(he) < 0 && re.push(he),
            (!ie || ie && !We) && (he.opacity = Te => Te ** 3),
            We) {
                let Te = he;
                if (Ee && de.length && o.iosAnimateNavbarBackIcon) {
                    const Fe = {
                        el: de[0]
                    };
                    Te = Fe,
                    re.push(Fe)
                }
                Te.transform = Fe => {
                    let at = Te.el.f7NavbarLeftOffset * (1 - Fe);
                    return s.pixelRatio === 1 && (at = Math.round(at)),
                    ie && ye ? `translate3d(${at}px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0)` : `translate3d(${at}px,0,0)`
                }
            }
        }
        ),
        re
    }
    function Y(re) {
        let {progress: ve, reset: Ne, transition: Ge, reflow: Ye} = re === void 0 ? {} : re;
        const tt = ["overflow", "transform", "transform-origin", "opacity"];
        if (Ge === !0 || Ge === !1)
            for (let ee = 0; ee < E.length; ee += 1) {
                const ye = E[ee];
                ye && ye.el && (Ge === !0 && ye.el.classList.add("navbar-page-transitioning"),
                Ge === !1 && ye.el.classList.remove("navbar-page-transitioning"))
            }
        Ye && E.length && E[0] && E[0].el && (E[0].el._clientLeft = E[0].el.clientLeft);
        for (let ee = 0; ee < E.length; ee += 1) {
            const ye = E[ee];
            if (ye && ye.el) {
                ye.className && !ye.classNameSet && !Ne && (ye.el.classList.add(ye.className),
                ye.classNameSet = !0),
                ye.className && Ne && ye.el.classList.remove(ye.className);
                for (let Le = 0; Le < tt.length; Le += 1) {
                    const Se = tt[Le];
                    ye[Se] && (Ne ? ye.el.style[Se] = "" : typeof ye[Se] == "function" ? ye.el.style[Se] = ye[Se](ve) : ye.el.style[Se] = ye[Se])
                }
            }
        }
    }
    function H(re) {
        const ve = o[`${r.theme}SwipeBack`];
        !g || !ve || l || r.swipeout && r.swipeout.el || !t.allowPageChange || $(re.target).closest(".range-slider, .calendar-months").length > 0 || $(re.target).closest(".page-master, .page-master-detail").length > 0 && o.masterDetailBreakpoint > 0 && r.width >= o.masterDetailBreakpoint || (c = !1,
        l = !0,
        f = void 0,
        u.x = re.type === "touchstart" ? re.targetTouches[0].pageX : re.pageX,
        u.y = re.type === "touchstart" ? re.targetTouches[0].pageY : re.pageY,
        b = zn(),
        w = t.dynamicNavbar)
    }
    function W(re) {
        if (!l)
            return;
        const ve = re.type === "touchmove" ? re.targetTouches[0].pageX : re.pageX
          , Ne = re.type === "touchmove" ? re.targetTouches[0].pageY : re.pageY;
        if (typeof f > "u" && (f = !!(f || Math.abs(Ne - u.y) > Math.abs(ve - u.x)) || ve < u.x && !r.rtl || ve > u.x && r.rtl),
        f || re.f7PreventSwipeBack || r.preventSwipeBack) {
            l = !1;
            return
        }
        if (!c) {
            let Le = !1;
            const Se = $(re.target)
              , Re = Se.closest(".swipeout");
            Re.length > 0 && (!r.rtl && Re.find(".swipeout-actions-left").length > 0 && (Le = !0),
            r.rtl && Re.find(".swipeout-actions-right").length > 0 && (Le = !0)),
            d = Se.closest(".page"),
            (d.hasClass("no-swipeback") || Se.closest(".no-swipeback, .card-opened").length > 0) && (Le = !0),
            p = n.find(".page-previous:not(.stacked)"),
            p.length > 1 && (p = p.eq(p.length - 1));
            let Ve = u.x - n.offset().left > A;
            if (h = n.width(),
            r.rtl ? Ve = u.x < n.offset().left - n[0].scrollLeft + (h - A) : Ve = u.x - n.offset().left > A,
            Ve && (Le = !0),
            (p.length === 0 || d.length === 0) && (Le = !0),
            Le) {
                l = !1;
                return
            }
            z && (C = d.find(".page-shadow-effect"),
            C.length === 0 && (C = $('<div class="page-shadow-effect"></div>'),
            d.append(C))),
            T && (_ = p.find(".page-opacity-effect"),
            _.length === 0 && (_ = $('<div class="page-opacity-effect"></div>'),
            p.append(_))),
            w && (v = a.find(".navbar-current:not(.stacked)"),
            y = a.find(".navbar-previous:not(.stacked)"),
            y.length > 1 && (y = y.eq(y.length - 1)),
            E = U(y, v)),
            $(".sheet.modal-in").length > 0 && r.sheet && r.sheet.close($(".sheet.modal-in"))
        }
        re.f7PreventSwipePanel = !0,
        c = !0,
        r.preventSwipePanelBySwipeBack = !0,
        re.preventDefault();
        const Ge = r.rtl ? -1 : 1;
        m = (ve - u.x - x) * Ge,
        m < 0 && (m = 0);
        const Ye = Math.min(Math.max(m / h, 0), 1)
          , tt = {
            percentage: Ye,
            progress: Ye,
            currentPageEl: d[0],
            previousPageEl: p[0],
            currentNavbarEl: v[0],
            previousNavbarEl: y[0]
        };
        n.trigger("swipeback:move", tt),
        t.emit("swipebackMove", tt);
        let ee = m * Ge
          , ye = (m / 5 - h / 5) * Ge;
        r.rtl ? (ee = Math.max(ee, -h),
        ye = Math.max(ye, 0)) : (ee = Math.min(ee, h),
        ye = Math.min(ye, 0)),
        s.pixelRatio === 1 && (ee = Math.round(ee),
        ye = Math.round(ye)),
        t.swipeBackActive = !0,
        $([d[0], p[0]]).addClass("page-swipeback-active"),
        d.transform(`translate3d(${ee}px,0,0)`),
        z && (C[0].style.opacity = 1 - 1 * Ye),
        r.theme === "ios" && p.transform(`translate3d(${ye}px,0,0)`),
        T && (_[0].style.opacity = 1 - 1 * Ye),
        w && Y({
            progress: Ye
        })
    }
    function j() {
        if (r.preventSwipePanelBySwipeBack = !1,
        !l || !c) {
            l = !1,
            c = !1;
            return
        }
        l = !1,
        c = !1,
        t.swipeBackActive = !1;
        const re = $([d[0], p[0]]);
        if (re.removeClass("page-swipeback-active"),
        m === 0) {
            re.transform(""),
            C && C.length > 0 && C.remove(),
            _ && _.length > 0 && _.remove(),
            w && Y({
                reset: !0
            });
            return
        }
        const ve = zn() - b;
        let Ne = !1;
        (ve < 300 && m > 10 || ve >= 300 && m > h / 2) && (d.removeClass("page-current").addClass(`page-next${r.theme !== "ios" ? " page-next-on-right" : ""}`),
        p.removeClass("page-previous").addClass("page-current").removeAttr("aria-hidden"),
        C && (C[0].style.opacity = ""),
        _ && (_[0].style.opacity = ""),
        w && (t.setNavbarPosition(v, "next"),
        t.setNavbarPosition(y, "current", !1)),
        Ne = !0),
        re.addClass("page-transitioning page-transitioning-swipeback"),
        s.ios && (d[0]._clientLeft = d[0].clientLeft),
        re.transform(""),
        w && Y({
            progress: Ne ? 1 : 0,
            transition: !0,
            reflow: !!s.ios
        }),
        g = !1,
        t.allowPageChange = !1;
        const Ge = {
            currentPageEl: d[0],
            previousPageEl: p[0],
            currentNavbarEl: v[0],
            previousNavbarEl: y[0]
        };
        Ne ? (t.currentRoute = p[0].f7Page.route,
        t.currentPage = p[0],
        t.pageCallback("beforeOut", d, v, "current", "next", {
            route: d[0].f7Page.route,
            swipeBack: !0
        }),
        t.pageCallback("beforeIn", p, y, "previous", "current", {
            route: p[0].f7Page.route,
            swipeBack: !0
        }, d[0]),
        n.trigger("swipeback:beforechange", Ge),
        t.emit("swipebackBeforeChange", Ge)) : (n.trigger("swipeback:beforereset", Ge),
        t.emit("swipebackBeforeReset", Ge)),
        d.transitionEnd( () => {
            re.removeClass("page-transitioning page-transitioning-swipeback"),
            w && Y({
                reset: !0,
                transition: !1
            }),
            g = !0,
            t.allowPageChange = !0,
            Ne ? (t.history.length === 1 && t.history.unshift(t.url),
            t.history.pop(),
            t.saveHistory(),
            o.browserHistory && nt.back(),
            t.pageCallback("afterOut", d, v, "current", "next", {
                route: d[0].f7Page.route,
                swipeBack: !0
            }),
            t.pageCallback("afterIn", p, y, "previous", "current", {
                route: p[0].f7Page.route,
                swipeBack: !0
            }),
            o.stackPages && t.initialPages.indexOf(d[0]) >= 0 ? (d.addClass("stacked"),
            w && v.addClass("stacked")) : (t.pageCallback("beforeRemove", d, v, "next", {
                swipeBack: !0
            }),
            t.removePage(d),
            w && t.removeNavbar(v)),
            n.trigger("swipeback:afterchange", Ge),
            t.emit("swipebackAfterChange", Ge),
            t.emit("routeChanged", t.currentRoute, t.previousRoute, t),
            o.preloadPreviousPage && t.back(t.history[t.history.length - 2], {
                preload: !0
            })) : (n.trigger("swipeback:afterreset", Ge),
            t.emit("swipebackAfterReset", Ge)),
            C && C.length > 0 && C.remove(),
            _ && _.length > 0 && _.remove()
        }
        )
    }
    function Q() {
        const re = r.touchEvents.start === "touchstart" && i.passiveListener ? {
            passive: !0,
            capture: !1
        } : !1;
        n.on(r.touchEvents.start, H, re),
        r.on("touchmove:active", W),
        r.on("touchend:passive", j)
    }
    function ne() {
        const re = r.touchEvents.start === "touchstart" && i.passiveListener ? {
            passive: !0,
            capture: !1
        } : !1;
        n.off(r.touchEvents.start, H, re),
        r.off("touchmove:active", W),
        r.off("touchend:passive", j)
    }
    Q(),
    t.on("routerDestroy", ne)
}
function K7(e, t, n) {
    const a = this
      , r = t.route.redirect
      , o = e === "forward" ? "navigate" : "back";
    n.initial && a.params.browserHistory && (n.replaceState = !0,
    n.history = !0);
    function i(l, c) {
        c === void 0 && (c = {}),
        a.allowPageChange = !0,
        a[o](l, se({}, n, c))
    }
    function s() {
        a.allowPageChange = !0
    }
    if (typeof r == "function") {
        a.allowPageChange = !1;
        const l = r.call(a, {
            router: a,
            to: t,
            resolve: i,
            reject: s,
            direction: e,
            app: a.app
        });
        return l && typeof l == "string" ? (a.allowPageChange = !0,
        a[o](l, n)) : a
    }
    return a[o](r, n)
}
function S3(e, t, n, a, r, o, i, s) {
    const l = [];
    Array.isArray(n) ? l.push(...n) : n && typeof n == "function" && l.push(n),
    t && (Array.isArray(t) ? l.push(...t) : l.push(t));
    function c() {
        if (l.length === 0) {
            o();
            return
        }
        l.shift().call(e, {
            router: e,
            to: a,
            from: r,
            resolve() {
                c()
            },
            reject() {
                i()
            },
            direction: s,
            app: e.app
        })
    }
    c()
}
function G2(e, t, n, a, r) {
    const o = this;
    function i() {
        e && e.route && (o.params.routesBeforeEnter || e.route.beforeEnter) ? (o.allowPageChange = !1,
        S3(o, o.params.routesBeforeEnter, e.route.beforeEnter, e, t, () => {
            o.allowPageChange = !0,
            n()
        }
        , () => {
            a()
        }
        , r)) : n()
    }
    function s() {
        t && t.route && (o.params.routesBeforeLeave || t.route.beforeLeave) ? (o.allowPageChange = !1,
        S3(o, o.params.routesBeforeLeave, t.route.beforeLeave, e, t, () => {
            o.allowPageChange = !0,
            i()
        }
        , () => {
            a()
        }
        , r)) : i()
    }
    s()
}
function yi(e, t) {
    if (!e.view)
        throw new Error(`Framework7: it is not allowed to use router methods on global app router. Use router methods only on related View, e.g. app.views.main.router.${t}(...)`)
}
function rc(e, t, n, a) {
    function r(i) {
        i.then(s => {
            n({
                component: s.default || s._default || s
            })
        }
        ).catch(s => {
            throw a(),
            new Error(s)
        }
        )
    }
    if (t instanceof Promise) {
        r(t);
        return
    }
    const o = t.call(e);
    o instanceof Promise ? r(o) : n({
        component: o
    })
}
function Ay(e) {
    e === void 0 && (e = {});
    const t = this;
    return yi(t, "refreshPage"),
    t.navigate(t.currentRoute.url, {
        ignoreCache: !0,
        reloadCurrent: !0,
        props: e
    })
}
function Hi(e, t, n) {
    n === void 0 && (n = {});
    const a = Qe()
      , r = $(t)
      , o = e.app
      , i = e.view
      , s = se(!1, {
        animate: e.params.animate,
        browserHistory: !0,
        replaceState: !1,
        history: !0,
        reloadCurrent: e.params.reloadPages,
        reloadPrevious: !1,
        reloadAll: !1,
        clearPreviousHistory: !1,
        reloadDetail: e.params.reloadDetail,
        on: {}
    }, n)
      , l = e.params.masterDetailBreakpoint > 0
      , c = l && s.route && s.route.route && (s.route.route.master === !0 || typeof s.route.route.master == "function" && s.route.route.master(o, e));
    let u, f, d = 0, p = e.currentRoute.modal, h;
    if (p || "popup popover sheet loginScreen actions customModal panel".split(" ").forEach(j => {
        e.currentRoute && e.currentRoute.route && e.currentRoute.route[j] && (p = !0,
        h = j)
    }
    ),
    p) {
        const j = e.currentRoute.modal || e.currentRoute.route.modalInstance || o[h].get()
          , Q = e.history[e.history.length - 2];
        let ne = e.findMatchingRoute(Q);
        !ne && Q && (ne = {
            url: Q,
            path: Q.split("?")[0],
            query: $s(Q),
            route: {
                path: Q.split("?")[0],
                url: Q
            }
        }),
        e.modalRemove(j)
    }
    const m = e.dynamicNavbar
      , g = e.$el
      , b = r
      , v = s.reloadPrevious || s.reloadCurrent || s.reloadAll;
    let y, w, C, _;
    if (e.allowPageChange = !1,
    b.length === 0)
        return e.allowPageChange = !0,
        e;
    b.length && e.removeThemeElements(b),
    m && (C = b.children(".navbar"),
    w = e.$navbarsEl,
    C.length === 0 && b[0] && b[0].f7Page && (C = b[0].f7Page.$navbarEl)),
    s.route && s.route.route && s.route.route.keepAlive && !s.route.route.keepAliveData && (s.route.route.keepAliveData = {
        pageEl: r[0]
    });
    const E = g.children(".page:not(.stacked)").filter(j => j !== b[0]);
    let z;
    if (m && (z = w.children(".navbar:not(.stacked)").filter(j => j !== C[0])),
    s.reloadPrevious && E.length < 2)
        return e.allowPageChange = !0,
        e;
    let T, A, x;
    if (l && !s.reloadAll) {
        for (let j = 0; j < E.length; j += 1)
            if (!u && E[j].classList.contains("page-master")) {
                u = E[j];
                continue
            }
        if (T = !c && u,
        T && u) {
            for (let j = 0; j < E.length; j += 1)
                if (E[j].classList.contains("page-master-detail")) {
                    f = E[j];
                    continue
                }
        }
        A = T && s.reloadDetail && o.width >= e.params.masterDetailBreakpoint && u
    }
    T && (x = !f || A || s.reloadAll || s.reloadCurrent);
    let M = "next";
    if (s.reloadCurrent || s.reloadAll || A ? M = "current" : s.reloadPrevious && (M = "previous"),
    b.removeClass("page-previous page-current page-next").addClass(`page-${M}${c ? " page-master" : ""}${T ? " page-master-detail" : ""}${x ? " page-master-detail-root" : ""}`).removeClass("stacked").trigger("page:unstack").trigger("page:position", {
        position: M
    }),
    e.emit("pageUnstack", b[0]),
    e.emit("pagePosition", b[0], M),
    (c || T) && (b.trigger("page:role", {
        role: c ? "master" : "detail",
        root: !!x
    }),
    e.emit("pageRole", b[0], {
        role: c ? "master" : "detail",
        detailRoot: !!x
    })),
    m && C.length && (C.removeClass("navbar-previous navbar-current navbar-next").addClass(`navbar-${M}${c ? " navbar-master" : ""}${T ? " navbar-master-detail" : ""}${x ? " navbar-master-detail-root" : ""}`).removeClass("stacked"),
    C.trigger("navbar:position", {
        position: M
    }),
    e.emit("navbarPosition", C[0], M),
    (c || T) && e.emit("navbarRole", C[0], {
        role: c ? "master" : "detail",
        detailRoot: !!x
    })),
    s.reloadCurrent || A)
        A ? (y = E.filter(j => !j.classList.contains("page-master")),
        m && (_ = $(y.map(j => o.navbar.getElByPage(j)))),
        y.length > 1 && u && (d = y.length - 1,
        $(u).removeClass("page-master-stacked").trigger("page:masterunstack"),
        e.emit("pageMasterUnstack", u),
        m && ($(o.navbar.getElByPage(u)).removeClass("navbar-master-stacked"),
        e.emit("navbarMasterUnstack", o.navbar.getElByPage(u))))) : (y = E.eq(E.length - 1),
        m && (_ = $(o.navbar.getElByPage(y))));
    else if (s.reloadPrevious)
        y = E.eq(E.length - 2),
        m && (_ = $(o.navbar.getElByPage(y)));
    else if (s.reloadAll)
        y = E.filter(j => j !== b[0]),
        m && (_ = z.filter(j => j !== C[0]));
    else {
        let j = []
          , Q = [];
        if (E.length > 1) {
            let ne = 0;
            for (ne = 0; ne < E.length - 1; ne += 1) {
                if (u && E[ne] === u) {
                    E.eq(ne).addClass("page-master-stacked"),
                    E.eq(ne).trigger("page:masterstack"),
                    e.emit("pageMasterStack", E[ne]),
                    m && ($(o.navbar.getElByPage(u)).addClass("navbar-master-stacked"),
                    e.emit("navbarMasterStack", o.navbar.getElByPage(u)));
                    continue
                }
                const re = o.navbar.getElByPage(E.eq(ne));
                e.params.stackPages ? (E.eq(ne).addClass("stacked"),
                E.eq(ne).trigger("page:stack"),
                e.emit("pageStack", E[ne]),
                m && $(re).addClass("stacked")) : (j.push(E[ne]),
                e.pageCallback("beforeRemove", E[ne], z && z[ne], "previous", void 0, s),
                e.removePage(E[ne]),
                m && re && (Q.push(re),
                e.removeNavbar(re)))
            }
        }
        y = g.children(".page:not(.stacked)").filter(ne => ne !== b[0] && j.indexOf(ne) < 0),
        m && (_ = w.children(".navbar:not(.stacked)").filter(ne => ne !== C[0] && Q.indexOf(Q) < 0)),
        j = [],
        Q = []
    }
    if (T && !s.reloadAll && ((y.length > 1 || A) && (y = y.filter(j => !j.classList.contains("page-master"))),
    _ && (_.length > 1 || A) && (_ = _.filter(j => !j.classList.contains("navbar-master")))),
    e.params.browserHistory && (s.browserHistory || s.replaceState) && !s.reloadPrevious) {
        const j = e.params.browserHistoryRoot || "";
        nt[s.reloadCurrent || A && f || s.reloadAll || s.replaceState ? "replace" : "push"](i.id, {
            url: s.route.url
        }, j + e.params.browserHistorySeparator + s.route.url)
    }
    s.reloadPrevious || (e.currentPageEl = b[0],
    m && C.length ? e.currentNavbarEl = C[0] : delete e.currentNavbarEl,
    e.currentRoute = s.route);
    const L = s.route.url;
    s.history && (((s.reloadCurrent || A && f) && e.history.length) > 0 || s.replaceState ? (A && d > 0 && (e.history = e.history.slice(0, e.history.length - d),
    e.propsHistory = e.propsHistory.slice(0, e.propsHistory.length - d)),
    e.history[e.history.length - (s.reloadPrevious ? 2 : 1)] = L,
    e.propsHistory[e.propsHistory.length - (s.reloadPrevious ? 2 : 1)] = s.props || {}) : s.reloadPrevious ? (e.history[e.history.length - 2] = L,
    e.propsHistory[e.propsHistory.length - 2] = s.props || {}) : s.reloadAll ? (e.history = [L],
    e.propsHistory = [s.props || {}]) : (e.history.push(L),
    e.propsHistory.push(s.props || {}))),
    e.saveHistory();
    const U = b.parents(a).length > 0
      , Y = b[0].f7Component;
    if (s.reloadPrevious ? (Y && !U ? Y.mount(j => {
        $(j).insertBefore(y)
    }
    ) : b.insertBefore(y),
    m && C.length && (C.find(".title-large").length && C.addClass("navbar-large"),
    _.length ? C.insertBefore(_) : (e.$navbarsEl.parents(a).length || e.$el.prepend(e.$navbarsEl),
    w.append(C)))) : (y.next(".page")[0] !== b[0] && (Y && !U ? Y.mount(j => {
        g.append(j)
    }
    ) : g.append(b[0])),
    m && C.length && (C.find(".title-large").length && C.addClass("navbar-large"),
    e.$navbarsEl.parents(a).length || e.$el.prepend(e.$navbarsEl),
    w.append(C[0]))),
    U ? s.route && s.route.route && s.route.route.keepAlive && !b[0].f7PageMounted && (b[0].f7PageMounted = !0,
    e.pageCallback("mounted", b, C, M, v ? M : "current", s, y)) : e.pageCallback("mounted", b, C, M, v ? M : "current", s, y),
    (s.reloadCurrent || A) && y.length > 0 ? e.params.stackPages && e.initialPages.indexOf(y[0]) >= 0 ? (y.addClass("stacked"),
    y.trigger("page:stack"),
    e.emit("pageStack", y[0]),
    m && _.addClass("stacked")) : (e.pageCallback("beforeOut", y, _, "current", void 0, s),
    e.pageCallback("afterOut", y, _, "current", void 0, s),
    e.pageCallback("beforeRemove", y, _, "current", void 0, s),
    e.removePage(y),
    m && _ && _.length && e.removeNavbar(_)) : s.reloadAll ? y.each( (j, Q) => {
        const ne = $(j)
          , re = $(o.navbar.getElByPage(ne));
        e.params.stackPages && e.initialPages.indexOf(ne[0]) >= 0 ? (ne.addClass("stacked"),
        ne.trigger("page:stack"),
        e.emit("pageStack", ne[0]),
        m && re.addClass("stacked")) : (ne.hasClass("page-current") && (e.pageCallback("beforeOut", y, _, "current", void 0, s),
        e.pageCallback("afterOut", y, _, "current", void 0, s)),
        e.pageCallback("beforeRemove", ne, _ && _.eq(Q), "previous", void 0, s),
        e.removePage(ne),
        m && re.length && e.removeNavbar(re))
    }
    ) : s.reloadPrevious && (e.params.stackPages && e.initialPages.indexOf(y[0]) >= 0 ? (y.addClass("stacked"),
    y.trigger("page:stack"),
    e.emit("pageStack", y[0]),
    m && _.addClass("stacked")) : (e.pageCallback("beforeRemove", y, _, "previous", void 0, s),
    e.removePage(y),
    m && _ && _.length && e.removeNavbar(_))),
    s.route.route.tab && e.tabLoad(s.route.route.tab, se({}, s, {
        history: !1,
        browserHistory: !1
    })),
    l && i.checkMasterDetailBreakpoint(),
    e.pageCallback("init", b, C, M, v ? M : "current", s, y),
    s.reloadCurrent || s.reloadAll || A)
        return e.allowPageChange = !0,
        e.pageCallback("beforeIn", b, C, M, "current", s),
        b.removeAttr("aria-hidden"),
        m && C && C.removeAttr("aria-hidden"),
        e.pageCallback("afterIn", b, C, M, "current", s),
        s.reloadCurrent && s.clearPreviousHistory && e.clearPreviousHistory(),
        A && (e.setPagePosition($(u), "previous"),
        u.f7Page && u.f7Page.navbarEl && e.setNavbarPosition($(u.f7Page.navbarEl), "previous")),
        e;
    if (s.reloadPrevious)
        return e.allowPageChange = !0,
        e;
    e.pageCallback("beforeOut", y, _, "current", "previous", s),
    e.pageCallback("beforeIn", b, C, "next", "current", s);
    function H() {
        e.setPagePosition(b, "current", !1),
        e.setPagePosition(y, "previous", !y.hasClass("page-master")),
        m && (e.setNavbarPosition(C, "current", !1),
        e.setNavbarPosition(_, "previous", !_.hasClass("navbar-master"))),
        e.allowPageChange = !0,
        e.pageCallback("afterOut", y, _, "current", "previous", s),
        e.pageCallback("afterIn", b, C, "next", "current", s);
        let j = (e.params.preloadPreviousPage || e.params[`${o.theme}SwipeBack`]) && !c;
        j || (b.hasClass("smart-select-page") || b.hasClass("photo-browser-page") || b.hasClass("autocomplete-page") || b.hasClass("color-picker-page")) && (j = !0),
        j || (e.params.stackPages ? (y.addClass("stacked"),
        y.trigger("page:stack"),
        e.emit("pageStack", y[0]),
        m && _.addClass("stacked")) : b.attr("data-name") && b.attr("data-name") === "smart-select-page" || (e.pageCallback("beforeRemove", y, _, "previous", void 0, s),
        e.removePage(y),
        m && _.length && e.removeNavbar(_))),
        s.clearPreviousHistory && e.clearPreviousHistory(),
        e.emit("routeChanged", e.currentRoute, e.previousRoute, e),
        e.params.browserHistory && nt.clearRouterQueue()
    }
    function W() {
        e.setPagePosition(y, "current", !1),
        e.setPagePosition(b, "next", !1),
        m && (e.setNavbarPosition(_, "current", !1),
        e.setNavbarPosition(C, "next", !1))
    }
    if (s.animate && !(c && o.width >= e.params.masterDetailBreakpoint)) {
        const j = e.params[`${e.app.theme}PageLoadDelay`];
        let Q = e.params.transition;
        s.transition && (Q = s.transition),
        !Q && e.currentRoute && e.currentRoute.route && (Q = e.currentRoute.route.transition),
        !Q && e.currentRoute && e.currentRoute.route.options && (Q = e.currentRoute.route.options.transition),
        Q && (b[0].f7PageTransition = Q),
        j ? setTimeout( () => {
            W(),
            e.animate(y, b, _, C, "forward", Q, () => {
                H()
            }
            )
        }
        , j) : (W(),
        e.animate(y, b, _, C, "forward", Q, () => {
            H()
        }
        ))
    } else
        H();
    return e
}
function qc(e, t, n, a) {
    if (t === void 0 && (t = {}),
    n === void 0 && (n = {}),
    !e.allowPageChange && !a)
        return e;
    const r = t
      , o = n
      , {url: i, content: s, el: l, pageName: c, component: u, componentUrl: f} = r;
    if (!o.reloadCurrent && o.route && o.route.route && o.route.route.parentPath && e.currentRoute.route && e.currentRoute.route.parentPath === o.route.route.parentPath) {
        if (o.route.url === e.url)
            return e.allowPageChange = !0,
            !1;
        let h = Object.keys(o.route.params).length === Object.keys(e.currentRoute.params).length;
        if (h && Object.keys(o.route.params).forEach(m => {
            (!(m in e.currentRoute.params) || e.currentRoute.params[m] !== o.route.params[m]) && (h = !1)
        }
        ),
        h)
            return o.route.route.tab ? e.tabLoad(o.route.route.tab, o) : !1;
        if (!h && o.route.route.tab && e.currentRoute.route.tab && e.currentRoute.parentPath === o.route.parentPath)
            return e.tabLoad(o.route.route.tab, o)
    }
    if (o.route && o.route.url && e.url === o.route.url && !(o.reloadCurrent || o.reloadPrevious) && !e.params.allowDuplicateUrls)
        return e.allowPageChange = !0,
        !1;
    !o.route && i && (o.route = e.parseRouteUrl(i),
    se(o.route, {
        route: {
            url: i,
            path: i
        }
    }));
    function d(h, m) {
        return Hi(e, h, se(o, m))
    }
    function p() {
        return e.allowPageChange = !0,
        e
    }
    if ((i || f || u) && (e.allowPageChange = !1),
    s)
        Hi(e, e.getPageEl(s), o);
    else if (l)
        Hi(e, e.getPageEl(l), o);
    else if (c)
        Hi(e, e.$el.children(`.page[data-name="${c}"]`).eq(0), o);
    else if (u || f)
        try {
            e.pageComponentLoader({
                routerEl: e.el,
                component: u,
                componentUrl: f,
                options: o,
                resolve: d,
                reject: p
            })
        } catch (h) {
            throw e.allowPageChange = !0,
            h
        }
    else
        i && (e.xhrAbortController && (e.xhrAbortController.abort(),
        e.xhrAbortController = !1),
        e.xhrRequest(i, o).then(h => {
            Hi(e, e.getPageEl(h), o)
        }
        ).catch( () => {
            e.allowPageChange = !0
        }
        ));
    return e
}
function Oy(e, t) {
    t === void 0 && (t = {});
    const n = this;
    if (n.swipeBackActive)
        return n;
    let a, r, o, i, s, l, c;
    if (typeof e == "string" ? a = e : (a = e.url,
    r = e.route,
    o = e.name,
    i = e.path,
    s = e.query,
    l = e.params),
    o || i)
        return a = n.generateUrl({
            path: i,
            name: o,
            params: l,
            query: s
        }),
        a ? n.navigate(a, t) : n;
    const u = n.app;
    if (yi(n, "navigate"),
    a === "#" || a === "")
        return n;
    let f = a.replace("./", "");
    if (f[0] !== "/" && f.indexOf("#") !== 0) {
        const m = n.currentRoute.parentPath || n.currentRoute.path;
        f = ((m ? `${m}/` : "/") + f).replace("///", "/").replace("//", "/")
    }
    if (r ? c = se(n.parseRouteUrl(f), {
        route: se({}, r)
    }) : c = n.findMatchingRoute(f),
    !c)
        return n;
    if (c.route && c.route.viewName) {
        const m = c.route.viewName
          , g = u.views[m];
        if (!g)
            throw new Error(`Framework7: There is no View with "${m}" name that was specified in this route`);
        if (g !== n.view)
            return g.router.navigate(e, t)
    }
    if (c.route.redirect)
        return K7.call(n, "forward", c, t);
    const d = {};
    if (c.route.options ? se(d, c.route.options, t) : se(d, t),
    d.openIn && (!n.params.ignoreOpenIn || n.params.ignoreOpenIn && n.history.length > 0))
        return n.openIn(n, f, d);
    d.route = c;
    function p() {
        let m = !1;
        if ("popup popover sheet loginScreen actions customModal panel".split(" ").forEach(v => {
            c.route[v] && !m && (m = !0,
            n.modalLoad(v, c, d, "forward"))
        }
        ),
        c.route.keepAlive && c.route.keepAliveData && (qc(n, {
            el: c.route.keepAliveData.pageEl
        }, d, !1),
        m = !0),
        "url content component pageName el componentUrl".split(" ").forEach(v => {
            c.route[v] && !m && (m = !0,
            qc(n, {
                [v]: c.route[v]
            }, d, !1))
        }
        ),
        m)
            return;
        function g(v, y) {
            n.allowPageChange = !1;
            let w = !1;
            "popup popover sheet loginScreen actions customModal panel".split(" ").forEach(C => {
                if (v[C]) {
                    w = !0;
                    const _ = se({}, c, {
                        route: v
                    });
                    n.allowPageChange = !0,
                    n.modalLoad(C, _, se(d, y), "forward")
                }
            }
            ),
            !w && qc(n, v, se(d, y), !0)
        }
        function b() {
            n.allowPageChange = !0
        }
        c.route.async && (n.allowPageChange = !1,
        c.route.async.call(n, {
            router: n,
            to: d.route,
            from: n.currentRoute,
            resolve: g,
            reject: b,
            direction: "forward",
            app: u
        })),
        c.route.asyncComponent && rc(n, c.route.asyncComponent, g, b)
    }
    function h() {
        n.allowPageChange = !0
    }
    if (n.params.masterDetailBreakpoint > 0 && c.route.masterRoute) {
        let m = !0
          , g = !1;
        if (n.currentRoute && n.currentRoute.route && ((n.currentRoute.route.master === !0 || typeof n.currentRoute.route.master == "function" && n.currentRoute.route.master(u, n)) && (n.currentRoute.route === c.route.masterRoute || n.currentRoute.route.path === c.route.masterRoute.path) && (m = !1),
        n.currentRoute.route.masterRoute && (n.currentRoute.route.masterRoute === c.route.masterRoute || n.currentRoute.route.masterRoute.path === c.route.masterRoute.path) && (m = !1,
        g = !0)),
        m || g && t.reloadAll)
            return n.navigate({
                path: c.route.masterRoute.path,
                params: c.params || {}
            }, {
                animate: !1,
                reloadAll: t.reloadAll,
                reloadCurrent: t.reloadCurrent,
                reloadPrevious: t.reloadPrevious,
                browserHistory: !t.initial,
                history: !t.initial,
                once: {
                    pageAfterIn() {
                        n.navigate(e, se({}, t, {
                            animate: !1,
                            reloadAll: !1,
                            reloadCurrent: !1,
                            reloadPrevious: !1,
                            history: !t.initial,
                            browserHistory: !t.initial
                        }))
                    }
                }
            }),
            n
    }
    return G2.call(n, c, n.currentRoute, () => {
        c.route.modules ? u.loadModules(Array.isArray(c.route.modules) ? c.route.modules : [c.route.modules]).then( () => {
            p()
        }
        ).catch( () => {
            h()
        }
        ) : p()
    }
    , () => {
        h()
    }
    , "forward"),
    n
}
function Py(e, t) {
    t === void 0 && (t = {});
    const n = this
      , a = se({
        animate: n.params.animate,
        browserHistory: !0,
        history: !0,
        parentPageEl: null,
        preload: !1,
        on: {}
    }, t);
    let r, o;
    a.route && (!a.preload && a.route !== n.currentRoute && (o = n.previousRoute,
    n.currentRoute = a.route),
    a.preload ? (r = a.route,
    o = n.currentRoute) : (r = n.currentRoute,
    o || (o = n.previousRoute)),
    n.params.browserHistory && a.browserHistory && !a.reloadPrevious && nt[n.params.browserHistoryTabs](n.view.id, {
        url: a.route.url
    }, (n.params.browserHistoryRoot || "") + n.params.browserHistorySeparator + a.route.url),
    a.history && (n.history[Math.max(n.history.length - 1, 0)] = a.route.url,
    n.saveHistory()));
    const i = $(a.parentPageEl || n.currentPageEl);
    let s;
    i.length && i.find(`#${e.id}`).length ? s = i.find(`#${e.id}`).eq(0) : n.view.selector ? s = `${n.view.selector} #${e.id}` : s = `#${e.id}`;
    const l = n.app.tab.show({
        tabEl: s,
        animate: a.animate,
        tabRoute: a.route
    })
      , {$newTabEl: c, $oldTabEl: u, animated: f, onTabsChanged: d} = l;
    if (c && c.parents(".page").length > 0 && a.route) {
        const v = c.parents(".page")[0].f7Page;
        v && a.route && (v.route = a.route)
    }
    function p(v) {
        n.removeThemeElements(c);
        let y = c;
        typeof v != "string" && (y = $(v)),
        y.trigger("tab:init tab:mounted", e),
        n.emit("tabInit tabMounted", c[0], e),
        u && u.length && (f ? d( () => {
            n.emit("routeChanged", n.currentRoute, n.previousRoute, n),
            n.params.unloadTabContent && n.tabRemove(u, c, e)
        }
        ) : (n.emit("routeChanged", n.currentRoute, n.previousRoute, n),
        n.params.unloadTabContent && n.tabRemove(u, c, e)))
    }
    if (c[0].f7RouterTabLoaded)
        return !u || !u.length || (f ? d( () => {
            n.emit("routeChanged", n.currentRoute, n.previousRoute, n)
        }
        ) : n.emit("routeChanged", n.currentRoute, n.previousRoute, n)),
        n;
    function h(v, y) {
        const {url: w, content: C, el: _, component: E, componentUrl: z} = v;
        function T(x) {
            n.allowPageChange = !0,
            x && (typeof x == "string" ? c.html(x) : (c.html(""),
            x.f7Component ? x.f7Component.mount(M => {
                c.append(M)
            }
            ) : c.append(x)),
            c[0].f7RouterTabLoaded = !0,
            p(x))
        }
        function A() {
            return n.allowPageChange = !0,
            n
        }
        if (C)
            T(C);
        else if (_)
            T(_);
        else if (E || z)
            try {
                n.tabComponentLoader({
                    tabEl: c[0],
                    component: E,
                    componentUrl: z,
                    options: y,
                    resolve: T,
                    reject: A
                })
            } catch (x) {
                throw n.allowPageChange = !0,
                x
            }
        else
            w && (n.xhrAbortController && (n.xhrAbortController.abort(),
            n.xhrAbortController = !1),
            n.xhrRequest(w, y).then(x => {
                T(x)
            }
            ).catch( () => {
                n.allowPageChange = !0
            }
            ))
    }
    let m;
    "url content component el componentUrl".split(" ").forEach(v => {
        e[v] && (m = !0,
        h({
            [v]: e[v]
        }, a))
    }
    );
    function g(v, y) {
        h(v, se(a, y))
    }
    function b() {
        n.allowPageChange = !0
    }
    return e.async ? e.async.call(n, {
        router: n,
        to: r,
        from: o,
        resolve: g,
        reject: b,
        app: n.app
    }) : e.asyncComponent ? rc(n, e.asyncComponent, g, b) : m || (n.allowPageChange = !0),
    n
}
function Ly(e, t, n) {
    const a = this;
    let r;
    e[0] && (e[0].f7RouterTabLoaded = !1,
    delete e[0].f7RouterTabLoaded),
    e.children().each(o => {
        o.f7Component && (r = !0,
        $(o).trigger("tab:beforeremove", n),
        o.f7Component.destroy())
    }
    ),
    r || e.trigger("tab:beforeremove", n),
    a.emit("tabBeforeRemove", e[0], t[0], n),
    a.removeTabContent(e[0], n)
}
function Iy(e, t, n, a) {
    n === void 0 && (n = {});
    const r = this
      , o = r.app
      , i = e === "panel"
      , s = i ? "panel" : "modal"
      , l = se({
        animate: r.params.animate,
        browserHistory: !0,
        history: !0,
        on: {},
        once: {}
    }, n)
      , c = se({}, t.route[e])
      , u = t.route
      , f = (b, v) => {
        const {on: y, once: w} = l;
        let C;
        v === "open" && (C = y.modalOpen || w.modalOpen || y.panelOpen || w.panelOpen),
        v === "close" && (C = y.modalClose || w.modalClose || y.panelClose || w.panelClose),
        v === "closed" && (C = y.modalClosed || w.modalClosed || y.panelClosed || w.panelClosed),
        C && C(b)
    }
    ;
    function d() {
        const b = o[e].create(c);
        u.modalInstance = b;
        const v = b.el;
        function y() {
            b.close()
        }
        b.on(`${s}Open`, () => {
            v || (r.removeThemeElements(b.el),
            b.$el.trigger(`${e.toLowerCase()}:init ${e.toLowerCase()}:mounted`, t, b),
            r.emit(`${i ? "" : "modalInit"} ${e}Init ${e}Mounted`, b.el, t, b)),
            r.once("swipeBackMove", y),
            f(b, "open")
        }
        ),
        b.on(`${s}Close`, () => {
            r.off("swipeBackMove", y),
            b.closeByRouter || r.back(),
            f(b, "close")
        }
        ),
        b.on(`${s}Closed`, () => {
            b.$el.trigger(`${e.toLowerCase()}:beforeremove`, t, b),
            b.emit(`${i ? "" : "modalBeforeRemove "}${e}BeforeRemove`, b.el, t, b);
            const w = b.el.f7Component;
            f(b, "closed"),
            w && w.destroy(),
            un( () => {
                (w || c.component || c.asyncComponent) && r.removeModal(b.el),
                b.destroy(),
                delete b.route,
                delete u.modalInstance
            }
            )
        }
        ),
        l.route && (r.params.browserHistory && l.browserHistory && nt.push(r.view.id, {
            url: l.route.url,
            modal: e
        }, (r.params.browserHistoryRoot || "") + r.params.browserHistorySeparator + l.route.url),
        l.route !== r.currentRoute && (b.route = se(l.route, {
            modal: b
        }),
        r.currentRoute = b.route),
        l.history && !l.reloadCurrent && (r.history.push(l.route.url),
        r.saveHistory())),
        v && (r.removeThemeElements(b.el),
        b.$el.trigger(`${e.toLowerCase()}:init ${e.toLowerCase()}:mounted`, t, b),
        r.emit(`${s}Init ${e}Init ${e}Mounted`, b.el, t, b)),
        b.open(l.animate === !1 || l.animate === !0 ? l.animate : void 0)
    }
    function p(b, v) {
        const {url: y, content: w, component: C, componentUrl: _} = b;
        function E(T) {
            T && (typeof T == "string" ? c.content = T : T.f7Component ? T.f7Component.mount(A => {
                c.el = A,
                o.$el.append(A)
            }
            ) : c.el = T,
            d())
        }
        function z() {
            return r.allowPageChange = !0,
            r
        }
        if (w)
            E(w);
        else if (C || _)
            try {
                r.modalComponentLoader({
                    rootEl: o.el,
                    component: C,
                    componentUrl: _,
                    options: v,
                    resolve: E,
                    reject: z
                })
            } catch (T) {
                throw r.allowPageChange = !0,
                T
            }
        else
            y ? (r.xhrAbortController && (r.xhrAbortController.abort(),
            r.xhrAbortController = !1),
            r.xhrRequest(y, v).then(T => {
                c.content = T,
                d()
            }
            ).catch( () => {
                r.allowPageChange = !0
            }
            )) : d()
    }
    let h;
    "url content component el componentUrl template".split(" ").forEach(b => {
        c[b] && !h && (h = !0,
        p({
            [b]: c[b]
        }, l))
    }
    ),
    !h && e === "actions" && d();
    function m(b, v) {
        p(b, se(l, v))
    }
    function g() {
        r.allowPageChange = !0
    }
    return c.async && c.async.call(r, {
        router: r,
        to: l.route,
        from: r.currentRoute,
        resolve: m,
        reject: g,
        direction: a,
        app: o
    }),
    c.asyncComponent && rc(r, c.asyncComponent, m, g),
    r
}
function By(e) {
    se(e, {
        closeByRouter: !0
    }),
    e.close()
}
function Vi(e, t, n) {
    const a = yt()
      , r = Qe()
      , o = $(t)
      , i = e.app
      , s = e.view
      , l = se(!1, {
        animate: e.params.animate,
        browserHistory: !0,
        replaceState: !1
    }, n)
      , c = e.params.masterDetailBreakpoint > 0
      , u = c && l.route && l.route.route && (l.route.route.master === !0 || typeof l.route.route.master == "function" && l.route.route.master(i, e));
    let f, d;
    const p = e.dynamicNavbar
      , h = o
      , m = e.$el.children(".page-current")
      , g = m.length === 0 && l.preload
      , b = c && m.hasClass("page-master");
    h.length && e.removeThemeElements(h);
    let v, y, w;
    if (p && (y = h.children(".navbar"),
    v = e.$navbarsEl,
    y.length === 0 && h[0] && h[0].f7Page && (y = h[0].f7Page.$navbarEl),
    w = v.find(".navbar-current")),
    e.allowPageChange = !1,
    h.length === 0 || m.length === 0 && !l.preload)
        return e.allowPageChange = !0,
        e;
    e.removeThemeElements(h),
    l.route && l.route.route && l.route.route.keepAlive && !l.route.route.keepAliveData && (l.route.route.keepAliveData = {
        pageEl: o[0]
    });
    let C, _;
    if (c) {
        const L = e.$el.children(".page:not(.stacked)").filter(U => U !== h[0]);
        for (let U = 0; U < L.length; U += 1)
            if (!f && L[U].classList.contains("page-master")) {
                f = L[U];
                continue
            }
        C = !u && f && e.history.indexOf(l.route.url) > e.history.indexOf(f.f7Page.route.url),
        !C && !u && f && f.f7Page && l.route.route.masterRoute && (C = l.route.route.masterRoute.path === f.f7Page.route.route.path)
    }
    C && f && f.f7Page && (_ = e.history.indexOf(l.route.url) - e.history.indexOf(f.f7Page.route.url) === 1),
    h.addClass(`page-${g ? "current" : "previous"}${u ? " page-master" : ""}${C ? " page-master-detail" : ""}${_ ? " page-master-detail-root" : ""}`).removeClass("stacked").removeAttr("aria-hidden").trigger("page:unstack").trigger("page:position", {
        position: g ? "current" : "previous"
    }),
    e.emit("pageUnstack", h[0]),
    e.emit("pagePosition", h[0], g ? "current" : "previous"),
    (u || C) && (h.trigger("page:role", {
        role: u ? "master" : "detail",
        root: !!_
    }),
    e.emit("pageRole", h[0], {
        role: u ? "master" : "detail",
        detailRoot: !!_
    })),
    p && y.length > 0 && (y.addClass(`navbar-${g ? "current" : "previous"}${u ? " navbar-master" : ""}${C ? " navbar-master-detail" : ""}${_ ? " navbar-master-detail-root" : ""}`).removeClass("stacked").removeAttr("aria-hidden"),
    y.trigger("navbar:position", {
        position: g ? "current" : "previous"
    }),
    e.emit("navbarPosition", y[0], g ? "current" : "previous"),
    (u || _) && e.emit("navbarRole", y[0], {
        role: u ? "master" : "detail",
        detailRoot: !!_
    }));
    let E;
    if (l.force && (m.prev(".page-previous:not(.stacked)").length > 0 || m.prev(".page-previous").length === 0))
        if (e.history.indexOf(l.route.url) >= 0 ? (E = e.history.length - e.history.indexOf(l.route.url) - 1,
        e.history = e.history.slice(0, e.history.indexOf(l.route.url) + 2),
        e.propsHistory = e.propsHistory.slice(0, e.history.indexOf(l.route.url) + 2),
        s.history = e.history) : e.history[[e.history.length - 2]] ? e.propsHistory[e.propsHistory.length - 2] = l.props || {} : (e.history.unshift(e.url),
        e.propsHistory.unshift(l.props || {})),
        E && e.params.stackPages)
            m.prevAll(".page-previous").each(L => {
                const U = $(L);
                let Y;
                p && (Y = $(i.navbar.getElByPage(U))),
                U[0] !== h[0] && U.index() > h.index() && (e.initialPages.indexOf(U[0]) >= 0 ? (U.addClass("stacked"),
                U.trigger("page:stack"),
                e.emit("pageStack", U[0]),
                p && Y.addClass("stacked")) : (e.pageCallback("beforeRemove", U, Y, "previous", void 0, l),
                U[0] === f && (d = !0),
                e.removePage(U),
                p && Y.length > 0 && e.removeNavbar(Y)))
            }
            );
        else {
            const L = m.prev(".page-previous:not(.stacked)");
            let U;
            p && (U = $(i.navbar.getElByPage(L))),
            e.params.stackPages && e.initialPages.indexOf(L[0]) >= 0 ? (L.addClass("stacked"),
            L.trigger("page:stack"),
            e.emit("pageStack", L[0]),
            U.addClass("stacked")) : L.length > 0 && (e.pageCallback("beforeRemove", L, U, "previous", void 0, l),
            L[0] === f && (d = !0),
            e.removePage(L),
            p && U.length && e.removeNavbar(U))
        }
    const z = h.parents(r).length > 0
      , T = h[0].f7Component;
    function A() {
        g && (!z && T ? T.mount(L => {
            e.$el.append(L)
        }
        ) : e.$el.append(h)),
        h.next(m).length === 0 && (!z && T ? T.mount(L => {
            $(L).insertBefore(m)
        }
        ) : h.insertBefore(m)),
        p && y.length && (y.find(".title-large").length && y.addClass("navbar-large"),
        y.insertBefore(w),
        w.length > 0 ? y.insertBefore(w) : (e.$navbarsEl.parents(r).length || e.$el.prepend(e.$navbarsEl),
        v.append(y))),
        z ? l.route && l.route.route && l.route.route.keepAlive && !h[0].f7PageMounted && (h[0].f7PageMounted = !0,
        e.pageCallback("mounted", h, y, "previous", "current", l, m)) : e.pageCallback("mounted", h, y, "previous", "current", l, m)
    }
    if (l.preload) {
        A(),
        l.route.route.tab && e.tabLoad(l.route.route.tab, se({}, l, {
            history: !1,
            browserHistory: !1,
            preload: !0
        })),
        u && (h.removeClass("page-master-stacked").trigger("page:masterunstack"),
        e.emit("pageMasterUnstack", h[0]),
        p && ($(i.navbar.getElByPage(h)).removeClass("navbar-master-stacked"),
        e.emit("navbarMasterUnstack", i.navbar.getElByPage(h)))),
        e.pageCallback("init", h, y, "previous", "current", l, m),
        g && (e.pageCallback("beforeIn", h, y, "current", void 0, l),
        e.pageCallback("afterIn", h, y, "current", void 0, l));
        const L = h.prevAll(".page-previous:not(.stacked):not(.page-master)");
        return L.length > 0 && L.each(U => {
            const Y = $(U);
            let H;
            p && (H = $(i.navbar.getElByPage(Y))),
            e.params.stackPages && e.initialPages.indexOf(U) >= 0 ? (Y.addClass("stacked"),
            Y.trigger("page:stack"),
            e.emit("pageStack", Y[0]),
            p && H.addClass("stacked")) : (e.pageCallback("beforeRemove", Y, H, "previous", void 0),
            e.removePage(Y),
            p && H.length && e.removeNavbar(H))
        }
        ),
        e.allowPageChange = !0,
        e
    }
    if (!(a.ie || a.edge || a.firefox && !a.ios) && e.params.browserHistory && l.browserHistory)
        if (l.replaceState) {
            const L = e.params.browserHistoryRoot || "";
            nt.replace(s.id, {
                url: l.route.url
            }, L + e.params.browserHistorySeparator + l.route.url)
        } else
            E ? nt.go(-E) : nt.back();
    if (l.replaceState ? (e.history[e.history.length - 1] = l.route.url,
    e.propsHistory[e.propsHistory.length - 1] = l.props || {}) : (e.history.length === 1 && (e.history.unshift(e.url),
    e.propsHistory.unshift(l.props || {})),
    e.history.pop(),
    e.propsHistory.pop()),
    e.saveHistory(),
    e.currentPageEl = h[0],
    p && y.length ? e.currentNavbarEl = y[0] : delete e.currentNavbarEl,
    e.currentRoute = l.route,
    (a.ie || a.edge || a.firefox && !a.ios) && e.params.browserHistory && l.browserHistory)
        if (l.replaceState) {
            const L = e.params.browserHistoryRoot || "";
            nt.replace(s.id, {
                url: l.route.url
            }, L + e.params.browserHistorySeparator + l.route.url)
        } else
            E ? nt.go(-E) : nt.back();
    A(),
    l.route.route.tab && e.tabLoad(l.route.route.tab, se({}, l, {
        history: !1,
        browserHistory: !1
    })),
    c && (b || d) && s.checkMasterDetailBreakpoint(!1),
    e.pageCallback("init", h, y, "previous", "current", l, m),
    e.pageCallback("beforeOut", m, w, "current", "next", l),
    e.pageCallback("beforeIn", h, y, "previous", "current", l);
    function x() {
        e.setPagePosition(h, "current", !1),
        e.setPagePosition(m, "next", !0),
        p && (e.setNavbarPosition(y, "current", !1),
        e.setNavbarPosition(w, "next", !0)),
        e.pageCallback("afterOut", m, w, "current", "next", l),
        e.pageCallback("afterIn", h, y, "previous", "current", l),
        e.params.stackPages && e.initialPages.indexOf(m[0]) >= 0 ? (m.addClass("stacked"),
        m.trigger("page:stack"),
        e.emit("pageStack", m[0]),
        p && w.addClass("stacked")) : (e.pageCallback("beforeRemove", m, w, "next", void 0, l),
        e.removePage(m),
        p && w.length && e.removeNavbar(w)),
        e.allowPageChange = !0,
        e.emit("routeChanged", e.currentRoute, e.previousRoute, e),
        (e.params.preloadPreviousPage || e.params[`${i.theme}SwipeBack`]) && e.history[e.history.length - 2] && !u && e.back(e.history[e.history.length - 2], {
            preload: !0,
            props: e.propsHistory[e.propsHistory.length - 2] || {}
        }),
        e.params.browserHistory && nt.clearRouterQueue()
    }
    function M() {
        e.setPagePosition(m, "current"),
        e.setPagePosition(h, "previous", !1),
        p && (e.setNavbarPosition(w, "current"),
        e.setNavbarPosition(y, "previous", !1))
    }
    if (l.animate && !(b && i.width >= e.params.masterDetailBreakpoint)) {
        let L = e.params.transition;
        m[0] && m[0].f7PageTransition && (L = m[0].f7PageTransition,
        delete m[0].f7PageTransition),
        l.transition && (L = l.transition),
        !L && e.previousRoute && e.previousRoute.route && (L = e.previousRoute.route.transition),
        !L && e.previousRoute && e.previousRoute.route && e.previousRoute.route.options && (L = e.previousRoute.route.options.transition),
        M(),
        e.animate(m, h, w, y, "backward", L, () => {
            x()
        }
        )
    } else
        x();
    return e
}
function Vo(e, t, n, a) {
    if (!e.allowPageChange && !a)
        return e;
    const r = t
      , o = n
      , {url: i, content: s, el: l, pageName: c, component: u, componentUrl: f} = r;
    if (o.route.url && e.url === o.route.url && !(o.reloadCurrent || o.reloadPrevious) && !e.params.allowDuplicateUrls)
        return e.allowPageChange = !0,
        !1;
    !o.route && i && (o.route = e.parseRouteUrl(i));
    function d(h, m) {
        return Vi(e, h, se(o, m))
    }
    function p() {
        return e.allowPageChange = !0,
        e
    }
    if ((i || f || u) && (e.allowPageChange = !1),
    s)
        Vi(e, e.getPageEl(s), o);
    else if (l)
        Vi(e, e.getPageEl(l), o);
    else if (c)
        Vi(e, e.$el.children(`.page[data-name="${c}"]`).eq(0), o);
    else if (u || f)
        try {
            e.pageComponentLoader({
                routerEl: e.el,
                component: u,
                componentUrl: f,
                options: o,
                resolve: d,
                reject: p
            })
        } catch (h) {
            throw e.allowPageChange = !0,
            h
        }
    else
        i && (e.xhrAbortController && (e.xhrAbortController.abort(),
        e.xhrAbortController = !1),
        e.xhrRequest(i, o).then(h => {
            Vi(e, e.getPageEl(h), o)
        }
        ).catch( () => {
            e.allowPageChange = !0
        }
        ));
    return e
}
function Ry() {
    const e = this
      , t = yt();
    if (e.swipeBackActive)
        return e;
    let n, a, r, o;
    typeof (arguments.length <= 0 ? void 0 : arguments[0]) == "object" ? a = (arguments.length <= 0 ? void 0 : arguments[0]) || {} : (n = arguments.length <= 0 ? void 0 : arguments[0],
    a = (arguments.length <= 1 ? void 0 : arguments[1]) || {});
    const {name: i, params: s, query: l} = a;
    if (i)
        return n = e.generateUrl({
            name: i,
            params: s,
            query: l
        }),
        n ? e.back(n, se({}, a, {
            name: null,
            params: null,
            query: null
        })) : e;
    const c = e.app;
    yi(e, "back");
    let u = e.currentRoute.modal, f;
    if (u || "popup popover sheet loginScreen actions customModal panel".split(" ").forEach(v => {
        e.currentRoute.route[v] && (u = !0,
        f = v)
    }
    ),
    u && !a.preload) {
        const v = e.currentRoute.modal || e.currentRoute.route.modalInstance || c[f].get()
          , y = e.history[e.history.length - 2];
        let w;
        if (v && v.$el) {
            const _ = v.$el.prevAll(".modal-in");
            if (_.length && _[0].f7Modal) {
                const E = _[0];
                e.$el.parents(E).length || (w = E.f7Modal.route)
            }
        }
        if (w || (w = e.findMatchingRoute(y)),
        !w && y && (w = {
            url: y,
            path: y.split("?")[0],
            query: $s(y),
            route: {
                path: y.split("?")[0],
                url: y
            }
        }),
        (!n || n.replace(/[# ]/g, "").trim().length === 0) && (!w || !v))
            return e;
        const C = a.force && w && n;
        if (w && v) {
            const _ = t.ie || t.edge || t.firefox && !t.ios
              , E = e.params.browserHistory && a.browserHistory !== !1
              , z = e.currentRoute && e.currentRoute.route && e.currentRoute.route.options && e.currentRoute.route.options.browserHistory === !1;
            E && !_ && !z && nt.back(),
            e.currentRoute = w,
            e.history.pop(),
            e.propsHistory.pop(),
            e.saveHistory(),
            E && _ && !z && nt.back(),
            e.modalRemove(v),
            C && e.navigate(n, {
                reloadCurrent: !0
            })
        } else
            v && (e.modalRemove(v),
            n && e.navigate(n, {
                reloadCurrent: !0
            }));
        return e
    }
    let d = e.$el.children(".page-current").prevAll(".page-previous:not(.page-master)").eq(0), p;
    if (e.params.masterDetailBreakpoint > 0) {
        const v = [];
        e.$el.children(".page").each(w => {
            v.push(w.className)
        }
        );
        const y = e.$el.children(".page-current").prevAll(".page-master").eq(0);
        if (y.length) {
            const w = e.history[e.history.length - 2]
              , C = e.findMatchingRoute(w);
            C && y[0].f7Page && C.route === y[0].f7Page.route.route && (d = y,
            a.preload || (p = c.width >= e.params.masterDetailBreakpoint))
        }
    }
    if (!a.force && d.length && !p) {
        if (e.params.browserHistory && d[0].f7Page && e.history[e.history.length - 2] !== d[0].f7Page.route.url)
            return e.back(e.history[e.history.length - 2], se(a, {
                force: !0,
                props: e.propsHistory[e.propsHistory.length - 2] || {}
            })),
            e;
        const v = d[0].f7Page.route;
        return a.preload && d.hasClass("stacked") ? (Vo(e, {
            el: d
        }, se(a, {
            route: v
        })),
        e) : (G2.call(e, v, e.currentRoute, () => {
            Vo(e, {
                el: d
            }, se(a, {
                route: v
            }))
        }
        , () => {}
        , "backward"),
        e)
    }
    if (n === "#" && (n = void 0),
    n && n[0] !== "/" && n.indexOf("#") !== 0 && (n = ((e.path || "/") + n).replace("//", "/")),
    !n && e.history.length > 1 && (n = e.history[e.history.length - 2],
    r = e.propsHistory[e.propsHistory.length - 2] || {}),
    p && !a.force && e.history[e.history.length - 3])
        return e.back(e.history[e.history.length - 3], se({}, a || {}, {
            force: !0,
            animate: !1,
            props: e.propsHistory[e.propsHistory.length - 3] || {}
        }));
    if (p && !a.force || (o = e.findMatchingRoute(n),
    o || n && (o = {
        url: n,
        path: n.split("?")[0],
        query: $s(n),
        route: {
            path: n.split("?")[0],
            url: n
        }
    }),
    !o))
        return e;
    if (o.route.redirect)
        return K7.call(e, "backward", o, a);
    const h = {};
    o.route.options ? se(h, o.route.options, a, {
        props: r || {}
    }) : se(h, a, {
        props: r || {}
    }),
    h.route = o;
    let m;
    if (h.force && e.params.stackPages && (e.$el.children(".page-previous.stacked").each(v => {
        v.f7Page && v.f7Page.route && v.f7Page.route.url === o.url && (m = !0,
        Vo(e, {
            el: v
        }, h))
    }
    ),
    m))
        return e;
    function g() {
        let v = !1;
        if (o.route.keepAlive && o.route.keepAliveData && (Vo(e, {
            el: o.route.keepAliveData.pageEl
        }, h),
        v = !0),
        "url content component pageName el componentUrl".split(" ").forEach(C => {
            o.route[C] && !v && (v = !0,
            Vo(e, {
                [C]: o.route[C]
            }, h))
        }
        ),
        v)
            return;
        function y(C, _) {
            e.allowPageChange = !1,
            Vo(e, C, se(h, _), !0)
        }
        function w() {
            e.allowPageChange = !0
        }
        o.route.async && (e.allowPageChange = !1,
        o.route.async.call(e, {
            router: e,
            to: o,
            from: e.currentRoute,
            resolve: y,
            reject: w,
            direction: "backward",
            app: c
        })),
        o.route.asyncComponent && rc(e, o.route.asyncComponent, y, w)
    }
    function b() {
        e.allowPageChange = !0
    }
    return h.preload ? g() : G2.call(e, o, e.currentRoute, () => {
        o.route.modules ? c.loadModules(Array.isArray(o.route.modules) ? o.route.modules : [o.route.modules]).then( () => {
            g()
        }
        ).catch( () => {
            b()
        }
        ) : g()
    }
    , () => {
        b()
    }
    , "backward"),
    e
}
function Dy(e) {
    yi(e, "clearPreviousPages");
    const t = e.app
      , n = e.dynamicNavbar;
    e.$el.children(".page").filter(r => e.currentRoute && (e.currentRoute.modal || e.currentRoute.panel) ? !0 : r !== e.currentPageEl).each(r => {
        const o = $(r)
          , i = $(t.navbar.getElByPage(o));
        e.params.stackPages && e.initialPages.indexOf(o[0]) >= 0 ? (o.addClass("stacked"),
        n && i.addClass("stacked")) : (e.pageCallback("beforeRemove", o, i, "previous", void 0, {}),
        e.removePage(o),
        n && i.length && e.removeNavbar(i))
    }
    )
}
function Ny() {
    const e = this;
    yi(e, "clearPreviousHistory");
    const t = e.history[e.history.length - 1];
    Dy(e),
    e.history = [t],
    e.view.history = [t],
    e.saveHistory()
}
class ba extends Bt {
    constructor(t, n) {
        super({}, [typeof n > "u" ? t : n]);
        const a = this;
        a.isAppRouter = typeof n > "u",
        a.isAppRouter ? se(!1, a, {
            app: t,
            params: t.params.view,
            routes: t.routes || [],
            cache: t.cache
        }) : se(!1, a, {
            app: t,
            view: n,
            viewId: n.id,
            id: n.params.routerId,
            params: n.params,
            routes: n.routes,
            history: n.history,
            propsHistory: [],
            scrollHistory: n.scrollHistory,
            cache: t.cache,
            dynamicNavbar: t.theme === "ios" && n.params.iosDynamicNavbar,
            initialPages: [],
            initialNavbars: []
        }),
        a.useModules(),
        a.allowPageChange = !0;
        let r = {}
          , o = {};
        return Object.defineProperty(a, "currentRoute", {
            enumerable: !0,
            configurable: !0,
            set(i) {
                i === void 0 && (i = {}),
                o = se({}, r),
                r = i,
                r && (a.url = r.url,
                a.emit("routeChange", i, o, a))
            },
            get() {
                return r
            }
        }),
        Object.defineProperty(a, "previousRoute", {
            enumerable: !0,
            configurable: !0,
            get() {
                return o
            },
            set(i) {
                o = i
            }
        }),
        a
    }
    mount() {
        const t = this
          , n = t.view
          , a = Qe();
        se(!1, t, {
            tempDom: a.createElement("div"),
            $el: n.$el,
            el: n.el,
            $navbarsEl: n.$navbarsEl,
            navbarsEl: n.navbarsEl
        }),
        t.emit("local::mount routerMount", t)
    }
    animatableNavElements(t, n, a, r, o) {
        const i = this
          , s = i.dynamicNavbar
          , l = i.params.iosAnimateNavbarBackIcon;
        let c, u;
        function f(d, p) {
            const h = d.hasClass("sliding") || p.hasClass("sliding")
              , m = d.hasClass("subnavbar")
              , g = h ? !m : !0
              , b = d.find(".back .icon");
            let v;
            return h && l && d.hasClass("left") && b.length > 0 && b.next("span").length && (d = b.next("span"),
            v = !0),
            {
                $el: d,
                isIconLabel: v,
                leftOffset: d[0].f7NavbarLeftOffset,
                rightOffset: d[0].f7NavbarRightOffset,
                isSliding: h,
                isSubnavbar: m,
                needsOpacityTransition: g
            }
        }
        return s && (c = [],
        u = [],
        t.children(".navbar-inner").children(".left, .right, .title, .subnavbar").each(d => {
            const p = $(d);
            p.hasClass("left") && r && o === "forward" || p.hasClass("title") && a || c.push(f(p, t.children(".navbar-inner")))
        }
        ),
        n.hasClass("navbar-master") && i.params.masterDetailBreakpoint > 0 && i.app.width >= i.params.masterDetailBreakpoint || n.children(".navbar-inner").children(".left, .right, .title, .subnavbar").each(d => {
            const p = $(d);
            p.hasClass("left") && a && !r && o === "forward" || p.hasClass("left") && a && o === "backward" || p.hasClass("title") && r || u.push(f(p, n.children(".navbar-inner")))
        }
        ),
        [u, c].forEach(d => {
            d.forEach(p => {
                const h = p
                  , {isSliding: m, $el: g} = p
                  , b = d === u ? c : u;
                m && g.hasClass("title") && b && b.forEach(v => {
                    if (v.isIconLabel) {
                        const y = v.$el[0];
                        h.leftOffset += y && y.offsetLeft || 0
                    }
                }
                )
            }
            )
        }
        )),
        {
            newNavEls: c,
            oldNavEls: u
        }
    }
    animate(t, n, a, r, o, i, s) {
        const l = this;
        if (l.params.animateCustom) {
            l.params.animateCustom.apply(l, [t, n, a, r, o, s]);
            return
        }
        const c = l.dynamicNavbar
          , u = l.app.theme === "ios";
        if (i) {
            const C = `router-transition-custom router-transition-${i}-${o}`
              , _ = () => {
                l.$el.removeClass(C),
                c && l.$navbarsEl.length && (r && l.$navbarsEl.prepend(r),
                a && l.$navbarsEl.prepend(a)),
                s && s()
            }
            ;
            (o === "forward" ? n : t).animationEnd(_),
            c && (r && n && (l.setNavbarPosition(r, ""),
            r.removeClass("navbar-next navbar-previous navbar-current"),
            n.prepend(r)),
            a && t && (l.setNavbarPosition(a, ""),
            a.removeClass("navbar-next navbar-previous navbar-current"),
            t.prepend(a))),
            l.$el.addClass(C);
            return
        }
        const f = `router-transition-${o} router-transition`;
        let d, p, h, m, g, b, v;
        if (u && c) {
            l.params.masterDetailBreakpoint > 0 && l.app.width >= l.params.masterDetailBreakpoint && (a.hasClass("navbar-master") && r.hasClass("navbar-master-detail") || a.hasClass("navbar-master-detail") && r.hasClass("navbar-master")) || (b = a && a.hasClass("navbar-large"),
            v = r && r.hasClass("navbar-large"),
            h = b && !a.hasClass("navbar-large-collapsed"),
            m = v && !r.hasClass("navbar-large-collapsed"),
            g = h && !m || m && !h);
            const _ = l.animatableNavElements(r, a, m, h, o);
            d = _.newNavEls,
            p = _.oldNavEls
        }
        function y(C) {
            u && c && (C === 1 && (m && (r.addClass("router-navbar-transition-to-large"),
            a.addClass("router-navbar-transition-to-large")),
            h && (r.addClass("router-navbar-transition-from-large"),
            a.addClass("router-navbar-transition-from-large"))),
            d.forEach(_ => {
                const E = _.$el
                  , z = o === "forward" ? _.rightOffset : _.leftOffset;
                _.isSliding && (_.isSubnavbar && v ? E[0].style.setProperty("transform", `translate3d(${z * (1 - C)}px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0)`, "important") : E.transform(`translate3d(${z * (1 - C)}px,0,0)`))
            }
            ),
            p.forEach(_ => {
                const E = _.$el
                  , z = o === "forward" ? _.leftOffset : _.rightOffset;
                _.isSliding && (_.isSubnavbar && b ? E.transform(`translate3d(${z * C}px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0)`) : E.transform(`translate3d(${z * C}px,0,0)`))
            }
            ))
        }
        function w() {
            l.dynamicNavbar && (r && (r.removeClass("router-navbar-transition-to-large router-navbar-transition-from-large"),
            r.addClass("navbar-no-title-large-transition"),
            xn( () => {
                r.removeClass("navbar-no-title-large-transition")
            }
            )),
            a && a.removeClass("router-navbar-transition-to-large router-navbar-transition-from-large"),
            r.hasClass("sliding") || r.children(".navbar-inner.sliding").length ? r.find(".title, .left, .right, .left .icon, .subnavbar").transform("") : r.find(".sliding").transform(""),
            a.hasClass("sliding") || a.children(".navbar-inner.sliding").length ? a.find(".title, .left, .right, .left .icon, .subnavbar").transform("") : a.find(".sliding").transform("")),
            l.$el.removeClass(f),
            s && s()
        }
        (o === "forward" ? n : t).animationEnd( () => {
            w()
        }
        ),
        c ? (y(0),
        xn( () => {
            l.$el.addClass(f),
            g && (l.el._clientLeft = l.el.clientLeft),
            y(1)
        }
        )) : l.$el.addClass(f)
    }
    removeModal(t) {
        this.removeEl(t)
    }
    removeTabContent(t) {
        $(t).html("")
    }
    removeNavbar(t) {
        this.removeEl(t)
    }
    removePage(t) {
        const n = $(t)
          , a = n && n[0] && n[0].f7Page
          , r = this;
        if (a && a.route && a.route.route && a.route.route.keepAlive) {
            n.remove();
            return
        }
        r.removeEl(t)
    }
    removeEl(t) {
        if (!t)
            return;
        const n = this
          , a = $(t);
        a.length !== 0 && (a.find(".tab").each(r => {
            $(r).children().each(o => {
                o.f7Component && ($(o).trigger("tab:beforeremove"),
                o.f7Component.destroy())
            }
            )
        }
        ),
        a[0].f7Component && a[0].f7Component.destroy && a[0].f7Component.destroy(),
        n.params.removeElements && (n.params.removeElementsWithTimeout ? setTimeout( () => {
            a.remove()
        }
        , n.params.removeElementsTimeout) : a.remove()))
    }
    getPageEl(t) {
        const n = this;
        if (typeof t == "string")
            n.tempDom.innerHTML = t;
        else {
            if ($(t).hasClass("page"))
                return t;
            n.tempDom.innerHTML = "",
            $(n.tempDom).append(t)
        }
        return n.findElement(".page", n.tempDom)
    }
    findElement(t, n, a) {
        const r = this
          , o = r.view
          , i = r.app
          , s = ".popup, .dialog, .popover, .actions-modal, .sheet-modal, .login-screen, .page"
          , l = $(n);
        let c = t;
        a && (c += ":not(.stacked)");
        let u = l.find(c).filter(f => $(f).parents(s).length === 0);
        if (u.length > 1 && (typeof o.selector == "string" && (u = l.find(`${o.selector} ${c}`)),
        u.length > 1 && (u = l.find(`.${i.params.viewMainClass} ${c}`))),
        u.length === 1 || (a || (u = r.findElement(c, l, !0)),
        u && u.length === 1))
            return u;
        if (u && u.length > 1)
            return $(u[0])
    }
    flattenRoutes(t) {
        t === void 0 && (t = this.routes);
        const n = this;
        let a = [];
        return t.forEach(r => {
            let o = !1;
            if ("tabs"in r && r.tabs) {
                const i = r.tabs.map(s => {
                    const l = se({}, r, {
                        path: `${r.path}/${s.path}`.replace("///", "/").replace("//", "/"),
                        parentPath: r.path,
                        tab: s
                    });
                    return delete l.tabs,
                    delete l.routes,
                    l
                }
                );
                o = !0,
                a = a.concat(n.flattenRoutes(i))
            }
            if ("detailRoutes"in r) {
                const i = r.detailRoutes.map(s => {
                    const l = se({}, s);
                    return l.masterRoute = r,
                    l.masterRoutePath = r.path,
                    l
                }
                );
                a = a.concat(r, n.flattenRoutes(i))
            }
            if ("routes"in r) {
                const i = r.routes.map(s => {
                    const l = se({}, s);
                    return l.path = `${r.path}/${l.path}`.replace("///", "/").replace("//", "/"),
                    l
                }
                );
                o ? a = a.concat(n.flattenRoutes(i)) : a = a.concat(r, n.flattenRoutes(i))
            }
            !("routes"in r) && !("tabs"in r && r.tabs) && !("detailRoutes"in r) && a.push(r)
        }
        ),
        a
    }
    parseRouteUrl(t) {
        if (!t)
            return {};
        const n = $s(t)
          , a = t.split("#")[1]
          , r = {}
          , o = t.split("#")[0].split("?")[0];
        return {
            query: n,
            hash: a,
            params: r,
            url: t,
            path: o
        }
    }
    generateUrl(t) {
        if (t === void 0 && (t = {}),
        typeof t == "string")
            return t;
        const {name: n, path: a, params: r, query: o} = t;
        if (!n && !a)
            throw new Error('Framework7: "name" or "path" parameter is required');
        const i = this
          , s = n ? i.findRouteByKey("name", n) : i.findRouteByKey("path", a);
        if (!s)
            throw n ? new Error(`Framework7: route with name "${n}" not found`) : new Error(`Framework7: route with path "${a}" not found`);
        const l = i.constructRouteUrl(s, {
            params: r,
            query: o
        });
        if (!l)
            throw new Error(`Framework7: can't construct URL for route with name "${n}"`);
        return l
    }
    constructRouteUrl(t, n) {
        let {params: a, query: r} = n === void 0 ? {} : n;
        const {path: o} = t
          , i = Sy(o);
        let s;
        try {
            s = i(a || {})
        } catch (l) {
            throw new Error(`Framework7: error constructing route URL from passed params:
Route: ${o}
${l.toString()}`)
        }
        return r && (typeof r == "string" ? s += `?${r}` : Object.keys(r).length && (s += `?${er(r)}`)),
        s
    }
    findTabRouteUrl(t) {
        const n = this
          , a = $(t)
          , r = n.currentRoute.route.parentPath
          , o = a.attr("id")
          , i = n.flattenRoutes(n.routes);
        let s;
        return i.forEach(l => {
            l.parentPath === r && l.tab && l.tab.id === o && (n.currentRoute.params && Object.keys(n.currentRoute.params).length > 0 ? s = n.constructRouteUrl(l, {
                params: n.currentRoute.params,
                query: n.currentRoute.query
            }) : s = l.path)
        }
        ),
        s
    }
    findRouteByKey(t, n) {
        const a = this
          , r = a.routes
          , o = a.flattenRoutes(r);
        let i;
        return o.forEach(s => {
            i || s[t] === n && (i = s)
        }
        ),
        i
    }
    findMatchingRoute(t) {
        if (!t)
            return;
        const n = this
          , a = n.routes
          , r = n.flattenRoutes(a)
          , {path: o, query: i, hash: s, params: l} = n.parseRouteUrl(t);
        let c;
        return r.forEach(u => {
            if (c)
                return;
            const f = []
              , d = [u.path];
            u.alias && (typeof u.alias == "string" ? d.push(u.alias) : Array.isArray(u.alias) && u.alias.forEach(h => {
                d.push(h)
            }
            ));
            let p;
            if (d.forEach(h => {
                p || (p = X7(h, f).exec(o))
            }
            ),
            p) {
                f.forEach( (m, g) => {
                    if (typeof m.name == "number")
                        return;
                    const b = p[g + 1];
                    typeof b > "u" || b === null ? l[m.name] = b : l[m.name] = decodeURIComponent(b)
                }
                );
                let h;
                u.parentPath && (h = o.split("/").slice(0, u.parentPath.split("/").length - 1).join("/")),
                c = {
                    query: i,
                    hash: s,
                    params: l,
                    url: t,
                    path: o,
                    parentPath: h,
                    route: u,
                    name: u.name
                }
            }
        }
        ),
        c
    }
    replaceRequestUrlParams(t, n) {
        t === void 0 && (t = ""),
        n === void 0 && (n = {});
        let a = t;
        return typeof a == "string" && a.indexOf("{{") >= 0 && n && n.route && n.route.params && Object.keys(n.route.params).length && Object.keys(n.route.params).forEach(r => {
            const o = new RegExp(`{{${r}}}`,"g");
            a = a.replace(o, n.route.params[r] || "")
        }
        ),
        a
    }
    removeFromXhrCache(t) {
        const a = this.cache.xhr;
        let r = !1;
        for (let o = 0; o < a.length; o += 1)
            a[o].url === t && (r = o);
        r !== !1 && a.splice(r, 1)
    }
    xhrRequest(t, n) {
        const a = this
          , r = a.params
          , {ignoreCache: o} = n;
        let i = t
          , s = i.indexOf("?") >= 0;
        return r.passRouteQueryToRequest && n && n.route && n.route.query && Object.keys(n.route.query).length && (i += `${s ? "&" : "?"}${er(n.route.query)}`,
        s = !0),
        r.passRouteParamsToRequest && n && n.route && n.route.params && Object.keys(n.route.params).length && (i += `${s ? "&" : "?"}${er(n.route.params)}`,
        s = !0),
        i.indexOf("{{") >= 0 && (i = a.replaceRequestUrlParams(i, n)),
        r.xhrCacheIgnoreGetParameters && i.indexOf("?") >= 0 && (i = i.split("?")[0]),
        new Promise( (l, c) => {
            if (r.xhrCache && !o && i.indexOf("nocache") < 0 && r.xhrCacheIgnore.indexOf(i) < 0)
                for (let u = 0; u < a.cache.xhr.length; u += 1) {
                    const f = a.cache.xhr[u];
                    if (f.url === i && zn() - f.time < r.xhrCacheDuration) {
                        l(f.content);
                        return
                    }
                }
            a.xhrAbortController = a.app.request.abortController(),
            a.app.request({
                abortController: a.xhrAbortController,
                url: i,
                method: "GET",
                beforeSend(u) {
                    a.emit("routerAjaxStart", u, n)
                },
                complete(u, f) {
                    a.emit("routerAjaxComplete", u),
                    f !== "error" && f !== "timeout" && u.status >= 200 && u.status < 300 || u.status === 0 ? (r.xhrCache && u.responseText !== "" && (a.removeFromXhrCache(i),
                    a.cache.xhr.push({
                        url: i,
                        time: zn(),
                        content: u.responseText
                    })),
                    a.emit("routerAjaxSuccess", u, n),
                    l(u.responseText)) : (a.emit("routerAjaxError", u, n),
                    c(u))
                },
                error(u) {
                    a.emit("routerAjaxError", u, n),
                    c(u)
                }
            })
        }
        )
    }
    setNavbarPosition(t, n, a) {
        const r = this;
        t.removeClass("navbar-previous navbar-current navbar-next"),
        n && t.addClass(`navbar-${n}`),
        a === !1 ? t.removeAttr("aria-hidden") : a === !0 && t.attr("aria-hidden", "true"),
        t.trigger("navbar:position", {
            position: n
        }),
        r.emit("navbarPosition", t[0], n)
    }
    setPagePosition(t, n, a) {
        const r = this;
        t.removeClass("page-previous page-current page-next"),
        t.addClass(`page-${n}`),
        a === !1 ? t.removeAttr("aria-hidden") : a === !0 && t.attr("aria-hidden", "true"),
        t.trigger("page:position", {
            position: n
        }),
        r.emit("pagePosition", t[0], n)
    }
    removeThemeElements(t) {
        const a = this.app.theme;
        let r;
        a === "ios" ? r = ".md-only, .aurora-only, .if-md, .if-aurora, .if-not-ios, .not-ios" : a === "md" ? r = ".ios-only, .aurora-only, .if-ios, .if-aurora, .if-not-md, .not-md" : a === "aurora" && (r = ".ios-only, .md-only, .if-ios, .if-md, .if-not-aurora, .not-aurora"),
        $(t).find(r).remove()
    }
    getPageData(t, n, a, r, o, i) {
        o === void 0 && (o = {});
        const s = this
          , l = $(t).eq(0)
          , c = $(n).eq(0)
          , u = l[0].f7Page || {};
        let f, d;
        if ((a === "next" && r === "current" || a === "current" && r === "previous") && (f = "forward"),
        (a === "current" && r === "next" || a === "previous" && r === "current") && (f = "backward"),
        u && !u.fromPage) {
            const h = $(i);
            h.length && (d = h[0].f7Page)
        }
        d = u.pageFrom || d,
        d && d.pageFrom && (d.pageFrom = null);
        const p = {
            app: s.app,
            view: s.view,
            router: s,
            $el: l,
            el: l[0],
            $pageEl: l,
            pageEl: l[0],
            $navbarEl: c,
            navbarEl: c[0],
            name: l.attr("data-name"),
            position: a,
            from: a,
            to: r,
            direction: f,
            route: u.route ? u.route : o,
            pageFrom: d
        };
        return l[0].f7Page = p,
        p
    }
    pageCallback(t, n, a, r, o, i, s) {
        if (i === void 0 && (i = {}),
        !n)
            return;
        const l = this
          , c = $(n);
        if (!c.length)
            return;
        const u = $(a)
          , {route: f} = i
          , d = l.params.restoreScrollTopOnBack && !(l.params.masterDetailBreakpoint > 0 && c.hasClass("page-master") && l.app.width >= l.params.masterDetailBreakpoint)
          , p = c[0].f7Page && c[0].f7Page.route && c[0].f7Page.route.route && c[0].f7Page.route.route.keepAlive;
        t === "beforeRemove" && p && (t = "beforeUnmount");
        const h = `page${t[0].toUpperCase() + t.slice(1, t.length)}`
          , m = `page:${t.toLowerCase()}`;
        let g = {};
        t === "beforeRemove" && c[0].f7Page ? g = se(c[0].f7Page, {
            from: r,
            to: o,
            position: r
        }) : g = l.getPageData(c[0], u[0], r, o, f, s),
        g.swipeBack = !!i.swipeBack;
        const {on: b={}, once: v={}} = i.route ? i.route.route : {};
        i.on && se(b, i.on),
        i.once && se(v, i.once);
        function y() {
            c[0].f7RouteEventsAttached || (c[0].f7RouteEventsAttached = !0,
            b && Object.keys(b).length > 0 && (c[0].f7RouteEventsOn = b,
            Object.keys(b).forEach(C => {
                b[C] = b[C].bind(l),
                c.on(Xi(C), b[C])
            }
            )),
            v && Object.keys(v).length > 0 && (c[0].f7RouteEventsOnce = v,
            Object.keys(v).forEach(C => {
                v[C] = v[C].bind(l),
                c.once(Xi(C), v[C])
            }
            )))
        }
        function w() {
            c[0].f7RouteEventsAttached && (c[0].f7RouteEventsOn && Object.keys(c[0].f7RouteEventsOn).forEach(C => {
                c.off(Xi(C), c[0].f7RouteEventsOn[C])
            }
            ),
            c[0].f7RouteEventsOnce && Object.keys(c[0].f7RouteEventsOnce).forEach(C => {
                c.off(Xi(C), c[0].f7RouteEventsOnce[C])
            }
            ),
            c[0].f7RouteEventsAttached = null,
            c[0].f7RouteEventsOn = null,
            c[0].f7RouteEventsOnce = null,
            delete c[0].f7RouteEventsAttached,
            delete c[0].f7RouteEventsOn,
            delete c[0].f7RouteEventsOnce)
        }
        if (t === "mounted" && y(),
        t === "init") {
            if (d && (r === "previous" || !r) && o === "current" && l.scrollHistory[g.route.url] && !c.hasClass("no-restore-scroll")) {
                let C = c.find(".page-content");
                C.length > 0 && (C = C.filter(_ => $(_).parents(".tab:not(.tab-active)").length === 0 && !$(_).is(".tab:not(.tab-active)"))),
                C.scrollTop(l.scrollHistory[g.route.url])
            }
            if (y(),
            c[0].f7PageInitialized) {
                c.trigger("page:reinit", g),
                l.emit("pageReinit", g);
                return
            }
            c[0].f7PageInitialized = !0
        }
        if (d && t === "beforeOut" && r === "current" && o === "previous") {
            let C = c.find(".page-content");
            C.length > 0 && (C = C.filter(_ => $(_).parents(".tab:not(.tab-active)").length === 0 && !$(_).is(".tab:not(.tab-active)"))),
            l.scrollHistory[g.route.url] = C.scrollTop()
        }
        d && t === "beforeOut" && r === "current" && o === "next" && delete l.scrollHistory[g.route.url],
        c.trigger(m, g),
        l.emit(h, g),
        (t === "beforeRemove" || t === "beforeUnmount") && (w(),
        p || (c[0].f7Page && c[0].f7Page.navbarEl && delete c[0].f7Page.navbarEl.f7Page,
        c[0].f7Page = null))
    }
    saveHistory() {
        const t = this
          , n = He();
        t.view.history = t.history,
        t.params.browserHistory && t.params.browserHistoryStoreHistory && n.localStorage && (n.localStorage[`f7router-${t.view.id}-history`] = JSON.stringify(t.history))
    }
    restoreHistory() {
        const t = this
          , n = He();
        t.params.browserHistory && t.params.browserHistoryStoreHistory && n.localStorage && n.localStorage[`f7router-${t.view.id}-history`] && (t.history = JSON.parse(n.localStorage[`f7router-${t.view.id}-history`]),
        t.view.history = t.history)
    }
    clearHistory() {
        const t = this;
        t.history = [],
        t.view && (t.view.history = []),
        t.saveHistory()
    }
    updateCurrentUrl(t) {
        const n = this;
        yi(n, "updateCurrentUrl"),
        n.history.length ? n.history[n.history.length - 1] = t : n.history.push(t);
        const {query: a, hash: r, params: o, url: i, path: s} = n.parseRouteUrl(t);
        if (n.currentRoute && se(n.currentRoute, {
            query: a,
            hash: r,
            params: o,
            url: i,
            path: s
        }),
        n.params.browserHistory) {
            const l = n.params.browserHistoryRoot || "";
            nt.replace(n.view.id, {
                url: t
            }, l + n.params.browserHistorySeparator + t)
        }
        n.saveHistory(),
        n.emit("routeUrlUpdate", n.currentRoute, n)
    }
    getInitialUrl() {
        const t = this;
        if (t.initialUrl)
            return {
                initialUrl: t.initialUrl,
                historyRestored: t.historyRestored
            };
        const {app: n, view: a} = t
          , r = Qe()
          , o = He()
          , i = n.params.url && typeof n.params.url == "string" && typeof URL < "u" ? new URL(n.params.url) : r.location;
        let s = t.params.url, l = i.href.split(i.origin)[1], c;
        const {browserHistory: u, browserHistoryOnLoad: f, browserHistorySeparator: d} = t.params;
        let {browserHistoryRoot: p} = t.params;
        return (o.cordova || o.Capacitor && o.Capacitor.isNative) && u && !d && !p && i.pathname.indexOf("index.html") && (console.warn("Framework7: wrong or not complete browserHistory configuration, trying to guess browserHistoryRoot"),
        p = i.pathname.split("index.html")[0]),
        !u || !f ? (s || (s = l),
        i.search && s.indexOf("?") < 0 && (s += i.search),
        i.hash && s.indexOf("#") < 0 && (s += i.hash)) : (p && l.indexOf(p) >= 0 && (l = l.substring(l.indexOf(p) + p.length),
        l === "" && (l = "/")),
        d.length > 0 && l.indexOf(d) >= 0 ? s = l.substring(l.indexOf(d) + d.length) : s = l,
        t.restoreHistory(),
        t.history.indexOf(s) >= 0 ? t.history = t.history.slice(0, t.history.indexOf(s) + 1) : t.params.url === s ? t.history = [s] : nt.state && nt.state[a.id] && nt.state[a.id].url === t.history[t.history.length - 1] ? s = t.history[t.history.length - 1] : t.history = [l.split(d)[0] || "/", s],
        t.history.length > 1 ? c = !0 : t.history = [],
        t.saveHistory()),
        t.initialUrl = s,
        t.historyRestored = c,
        {
            initialUrl: s,
            historyRestored: c
        }
    }
    init() {
        const t = this
          , {app: n, view: a} = t
          , r = Qe();
        t.mount();
        const {initialUrl: o, historyRestored: i} = t.getInitialUrl();
        (a && t.params.iosSwipeBack && n.theme === "ios" || a && t.params.mdSwipeBack && n.theme === "md" || a && t.params.auroraSwipeBack && n.theme === "aurora") && zy(t);
        const {browserHistory: s, browserHistoryOnLoad: l, browserHistoryAnimateOnLoad: c, browserHistoryInitialMatch: u} = t.params;
        let f;
        if (t.history.length > 1) {
            const d = u ? o : t.history[0];
            f = t.findMatchingRoute(d),
            f || (f = se(t.parseRouteUrl(d), {
                route: {
                    url: d,
                    path: d.split("?")[0]
                }
            }))
        } else
            f = t.findMatchingRoute(o),
            f || (f = se(t.parseRouteUrl(o), {
                route: {
                    url: o,
                    path: o.split("?")[0]
                }
            }));
        if (t.params.stackPages && t.$el.children(".page").each(d => {
            const p = $(d);
            t.initialPages.push(p[0]),
            t.dynamicNavbar && p.children(".navbar").length > 0 && t.initialNavbars.push(p.children(".navbar")[0])
        }
        ),
        t.$el.children(".page:not(.stacked)").length === 0 && o && t.params.loadInitialPage)
            t.navigate(o, {
                initial: !0,
                reloadCurrent: !0,
                browserHistory: !1,
                animate: !1,
                once: {
                    modalOpen() {
                        if (!i)
                            return;
                        (t.params.preloadPreviousPage || t.params[`${n.theme}SwipeBack`]) && t.history.length > 1 && t.back({
                            preload: !0
                        })
                    },
                    pageAfterIn() {
                        if (!i)
                            return;
                        (t.params.preloadPreviousPage || t.params[`${n.theme}SwipeBack`]) && t.history.length > 1 && t.back({
                            preload: !0
                        })
                    }
                }
            });
        else if (t.$el.children(".page:not(.stacked)").length) {
            let d;
            t.currentRoute = f,
            t.$el.children(".page:not(.stacked)").each(p => {
                const h = $(p);
                let m;
                t.setPagePosition(h, "current"),
                t.dynamicNavbar && (m = h.children(".navbar"),
                m.length > 0 ? (t.$navbarsEl.parents(r).length || t.$el.prepend(t.$navbarsEl),
                t.setNavbarPosition(m, "current"),
                t.$navbarsEl.append(m),
                m.children(".title-large").length && m.addClass("navbar-large"),
                h.children(".navbar").remove()) : (t.$navbarsEl.addClass("navbar-hidden"),
                m.children(".title-large").length && t.$navbarsEl.addClass("navbar-hidden navbar-large-hidden"))),
                t.currentRoute && t.currentRoute.route && (t.currentRoute.route.master === !0 || typeof t.currentRoute.route.master == "function" && t.currentRoute.route.master(n, t)) && t.params.masterDetailBreakpoint > 0 && (h.addClass("page-master"),
                h.trigger("page:role", {
                    role: "master"
                }),
                m && m.length && m.addClass("navbar-master"),
                a.checkMasterDetailBreakpoint());
                const g = {
                    route: t.currentRoute
                };
                t.currentRoute && t.currentRoute.route && t.currentRoute.route.options && se(g, t.currentRoute.route.options),
                t.currentPageEl = h[0],
                t.dynamicNavbar && m.length && (t.currentNavbarEl = m[0]),
                t.removeThemeElements(h),
                t.dynamicNavbar && m.length && t.removeThemeElements(m),
                g.route.route.tab && (d = !0,
                t.tabLoad(g.route.route.tab, se({}, g))),
                t.pageCallback("init", h, m, "current", void 0, g),
                t.pageCallback("beforeIn", h, m, "current", void 0, g),
                t.pageCallback("afterIn", h, m, "current", void 0, g)
            }
            ),
            i && (u ? (t.params.preloadPreviousPage || t.params[`${n.theme}SwipeBack`]) && t.history.length > 1 && t.back({
                preload: !0
            }) : t.navigate(o, {
                initial: !0,
                browserHistory: !1,
                history: !1,
                animate: c,
                once: {
                    pageAfterIn() {
                        (t.params.preloadPreviousPage || t.params[`${n.theme}SwipeBack`]) && t.history.length > 2 && t.back({
                            preload: !0
                        })
                    }
                }
            })),
            !i && !d && (t.history.push(o),
            t.saveHistory())
        }
        o && s && l && (!nt.state || !nt.state[a.id]) && nt.initViewState(a.id, {
            url: o
        }),
        t.emit("local::init routerInit", t)
    }
    destroy() {
        let t = this;
        t.emit("local::destroy routerDestroy", t),
        Object.keys(t).forEach(n => {
            t[n] = null,
            delete t[n]
        }
        ),
        t = null
    }
}
ba.prototype.navigate = Oy;
ba.prototype.refreshPage = Ay;
ba.prototype.tabLoad = Py;
ba.prototype.tabRemove = Ly;
ba.prototype.modalLoad = Iy;
ba.prototype.modalRemove = By;
ba.prototype.back = Ry;
ba.prototype.clearPreviousHistory = Ny;
const Z7 = {
    name: "router",
    static: {
        Router: ba
    },
    instance: {
        cache: {
            xhr: [],
            templates: [],
            components: []
        }
    },
    create() {
        const e = this;
        e.app ? e.params.router && (e.router = new ba(e.app,e)) : e.router = new ba(e)
    }
};
function Hy(e) {
    const t = e.app
      , n = Mt();
    if (e.resizableInitialized)
        return;
    se(e, {
        resizable: !0,
        resizableWidth: null,
        resizableInitialized: !0
    });
    const a = $("html")
      , {$el: r} = e;
    if (!r)
        return;
    let o, i, s;
    const l = {};
    let c, u, f, d;
    function p(w) {
        if (!w)
            return null;
        if (w.indexOf("%") >= 0 || w.indexOf("vw") >= 0)
            return parseInt(w, 10) / 100 * t.width;
        const C = parseInt(w, 10);
        return Number.isNaN(C) ? null : C
    }
    function h() {
        return e.resizable && r.hasClass("view-resizable") && r.hasClass("view-master-detail")
    }
    function m(w) {
        if (!h())
            return;
        l.x = w.type === "touchstart" ? w.targetTouches[0].pageX : w.pageX,
        l.y = w.type === "touchstart" ? w.targetTouches[0].pageY : w.pageY,
        s = !1,
        i = !0;
        const C = r.children(".page-master");
        f = p(C.css("min-width")),
        d = p(C.css("max-width"))
    }
    function g(w) {
        if (!i)
            return;
        w.f7PreventSwipePanel = !0;
        const C = w.type === "touchmove" ? w.targetTouches[0].pageX : w.pageX;
        s || (u = o[0].offsetLeft + o[0].offsetWidth,
        r.addClass("view-resizing"),
        a.css("cursor", "col-resize")),
        s = !0,
        w.preventDefault(),
        c = C - l.x;
        let _ = u + c;
        f && !Number.isNaN(f) && (_ = Math.max(_, f)),
        d && !Number.isNaN(d) && (_ = Math.min(_, d)),
        _ = Math.min(Math.max(_, 0), t.width),
        e.resizableWidth = _,
        a[0].style.setProperty("--f7-page-master-width", `${_}px`),
        r.trigger("view:resize", _),
        e.emit("local::resize viewResize", e, _)
    }
    function b() {
        if ($("html").css("cursor", ""),
        !i || !s) {
            i = !1,
            s = !1;
            return
        }
        i = !1,
        s = !1,
        a[0].style.setProperty("--f7-page-master-width", `${e.resizableWidth}px`),
        r.removeClass("view-resizing")
    }
    function v() {
        e.resizableWidth && (f = p(o.css("min-width")),
        d = p(o.css("max-width")),
        f && !Number.isNaN(f) && e.resizableWidth < f && (e.resizableWidth = Math.max(e.resizableWidth, f)),
        d && !Number.isNaN(d) && e.resizableWidth > d && (e.resizableWidth = Math.min(e.resizableWidth, d)),
        e.resizableWidth = Math.min(Math.max(e.resizableWidth, 0), t.width),
        a[0].style.setProperty("--f7-page-master-width", `${e.resizableWidth}px`))
    }
    o = e.$el.children(".view-resize-handler"),
    o.length || (e.$el.append('<div class="view-resize-handler"></div>'),
    o = e.$el.children(".view-resize-handler")),
    e.$resizeHandlerEl = o,
    r.addClass("view-resizable");
    const y = n.passiveListener ? {
        passive: !0
    } : !1;
    e.$el.on(t.touchEvents.start, ".view-resize-handler", m, y),
    t.on("touchmove:active", g),
    t.on("touchend:passive", b),
    t.on("resize", v),
    e.on("beforeOpen", v),
    e.once("viewDestroy", () => {
        r.removeClass("view-resizable"),
        e.$resizeHandlerEl.remove(),
        e.$el.off(t.touchEvents.start, ".view-resize-handler", m, y),
        t.off("touchmove:active", g),
        t.off("touchend:passive", b),
        t.off("resize", v),
        e.off("beforeOpen", v)
    }
    )
}
let k1 = class extends Bt {
    constructor(t, n, a) {
        a === void 0 && (a = {}),
        super(a, [t]);
        const r = this
          , o = r.params.routerId
          , i = {
            routes: [],
            routesAdd: []
        };
        if (!o && !$(n).length) {
            let c = "Framework7: can't create a View instance because ";
            throw c += typeof n == "string" ? `the selector "${n}" didn't match any element` : "el must be an HTMLElement or Dom7 object",
            new Error(c)
        }
        r.params = se({
            el: n
        }, i, t.params.view, a),
        r.params.routes.length > 0 ? r.routes = r.params.routes : r.routes = [].concat(t.routes, r.params.routesAdd),
        se(!1, r, {
            app: t,
            name: r.params.name,
            main: r.params.main,
            history: [],
            scrollHistory: {}
        }),
        r.useModules(),
        t.views.push(r),
        r.main && (t.views.main = r),
        r.name && (t.views[r.name] = r),
        r.index = t.views.indexOf(r);
        let s;
        return r.name ? s = `view_${r.name}` : r.main ? s = "view_main" : s = `view_${r.index}`,
        r.id = s,
        r.params.init && (t.initialized ? r.init() : t.on("init", () => {
            r.init()
        }
        )),
        r
    }
    destroy() {
        let t = this;
        const n = t.app;
        t.$el.trigger("view:beforedestroy"),
        t.emit("local::beforeDestroy viewBeforeDestroy", t),
        n.off("resize", t.checkMasterDetailBreakpoint),
        t.main ? (n.views.main = null,
        delete n.views.main) : t.name && (n.views[t.name] = null,
        delete n.views[t.name]),
        t.$el[0].f7View = null,
        delete t.$el[0].f7View,
        n.views.splice(n.views.indexOf(t), 1),
        t.params.router && t.router && t.router.destroy(),
        t.emit("local::destroy viewDestroy", t),
        Object.keys(t).forEach(a => {
            t[a] = null,
            delete t[a]
        }
        ),
        t = null
    }
    checkMasterDetailBreakpoint(t) {
        const n = this
          , a = n.app
          , r = n.$el.hasClass("view-master-detail")
          , o = a.width >= n.params.masterDetailBreakpoint && n.$el.children(".page-master").length;
        typeof t > "u" && o || t === !0 ? (n.$el.addClass("view-master-detail"),
        r || (n.emit("local::masterDetailBreakpoint viewMasterDetailBreakpoint", n),
        n.$el.trigger("view:masterDetailBreakpoint"))) : (n.$el.removeClass("view-master-detail"),
        r && (n.emit("local::masterDetailBreakpoint viewMasterDetailBreakpoint", n),
        n.$el.trigger("view:masterDetailBreakpoint")))
    }
    initMasterDetail() {
        const t = this
          , n = t.app;
        t.checkMasterDetailBreakpoint = t.checkMasterDetailBreakpoint.bind(t),
        t.checkMasterDetailBreakpoint(),
        t.params.masterDetailResizable && Hy(t),
        n.on("resize", t.checkMasterDetailBreakpoint)
    }
    mount(t) {
        const n = this
          , a = n.app
          , r = n.params.el || t
          , o = $(r);
        let i;
        typeof r == "string" ? i = r : i = (o.attr("id") ? `#${o.attr("id")}` : "") + (o.attr("class") ? `.${o.attr("class").replace(/ /g, ".").replace(".active", "")}` : "");
        let s;
        a.theme === "ios" && n.params.iosDynamicNavbar && (s = o.children(".navbars").eq(0),
        s.length === 0 && (s = $('<div class="navbars"></div>'))),
        se(n, {
            $el: o,
            el: o[0],
            main: n.main || o.hasClass("view-main"),
            $navbarsEl: s,
            navbarsEl: s ? s[0] : void 0,
            selector: i
        }),
        n.main && (a.views.main = n),
        o && o[0] && (o[0].f7View = n),
        n.emit("local::mount viewMount", n)
    }
    init(t) {
        const n = this;
        n.mount(t),
        n.params.router && (n.params.masterDetailBreakpoint > 0 && n.initMasterDetail(),
        n.params.initRouterOnTabShow && n.$el.hasClass("tab") && !n.$el.hasClass("tab-active") ? n.$el.once("tab:show", () => {
            n.router.init()
        }
        ) : n.router.init(),
        n.$el.trigger("view:init"),
        n.emit("local::init viewInit", n))
    }
}
;
k1.use(Z7);
function Vy(e) {
    function t(n) {
        const a = He()
          , r = $(n.target)
          , o = r.closest("a")
          , i = o.length > 0
          , s = i && o.attr("href");
        if (i && (o.is(e.params.clicks.externalLinks) || s && s.indexOf("javascript:") >= 0)) {
            const u = o.attr("target");
            s && a.cordova && a.cordova.InAppBrowser && (u === "_system" || u === "_blank") ? (n.preventDefault(),
            a.cordova.InAppBrowser.open(s, u)) : s && a.Capacitor && a.Capacitor.Plugins && a.Capacitor.Plugins.Browser && (u === "_system" || u === "_blank") && (n.preventDefault(),
            a.Capacitor.Plugins.Browser.open({
                url: s
            }));
            return
        }
        Object.keys(e.modules).forEach(u => {
            const f = e.modules[u].clicks;
            f && (n.preventF7Router || Object.keys(f).forEach(d => {
                const p = r.closest(d).eq(0);
                p.length > 0 && f[d].call(e, p, p.dataset(), n)
            }
            ))
        }
        );
        let l = {};
        if (i && (n.preventDefault(),
        l = o.dataset()),
        l.clickedEl = o[0],
        n.preventF7Router || o.hasClass("prevent-router") || o.hasClass("router-prevent"))
            return;
        if (s && s.length > 0 && s[0] !== "#" || o.hasClass("back")) {
            let u;
            if (l.view && l.view === "current" ? u = e.views.current : l.view ? u = $(l.view)[0].f7View : (u = r.parents(".view")[0] && r.parents(".view")[0].f7View,
            !o.hasClass("back") && u && u.params.linksView && (typeof u.params.linksView == "string" ? u = $(u.params.linksView)[0].f7View : u.params.linksView instanceof k1 && (u = u.params.linksView))),
            u || e.views.main && (u = e.views.main),
            !u || !u.router)
                return;
            o[0].f7RouteProps && (l.props = o[0].f7RouteProps),
            o.hasClass("back") ? u.router.back(s, l) : u.router.navigate(s, l)
        }
    }
    e.on("click", t)
}
const Fy = {
    name: "clicks",
    params: {
        clicks: {
            externalLinks: ".external"
        }
    },
    on: {
        init() {
            Vy(this)
        }
    }
}
  , jy = {
    name: "history",
    static: {
        history: nt
    },
    on: {
        init() {
            nt.init(this)
        }
    }
}
  , Er = {
    registrations: [],
    register(e, t) {
        const n = this;
        return !("serviceWorker"in He().navigator) || !n.serviceWorker.container ? new Promise( (r, o) => {
            o(new Error("Service worker is not supported"))
        }
        ) : new Promise( (r, o) => {
            n.serviceWorker.container.register(e, t ? {
                scope: t
            } : {}).then(i => {
                Er.registrations.push(i),
                n.emit("serviceWorkerRegisterSuccess", i),
                r(i)
            }
            ).catch(i => {
                n.emit("serviceWorkerRegisterError", i),
                o(i)
            }
            )
        }
        )
    },
    unregister(e) {
        const t = this;
        if (!("serviceWorker"in He().navigator) || !t.serviceWorker.container)
            return new Promise( (r, o) => {
                o(new Error("Service worker is not supported"))
            }
            );
        let a;
        return e ? Array.isArray(e) ? a = e : a = [e] : a = Er.registrations,
        Promise.all(a.map(r => new Promise( (o, i) => {
            r.unregister().then( () => {
                Er.registrations.indexOf(r) >= 0 && Er.registrations.splice(Er.registrations.indexOf(r), 1),
                t.emit("serviceWorkerUnregisterSuccess", r),
                o()
            }
            ).catch(s => {
                t.emit("serviceWorkerUnregisterError", r, s),
                i(s)
            }
            )
        }
        )))
    }
}
  , Uy = {
    name: "sw",
    params: {
        serviceWorker: {
            path: void 0,
            scope: void 0
        }
    },
    create() {
        const e = this
          , t = He();
        se(e, {
            serviceWorker: {
                container: "serviceWorker"in t.navigator ? t.navigator.serviceWorker : void 0,
                registrations: Er.registrations,
                register: Er.register.bind(e),
                unregister: Er.unregister.bind(e)
            }
        })
    },
    on: {
        init() {
            const e = He();
            if (!("serviceWorker"in e.navigator))
                return;
            const t = this;
            if (t.device.cordova || e.Capacitor && e.Capacitor.isNative || !t.serviceWorker.container)
                return;
            const n = t.params.serviceWorker.path
              , a = t.params.serviceWorker.scope;
            if (!n || Array.isArray(n) && !n.length)
                return;
            (Array.isArray(n) ? n : [n]).forEach(o => {
                t.serviceWorker.register(o, a)
            }
            )
        }
    }
};
function $3(e) {
    e === void 0 && (e = {});
    const t = {
        __store: !0
    }
      , n = {
        ...e.state || {}
    }
      , a = {
        ...e.actions || {}
    }
      , r = {
        ...e.getters || {}
    }
      , o = se({}, n);
    let i = [];
    const s = {}
      , l = {};
    Object.keys(r).forEach(m => {
        s[m] = [],
        l[m] = []
    }
    );
    const c = m => r[m]({
        state: t.state
    })
      , u = (m, g) => {
        s[m] || (s[m] = []),
        g.forEach(b => {
            s[m].indexOf(b) < 0 && s[m].push(b)
        }
        )
    }
      , f = (m, g) => {
        l[m] || (l[m] = []),
        l[m].push(g)
    }
      , d = m => {
        Object.keys(s).filter(b => s[b].indexOf(m) >= 0).forEach(b => {
            !l[b] || !l[b].length || l[b].forEach(v => {
                v(c(b))
            }
            )
        }
        )
    }
      , p = m => {
        Object.keys(l).forEach(g => {
            const b = l[g];
            b.indexOf(m) >= 0 && b.splice(b.indexOf(m), 1)
        }
        )
    }
    ;
    t.__removeCallback = m => {
        p(m)
    }
    ;
    const h = function(m, g) {
        if (g === void 0 && (g = !0),
        m === "constructor")
            return;
        i = [];
        const b = c(m);
        u(m, i);
        const y = {
            value: b,
            onUpdated: C => {
                f(m, C)
            }
        };
        if (!g)
            return y;
        const w = C => {
            y.value = C
        }
        ;
        return y.__callback = w,
        f(m, w),
        y
    };
    return t.state = new Proxy(o,{
        set: (m, g, b) => (m[g] = b,
        d(g),
        !0),
        get: (m, g) => (i.push(g),
        m[g])
    }),
    t.getters = new Proxy(r,{
        set: () => !1,
        get: (m, g) => {
            if (m[g])
                return h(g, !0)
        }
    }),
    t._gettersPlain = new Proxy(r,{
        set: () => !1,
        get: (m, g) => {
            if (m[g])
                return h(g, !1)
        }
    }),
    t.dispatch = (m, g) => new Promise( (b, v) => {
        if (!a[m])
            throw v(),
            new Error(`Framework7: Store action "${m}" is not found`);
        const y = a[m]({
            state: t.state,
            dispatch: t.dispatch
        }, g);
        b(y)
    }
    ),
    t
}
const qy = {
    name: "store",
    static: {
        createStore: $3
    },
    proto: {
        createStore: $3
    }
}
  , Kr = () => {
    const e = He();
    return e.Capacitor && e.Capacitor.isNative && e.Capacitor.Plugins && e.Capacitor.Plugins.StatusBar
}
  , Ln = {
    hide() {
        const e = He();
        yt().cordova && e.StatusBar && e.StatusBar.hide(),
        Kr() && e.Capacitor.Plugins.StatusBar.hide()
    },
    show() {
        const e = He();
        yt().cordova && e.StatusBar && e.StatusBar.show(),
        Kr() && e.Capacitor.Plugins.StatusBar.show()
    },
    onClick() {
        const e = this;
        let t;
        $(".popup.modal-in").length > 0 ? t = $(".popup.modal-in").find(".page:not(.page-previous):not(.page-next):not(.cached)").find(".page-content") : $(".panel.panel-in").length > 0 ? t = $(".panel.panel-in").find(".page:not(.page-previous):not(.page-next):not(.cached)").find(".page-content") : $(".views > .view.tab-active").length > 0 ? t = $(".views > .view.tab-active").find(".page:not(.page-previous):not(.page-next):not(.cached)").find(".page-content") : $(".views").length > 0 ? t = $(".views").find(".page:not(.page-previous):not(.page-next):not(.cached)").find(".page-content") : t = e.$el.children(".view").find(".page:not(.page-previous):not(.page-next):not(.cached)").find(".page-content"),
        t && t.length > 0 && (t.hasClass("tab") && (t = t.parent(".tabs").children(".page-content.tab-active")),
        t.length > 0 && t.scrollTop(0, 300))
    },
    setTextColor(e) {
        const t = He();
        yt().cordova && t.StatusBar && (e === "white" ? t.StatusBar.styleLightContent() : t.StatusBar.styleDefault()),
        Kr() && (e === "white" ? t.Capacitor.Plugins.StatusBar.setStyle({
            style: "DARK"
        }) : t.Capacitor.Plugins.StatusBar.setStyle({
            style: "LIGHT"
        }))
    },
    setBackgroundColor(e) {
        const t = He();
        yt().cordova && t.StatusBar && t.StatusBar.backgroundColorByHexString(e),
        Kr() && t.Capacitor.Plugins.StatusBar.setBackgroundColor({
            color: e
        })
    },
    isVisible() {
        const e = He()
          , t = yt();
        return new Promise(n => {
            t.cordova && e.StatusBar && n(e.StatusBar.isVisible),
            Kr() && e.Capacitor.Plugins.StatusBar.getInfo().then(a => {
                n(a.visible)
            }
            ),
            n(!1)
        }
        )
    },
    overlaysWebView(e) {
        e === void 0 && (e = !0);
        const t = He();
        yt().cordova && t.StatusBar && t.StatusBar.overlaysWebView(e),
        Kr() && t.Capacitor.Plugins.StatusBar.setOverlaysWebView({
            overlay: e
        })
    },
    init() {
        const e = this
          , t = He()
          , n = yt()
          , a = e.params.statusbar;
        if (!a.enabled)
            return;
        const r = n.cordova && t.StatusBar
          , o = Kr();
        (r || o) && (a.scrollTopOnClick && $(t).on("statusTap", Ln.onClick.bind(e)),
        n.ios && (a.iosOverlaysWebView ? Ln.overlaysWebView(!0) : Ln.overlaysWebView(!1),
        a.iosTextColor === "white" ? Ln.setTextColor("white") : Ln.setTextColor("black")),
        n.android && (a.androidOverlaysWebView ? Ln.overlaysWebView(!0) : Ln.overlaysWebView(!1),
        a.androidTextColor === "white" ? Ln.setTextColor("white") : Ln.setTextColor("black"))),
        a.iosBackgroundColor && n.ios && Ln.setBackgroundColor(a.iosBackgroundColor),
        a.androidBackgroundColor && n.android && Ln.setBackgroundColor(a.androidBackgroundColor)
    }
}
  , Wy = {
    name: "statusbar",
    params: {
        statusbar: {
            enabled: !0,
            scrollTopOnClick: !0,
            iosOverlaysWebView: !0,
            iosTextColor: "black",
            iosBackgroundColor: null,
            androidOverlaysWebView: !1,
            androidTextColor: "black",
            androidBackgroundColor: null
        }
    },
    create() {
        hn(this, {
            statusbar: Ln
        })
    },
    on: {
        init() {
            const e = this;
            Ln.init.call(e)
        }
    }
};
function Yy(e) {
    const t = $(".popover.modal-in .view")
      , n = $(".popup.modal-in .view")
      , a = $(".panel.panel-in .view");
    let r = $(".views");
    r.length === 0 && (r = e.$el);
    let o = r.children(".view");
    if (o.length === 0 && (o = r.children(".tabs").children(".view")),
    o.length > 1 && o.hasClass("tab") && (o = r.children(".view.tab-active"),
    o.length === 0 && (o = r.children(".tabs").children(".view.tab-active"))),
    t.length > 0 && t[0].f7View)
        return t[0].f7View;
    if (n.length > 0 && n[0].f7View)
        return n[0].f7View;
    if (a.length > 0 && a[0].f7View)
        return a[0].f7View;
    if (o.length > 0) {
        if (o.length === 1 && o[0].f7View)
            return o[0].f7View;
        if (o.length > 1)
            return e.views.main
    }
}
const Gy = {
    name: "view",
    params: {
        view: {
            init: !0,
            initRouterOnTabShow: !1,
            name: void 0,
            main: !1,
            router: !0,
            linksView: null,
            stackPages: !1,
            xhrCache: !0,
            xhrCacheIgnore: [],
            xhrCacheIgnoreGetParameters: !1,
            xhrCacheDuration: 1e3 * 60 * 10,
            componentCache: !0,
            preloadPreviousPage: !0,
            allowDuplicateUrls: !1,
            reloadPages: !1,
            reloadDetail: !1,
            masterDetailBreakpoint: 0,
            masterDetailResizable: !1,
            removeElements: !0,
            removeElementsWithTimeout: !1,
            removeElementsTimeout: 0,
            restoreScrollTopOnBack: !0,
            unloadTabContent: !0,
            passRouteQueryToRequest: !0,
            passRouteParamsToRequest: !1,
            loadInitialPage: !0,
            iosSwipeBack: !0,
            iosSwipeBackAnimateShadow: !0,
            iosSwipeBackAnimateOpacity: !0,
            iosSwipeBackActiveArea: 30,
            iosSwipeBackThreshold: 0,
            mdSwipeBack: !1,
            mdSwipeBackAnimateShadow: !0,
            mdSwipeBackAnimateOpacity: !1,
            mdSwipeBackActiveArea: 30,
            mdSwipeBackThreshold: 0,
            auroraSwipeBack: !1,
            auroraSwipeBackAnimateShadow: !1,
            auroraSwipeBackAnimateOpacity: !0,
            auroraSwipeBackActiveArea: 30,
            auroraSwipeBackThreshold: 0,
            browserHistory: !1,
            browserHistoryRoot: void 0,
            browserHistoryAnimate: !0,
            browserHistoryAnimateOnLoad: !1,
            browserHistorySeparator: "#!",
            browserHistoryOnLoad: !0,
            browserHistoryInitialMatch: !1,
            browserHistoryStoreHistory: !0,
            browserHistoryTabs: "replace",
            animate: !0,
            iosDynamicNavbar: !0,
            iosAnimateNavbarBackIcon: !0,
            iosPageLoadDelay: 0,
            mdPageLoadDelay: 0,
            auroraPageLoadDelay: 0,
            routesBeforeEnter: null,
            routesBeforeLeave: null
        }
    },
    static: {
        View: k1
    },
    create() {
        const e = this;
        se(e, {
            views: se([], {
                create(t, n) {
                    return new k1(e,t,n)
                },
                get(t) {
                    const n = $(t);
                    if (n.length && n[0].f7View)
                        return n[0].f7View
                }
            })
        }),
        Object.defineProperty(e.views, "current", {
            enumerable: !0,
            configurable: !0,
            get() {
                return Yy(e)
            }
        }),
        e.view = e.views
    },
    on: {
        init() {
            const e = this;
            $(".view-init").each(t => {
                if (t.f7View)
                    return;
                const n = $(t).dataset();
                e.views.create(t, n)
            }
            )
        },
        "modalOpen panelOpen": function(t) {
            const n = this;
            t.$el.find(".view-init").each(a => {
                if (a.f7View)
                    return;
                const r = $(a).dataset();
                n.views.create(a, r)
            }
            )
        },
        "modalBeforeDestroy panelBeforeDestroy": function(t) {
            !t || !t.$el || t.$el.find(".view-init").each(n => {
                const a = n.f7View;
                a && a.destroy()
            }
            )
        }
    },
    vnode: {
        "view-init": {
            insert(e) {
                const t = this
                  , n = e.elm;
                if (n.f7View)
                    return;
                const a = $(n).dataset();
                t.views.create(n, a)
            },
            destroy(e) {
                const n = e.elm.f7View;
                n && n.destroy()
            }
        }
    }
}
  , Xy = {
    size(e) {
        const t = this;
        let n = $(e);
        if (n.hasClass("navbars")) {
            n = n.children(".navbar").each(x => {
                t.navbar.size(x)
            }
            );
            return
        }
        const a = n.children(".navbar-inner");
        if (!a.length)
            return;
        const r = a.hasClass("navbar-inner-centered-title") || t.params.navbar[`${t.theme}CenterTitle`]
          , o = t.theme === "ios" && !t.params.navbar[`${t.theme}CenterTitle`];
        if (!r && !o || n.hasClass("stacked") || n.parents(".stacked").length > 0 || n.parents(".tab:not(.tab-active)").length > 0 || n.parents(".popup:not(.modal-in)").length > 0)
            return;
        t.theme !== "ios" && t.params.navbar[`${t.theme}CenterTitle`] && a.addClass("navbar-inner-centered-title"),
        t.theme === "ios" && !t.params.navbar.iosCenterTitle && a.addClass("navbar-inner-left-title");
        const i = n.parents(".view").eq(0)
          , s = t.rtl ? a.children(".right") : a.children(".left")
          , l = t.rtl ? a.children(".left") : a.children(".right")
          , c = a.children(".title")
          , u = a.children(".subnavbar")
          , f = s.length === 0
          , d = l.length === 0
          , p = f ? 0 : s.outerWidth(!0)
          , h = d ? 0 : l.outerWidth(!0)
          , m = c.outerWidth(!0)
          , g = a.styles()
          , v = a[0].offsetWidth - parseInt(g.paddingLeft, 10) - parseInt(g.paddingRight, 10)
          , y = n.hasClass("navbar-previous")
          , w = a.hasClass("sliding");
        let C, _;
        i.length > 0 && i[0].f7View && (C = i[0].f7View.router,
        _ = C && C.dynamicNavbar);
        let E, z;
        d && (E = v - m),
        f && (E = 0),
        !f && !d && (E = (v - h - m + p) / 2);
        let T = (v - m) / 2;
        v - p - h > m ? (T < p && (T = p),
        T + m > v - h && (T = v - h - m),
        z = T - E) : z = 0;
        const A = t.rtl ? -1 : 1;
        if (_ && t.theme === "ios") {
            if (c.hasClass("sliding") || c.length > 0 && w) {
                let x = -(E + z) * A;
                const M = (v - E - z - m) * A;
                if (y && C && C.params.iosAnimateNavbarBackIcon) {
                    const L = n.parent().find(".navbar-current").children(".left.sliding").find(".back .icon ~ span");
                    L.length > 0 && (x += L[0].offsetLeft)
                }
                c[0].f7NavbarLeftOffset = x,
                c[0].f7NavbarRightOffset = M
            }
            if (!f && (s.hasClass("sliding") || w)) {
                if (t.rtl)
                    s[0].f7NavbarLeftOffset = -(v - s[0].offsetWidth) / 2 * A,
                    s[0].f7NavbarRightOffset = p * A;
                else if (s[0].f7NavbarLeftOffset = -p,
                s[0].f7NavbarRightOffset = (v - s[0].offsetWidth) / 2,
                C && C.params.iosAnimateNavbarBackIcon && s.find(".back .icon").length > 0 && s.find(".back .icon ~ span").length) {
                    const x = s[0].f7NavbarLeftOffset
                      , M = s[0].f7NavbarRightOffset;
                    s[0].f7NavbarLeftOffset = 0,
                    s[0].f7NavbarRightOffset = 0,
                    s.find(".back .icon ~ span")[0].f7NavbarLeftOffset = x,
                    s.find(".back .icon ~ span")[0].f7NavbarRightOffset = M - s.find(".back .icon")[0].offsetWidth
                }
            }
            !d && (l.hasClass("sliding") || w) && (t.rtl ? (l[0].f7NavbarLeftOffset = -h * A,
            l[0].f7NavbarRightOffset = (v - l[0].offsetWidth) / 2 * A) : (l[0].f7NavbarLeftOffset = -(v - l[0].offsetWidth) / 2,
            l[0].f7NavbarRightOffset = h)),
            u.length && (u.hasClass("sliding") || w) && (u[0].f7NavbarLeftOffset = t.rtl ? u[0].offsetWidth : -u[0].offsetWidth,
            u[0].f7NavbarRightOffset = -u[0].f7NavbarLeftOffset)
        }
        if (r) {
            let x = z;
            t.rtl && f && d && c.length > 0 && (x = -x),
            c.css({
                left: `${x}px`
            })
        }
    },
    hide(e, t, n, a) {
        t === void 0 && (t = !0),
        n === void 0 && (n = !1),
        a === void 0 && (a = !1);
        const r = this;
        let o = $(e);
        const i = o.hasClass("navbar") && o.parent(".navbars").length && !a;
        if (i && (o = o.parents(".navbars")),
        !o.length || o.hasClass("navbar-hidden"))
            return;
        let s = `navbar-hidden${t ? " navbar-transitioning" : ""}`;
        (i ? o.find(".navbar-current .title-large").length : o.find(".title-large").length) && (s += " navbar-large-hidden"),
        n && (s += " navbar-hidden-statusbar"),
        o.transitionEnd( () => {
            o.removeClass("navbar-transitioning")
        }
        ),
        o.addClass(s),
        i ? o.children(".navbar").each(c => {
            $(c).trigger("navbar:hide"),
            r.emit("navbarHide", c)
        }
        ) : (o.trigger("navbar:hide"),
        r.emit("navbarHide", o[0]))
    },
    show(e, t, n) {
        e === void 0 && (e = ".navbar-hidden"),
        t === void 0 && (t = !0),
        n === void 0 && (n = !1);
        const a = this;
        let r = $(e);
        const o = r.hasClass("navbar") && r.parent(".navbars").length && !n;
        o && (r = r.parents(".navbars")),
        r.length && r.hasClass("navbar-hidden") && (t && (r.addClass("navbar-transitioning"),
        r.transitionEnd( () => {
            r.removeClass("navbar-transitioning")
        }
        )),
        r.removeClass("navbar-hidden navbar-large-hidden navbar-hidden-statusbar"),
        o ? r.children(".navbar").each(i => {
            $(i).trigger("navbar:show"),
            a.emit("navbarShow", i)
        }
        ) : (r.trigger("navbar:show"),
        a.emit("navbarShow", r[0])))
    },
    getElByPage(e) {
        let t, n, a;
        if (e.$navbarEl || e.$el ? (a = e,
        t = e.$el) : (t = $(e),
        t.length > 0 && (a = t[0].f7Page)),
        a && a.$navbarEl && a.$navbarEl.length > 0 ? n = a.$navbarEl : t && (n = t.children(".navbar")),
        !(!n || n && n.length === 0))
            return n[0]
    },
    getPageByEl(e) {
        const t = $(e);
        if (t.parents(".page").length)
            return t.parents(".page")[0];
        let n;
        return t.parents(".view").find(".page").each(a => {
            a && a.f7Page && a.f7Page.navbarEl && t[0] === a.f7Page.navbarEl && (n = a)
        }
        ),
        n
    },
    collapseLargeTitle(e) {
        const t = this;
        let n = $(e);
        if (n.hasClass("navbars") && (n = n.find(".navbar"),
        n.length > 1 && (n = $(e).find(".navbar-large.navbar-current")),
        n.length > 1 || !n.length))
            return;
        const a = $(t.navbar.getPageByEl(n));
        n.addClass("navbar-large-collapsed"),
        a.eq(0).addClass("page-with-navbar-large-collapsed").trigger("page:navbarlargecollapsed"),
        t.emit("pageNavbarLargeCollapsed", a[0]),
        n.trigger("navbar:collapse"),
        t.emit("navbarCollapse", n[0])
    },
    expandLargeTitle(e) {
        const t = this;
        let n = $(e);
        if (n.hasClass("navbars") && (n = n.find(".navbar-large"),
        n.length > 1 && (n = $(e).find(".navbar-large.navbar-current")),
        n.length > 1 || !n.length))
            return;
        const a = $(t.navbar.getPageByEl(n));
        n.removeClass("navbar-large-collapsed"),
        a.eq(0).removeClass("page-with-navbar-large-collapsed").trigger("page:navbarlargeexpanded"),
        t.emit("pageNavbarLargeExpanded", a[0]),
        n.trigger("navbar:expand"),
        t.emit("navbarExpand", n[0])
    },
    toggleLargeTitle(e) {
        const t = this;
        let n = $(e);
        n.hasClass("navbars") && (n = n.find(".navbar-large"),
        n.length > 1 && (n = $(e).find(".navbar-large.navbar-current")),
        n.length > 1 || !n.length) || (n.hasClass("navbar-large-collapsed") ? t.navbar.expandLargeTitle(n) : t.navbar.collapseLargeTitle(n))
    },
    initNavbarOnScroll(e, t, n, a, r) {
        const o = this
          , i = Mt()
          , s = $(e)
          , l = $(t)
          , c = l.find(".title-large")
          , u = c.length || l.hasClass(".navbar-large");
        let f = 44;
        const d = o.params.navbar.snapPageScrollToLargeTitle
          , p = o.params.navbar.snapPageScrollToTransparentNavbar;
        let h, m, g, b, v, y, w, C, _, E;
        (a || n && u) && (_ = l.css("--f7-navbar-large-title-height"),
        _ && _.indexOf("px") >= 0 ? (_ = parseInt(_, 10),
        Number.isNaN(_) && c.length ? _ = c[0].offsetHeight : Number.isNaN(_) && (o.theme === "ios" ? _ = 52 : o.theme === "md" ? _ = 48 : o.theme === "aurora" && (_ = 38))) : c.length ? _ = c[0].offsetHeight : o.theme === "ios" ? _ = 52 : o.theme === "md" ? _ = 48 : o.theme === "aurora" && (_ = 38)),
        n && u && (f += _);
        let z, T, A, x;
        const M = 70
          , L = 300;
        function U() {
            s.find(".page-content").each(Ye => {
                Ye.f7ScrollableDistance = Ye.scrollHeight - Ye.offsetHeight
            }
            )
        }
        function Y() {
            l.hasClass("with-searchbar-expandable-enabled") || !T || m < 0 || (m >= _ / 2 && m < _ ? $(T).scrollTop(_, 100) : m < _ && $(T).scrollTop(0, 200))
        }
        function H() {
            l.hasClass("with-searchbar-expandable-enabled") || !T || m < 0 || (m >= E / 2 && m < E ? $(T).scrollTop(E, 100) : m < E && $(T).scrollTop(0, 200))
        }
        function W() {
            const Ye = l.hasClass("navbar-hidden") || l.parent(".navbars").hasClass("navbar-hidden");
            if (l.hasClass("with-searchbar-expandable-enabled") || Ye)
                return;
            E || (E = t.offsetHeight);
            let ee = m / E;
            const ye = l.hasClass("navbar-transparent-visible");
            if (ee = Math.max(Math.min(ee, 1), 0),
            ye && ee === 1 || !ye && ee === 0) {
                l.find(".navbar-bg, .title").css("opacity", "");
                return
            }
            if (ye && ee === 0) {
                l.trigger("navbar:transparenthide"),
                o.emit("navbarTransparentHide", l[0]),
                l.removeClass("navbar-transparent-visible"),
                l.find(".navbar-bg, .title").css("opacity", "");
                return
            }
            if (!ye && ee === 1) {
                l.trigger("navbar:transparentshow"),
                o.emit("navbarTransparentShow", l[0]),
                l.addClass("navbar-transparent-visible"),
                l.find(".navbar-bg, .title").css("opacity", "");
                return
            }
            l.find(".navbar-bg, .title").css("opacity", ee),
            p && (i.touch ? x && (clearTimeout(x),
            x = null,
            x = setTimeout( () => {
                H(),
                clearTimeout(x),
                x = null
            }
            , M)) : (clearTimeout(A),
            A = setTimeout( () => {
                H()
            }
            , L)))
        }
        let j = null
          , Q = null;
        function ne(Ye) {
            if (l.hasClass("navbar-hidden") || l.parent(".navbars").hasClass("navbar-hidden"))
                return;
            const ee = l.hasClass("navbar-large-transparent") || l.hasClass("navbar-large") && l.hasClass("navbar-transparent");
            j = Q;
            const ye = Math.min(_, Ye.f7ScrollableDistance || _);
            Q = Math.min(Math.max(m / ye, 0), 1);
            const Le = j > 0 && j < 1;
            l.hasClass("with-searchbar-expandable-enabled") || (C = l.hasClass("navbar-large-collapsed"),
            Q === 0 && C ? o.navbar.expandLargeTitle(l[0]) : Q === 1 && !C && o.navbar.collapseLargeTitle(l[0]),
            Q === 0 && C || Q === 0 && Le || Q === 1 && !C || Q === 1 && Le ? (o.theme === "md" && l.find(".navbar-inner").css("overflow", ""),
            l.find(".title").css("opacity", ""),
            l.find(".title-large-text, .subnavbar").css("transform", ""),
            ee ? l.find(".navbar-bg").css("opacity", "") : l.find(".navbar-bg").css("transform", "")) : Q > 0 && Q < 1 && (o.theme === "md" && l.find(".navbar-inner").css("overflow", "visible"),
            l.find(".title").css("opacity", Q),
            l.find(".title-large-text, .subnavbar").css("transform", `translate3d(0px, ${-1 * Q * _}px, 0)`),
            ee ? l.find(".navbar-bg").css("opacity", Q) : l.find(".navbar-bg").css("transform", `translate3d(0px, ${-1 * Q * _}px, 0)`)),
            d && (i.touch ? x && (clearTimeout(x),
            x = null,
            x = setTimeout( () => {
                Y(),
                clearTimeout(x),
                x = null
            }
            , M)) : (clearTimeout(A),
            A = setTimeout( () => {
                Y()
            }
            , L))))
        }
        function re() {
            s.hasClass("page-with-card-opened") || (g = T.scrollHeight,
            b = T.offsetHeight,
            v = m + b >= g,
            w = l.hasClass("navbar-hidden") || l.parent(".navbars").hasClass("navbar-hidden"),
            v ? o.params.navbar.showOnPageScrollEnd && (y = "show") : h > m ? o.params.navbar.showOnPageScrollTop || m <= f ? y = "show" : y = "hide" : m > f ? y = "hide" : y = "show",
            y === "show" && w ? (o.navbar.show(l, !0, !0),
            w = !1) : y === "hide" && !w && (o.navbar.hide(l, !0, !1, !0),
            w = !0),
            h = m)
        }
        function ve(Ye) {
            T = this,
            !(Ye && Ye.target && Ye.target !== T) && (m = T.scrollTop,
            z = m,
            a ? ne(T) : r && W(),
            !s.hasClass("page-previous") && n && re())
        }
        function Ne() {
            z = !1
        }
        function Ge() {
            clearTimeout(x),
            x = null,
            x = setTimeout( () => {
                z !== !1 && (r && !a ? H() : Y(),
                clearTimeout(x),
                x = null)
            }
            , M)
        }
        s.on("scroll", ".page-content", ve, !0),
        i.touch && (a && d || r && p) && (o.on("touchstart:passive", Ne),
        o.on("touchend:passive", Ge)),
        U(),
        (a || r) && s.find(".page-content").each(Ye => {
            Ye.scrollTop > 0 && ve.call(Ye)
        }
        ),
        o.on("resize", U),
        s[0].f7DetachNavbarScrollHandlers = function() {
            o.off("resize", U),
            delete s[0].f7DetachNavbarScrollHandlers,
            s.off("scroll", ".page-content", ve, !0),
            i.touch && (a && d || r && p) && (o.off("touchstart:passive", Ne),
            o.off("touchend:passive", Ge))
        }
    }
}
  , Ky = {
    name: "navbar",
    create() {
        hn(this, {
            navbar: Xy
        })
    },
    params: {
        navbar: {
            scrollTopOnTitleClick: !0,
            iosCenterTitle: !0,
            mdCenterTitle: !1,
            auroraCenterTitle: !0,
            hideOnPageScroll: !1,
            showOnPageScrollEnd: !0,
            showOnPageScrollTop: !0,
            collapseLargeTitleOnScroll: !0,
            snapPageScrollToLargeTitle: !0,
            snapPageScrollToTransparentNavbar: !0
        }
    },
    on: {
        "panelBreakpoint panelCollapsedBreakpoint panelResize viewResize resize viewMasterDetailBreakpoint": function() {
            const t = this;
            $(".navbar").each(n => {
                t.navbar.size(n)
            }
            )
        },
        pageBeforeRemove(e) {
            e.$el[0].f7DetachNavbarScrollHandlers && e.$el[0].f7DetachNavbarScrollHandlers()
        },
        pageBeforeIn(e) {
            const t = this;
            if (t.theme !== "ios")
                return;
            let n;
            const a = e.$el.parents(".view")[0].f7View
              , r = t.navbar.getElByPage(e);
            if (r ? n = $(r).parents(".navbars") : n = e.$el.parents(".view").children(".navbars"),
            e.$el.hasClass("no-navbar") || a.router.dynamicNavbar && !r) {
                const o = !!(e.pageFrom && e.router.history.length > 0);
                t.navbar.hide(n, o)
            } else
                t.navbar.show(n)
        },
        pageReinit(e) {
            const t = this
              , n = $(t.navbar.getElByPage(e));
            !n || n.length === 0 || t.navbar.size(n)
        },
        pageInit(e) {
            const t = this
              , n = $(t.navbar.getElByPage(e));
            if (!n || n.length === 0)
                return;
            t.navbar.size(n);
            let a;
            n.find(".title-large").length > 0 && n.addClass("navbar-large"),
            n.hasClass("navbar-large") && (t.params.navbar.collapseLargeTitleOnScroll && (a = !0),
            e.$el.addClass("page-with-navbar-large"));
            let r;
            !a && n.hasClass("navbar-transparent") && (r = !0);
            let o;
            (t.params.navbar.hideOnPageScroll || e.$el.find(".hide-navbar-on-scroll").length || e.$el.hasClass("hide-navbar-on-scroll") || e.$el.find(".hide-bars-on-scroll").length || e.$el.hasClass("hide-bars-on-scroll")) && (e.$el.find(".keep-navbar-on-scroll").length || e.$el.hasClass("keep-navbar-on-scroll") || e.$el.find(".keep-bars-on-scroll").length || e.$el.hasClass("keep-bars-on-scroll") ? o = !1 : o = !0),
            (a || o || r) && t.navbar.initNavbarOnScroll(e.el, n[0], o, a, r)
        },
        "panelOpen panelSwipeOpen modalOpen": function(t) {
            const n = this;
            t.$el.find(".navbar:not(.navbar-previous):not(.stacked)").each(a => {
                n.navbar.size(a)
            }
            )
        },
        tabShow(e) {
            const t = this;
            $(e).find(".navbar:not(.navbar-previous):not(.stacked)").each(n => {
                t.navbar.size(n)
            }
            )
        }
    },
    clicks: {
        ".navbar .title": function(t, n, a) {
            if (!this.params.navbar.scrollTopOnTitleClick || $(a.target).closest("a, button").length > 0)
                return;
            let o;
            const i = t.parents(".navbar")
              , s = i.parents(".navbars");
            o = i.parents(".page-content"),
            o.length === 0 && (i.parents(".page").length > 0 && (o = i.parents(".page").find(".page-content")),
            o.length === 0 && s.length && s.nextAll(".page-current:not(.stacked)").length > 0 && (o = s.nextAll(".page-current:not(.stacked)").find(".page-content")),
            o.length === 0 && i.nextAll(".page-current:not(.stacked)").length > 0 && (o = i.nextAll(".page-current:not(.stacked)").find(".page-content"))),
            o && o.length > 0 && (o.hasClass("tab") && (o = o.parent(".tabs").children(".page-content.tab-active")),
            o.length > 0 && o.scrollTop(0, 300))
        }
    },
    vnode: {
        navbar: {
            postpatch(e) {
                this.navbar.size(e.elm)
            }
        }
    }
}
  , Zy = {
    setHighlight(e) {
        const t = this
          , n = $(e);
        if (t.theme === "ios" && !n.hasClass("tabbar-highlight") || n.length === 0 || !(n.hasClass("tabbar") || n.hasClass("tabbar-labels")))
            return;
        let a = n.find(".tab-link-highlight");
        const r = n.find(".tab-link").length;
        if (r === 0) {
            a.remove();
            return
        }
        a.length === 0 ? (n.children(".toolbar-inner").append('<span class="tab-link-highlight"></span>'),
        a = n.find(".tab-link-highlight")) : a.next().length && n.children(".toolbar-inner").append(a);
        const o = n.find(".tab-link-active");
        let i, s;
        if (n.hasClass("tabbar-scrollable") && o && o[0])
            i = `${o[0].offsetWidth}px`,
            s = `${o[0].offsetLeft}px`;
        else {
            const l = o.index();
            i = `${100 / r}%`,
            s = `${(t.rtl ? -l : l) * 100}%`
        }
        xn( () => {
            a.css("width", i).transform(`translate3d(${s},0,0)`)
        }
        )
    },
    init(e) {
        this.toolbar.setHighlight(e)
    },
    hide(e, t) {
        t === void 0 && (t = !0);
        const n = this
          , a = $(e);
        if (a.hasClass("toolbar-hidden"))
            return;
        const r = `toolbar-hidden${t ? " toolbar-transitioning" : ""}`;
        a.transitionEnd( () => {
            a.removeClass("toolbar-transitioning")
        }
        ),
        a.addClass(r),
        a.trigger("toolbar:hide"),
        n.emit("toolbarHide", a[0])
    },
    show(e, t) {
        t === void 0 && (t = !0);
        const n = this
          , a = $(e);
        a.hasClass("toolbar-hidden") && (t && (a.addClass("toolbar-transitioning"),
        a.transitionEnd( () => {
            a.removeClass("toolbar-transitioning")
        }
        )),
        a.removeClass("toolbar-hidden"),
        a.trigger("toolbar:show"),
        n.emit("toolbarShow", a[0]))
    },
    initToolbarOnScroll(e) {
        const t = this
          , n = $(e);
        let a = n.parents(".view").children(".toolbar");
        if (a.length === 0 && (a = n.find(".toolbar")),
        a.length === 0 && (a = n.parents(".views").children(".tabbar, .tabbar-labels")),
        a.length === 0)
            return;
        let r, o, i, s, l, c, u;
        function f(d) {
            if (n.hasClass("page-with-card-opened") || n.hasClass("page-previous"))
                return;
            const p = this;
            d && d.target && d.target !== p || (o = p.scrollTop,
            i = p.scrollHeight,
            s = p.offsetHeight,
            l = o + s >= i,
            u = a.hasClass("toolbar-hidden"),
            l ? t.params.toolbar.showOnPageScrollEnd && (c = "show") : r > o ? t.params.toolbar.showOnPageScrollTop || o <= 44 ? c = "show" : c = "hide" : o > 44 ? c = "hide" : c = "show",
            c === "show" && u ? (t.toolbar.show(a),
            u = !1) : c === "hide" && !u && (t.toolbar.hide(a),
            u = !0),
            r = o)
        }
        n.on("scroll", ".page-content", f, !0),
        n[0].f7ScrollToolbarHandler = f
    }
}
  , Jy = {
    name: "toolbar",
    create() {
        hn(this, {
            toolbar: Zy
        })
    },
    params: {
        toolbar: {
            hideOnPageScroll: !1,
            showOnPageScrollEnd: !0,
            showOnPageScrollTop: !0
        }
    },
    on: {
        pageBeforeRemove(e) {
            e.$el[0].f7ScrollToolbarHandler && e.$el.off("scroll", ".page-content", e.$el[0].f7ScrollToolbarHandler, !0)
        },
        pageBeforeIn(e) {
            const t = this;
            let n = e.$el.parents(".view").children(".toolbar");
            n.length === 0 && (n = e.$el.parents(".views").children(".tabbar, .tabbar-labels")),
            n.length === 0 && (n = e.$el.find(".toolbar")),
            n.length !== 0 && (e.$el.hasClass("no-toolbar") ? t.toolbar.hide(n) : t.toolbar.show(n))
        },
        pageInit(e) {
            const t = this;
            if (e.$el.find(".tabbar, .tabbar-labels").each(n => {
                t.toolbar.init(n)
            }
            ),
            t.params.toolbar.hideOnPageScroll || e.$el.find(".hide-toolbar-on-scroll").length || e.$el.hasClass("hide-toolbar-on-scroll") || e.$el.find(".hide-bars-on-scroll").length || e.$el.hasClass("hide-bars-on-scroll")) {
                if (e.$el.find(".keep-toolbar-on-scroll").length || e.$el.hasClass("keep-toolbar-on-scroll") || e.$el.find(".keep-bars-on-scroll").length || e.$el.hasClass("keep-bars-on-scroll"))
                    return;
                t.toolbar.initToolbarOnScroll(e.el)
            }
        },
        init() {
            const e = this;
            e.$el.find(".tabbar, .tabbar-labels").each(t => {
                e.toolbar.init(t)
            }
            )
        }
    },
    vnode: {
        tabbar: {
            insert(e) {
                this.toolbar.init(e.elm)
            }
        }
    }
}
  , Qy = {
    name: "subnavbar",
    on: {
        pageInit(e) {
            e.$navbarEl && e.$navbarEl.length && e.$navbarEl.find(".subnavbar").length && e.$el.addClass("page-with-subnavbar"),
            e.$el.find(".subnavbar").filter(n => $(n).parents(".page")[0] === e.$el[0]).length && e.$el.addClass("page-with-subnavbar")
        }
    }
};
let E3 = class {
    constructor(t, n, a, r) {
        const o = this;
        if (!n)
            return;
        const {left: i, top: s, width: l, height: c} = n[0].getBoundingClientRect()
          , u = {
            x: a - i,
            y: r - s
        };
        let f = Math.max((c ** 2 + l ** 2) ** .5, 48)
          , d = !1;
        const p = t.params.touch.touchRippleInsetElements || "";
        if (p && n.is(p) && (d = !0),
        d && (f = Math.max(Math.min(l, c), 48)),
        !d && n.css("overflow") === "hidden") {
            const h = ((u.x - l / 2) ** 2 + (u.y - c / 2) ** 2) ** .5
              , m = (f / 2 + h) / (f / 2);
            o.rippleTransform = `translate3d(0px, 0px, 0) scale(${m})`
        } else
            o.rippleTransform = `translate3d(${-u.x + l / 2}px, ${-u.y + c / 2}px, 0) scale(1)`;
        return d && n.addClass("ripple-inset"),
        o.$rippleWaveEl = $(`<div class="ripple-wave" style="width: ${f}px; height: ${f}px; margin-top:-${f / 2}px; margin-left:-${f / 2}px; left:${u.x}px; top:${u.y}px; --f7-ripple-transform: ${o.rippleTransform}"></div>`),
        n.prepend(o.$rippleWaveEl),
        o.$rippleWaveEl.animationEnd( () => {
            o.$rippleWaveEl && (o.$rippleWaveEl.hasClass("ripple-wave-out") || (o.$rippleWaveEl.addClass("ripple-wave-in"),
            o.shouldBeRemoved && o.out()))
        }
        ),
        o
    }
    destroy() {
        let t = this;
        t.$rippleWaveEl && t.$rippleWaveEl.remove(),
        Object.keys(t).forEach(n => {
            t[n] = null,
            delete t[n]
        }
        ),
        t = null
    }
    out() {
        const t = this
          , {$rippleWaveEl: n} = this;
        clearTimeout(t.removeTimeout),
        n.addClass("ripple-wave-out"),
        t.removeTimeout = setTimeout( () => {
            t.destroy()
        }
        , 300),
        n.animationEnd( () => {
            clearTimeout(t.removeTimeout),
            t.destroy()
        }
        )
    }
    remove() {
        const t = this;
        t.shouldBeRemoved || (t.removeTimeout = setTimeout( () => {
            t.destroy()
        }
        , 400),
        t.shouldBeRemoved = !0,
        t.$rippleWaveEl.hasClass("ripple-wave-in") && t.out())
    }
}
;
const eC = {
    name: "touch-ripple",
    static: {
        TouchRipple: E3
    },
    create() {
        const e = this;
        e.touchRipple = {
            create() {
                for (var t = arguments.length, n = new Array(t), a = 0; a < t; a++)
                    n[a] = arguments[a];
                return new E3(...n)
            }
        }
    }
}
  , Fi = []
  , Go = [];
function tC() {
    if (Go.length === 0)
        return;
    Go.shift().open()
}
let Va = class extends Bt {
    constructor(t, n) {
        super(n, [t]);
        const a = this
          , r = {};
        a.useModulesParams(r),
        a.params = se(r, n),
        a.opened = !1;
        let o = a.params.containerEl ? $(a.params.containerEl).eq(0) : t.$el;
        return o.length || (o = t.$el),
        a.$containerEl = o,
        a.containerEl = o[0],
        a.useModules(),
        this
    }
    onOpen() {
        const t = this;
        t.opened = !0,
        Fi.push(t),
        $("html").addClass(`with-modal-${t.type.toLowerCase()}`),
        t.$el.trigger(`modal:open ${t.type.toLowerCase()}:open`),
        t.emit(`local::open modalOpen ${t.type}Open`, t)
    }
    onOpened() {
        const t = this;
        t.$el.trigger(`modal:opened ${t.type.toLowerCase()}:opened`),
        t.emit(`local::opened modalOpened ${t.type}Opened`, t)
    }
    onClose() {
        const t = this;
        t.opened = !1,
        !(!t.type || !t.$el) && (Fi.splice(Fi.indexOf(t), 1),
        $("html").removeClass(`with-modal-${t.type.toLowerCase()}`),
        t.$el.trigger(`modal:close ${t.type.toLowerCase()}:close`),
        t.emit(`local::close modalClose ${t.type}Close`, t))
    }
    onClosed() {
        const t = this;
        !t.type || !t.$el || (t.$el.removeClass("modal-out"),
        t.$el.hide(),
        t.params.backdrop && (t.params.backdropUnique || t.forceBackdropUnique) && t.$backdropEl && t.$backdropEl.remove(),
        t.$el.trigger(`modal:closed ${t.type.toLowerCase()}:closed`),
        t.emit(`local::closed modalClosed ${t.type}Closed`, t))
    }
    open(t) {
        const n = this
          , a = Qe()
          , r = n.app
          , o = n.$el
          , i = n.$backdropEl
          , s = n.type;
        let l = !0;
        if (typeof t < "u" ? l = t : typeof n.params.animate < "u" && (l = n.params.animate),
        !o || o.hasClass("modal-in"))
            return t === !1 && o[0] && s !== "dialog" && (o[0].style.display = "block"),
            n;
        if (s === "dialog" && r.params.modal.queueDialogs) {
            let d;
            if ($(".dialog.modal-in").length > 0 ? d = !0 : Fi.length > 0 && Fi.forEach(p => {
                p.type === "dialog" && (d = !0)
            }
            ),
            d)
                return Go.push(n),
                n
        }
        const c = o.parent()
          , u = o.parents(a).length > 0;
        c.is(n.$containerEl) || (n.$containerEl.append(o),
        n.once(`${s}Closed`, () => {
            u ? c.append(o) : o.remove()
        }
        )),
        o.show(),
        n.params.backdrop && (n.params.backdropUnique || n.forceBackdropUnique) && n.$backdropEl && n.$backdropEl.insertBefore(o),
        n._clientLeft = o[0].clientLeft;
        function f() {
            o.hasClass("modal-out") ? n.onClosed() : o.hasClass("modal-in") && n.onOpened()
        }
        return l ? (i && (i.removeClass("not-animated"),
        i.addClass("backdrop-in")),
        o.animationEnd( () => {
            f()
        }
        ),
        o.transitionEnd( () => {
            f()
        }
        ),
        o.removeClass("modal-out not-animated").addClass("modal-in"),
        n.onOpen()) : (i && i.addClass("backdrop-in not-animated"),
        o.removeClass("modal-out").addClass("modal-in not-animated"),
        n.onOpen(),
        n.onOpened()),
        n
    }
    close(t) {
        const n = this
          , a = n.$el
          , r = n.$backdropEl;
        let o = !0;
        if (typeof t < "u" ? o = t : typeof n.params.animate < "u" && (o = n.params.animate),
        !a || !a.hasClass("modal-in"))
            return Go.indexOf(n) >= 0 && Go.splice(Go.indexOf(n), 1),
            n;
        if (r) {
            let s = !0;
            n.type === "popup" && n.$el.prevAll(".popup.modal-in").add(n.$el.nextAll(".popup.modal-in")).each(l => {
                const c = l.f7Modal;
                c && c.params.closeByBackdropClick && c.params.backdrop && c.backdropEl === n.backdropEl && (s = !1)
            }
            ),
            s && (r[o ? "removeClass" : "addClass"]("not-animated"),
            r.removeClass("backdrop-in"))
        }
        a[o ? "removeClass" : "addClass"]("not-animated");
        function i() {
            a.hasClass("modal-out") ? n.onClosed() : a.hasClass("modal-in") && n.onOpened()
        }
        return o ? (a.animationEnd( () => {
            i()
        }
        ),
        a.transitionEnd( () => {
            i()
        }
        ),
        a.removeClass("modal-in").addClass("modal-out"),
        n.onClose()) : (a.addClass("not-animated").removeClass("modal-in").addClass("modal-out"),
        n.onClose(),
        n.onClosed()),
        n.type === "dialog" && tC(),
        n
    }
    destroy() {
        const t = this;
        t.destroyed || (t.emit(`local::beforeDestroy modalBeforeDestroy ${t.type}BeforeDestroy`, t),
        t.$el && (t.$el.trigger(`modal:beforedestroy ${t.type.toLowerCase()}:beforedestroy`),
        t.$el.length && t.$el[0].f7Modal && delete t.$el[0].f7Modal),
        Yt(t),
        t.destroyed = !0)
    }
}
;
class x3 extends Va {
    constructor(t, n) {
        const a = se({
            backdrop: !0,
            closeByBackdropClick: !0,
            on: {}
        }, n);
        super(t, a);
        const r = this;
        r.params = a;
        let o;
        if (r.params.el ? o = $(r.params.el) : o = $(r.params.content),
        o && o.length > 0 && o[0].f7Modal)
            return o[0].f7Modal;
        if (o.length === 0)
            return r.destroy();
        let i;
        r.params.backdrop && (i = t.$el.children(".custom-modal-backdrop"),
        i.length === 0 && (i = $('<div class="custom-modal-backdrop"></div>'),
        t.$el.append(i)));
        function s(l) {
            !r || r.destroyed || i && l.target === i[0] && r.close()
        }
        return r.on("customModalOpened", () => {
            r.params.closeByBackdropClick && r.params.backdrop && t.on("click", s)
        }
        ),
        r.on("customModalClose", () => {
            r.params.closeByBackdropClick && r.params.backdrop && t.off("click", s)
        }
        ),
        se(r, {
            app: t,
            $el: o,
            el: o[0],
            $backdropEl: i,
            backdropEl: i && i[0],
            type: "customModal"
        }),
        o[0].f7Modal = r,
        r
    }
}
const nC = {
    name: "modal",
    static: {
        Modal: Va,
        CustomModal: x3
    },
    create() {
        const e = this;
        e.customModal = {
            create(t) {
                return new x3(e,t)
            }
        }
    },
    params: {
        modal: {
            queueDialogs: !0
        }
    }
};
an.use([gy, vy, by, yy, Cy, _y, Fy, Z7, jy, Uy, qy, Wy, Gy, Ky, Jy, Qy, eC, nC]);
function aa(e) {
    const t = {};
    return Object.keys(e).forEach(n => {
        typeof e[n] < "u" && (t[n] = e[n])
    }
    ),
    t
}
function xt(e) {
    return typeof e == "string" && e !== ""
}
function Sl(e) {
    return typeof e == "object" && e !== null && e.constructor && e.constructor === Object
}
function J7() {
    return Date.now()
}
function Tn() {
    let e = !0, t, n;
    for (var a = arguments.length, r = new Array(a), o = 0; o < a; o++)
        r[o] = arguments[o];
    typeof r[0] == "boolean" ? ([e,t] = r,
    r.splice(0, 2),
    n = r) : ([t] = r,
    r.splice(0, 1),
    n = r);
    for (let i = 0; i < n.length; i += 1) {
        const s = r[i];
        if (s != null) {
            const l = Object.keys(Object(s));
            for (let c = 0, u = l.length; c < u; c += 1) {
                const f = l[c]
                  , d = Object.getOwnPropertyDescriptor(s, f);
                d !== void 0 && d.enumerable && (e ? Sl(t[f]) && Sl(s[f]) ? Tn(t[f], s[f]) : !Sl(t[f]) && Sl(s[f]) ? (t[f] = {},
                Tn(t[f], s[f])) : t[f] = s[f] : t[f] = s[f])
            }
        }
    }
    return t
}
function Oe() {
    const e = [];
    for (var t = arguments.length, n = new Array(t), a = 0; a < t; a++)
        n[a] = arguments[a];
    n.forEach(o => {
        typeof o == "object" && o.constructor === Object ? Object.keys(o).forEach(i => {
            o[i] && e.push(i)
        }
        ) : o && e.push(o)
    }
    );
    const r = [];
    return e.forEach(o => {
        r.indexOf(o) < 0 && r.push(o)
    }
    ),
    r.join(" ")
}
let X2 = 0
  , K2 = 0;
function aC() {
    X2 = 0,
    K2 = 0
}
function T3() {
    return X2 += 1,
    `${J7()}_${X2}`
}
function fs() {
    return K2 += 1,
    `${J7()}_${K2}`
}
function rC(e, t) {
    t === void 0 && (t = "default");
    const n = []
      , a = r => {
        Array.isArray(r) && r.forEach(o => {
            o.type === Be && o.children ? a(o.children) : o.type && o.type !== pn && n.push(o)
        }
        )
    }
    ;
    return e[t] && a(e[t]()),
    n
}
let D, Nn;
const Ut = {}
  , tn = {
    views: [],
    tabs: [],
    modals: null
}
  , Q7 = () => {
    D && (Ut.ios = D.theme === "ios",
    Ut.md = D.theme === "md",
    Ut.aurora = D.theme === "aurora")
}
  , oC = () => {
    aC(),
    delete Ut.ios,
    delete Ut.md,
    delete Ut.aurora,
    tn.views = [],
    tn.tabs = [],
    tn.modals = null
}
  , iC = () => {
    Nn = new an.Events
}
  , M3 = function(e, t, n) {
    t === void 0 && (t = {}),
    n === void 0 && (n = !0);
    const a = Tn({}, t, {
        el: e,
        init: n
    });
    if (typeof t.store < "u" && (a.store = t.store),
    a.routes || (a.routes = []),
    a.userAgent && (a.theme === "auto" || !a.theme)) {
        const o = an.getDevice({
            userAgent: a.userAgent
        }, !0);
        Ut.ios = !!o.ios,
        Ut.aurora = o.desktop && o.electron,
        Ut.md = !Ut.ios && !Ut.aurora
    }
    if (D && typeof window < "u")
        return;
    typeof window > "u" && oC();
    const r = new an(a);
    D = r,
    Q7(),
    r.initialized ? (D = r,
    Nn.emit("ready", D)) : r.on("init", () => {
        D = r,
        Nn.emit("ready", D)
    }
    )
}
  , ut = e => {
    e && (D && D.initialized ? e(D) : Nn.once("ready", e))
}
;
function je(e) {
    const {color: t, colorTheme: n, textColor: a, bgColor: r, borderColor: o, rippleColor: i, dark: s} = e;
    return {
        dark: s,
        [`color-${t}`]: t,
        [`color-theme-${n}`]: n,
        [`text-color-${a}`]: a,
        [`bg-color-${r}`]: r,
        [`border-color-${o}`]: o,
        [`ripple-color-${i}`]: i
    }
}
const qe = {
    color: String,
    colorTheme: String,
    textColor: String,
    bgColor: String,
    borderColor: String,
    rippleColor: String,
    dark: Boolean
}
  , Ws = {
    icon: String,
    iconMaterial: String,
    iconF7: String,
    iconIos: String,
    iconMd: String,
    iconAurora: String,
    iconColor: String,
    iconSize: [String, Number],
    iconBadge: [String, Number],
    iconBadgeColor: String
}
  , Mo = {
    back: Boolean,
    external: Boolean,
    force: Boolean,
    animate: {
        type: Boolean,
        default: void 0
    },
    ignoreCache: Boolean,
    reloadCurrent: Boolean,
    reloadAll: Boolean,
    reloadPrevious: Boolean,
    reloadDetail: {
        type: Boolean,
        default: void 0
    },
    routeTabId: String,
    view: String,
    routeProps: Object,
    preventRouter: Boolean,
    transition: String,
    openIn: String
};
function zo(e) {
    const {force: t, reloadCurrent: n, reloadPrevious: a, reloadAll: r, reloadDetail: o, animate: i, ignoreCache: s, routeTabId: l, view: c, transition: u, openIn: f} = e;
    let d;
    "animate"in e && typeof i < "u" && (d = i.toString());
    let p;
    return "reloadDetail"in e && typeof o < "u" && (p = o.toString()),
    {
        "data-force": t || void 0,
        "data-reload-current": n || void 0,
        "data-reload-all": r || void 0,
        "data-reload-previous": a || void 0,
        "data-reload-detail": p,
        "data-animate": d,
        "data-ignore-cache": s || void 0,
        "data-route-tab-id": l || void 0,
        "data-view": xt(c) ? c : void 0,
        "data-transition": xt(u) ? u : void 0,
        "data-open-in": xt(f) ? f : void 0
    }
}
function Ao(e) {
    const {back: t, linkBack: n, external: a, preventRouter: r} = e;
    return {
        back: t || n,
        external: a,
        "prevent-router": r
    }
}
const Oo = {
    searchbarEnable: [Boolean, String],
    searchbarDisable: [Boolean, String],
    searchbarClear: [Boolean, String],
    searchbarToggle: [Boolean, String],
    panelOpen: [Boolean, String],
    panelClose: [Boolean, String],
    panelToggle: [Boolean, String],
    popupOpen: [Boolean, String],
    popupClose: [Boolean, String],
    actionsOpen: [Boolean, String],
    actionsClose: [Boolean, String],
    popoverOpen: [Boolean, String],
    popoverClose: [Boolean, String],
    loginScreenOpen: [Boolean, String],
    loginScreenClose: [Boolean, String],
    sheetOpen: [Boolean, String],
    sheetClose: [Boolean, String],
    sortableEnable: [Boolean, String],
    sortableDisable: [Boolean, String],
    sortableToggle: [Boolean, String],
    cardOpen: [Boolean, String],
    cardPreventOpen: [Boolean, String],
    cardClose: [Boolean, String],
    menuClose: {
        type: [Boolean, String],
        default: void 0
    }
};
function Po(e) {
    const {searchbarEnable: t, searchbarDisable: n, searchbarClear: a, searchbarToggle: r, panelOpen: o, panelClose: i, panelToggle: s, popupOpen: l, popupClose: c, actionsOpen: u, actionsClose: f, popoverOpen: d, popoverClose: p, loginScreenOpen: h, loginScreenClose: m, sheetOpen: g, sheetClose: b, sortableEnable: v, sortableDisable: y, sortableToggle: w, cardOpen: C, cardClose: _} = e;
    return {
        "data-searchbar": xt(t) && t || xt(n) && n || xt(a) && a || xt(r) && r || void 0,
        "data-panel": xt(o) && o || xt(i) && i || xt(s) && s || void 0,
        "data-popup": xt(l) && l || xt(c) && c || void 0,
        "data-actions": xt(u) && u || xt(f) && f || void 0,
        "data-popover": xt(d) && d || xt(p) && p || void 0,
        "data-sheet": xt(g) && g || xt(b) && b || void 0,
        "data-login-screen": xt(h) && h || xt(m) && m || void 0,
        "data-sortable": xt(v) && v || xt(y) && y || xt(w) && w || void 0,
        "data-card": xt(C) && C || xt(_) && _ || void 0
    }
}
function Lo(e) {
    const {searchbarEnable: t, searchbarDisable: n, searchbarClear: a, searchbarToggle: r, panelOpen: o, panelClose: i, panelToggle: s, popupOpen: l, popupClose: c, actionsClose: u, actionsOpen: f, popoverOpen: d, popoverClose: p, loginScreenOpen: h, loginScreenClose: m, sheetOpen: g, sheetClose: b, sortableEnable: v, sortableDisable: y, sortableToggle: w, cardOpen: C, cardPreventOpen: _, cardClose: E, menuClose: z} = e;
    return {
        "searchbar-enable": t || t === "",
        "searchbar-disable": n || n === "",
        "searchbar-clear": a || a === "",
        "searchbar-toggle": r || r === "",
        "panel-close": i || i === "",
        "panel-open": o || o === "",
        "panel-toggle": s || s === "",
        "popup-close": c || c === "",
        "popup-open": l || l === "",
        "actions-close": u || u === "",
        "actions-open": f || f === "",
        "popover-close": p || p === "",
        "popover-open": d || d === "",
        "sheet-close": b || b === "",
        "sheet-open": g || g === "",
        "login-screen-close": m || m === "",
        "login-screen-open": h || h === "",
        "sortable-enable": v || v === "",
        "sortable-disable": y || y === "",
        "sortable-toggle": w || w === "",
        "card-close": E || E === "",
        "card-open": C || C === "",
        "card-prevent-open": _ || _ === "",
        "menu-close": z || z === ""
    }
}
const Ys = function(e) {
    let {isOpened: t, isClosing: n} = e === void 0 ? {} : e;
    return {
        "modal-in": t && !n,
        "modal-out": n
    }
};
function sC(e, t) {
    return O(),
    G("div", {
        ref: "elRef",
        class: Ae(e.classes)
    }, [ce(e.$slots, "default")], 2)
}
const e6 = {
    name: "f7-popup",
    render: sC,
    props: {
        tabletFullscreen: Boolean,
        opened: Boolean,
        animate: {
            type: Boolean,
            default: void 0
        },
        backdrop: {
            type: Boolean,
            default: void 0
        },
        backdropEl: {
            type: [String, Object],
            default: void 0
        },
        closeByBackdropClick: {
            type: Boolean,
            default: void 0
        },
        closeOnEscape: {
            type: Boolean,
            default: void 0
        },
        swipeToClose: {
            type: [Boolean, String],
            default: !1
        },
        swipeHandler: {
            type: [String, Object],
            default: void 0
        },
        push: Boolean,
        containerEl: {
            type: [String, Object],
            default: void 0
        },
        ...qe
    },
    emits: ["popup:swipestart", "popup:swipemove", "popup:swipeend", "popup:swipeclose", "popup:open", "popup:opened", "popup:close", "popup:closed", "update:opened"],
    setup(e, t) {
        let {emit: n} = t;
        const a = oe(null);
        let r = e.opened
          , o = !1;
        const i = oe(null)
          , s = g => {
            n("popup:swipestart", g)
        }
          , l = g => {
            n("popup:swipemove", g)
        }
          , c = g => {
            n("popup:swipeend", g)
        }
          , u = g => {
            n("popup:swipeclose", g)
        }
          , f = g => {
            r = !0,
            o = !1,
            n("popup:open", g),
            n("update:opened", !0)
        }
          , d = g => {
            n("popup:opened", g)
        }
          , p = g => {
            r = !1,
            o = !0,
            n("popup:close", g)
        }
          , h = g => {
            o = !1,
            n("popup:closed", g),
            n("update:opened", !1)
        }
        ;
        st( () => e.opened, g => {
            a.value && (g ? a.value.open() : a.value.close())
        }
        ),
        Xe( () => {
            if (!i.value)
                return;
            const g = {
                el: i.value,
                on: {
                    swipeStart: s,
                    swipeMove: l,
                    swipeEnd: c,
                    swipeClose: u,
                    open: f,
                    opened: d,
                    close: p,
                    closed: h
                }
            }
              , {closeByBackdropClick: b, closeOnEscape: v, animate: y, backdrop: w, backdropEl: C, swipeToClose: _, swipeHandler: E, containerEl: z} = e;
            typeof b < "u" && (g.closeByBackdropClick = b),
            typeof v < "u" && (g.closeOnEscape = v),
            typeof y < "u" && (g.animate = y),
            typeof w < "u" && (g.backdrop = w),
            typeof C < "u" && (g.backdropEl = C),
            typeof _ < "u" && (g.swipeToClose = _),
            typeof E < "u" && (g.swipeHandler = E),
            typeof z < "u" && (g.containerEl = z),
            ut( () => {
                a.value = D.popup.create(g),
                e.opened && a.value.open(!1)
            }
            )
        }
        ),
        lt( () => {
            a.value && a.value.destroy(),
            a.value = null
        }
        );
        const m = ae( () => Oe("popup", {
            "popup-tablet-fullscreen": e.tabletFullscreen,
            "popup-push": e.push
        }, Ys({
            isOpened: r,
            isClosing: o
        }), je(e)));
        return {
            elRef: i,
            classes: m
        }
    }
}
  , Gs = (e, t) => {
    const n = r => {
        e.value === r && t("tab:show", r)
    }
      , a = r => {
        e.value === r && t("tab:hide", r)
    }
    ;
    Xe( () => {
        e.value && ut( () => {
            D.on("tabShow", n),
            D.on("tabHide", a)
        }
        )
    }
    ),
    lt( () => {
        D && (D.off("tabShow", n),
        D.off("tabHide", a))
    }
    )
}
  , lC = (e, t) => {
    let n;
    const {initialUrl: a} = e.getInitialUrl()
      , r = e.findMatchingRoute(a);
    let o = {};
    r && r.route && r.route.options && (o = r.route.options.props);
    const i = s => s.master === !0 ? !0 : typeof s.master == "function" ? s.master(e.app) : !1;
    return r && r.route && (r.route.component || r.route.asyncComponent) && !i(r.route) && (n = {
        component: r.route.component || r.route.asyncComponent,
        initialComponent: t,
        id: fs(),
        isAsync: !!r.route.asyncComponent,
        props: {
            f7route: r,
            f7router: e,
            ...o,
            ...r.params
        }
    }),
    {
        initialPage: n,
        initialRoute: r
    }
}
  , Uo = {
    name: "f7-view",
    props: {
        tab: Boolean,
        tabActive: Boolean,
        name: String,
        initRouterOnTabShow: {
            type: Boolean,
            default: void 0
        },
        router: {
            type: Boolean,
            default: !0
        },
        linksView: [Object, String],
        url: String,
        main: {
            type: Boolean,
            default: void 0
        },
        stackPages: {
            type: Boolean,
            default: void 0
        },
        xhrCache: {
            type: Boolean,
            default: void 0
        },
        xhrCacheIgnore: Array,
        xhrCacheIgnoreGetParameters: {
            type: Boolean,
            default: void 0
        },
        xhrCacheDuration: Number,
        preloadPreviousPage: {
            type: Boolean,
            default: void 0
        },
        allowDuplicateUrls: {
            type: Boolean,
            default: void 0
        },
        reloadPages: {
            type: Boolean,
            default: void 0
        },
        reloadDetail: {
            type: Boolean,
            default: void 0
        },
        masterDetailResizable: {
            type: Boolean,
            default: void 0
        },
        masterDetailBreakpoint: Number,
        removeElements: {
            type: Boolean,
            default: void 0
        },
        removeElementsWithTimeout: {
            type: Boolean,
            default: void 0
        },
        removeElementsTimeout: Number,
        restoreScrollTopOnBack: {
            type: Boolean,
            default: void 0
        },
        loadInitialPage: {
            type: Boolean,
            default: void 0
        },
        iosSwipeBack: {
            type: Boolean,
            default: void 0
        },
        iosSwipeBackAnimateShadow: {
            type: Boolean,
            default: void 0
        },
        iosSwipeBackAnimateOpacity: {
            type: Boolean,
            default: void 0
        },
        iosSwipeBackActiveArea: Number,
        iosSwipeBackThreshold: Number,
        mdSwipeBack: {
            type: Boolean,
            default: void 0
        },
        mdSwipeBackAnimateShadow: {
            type: Boolean,
            default: void 0
        },
        mdSwipeBackAnimateOpacity: {
            type: Boolean,
            default: void 0
        },
        mdSwipeBackActiveArea: Number,
        mdSwipeBackThreshold: Number,
        auroraSwipeBack: {
            type: Boolean,
            default: void 0
        },
        auroraSwipeBackAnimateShadow: {
            type: Boolean,
            default: void 0
        },
        auroraSwipeBackAnimateOpacity: {
            type: Boolean,
            default: void 0
        },
        auroraSwipeBackActiveArea: Number,
        auroraSwipeBackThreshold: Number,
        browserHistory: {
            type: Boolean,
            default: void 0
        },
        browserHistoryRoot: String,
        browserHistoryAnimate: {
            type: Boolean,
            default: void 0
        },
        browserHistoryAnimateOnLoad: {
            type: Boolean,
            default: void 0
        },
        browserHistorySeparator: String,
        browserHistoryOnLoad: {
            type: Boolean,
            default: void 0
        },
        browserHistoryInitialMatch: {
            type: Boolean,
            default: !0
        },
        browserHistoryStoreHistory: {
            type: Boolean,
            default: void 0
        },
        animate: {
            type: Boolean,
            default: void 0
        },
        transition: String,
        iosDynamicNavbar: {
            type: Boolean,
            default: void 0
        },
        iosAnimateNavbarBackIcon: {
            type: Boolean,
            default: void 0
        },
        materialPageLoadDelay: Number,
        passRouteQueryToRequest: {
            type: Boolean,
            default: void 0
        },
        passRouteParamsToRequest: {
            type: Boolean,
            default: void 0
        },
        routes: Array,
        routesAdd: Array,
        routesBeforeEnter: [Function, Array],
        routesBeforeLeave: [Function, Array],
        init: {
            type: Boolean,
            default: !0
        },
        ...qe
    },
    emits: ["view:init", "view:resize", "swipeback:move", "swipeback:beforechange", "swipeback:afterchange", "swipeback:beforereset", "swipeback:afterreset", "tab:hide", "tab:show"],
    setup(e, t) {
        let {emit: n, slots: a} = t;
        const r = null
          , o = !(e.initRouterOnTabShow && e.tab && !e.tabActive);
        let i = null;
        const s = oe(null);
        let l = null, c, u;
        const f = z => {
            n("view:init", z),
            e.init || (l.instance = z,
            i = l.instance)
        }
          , d = () => {
            const z = rt(e.routes || [])
              , T = rt(e.routesAdd || []);
            return aa({
                ...e,
                routes: z,
                routesAdd: T
            })
        }
        ;
        if (D && !i && e.init) {
            const z = T3();
            if (i = D.views.create(s.value, {
                ...d(),
                routerId: z,
                init: !1,
                on: {
                    init: f
                }
            }),
            l = {
                routerId: z,
                instance: i
            },
            tn.views.push(l),
            o && i && i.router && (e.url || e.main)) {
                const T = lC(i.router, r);
                c = T.initialPage,
                u = T.initialRoute,
                u && u.route && u.route.masterRoute && (c = void 0,
                u = void 0)
            }
        }
        const p = oe(c ? [c] : [])
          , h = z => {
            z.forEach(T => {
                T.component = rt(T.component)
            }
            ),
            p.value = z
        }
          , m = (z, T) => {
            n("view:resize", T)
        }
          , g = z => {
            n("swipeback:move", z)
        }
          , b = z => {
            n("swipeback:beforechange", z)
        }
          , v = z => {
            n("swipeback:afterchange", z)
        }
          , y = z => {
            n("swipeback:beforereset", z)
        }
          , w = z => {
            n("swipeback:afterreset", z)
        }
        ;
        Xe( () => {
            ut( () => {
                if (i)
                    l.el = s.value,
                    l.pages = p.value,
                    l.setPages = z => {
                        h([...z])
                    }
                    ,
                    c && c.isAsync && !c.initialComponent ? c.component().then( () => {
                        setTimeout( () => {
                            i.init(s.value),
                            c && (c.el = i.router.currentPageEl,
                            u && u.route && u.route.keepAlive && (u.route.keepAliveData = {
                                pageEl: c.el
                            }))
                        }
                        , 100)
                    }
                    ) : (i.init(s.value),
                    c && (c.el = i.router.currentPageEl,
                    u && u.route && u.route.keepAlive && (u.route.keepAliveData = {
                        pageEl: c.el
                    })));
                else {
                    const z = T3();
                    l = {
                        el: s.value,
                        routerId: z,
                        pages: p.value,
                        instance: i,
                        setPages(T) {
                            h([...T])
                        }
                    },
                    tn.views.push(l),
                    l.instance = D.views.create(s.value, {
                        routerId: z,
                        ...d(),
                        on: {
                            init: f
                        }
                    }),
                    i = l.instance
                }
                e.init && (i.on("resize", m),
                i.on("swipebackMove", g),
                i.on("swipebackBeforeChange", b),
                i.on("swipebackAfterChange", v),
                i.on("swipebackBeforeReset", y),
                i.on("swipebackAfterReset", w))
            }
            )
        }
        ),
        lt( () => {
            i && (i.off("resize", m),
            i.off("swipebackMove", g),
            i.off("swipebackBeforeChange", b),
            i.off("swipebackAfterChange", v),
            i.off("swipebackBeforeReset", y),
            i.off("swipebackAfterReset", w),
            i.destroy && i.destroy(),
            i = null),
            tn.views.splice(tn.views.indexOf(l), 1),
            l = null
        }
        ),
        On( () => {
            !l || !D || Nn.emit("viewRouterDidUpdate", l)
        }
        ),
        Gs(s, n);
        const C = ae( () => Oe("view", {
            "view-main": e.main,
            "tab-active": e.tabActive,
            tab: e.tab
        }, je(e)))
          , _ = z => rt(z.component)
          , E = z => {
            const {component: T, props: A} = z;
            let x = [];
            const M = {};
            return T && T.props && (x = Object.keys(T.props)),
            x.forEach(L => {
                L in A && (M[L] = A[L])
            }
            ),
            M
        }
        ;
        return () => Pe("div", {
            ref: s,
            class: C.value
        }, [a.default && a.default(), ...p.value.map(z => Pe(_(z), {
            key: z.id,
            ...E(z)
        }))])
    }
};
function cC(e, t) {
    return O(),
    G("div", {
        ref: "elRef",
        class: Ae(e.classes)
    }, [ce(e.$slots, "default")], 2)
}
const t6 = {
    name: "f7-login-screen",
    render: cC,
    props: {
        opened: Boolean,
        animate: {
            type: Boolean,
            default: void 0
        },
        containerEl: {
            type: [String, Object],
            default: void 0
        },
        ...qe
    },
    emits: ["loginscreen:open", "loginscreen:opened", "loginscreen:close", "loginscreen:closed", "update:opened"],
    setup(e, t) {
        let {emit: n} = t;
        const a = oe(null);
        let r = e.opened
          , o = !1;
        const i = oe(null)
          , s = d => {
            r = !0,
            o = !1,
            n("loginscreen:open", d),
            n("update:opened", !0)
        }
          , l = d => {
            n("loginscreen:opened", d)
        }
          , c = d => {
            r = !1,
            o = !0,
            n("loginscreen:close", d)
        }
          , u = d => {
            o = !1,
            n("loginscreen:closed", d),
            n("update:opened", !1)
        }
        ;
        st( () => e.opened, d => {
            a.value && (d ? a.value.open() : a.value.close())
        }
        ),
        Xe( () => {
            i.value && ut( () => {
                const d = {
                    el: i.value,
                    on: {
                        open: s,
                        opened: l,
                        close: c,
                        closed: u
                    }
                };
                typeof e.animate < "u" && (d.animate = e.animate),
                typeof e.containerEl < "u" && (d.containerEl = e.containerEl),
                a.value = D.loginScreen.create(d),
                e.opened && a.value.open(!1)
            }
            )
        }
        ),
        lt( () => {
            a.value && a.value.destroy(),
            a.value = null
        }
        );
        const f = ae( () => Oe("login-screen", Ys({
            isOpened: r,
            isClosing: o
        }), je(e)));
        return {
            elRef: i,
            classes: f
        }
    }
}
  , n6 = {
    name: "f7-sheet",
    props: {
        opened: Boolean,
        animate: {
            type: Boolean,
            default: void 0
        },
        top: Boolean,
        bottom: Boolean,
        position: String,
        backdrop: {
            type: Boolean,
            default: void 0
        },
        backdropEl: {
            type: [String, Object],
            default: void 0
        },
        closeByBackdropClick: {
            type: Boolean,
            default: void 0
        },
        closeByOutsideClick: {
            type: Boolean,
            default: void 0
        },
        closeOnEscape: {
            type: Boolean,
            default: void 0
        },
        push: Boolean,
        swipeToClose: {
            type: Boolean,
            default: void 0
        },
        swipeToStep: {
            type: Boolean,
            default: void 0
        },
        swipeHandler: {
            type: [String, Object],
            default: void 0
        },
        containerEl: {
            type: [String, Object],
            default: void 0
        },
        ...qe
    },
    emits: ["sheet:stepprogress", "sheet:stepopen", "sheet:stepclose", "sheet:open", "sheet:opened", "sheet:close", "sheet:closed", "update:opened"],
    setup(e, t) {
        let {emit: n, slots: a} = t
          , r = null
          , o = e.opened
          , i = !1;
        const s = oe(null)
          , l = (b, v) => {
            n("sheet:stepprogress", b, v)
        }
          , c = b => {
            n("sheet:stepopen", b)
        }
          , u = b => {
            n("sheet:stepclose", b)
        }
          , f = b => {
            o = !0,
            i = !1,
            n("sheet:open", b),
            n("update:opened", !0)
        }
          , d = b => {
            n("sheet:opened", b)
        }
          , p = b => {
            o = !1,
            i = !0,
            n("sheet:close", b)
        }
          , h = b => {
            i = !1,
            n("sheet:closed", b),
            n("update:opened", !1)
        }
        ;
        Xe( () => {
            if (!s.value)
                return;
            const b = {
                el: s.value,
                on: {
                    open: f,
                    opened: d,
                    close: p,
                    closed: h,
                    stepOpen: c,
                    stepClose: u,
                    stepProgress: l
                }
            }
              , {animate: v, backdrop: y, backdropEl: w, closeByBackdropClick: C, closeByOutsideClick: _, closeOnEscape: E, swipeToClose: z, swipeToStep: T, swipeHandler: A, containerEl: x} = e;
            typeof v < "u" && (b.animate = v),
            typeof y < "u" && (b.backdrop = y),
            typeof w < "u" && (b.backdropEl = w),
            typeof C < "u" && (b.closeByBackdropClick = C),
            typeof _ < "u" && (b.closeByOutsideClick = _),
            typeof E < "u" && (b.closeOnEscape = E),
            typeof z < "u" && (b.swipeToClose = z),
            typeof T < "u" && (b.swipeToStep = T),
            typeof A < "u" && (b.swipeHandler = A),
            typeof x < "u" && (b.containerEl = x),
            ut( () => {
                r = D.sheet.create(b),
                e.opened && r.open(!1)
            }
            )
        }
        ),
        lt( () => {
            r && r.destroy(),
            r = null
        }
        ),
        st( () => e.opened, b => {
            r && (b ? r.open() : r.close())
        }
        ),
        ["closeByBackdropClick", "closeByOutsideClick", "closeOnEscape", "swipeToClose"].forEach(b => {
            st( () => e[b], v => {
                r && (r.params[b] = v)
            }
            )
        }
        );
        const m = ae( () => {
            let b = "bottom";
            return e.position ? b = e.position : e.top ? b = "top" : e.bottom && (b = "bottom"),
            Oe("sheet-modal", `sheet-modal-${b}`, {
                "sheet-modal-push": e.push
            }, Ys({
                isOpened: o,
                isClosing: i
            }), je(e))
        }
        )
          , g = "navbar toolbar tabbar subnavbar searchbar messagebar fab list-index panel".split(" ").map(b => `f7-${b}`);
        return () => {
            const b = []
              , v = [];
            return a.default && a.default().forEach(y => {
                if (typeof y > "u")
                    return;
                const w = y.type && y.type.name ? y.type.name : y.type;
                g.indexOf(w) >= 0 ? b.push(y) : v.push(y)
            }
            ),
            Pe("div", {
                class: m.value,
                ref: s
            }, [b, a.fixed && a.fixed(), Pe("div", {
                class: "sheet-modal-inner"
            }, [v, a.static && a.static()])])
        }
    }
}
  , uC = V("div", {
    class: "popover-angle"
}, null, -1)
  , fC = {
    class: "popover-inner"
};
function dC(e, t) {
    return O(),
    G("div", {
        ref: "elRef",
        class: Ae(e.classes)
    }, [uC, V("div", fC, [ce(e.$slots, "default")])], 2)
}
const a6 = {
    name: "f7-popover",
    render: dC,
    props: {
        opened: Boolean,
        animate: {
            type: Boolean,
            default: void 0
        },
        targetEl: {
            type: [String, Object],
            default: void 0
        },
        backdrop: {
            type: Boolean,
            default: void 0
        },
        backdropEl: {
            type: [String, Object],
            default: void 0
        },
        closeByBackdropClick: {
            type: Boolean,
            default: void 0
        },
        closeByOutsideClick: {
            type: Boolean,
            default: void 0
        },
        closeOnEscape: {
            type: Boolean,
            default: void 0
        },
        containerEl: {
            type: [String, Object],
            default: void 0
        },
        verticalPosition: {
            type: String,
            default: void 0
        },
        ...qe
    },
    emits: ["popover:open", "popover:opened", "popover:close", "popover:closed", "update:opened"],
    setup(e, t) {
        let {emit: n} = t;
        const a = oe(null);
        let r = e.opened
          , o = !1;
        const i = oe(null)
          , s = d => {
            r = !0,
            o = !1,
            n("popover:open", d),
            n("update:opened", !0)
        }
          , l = d => {
            n("popover:opened", d)
        }
          , c = d => {
            r = !1,
            o = !0,
            n("popover:close", d)
        }
          , u = d => {
            o = !1,
            n("popover:closed", d),
            n("update:opened", !1)
        }
        ;
        st( () => e.opened, d => {
            a.value && (d ? a.value.open() : a.value.close())
        }
        ),
        Xe( () => {
            if (!i.value)
                return;
            const d = {
                el: i.value,
                on: {
                    open: s,
                    opened: l,
                    close: c,
                    closed: u
                }
            }
              , {targetEl: p, closeByBackdropClick: h, closeByOutsideClick: m, closeOnEscape: g, backdrop: b, backdropEl: v, containerEl: y, verticalPosition: w} = e;
            typeof p < "u" && (d.targetEl = p),
            typeof h < "u" && (d.closeByBackdropClick = h),
            typeof m < "u" && (d.closeByOutsideClick = m),
            typeof g < "u" && (d.closeOnEscape = g),
            typeof b < "u" && (d.backdrop = b),
            typeof v < "u" && (d.backdropEl = v),
            typeof y < "u" && (d.containerEl = y),
            typeof w < "u" && (d.verticalPosition = w),
            ut( () => {
                a.value = D.popover.create(d),
                e.opened && a.value.open(p, !1)
            }
            )
        }
        ),
        lt( () => {
            a.value && a.value.destroy(),
            a.value = null
        }
        );
        const f = ae( () => Oe("popover", Ys({
            isOpened: r,
            isClosing: o
        }), je(e)));
        return {
            elRef: i,
            classes: f
        }
    }
}
  , pC = {
    key: 0,
    class: "panel-resize-handler"
};
function hC(e, t) {
    return O(),
    G("div", {
        ref: "elRef",
        class: Ae(e.classes)
    }, [ce(e.$slots, "default"), e.resizable ? (O(),
    G("div", pC)) : pe("", !0)], 2)
}
const r6 = {
    name: "f7-panel",
    render: hC,
    props: {
        side: String,
        effect: String,
        cover: Boolean,
        reveal: Boolean,
        push: Boolean,
        left: Boolean,
        right: Boolean,
        opened: Boolean,
        resizable: Boolean,
        backdrop: {
            type: Boolean,
            default: !0
        },
        backdropEl: {
            type: String,
            default: void 0
        },
        containerEl: {
            type: String,
            default: void 0
        },
        closeByBackdropClick: {
            type: Boolean,
            default: void 0
        },
        visibleBreakpoint: {
            type: Number,
            default: void 0
        },
        collapsedBreakpoint: {
            type: Number,
            default: void 0
        },
        swipe: Boolean,
        swipeNoFollow: Boolean,
        swipeOnlyClose: Boolean,
        swipeActiveArea: {
            type: Number,
            default: 0
        },
        swipeThreshold: {
            type: Number,
            default: 0
        },
        ...qe
    },
    emits: ["panel:open", "panel:opened", "panel:close", "panel:closed", "click", "panel:backdropclick", "panel:swipe", "panel:swipeopen", "panel:breakpoint", "panel:collapsedbreakpoint", "panel:resize", "update:opened"],
    setup(e, t) {
        let {emit: n} = t
          , a = null;
        const r = oe(null);
        let o = !1
          , i = !1
          , s = !1
          , l = !1;
        const c = w => {
            o = !0,
            i = !1,
            n("panel:open", w),
            n("update:opened", !0)
        }
          , u = w => {
            n("panel:opened", w)
        }
          , f = w => {
            o = !1,
            i = !0,
            n("panel:close", w)
        }
          , d = w => {
            i = !1,
            n("panel:closed", w),
            n("update:opened", !1)
        }
          , p = w => {
            n("click", w),
            n("panel:backdropclick", w)
        }
          , h = w => {
            n("panel:swipe", w)
        }
          , m = w => {
            n("panel:swipeopen", w)
        }
          , g = w => {
            l = !0,
            s = !1,
            n("panel:breakpoint", w)
        }
          , b = w => {
            l = !1,
            s = !0,
            n("panel:collapsedbreakpoint", w)
        }
          , v = function() {
            for (var w = arguments.length, C = new Array(w), _ = 0; _ < w; _++)
                C[_] = arguments[_];
            n("panel:resize", ...C)
        };
        st( () => e.resizable, w => {
            a && (w ? a.enableResizable() : a.disableResizable())
        }
        ),
        st( () => e.opened, w => {
            a && (w ? a.open() : a.close())
        }
        ),
        Xe( () => {
            ut( () => {
                const w = D.$;
                if (!w)
                    return;
                w(".panel-backdrop").length === 0 && w('<div class="panel-backdrop"></div>').insertBefore(r.value);
                const C = aa({
                    el: r.value,
                    resizable: e.resizable,
                    backdrop: e.backdrop,
                    backdropEl: e.backdropEl,
                    containerEl: e.containerEl,
                    closeByBackdropClick: e.containerEl,
                    visibleBreakpoint: e.visibleBreakpoint,
                    collapsedBreakpoint: e.collapsedBreakpoint,
                    swipe: e.swipe,
                    swipeNoFollow: e.swipeNoFollow,
                    swipeOnlyClose: e.swipeOnlyClose,
                    swipeActiveArea: e.swipeActiveArea,
                    swipeThreshold: e.swipeThreshold,
                    on: {
                        open: c,
                        opened: u,
                        close: f,
                        closed: d,
                        backdropClick: p,
                        swipe: h,
                        swipeOpen: m,
                        collapsedBreakpoint: b,
                        breakpoint: g,
                        resize: v
                    }
                });
                a = D.panel.create(C),
                e.opened && a.open(!1)
            }
            )
        }
        ),
        lt( () => {
            a && a.destroy && a.destroy(),
            a = null
        }
        );
        const y = ae( () => {
            const w = e.side || (e.left ? "left" : "right")
              , C = e.effect || (e.reveal ? "reveal" : e.push ? "push" : "cover");
            return Oe("panel", {
                "panel-in": o && !i && !l,
                "panel-in-breakpoint": l,
                "panel-in-collapsed": s,
                "panel-resizable": e.resizable,
                [`panel-${w}`]: w,
                [`panel-${C}`]: C
            }, je(e))
        }
        );
        return {
            elRef: r,
            classes: y
        }
    }
}
  , mC = (e, t, n) => {
    const a = {
        url: t,
        route: {
            path: t,
            options: {
                ...n,
                openIn: void 0
            }
        }
    }
      , r = {
        ...n
    };
    if (n.openIn === "popup" && (r.component = {
        setup() {
            return () => Pe(e6, {
                class: "popup-router-open-in",
                "data-url": t
            }, [Pe(Uo, {
                linksView: e.view.selector,
                url: t,
                ignoreOpenIn: !0
            })])
        }
    },
    a.route.popup = r),
    n.openIn === "loginScreen" && (r.component = {
        setup() {
            return () => Pe(t6, {
                class: "login-screen-router-open-in",
                "data-url": t
            }, [Pe(Uo, {
                linksView: e.view.selector,
                url: t,
                ignoreOpenIn: !0
            })])
        }
    },
    a.route.loginScreen = r),
    n.openIn === "sheet" && (r.component = {
        setup() {
            return () => Pe(n6, {
                class: "sheet-modal-router-open-in",
                "data-url": t
            }, [Pe(Uo, {
                linksView: e.view.selector,
                url: t,
                ignoreOpenIn: !0
            })])
        }
    },
    a.route.sheet = r),
    n.openIn === "popover" && (r.targetEl = n.clickedEl || n.targetEl,
    r.component = {
        setup() {
            return () => Pe(a6, {
                class: "popover-router-open-in",
                "data-url": t,
                targetEl: n.clickedEl || n.targetEl
            }, [Pe(Uo, {
                linksView: e.view.selector,
                url: t,
                ignoreOpenIn: !0
            })])
        }
    },
    a.route.popover = r),
    n.openIn.indexOf("panel") >= 0) {
        const o = n.openIn.split(":")
          , i = o[1] || "left"
          , s = o[2] || "cover";
        r.component = {
            setup() {
                return () => Pe(r6, {
                    class: "panel-router-open-in",
                    "data-url": t,
                    side: i,
                    effect: s
                }, [Pe(Uo, {
                    linksView: e.view.selector,
                    url: t,
                    ignoreOpenIn: !0
                })])
            }
        },
        a.route.panel = r
    }
    return e.navigate(a)
}
  , z3 = e => {
    const t = [];
    for (let n = 0; n < e.children.length; n += 1)
        t.push(e.children[n]);
    return t
}
  , gC = (e, t) => e.length !== t.length ? !1 : new Set([...e, ...t]).size === e.length
  , vC = {
    proto: {
        openIn(e, t, n) {
            return mC(e, t, n)
        },
        pageComponentLoader(e) {
            let {routerEl: t, component: n, options: a, resolve: r, reject: o} = e;
            const i = this
              , s = i.id
              , l = t;
            let c;
            if (tn.views.forEach(h => {
                (h.el && h.el === t || h.routerId && h.routerId === s) && (c = h)
            }
            ),
            !c) {
                o();
                return
            }
            const u = {
                component: n,
                id: fs(),
                props: Tn({
                    f7route: a.route,
                    f7router: i
                }, a.route.params, a.props || {})
            };
            let f;
            const d = z3(l);
            function p(h) {
                if (h !== c || f)
                    return;
                const m = z3(l);
                if (gC(d, m))
                    return;
                Nn.off("viewRouterDidUpdate", p);
                const g = l.children[l.children.length - 1];
                u.el = g,
                r(g),
                f = !0
            }
            Nn.on("viewRouterDidUpdate", p),
            c.pages.push(u),
            c.setPages(c.pages)
        },
        removePage(e) {
            if (!e)
                return;
            const t = this;
            let n;
            if ("length"in e && e[0] ? n = e[0].f7Page : n = e.f7Page,
            n && n.route && n.route.route && n.route.route.keepAlive) {
                t.app.$(e).remove();
                return
            }
            let a;
            tn.views.forEach(i => {
                i.el && i.el === t.el && (a = i)
            }
            );
            let r;
            if ("length"in e) {
                if (e.length === 0)
                    return;
                r = e[0]
            } else
                r = e;
            if (!r)
                return;
            let o;
            a.pages.forEach( (i, s) => {
                i.el === r && (o = !0,
                a.pages.splice(s, 1),
                a.setPages(a.pages))
            }
            ),
            o || r.parentNode.removeChild(r)
        },
        tabComponentLoader(e) {
            let {tabEl: t, component: n, options: a, resolve: r, reject: o} = e === void 0 ? {} : e;
            const i = this;
            t || o();
            let s;
            if (tn.tabs.forEach(d => {
                d.el && d.el === t && (s = d)
            }
            ),
            !s) {
                o();
                return
            }
            const c = {
                id: fs(),
                component: n,
                props: Tn({
                    f7route: a.route,
                    f7router: i
                }, a.route.route && a.route.route.tab && a.route.route.tab.options && a.route.route.tab.options.props || {}, a.route.params, a.props || {})
            };
            let u;
            function f(d) {
                if (d !== s || u)
                    return;
                Nn.off("tabRouterDidUpdate", f);
                const p = t.children[0];
                r(p),
                u = !0
            }
            Nn.on("tabRouterDidUpdate", f),
            s.setTabContent(c)
        },
        removeTabContent(e) {
            if (!e)
                return;
            let t;
            if (tn.tabs.forEach(n => {
                n.el && n.el === e && (t = n)
            }
            ),
            !t) {
                e.innerHTML = "";
                return
            }
            t.setTabContent(null)
        },
        modalComponentLoader(e) {
            let {component: t, options: n, resolve: a, reject: r} = e === void 0 ? {} : e;
            const o = this
              , i = tn.modals;
            if (!i) {
                r();
                return
            }
            const s = {
                component: t,
                id: fs(),
                props: Tn({
                    f7route: n.route,
                    f7router: o
                }, n.route.params, n.props || {})
            };
            let l;
            function c() {
                if (l)
                    return;
                Nn.off("modalsRouterDidUpdate", c);
                const u = i.el.children[i.el.children.length - 1];
                s.el = u,
                a(u),
                l = !0
            }
            Nn.on("modalsRouterDidUpdate", c),
            i.modals.push(s),
            i.setModals(i.modals)
        },
        removeModal(e) {
            const t = tn.modals;
            if (!t)
                return;
            let n;
            t.modals.forEach(a => {
                a.el === e && (n = a)
            }
            ),
            t.modals.splice(t.modals.indexOf(n), 1),
            t.setModals(t.modals)
        }
    }
}
  , Z2 = {
    name: "vuePlugin",
    installed: !1,
    install(e) {
        if (e === void 0 && (e = {}),
        Z2.installed)
            return;
        Z2.installed = !0,
        iC();
        const {theme: t, userAgent: n} = e;
        if (t === "md" && (Ut.md = !0),
        t === "ios" && (Ut.ios = !0),
        t === "aurora" && (Ut.aurora = !0),
        (typeof window > "u" ? !!n : !0) && (!t || t === "auto")) {
            const r = an.getDevice({
                userAgent: n
            }, !0);
            Ut.ios = !!r.ios,
            Ut.aurora = r.desktop && r.electron,
            Ut.md = !Ut.ios && !Ut.aurora
        }
        ut( () => {
            Q7()
        }
        ),
        an.Router.use(vC)
    }
};
function bC(e, t) {
    return O(),
    G("div", {
        class: Ae(e.classes)
    }, [ce(e.$slots, "default")], 2)
}
const yC = {
    name: "f7-accordion-content",
    render: bC,
    props: {
        ...qe
    },
    setup(e) {
        return {
            classes: ae( () => Oe("accordion-item-content", je(e)))
        }
    }
};
function CC(e, t) {
    return O(),
    G("div", {
        ref: "elRef",
        class: Ae(e.classes)
    }, [ce(e.$slots, "default")], 2)
}
const wC = {
    name: "f7-accordion-item",
    render: CC,
    props: {
        opened: Boolean,
        ...qe
    },
    emits: ["accordion:beforeopen", "accordion:open", "accordion:opened", "accordion:beforeclose", "accordion:close", "accordion:closed"],
    setup(e, t) {
        let {emit: n} = t;
        const a = oe(null)
          , r = (p, h) => {
            a.value === p && n("accordion:beforeopen", h)
        }
          , o = p => {
            a.value === p && n("accordion:open")
        }
          , i = p => {
            a.value === p && n("accordion:opened")
        }
          , s = (p, h) => {
            a.value === p && n("accordion:beforeclose", h)
        }
          , l = p => {
            a.value === p && n("accordion:close")
        }
          , c = p => {
            a.value === p && n("accordion:closed")
        }
          , u = () => {
            ut( () => {
                D.on("accordionBeforeOpen", r),
                D.on("accordionOpen", o),
                D.on("accordionOpened", i),
                D.on("accordionBeforeClose", s),
                D.on("accordionClose", l),
                D.on("accordionClosed", c)
            }
            )
        }
          , f = () => {
            D.off("accordionBeforeOpen", r),
            D.off("accordionOpen", o),
            D.off("accordionOpened", i),
            D.off("accordionBeforeClose", s),
            D.off("accordionClose", l),
            D.off("accordionClosed", c)
        }
        ;
        Xe( () => u()),
        lt( () => f());
        const d = ae( () => Oe("accordion-item", {
            "accordion-item-opened": e.opened
        }, je(e)));
        return {
            elRef: a,
            classes: d
        }
    }
};
function _C(e, t) {
    return O(),
    G("div", {
        class: Ae(e.classes)
    }, [ce(e.$slots, "default")], 2)
}
const kC = {
    name: "f7-accordion-toggle",
    render: _C,
    props: {
        ...qe
    },
    setup(e) {
        return {
            classes: ae( () => Oe("accordion-item-toggle", je(e)))
        }
    }
};
function SC(e, t) {
    return O(),
    G("div", {
        class: Ae(e.classes)
    }, [ce(e.$slots, "default")], 2)
}
const $C = {
    name: "f7-accordion",
    render: SC,
    props: {
        accordionOpposite: Boolean,
        ...qe
    },
    setup(e) {
        return {
            classes: ae( () => Oe("accordion-list", e.accordionOpposite && "accordion-opposite", je(e)))
        }
    }
}
  , EC = {
    key: 0,
    class: "actions-button-media"
}
  , xC = {
    class: "actions-button-text"
};
function TC(e, t) {
    return O(),
    G("div", {
        ref: "elRef",
        class: Ae(e.classes),
        onClick: t[0] || (t[0] = function() {
            return e.onClick && e.onClick(...arguments)
        }
        )
    }, [e.hasMedia ? (O(),
    G("div", EC, [ce(e.$slots, "media")])) : pe("", !0), V("div", xC, [ce(e.$slots, "default")])], 2)
}
const MC = {
    name: "f7-actions-button",
    render: TC,
    props: {
        bold: Boolean,
        close: {
            type: Boolean,
            default: !0
        },
        ...qe
    },
    emits: ["click"],
    setup(e, t) {
        let {slots: n, emit: a} = t;
        const r = oe(null)
          , o = l => {
            r.value && e.close && D && D.actions.close(D.$(r.value).parents(".actions-modal")),
            a("click", l)
        }
          , i = ae( () => n && !!n.media);
        return {
            classes: ae( () => Oe({
                "actions-button": !0,
                "actions-button-bold": e.bold
            }, je(e))),
            elRef: r,
            hasMedia: i,
            onClick: o
        }
    }
};
function zC(e, t) {
    return O(),
    G("div", {
        class: Ae(e.classes)
    }, [ce(e.$slots, "default")], 2)
}
const AC = {
    name: "f7-actions-group",
    render: zC,
    props: {
        ...qe
    },
    setup(e) {
        return {
            classes: ae( () => Oe("actions-group", je(e)))
        }
    }
};
function OC(e, t) {
    return O(),
    G("div", {
        class: Ae(e.classes),
        onClick: t[0] || (t[0] = function() {
            return e.onClick && e.onClick(...arguments)
        }
        )
    }, [ce(e.$slots, "default")], 2)
}
const PC = {
    name: "f7-actions-label",
    render: OC,
    props: {
        bold: Boolean,
        ...qe
    },
    emits: ["click"],
    setup(e, t) {
        let {emit: n} = t;
        const a = o => {
            n("click", o)
        }
        ;
        return {
            classes: ae( () => Oe("actions-label", {
                "actions-button-bold": e.bold
            }, je(e))),
            onClick: a
        }
    }
};
function LC(e, t) {
    return O(),
    G("div", {
        ref: "elRef",
        class: Ae(e.classes)
    }, [ce(e.$slots, "default")], 2)
}
const IC = {
    name: "f7-actions",
    render: LC,
    props: {
        tabletFullscreen: Boolean,
        opened: Boolean,
        animate: {
            type: Boolean,
            default: void 0
        },
        grid: Boolean,
        target: {
            type: [String, Object],
            default: void 0
        },
        convertToPopover: {
            type: Boolean,
            default: void 0
        },
        forceToPopover: {
            type: Boolean,
            default: void 0
        },
        backdrop: {
            type: Boolean,
            default: void 0
        },
        backdropEl: {
            type: [String, Object],
            default: void 0
        },
        closeByBackdropClick: {
            type: Boolean,
            default: void 0
        },
        closeByOutsideClick: {
            type: Boolean,
            default: void 0
        },
        closeOnEscape: {
            type: Boolean,
            default: void 0
        },
        containerEl: {
            type: [String, Object],
            default: void 0
        },
        ...qe
    },
    emits: ["actions:open", "actions:opened", "actions:close", "actions:closed", "update:opened"],
    setup(e, t) {
        let {emit: n} = t
          , a = null
          , r = e.opened
          , o = !1;
        const i = oe(null)
          , s = d => {
            r = !0,
            o = !1,
            n("actions:open", d),
            n("update:opened", !0)
        }
          , l = d => {
            n("actions:opened", d)
        }
          , c = d => {
            r = !1,
            o = !0,
            n("actions:close", d)
        }
          , u = d => {
            o = !1,
            n("actions:closed", d),
            n("update:opened", !1)
        }
        ;
        st( () => e.opened, d => {
            a && (d ? a.open() : a.close())
        }
        ),
        Xe( () => {
            if (!i.value)
                return;
            const {target: d, convertToPopover: p, forceToPopover: h, closeByBackdropClick: m, closeByOutsideClick: g, closeOnEscape: b, backdrop: v, backdropEl: y, grid: w, containerEl: C} = e
              , _ = {
                el: i.value,
                grid: w,
                on: {
                    open: s,
                    opened: l,
                    close: c,
                    closed: u
                }
            };
            typeof d < "u" && (_.target = d),
            typeof p < "u" && (_.convertToPopover = p),
            typeof h < "u" && (_.forceToPopover = h),
            typeof m < "u" && (_.closeByBackdropClick = m),
            typeof g < "u" && (_.closeByOutsideClick = g),
            typeof b < "u" && (_.closeOnEscape = b),
            typeof v < "u" && (_.backdrop = v),
            typeof y < "u" && (_.backdropEl = y),
            typeof C < "u" && (_.containerEl = C),
            ut( () => {
                a = D.popup.create(_),
                e.opened && a.open(!1)
            }
            )
        }
        ),
        lt( () => {
            a && a.destroy(),
            a = null
        }
        );
        const f = ae( () => Oe("actions-modal", {
            "actions-grid": e.grid
        }, Ys({
            isOpened: r,
            isClosing: o
        }), je(e)));
        return {
            elRef: i,
            classes: f
        }
    }
}
  , o6 = {
    name: "f7-routable-modals",
    setup() {
        const e = oe(null)
          , t = oe([])
          , n = oe(null);
        Xe( () => {
            n.value = {
                modals: t,
                el: e.value,
                setModals(o) {
                    o.forEach(i => {
                        i.component = rt(i.component)
                    }
                    ),
                    t.value = [...o]
                }
            },
            tn.modals = n.value
        }
        ),
        On( () => {
            !n.value || !D || Nn.emit("modalsRouterDidUpdate", n.value)
        }
        ),
        lt( () => {
            n.value && (tn.modals = null,
            n.value = null)
        }
        );
        const a = o => rt(o.component)
          , r = o => {
            const {component: i, props: s} = o;
            let l = [];
            const c = {};
            return i && i.props && (l = Object.keys(i.props)),
            l.forEach(u => {
                u in s && (c[u] = s[u])
            }
            ),
            c
        }
        ;
        return () => Pe("div", {
            ref: e,
            class: "framework7-modals"
        }, [...t.value.map(o => Pe(a(o), {
            key: o.id,
            ...r(o)
        }))])
    }
};
function BC(e, t) {
    const n = P("routable-modals");
    return O(),
    G("div", {
        id: "framework7-root",
        ref: "elRef",
        class: Ae(e.classes)
    }, [ce(e.$slots, "default"), S(n)], 2)
}
const RC = {
    name: "f7-app",
    render: BC,
    components: {
        RoutableModals: o6
    },
    inheritAttrs: !1,
    props: {
        id: {
            type: String,
            default: void 0
        },
        name: {
            type: String,
            default: void 0
        },
        version: {
            type: String,
            default: void 0
        },
        theme: {
            type: String,
            default: void 0
        },
        language: {
            type: String,
            default: void 0
        },
        routes: {
            type: Array,
            default: () => []
        },
        store: Object,
        autoDarkMode: {
            type: Boolean,
            default: void 0
        },
        lazyModulesPath: {
            type: String,
            default: void 0
        },
        initOnDeviceReady: {
            type: Boolean,
            default: void 0
        },
        iosTranslucentBars: {
            type: Boolean,
            default: void 0
        },
        iosTranslucentModals: {
            type: Boolean,
            default: void 0
        },
        userAgent: {
            type: String,
            default: void 0
        },
        url: {
            type: String,
            default: void 0
        },
        accordion: {
            type: Object,
            default: () => {}
        },
        actions: {
            type: Object,
            default: () => {}
        },
        areaChart: {
            type: Object,
            default: () => {}
        },
        autocomplete: {
            type: Object,
            default: () => {}
        },
        calendar: {
            type: Object,
            default: () => {}
        },
        card: {
            type: Object,
            default: () => {}
        },
        colorPicker: {
            type: Object,
            default: () => {}
        },
        dialog: {
            type: Object,
            default: () => {}
        },
        form: {
            type: Object,
            default: () => {}
        },
        gauge: {
            type: Object,
            default: () => {}
        },
        grid: {
            type: Object,
            default: () => {}
        },
        infiniteScroll: {
            type: Object,
            default: () => {}
        },
        input: {
            type: Object,
            default: () => {}
        },
        lazy: {
            type: Object,
            default: () => {}
        },
        listIndex: {
            type: Object,
            default: () => {}
        },
        loginScreen: {
            type: Object,
            default: () => {}
        },
        messagebar: {
            type: Object,
            default: () => {}
        },
        messages: {
            type: Object,
            default: () => {}
        },
        navbar: {
            type: Object,
            default: () => {}
        },
        notification: {
            type: Object,
            default: () => {}
        },
        panel: {
            type: Object,
            default: () => {}
        },
        photoBrowser: {
            type: Object,
            default: () => {}
        },
        picker: {
            type: Object,
            default: () => {}
        },
        pieChart: {
            type: Object,
            default: () => {}
        },
        popover: {
            type: Object,
            default: () => {}
        },
        popup: {
            type: Object,
            default: () => {}
        },
        range: {
            type: Object,
            default: () => {}
        },
        searchbar: {
            type: Object,
            default: () => {}
        },
        sheet: {
            type: Object,
            default: () => {}
        },
        smartSelect: {
            type: Object,
            default: () => {}
        },
        sortable: {
            type: Object,
            default: () => {}
        },
        statusbar: {
            type: Object,
            default: () => {}
        },
        stepper: {
            type: Object,
            default: () => {}
        },
        swipeout: {
            type: Object,
            default: () => {}
        },
        textEditor: {
            type: Object,
            default: () => {}
        },
        toast: {
            type: Object,
            default: () => {}
        },
        toolbar: {
            type: Object,
            default: () => {}
        },
        tooltip: {
            type: Object,
            default: () => {}
        },
        view: {
            type: Object,
            default: () => {}
        },
        virtualList: {
            type: Object,
            default: () => {}
        },
        clicks: {
            type: Object,
            default: () => {}
        },
        serviceWorker: {
            type: Object,
            default: () => {}
        },
        touch: {
            type: Object,
            default: () => {}
        },
        ...qe
    },
    setup(e) {
        const t = oe(null)
          , n = rt(e.routes);
        return (!D || typeof window > "u") && M3(t.value, aa({
            ...e,
            routes: n
        }), !1),
        Xe( () => {
            const r = t.value && t.value.parentNode;
            if (typeof document < "u" && r && r !== document.body && r.parentNode === document.body && (r.style.height = "100%"),
            D) {
                D.init(t.value);
                return
            }
            M3(t.value, aa({
                ...e,
                routes: n
            }), !0)
        }
        ),
        {
            classes: ae( () => Oe("framework7-root", je(e))),
            elRef: t
        }
    }
};
function DC(e, t) {
    return O(),
    G("div", {
        class: Ae(e.classes)
    }, [ce(e.$slots, "before-inner"), e.inner ? (O(),
    G("div", {
        key: 0,
        class: Ae(e.innerClasses)
    }, [ce(e.$slots, "default")], 2)) : ce(e.$slots, "default", {
        key: 1
    }), ce(e.$slots, "after-inner")], 2)
}
const NC = {
    name: "f7-appbar",
    render: DC,
    props: {
        noShadow: Boolean,
        noHairline: Boolean,
        inner: {
            type: Boolean,
            default: !0
        },
        innerClass: String,
        innerClassName: String,
        ...qe
    },
    setup(e) {
        const t = ae( () => Oe("appbar", {
            "no-shadow": e.noShadow,
            "no-hairline": e.noHairline
        }, je(e)))
          , n = ae( () => Oe("appbar-inner", e.innerClass, e.innerClassName));
        return {
            classes: t,
            innerClasses: n
        }
    }
}
  , HC = ["width", "height", "viewBox"]
  , VC = ["data-index", "x1", "x2", "y2"]
  , FC = {
    key: 0,
    class: "area-chart-axis"
}
  , jC = {
    key: 0
}
  , UC = {
    key: 1,
    class: "area-chart-legend"
};
function qC(e, t) {
    return O(),
    G("div", {
        ref: "elRef",
        class: Ae(e.classes)
    }, [(O(),
    G("svg", {
        ref: "svgElRef",
        xmlns: "http://www.w3.org/2000/svg",
        width: e.width,
        height: e.height,
        viewBox: `0 0 ${e.width} ${e.height}`,
        preserveAspectRatio: "none"
    }, [(O(!0),
    G(Be, null, vt(e.chartData, (n, a) => (O(),
    K(jn(e.ChartTag), {
        key: `${e.ChartTag}-${a}`,
        fill: e.lineChart ? void 0 : n.color,
        stroke: e.lineChart ? n.color : void 0,
        "fill-rule": "evenodd",
        points: e.lineChart ? void 0 : n.points,
        d: e.lineChart ? n.points : void 0
    }, null, 8, ["fill", "stroke", "points", "d"]))), 128)), (O(!0),
    G(Be, null, vt(e.verticalLines, (n, a) => (O(),
    G("line", {
        key: `line-${a}`,
        "data-index": a,
        fill: "#000",
        x1: n,
        y1: 0,
        x2: n,
        y2: e.height,
        class: Ae(e.classNames({
            "area-chart-current-line": e.currentIndex === a
        }))
    }, null, 10, VC))), 128))], 8, HC)), e.axis ? (O(),
    G("div", FC, [(O(!0),
    G(Be, null, vt(e.axisLabels, (n, a) => (O(),
    G("span", {
        key: a
    }, [e.visibleLegends.includes(n) ? (O(),
    G("span", jC, Me(e.formatAxisLabelMethod(n)), 1)) : pe("", !0)]))), 128))])) : pe("", !0), e.legend ? (O(),
    G("div", UC, [(O(!0),
    G(Be, null, vt(e.datasets, (n, a) => (O(),
    K(jn(e.LegendItemTag), {
        key: a,
        class: Ae(e.classNames("area-chart-legend-item", {
            "area-chart-legend-item-hidden": e.hiddenDatasets.includes(a),
            "area-chart-legend-button": e.toggleDatasets
        })),
        type: e.toggleDatasets ? "button" : void 0,
        onClick: r => e.toggleDataset(a)
    }, {
        default: k( () => [V("span", {
            style: Rt({
                backgroundColor: n.color
            })
        }, null, 4), J(" " + Me(e.formatLegendLabelMethod(n.label)), 1)]),
        _: 2
    }, 1032, ["class", "type", "onClick"]))), 128))])) : pe("", !0), ce(e.$slots, "default")], 2)
}
const WC = {
    name: "f7-area-chart",
    render: qC,
    props: {
        lineChart: Boolean,
        datasets: {
            type: Array,
            default: () => []
        },
        axis: Boolean,
        axisLabels: {
            type: Array,
            default: () => []
        },
        tooltip: Boolean,
        legend: Boolean,
        toggleDatasets: Boolean,
        width: {
            type: Number,
            default: 640
        },
        height: {
            type: Number,
            default: 320
        },
        maxAxisLabels: {
            type: Number,
            default: 8
        },
        formatAxisLabel: Function,
        formatLegendLabel: Function,
        formatTooltip: Function,
        formatTooltipAxisLabel: Function,
        formatTooltipTotal: Function,
        formatTooltipDataset: Function
    },
    emits: ["select"],
    setup(e, t) {
        let {emit: n} = t
          , a = null;
        const r = oe(null)
          , o = oe([])
          , i = oe(null)
          , s = oe(null)
          , l = oe(null)
          , c = ae( () => {
            if (!e.maxAxisLabels || e.axisLabels.length <= e.maxAxisLabels)
                return e.axisLabels;
            const T = Math.ceil(e.axisLabels.length / e.maxAxisLabels);
            return e.axisLabels.filter( (x, M) => M % T === 0)
        }
        )
          , u = ae( () => {
            const T = [];
            return e.datasets.filter( (A, x) => !o.value.includes(x)).forEach(A => {
                let {values: x} = A;
                x.forEach( (M, L) => {
                    T[L] || (T[L] = 0),
                    T[L] += M
                }
                )
            }
            ),
            T
        }
        )
          , f = ae( () => {
            const {datasets: T, lineChart: A, width: x, height: M} = e
              , L = [];
            if (!T.length)
                return L;
            const U = T[0].values.map( () => 0);
            let Y = 0;
            return A ? T.forEach(H => {
                let {values: W} = H;
                const j = Math.max(...W);
                j > Y && (Y = j)
            }
            ) : Y = Math.max(...u.value),
            T.filter( (H, W) => !o.value.includes(W)).forEach(H => {
                let {label: W, values: j, color: Q} = H;
                const ne = j.map( (re, ve) => {
                    U[ve] += re;
                    const Ne = A ? re : U[ve]
                      , Ge = ve / (j.length - 1) * x
                      , Ye = M - Ne / Y * M;
                    return A ? `${ve === 0 ? "M" : "L"}${Ge},${Ye}` : `${Ge} ${Ye}`
                }
                );
                A || ne.push(`${x} ${M} 0 ${M}`),
                L.push({
                    label: W,
                    points: ne.join(" "),
                    color: Q
                })
            }
            ),
            L.reverse()
        }
        )
          , d = ae( () => {
            const T = [];
            if (!e.datasets.length)
                return T;
            const A = e.datasets[0].values;
            return A.forEach( (x, M) => {
                const L = M / (A.length - 1) * e.width;
                T.push(L)
            }
            ),
            T
        }
        )
          , p = T => {
            e.toggleDatasets && (o.value.includes(T) ? o.value.splice(o.value.indexOf(T), 1) : o.value.push(T),
            o.value = [...o.value])
        }
          , h = T => e.formatAxisLabel ? e.formatAxisLabel(T) : T
          , m = T => e.formatLegendLabel ? e.formatLegendLabel(T) : T
          , g = () => {
            const T = s.value.querySelectorAll("line");
            l.value = [];
            for (let A = 0; A < T.length; A += 1)
                l.value.push(T[A].getBoundingClientRect().left)
        }
          , b = () => {
            const T = r.value;
            if (T === null)
                return "";
            let A = 0;
            const x = e.datasets.filter( (Y, H) => !o.value.includes(H)).map(Y => ({
                color: Y.color,
                label: Y.label,
                value: Y.values[T]
            }));
            if (x.forEach(Y => {
                A += Y.value
            }
            ),
            e.formatTooltip)
                return e.formatTooltip({
                    index: T,
                    total: A,
                    datasets: x
                });
            let M = e.formatTooltipAxisLabel ? e.formatTooltipAxisLabel(e.axisLabels[T]) : h(e.axisLabels[T]);
            M || (M = "");
            const L = e.formatTooltipTotal ? e.formatTooltipTotal(A) : A
              , U = x.length > 0 ? `
      <ul class="area-chart-tooltip-list">
        ${x.map(Y => {
                let {label: H, color: W, value: j} = Y;
                const Q = e.formatTooltipDataset ? e.formatTooltipDataset(H, j, W) : `${H}: ${j}`;
                return `
              <li><span style="background-color: ${W};"></span>${Q}</li>
            `
            }
            ).join("")}
      </ul>` : "";
            return `
      <div class="area-chart-tooltip-label">${M}</div>
      <div class="area-chart-tooltip-total">${L}</div>
      ${U}
    `
        }
          , v = () => {
            const {tooltip: T, datasets: A} = e
              , x = r.value;
            if (!T)
                return;
            if (!(A.filter( (L, U) => !o.value.includes(U)).length > 0)) {
                a && a.hide && a.hide();
                return
            }
            if (x !== null && !a) {
                a = D.tooltip.create({
                    trigger: "manual",
                    containerEl: i.value,
                    targetEl: s.value.querySelector(`line[data-index="${x}"]`),
                    text: b(),
                    cssClass: "area-chart-tooltip"
                }),
                a && a.show && a.show();
                return
            }
            !a || !a.hide || !a.show || (x !== null ? (a.setText(b()),
            a.setTargetEl(s.value.querySelector(`line[data-index="${x}"]`)),
            a.show()) : a.hide())
        }
          , y = () => {
            g()
        }
          , w = T => {
            l.value || g();
            let A = T.pageX;
            typeof A > "u" && (A = 0);
            const x = l.value.map(U => Math.abs(A - U))
              , M = Math.min(...x)
              , L = x.indexOf(M);
            r.value = L
        }
          , C = () => {
            r.value = null
        }
        ;
        st( () => r.value, () => {
            n("select", r.value),
            v()
        }
        ),
        Xe( () => {
            s.value && (s.value.addEventListener("mouseenter", y),
            s.value.addEventListener("mousemove", w),
            s.value.addEventListener("mouseleave", C))
        }
        ),
        lt( () => {
            a && a.destroy && a.destroy(),
            a = null,
            s.value && (s.value.removeEventListener("mouseenter", y),
            s.value.removeEventListener("mousemove", w),
            s.value.removeEventListener("mouseleave", C))
        }
        );
        const _ = ae( () => Oe("area-chart"))
          , E = ae( () => e.toggleDatasets ? "button" : "span")
          , z = ae( () => e.lineChart ? "path" : "polygon");
        return {
            currentIndex: r,
            hiddenDatasets: o,
            visibleLegends: c,
            chartData: f,
            verticalLines: d,
            elRef: i,
            svgElRef: s,
            classes: _,
            toggleDataset: p,
            formatAxisLabelMethod: h,
            formatLegendLabelMethod: m,
            LegendItemTag: E,
            ChartTag: z,
            classNames: Oe
        }
    }
}
  , wa = (e, t) => {
    let n = null;
    const {tooltip: a, tooltipTrigger: r} = t;
    Xe( () => {
        e.value && a && ut( () => {
            n = D.tooltip.create({
                targetEl: e.value,
                text: a,
                trigger: r
            })
        }
        )
    }
    ),
    lt( () => {
        n && n.destroy && (n.destroy(),
        n = null)
    }
    ),
    st( () => t.tooltip, o => {
        if (!o && n) {
            n.destroy(),
            n = null;
            return
        }
        if (o && !n && D) {
            n = D.tooltip.create({
                targetEl: e.value,
                text: o,
                trigger: r
            });
            return
        }
        !o || !n || n.setText(o)
    }
    )
}
;
function YC(e, t) {
    return O(),
    G("span", {
        ref: "elRef",
        class: Ae(e.classes)
    }, [ce(e.$slots, "default")], 2)
}
const oc = {
    name: "f7-badge",
    render: YC,
    props: {
        tooltip: String,
        tooltipTrigger: String,
        ...qe
    },
    setup(e) {
        const t = oe(null);
        wa(t, e);
        const n = ae( () => Oe("badge", je(e)));
        return {
            elRef: t,
            classes: n
        }
    }
};
function GC(e, t) {
    return O(),
    G("div", {
        class: Ae(e.classes)
    }, [ce(e.$slots, "default")], 2)
}
const XC = {
    name: "f7-block-footer",
    render: GC,
    props: {
        ...qe
    },
    setup(e) {
        return {
            classes: ae( () => Oe("block-footer", je(e)))
        }
    }
};
function KC(e, t) {
    return O(),
    G("div", {
        class: Ae(e.classes)
    }, [ce(e.$slots, "default")], 2)
}
const ZC = {
    name: "f7-block-header",
    render: KC,
    props: {
        ...qe
    },
    setup(e) {
        return {
            classes: ae( () => Oe("block-header", je(e)))
        }
    }
}
  , JC = ["medium"];
function QC(e, t) {
    return O(),
    G("div", {
        class: Ae(e.classes),
        medium: e.medium
    }, [ce(e.$slots, "default")], 10, JC)
}
const ew = {
    name: "f7-block-title",
    render: QC,
    props: {
        large: Boolean,
        medium: Boolean,
        ...qe
    },
    setup(e) {
        return {
            classes: ae( () => {
                const {large: n, medium: a} = e;
                return Oe("block-title", {
                    "block-title-large": n,
                    "block-title-medium": a
                }, je(e))
            }
            )
        }
    }
};
function tw(e, t) {
    return O(),
    G("div", {
        ref: "elRef",
        class: Ae(e.classes)
    }, [ce(e.$slots, "default")], 2)
}
const aw = {
    name: "f7-block",
    render: tw,
    props: {
        inset: Boolean,
        xsmallInset: Boolean,
        smallInset: Boolean,
        mediumInset: Boolean,
        largeInset: Boolean,
        xlargeInset: Boolean,
        strong: Boolean,
        tabs: Boolean,
        tab: Boolean,
        tabActive: Boolean,
        accordionList: Boolean,
        accordionOpposite: Boolean,
        noHairlines: Boolean,
        noHairlinesMd: Boolean,
        noHairlinesIos: Boolean,
        noHairlinesAurora: Boolean,
        ...qe
    },
    emits: ["tab:hide", "tab:show"],
    setup(e, t) {
        let {emit: n} = t;
        const a = oe(null);
        Gs(a, n);
        const r = ae( () => {
            const {inset: o, xsmallInset: i, smallInset: s, mediumInset: l, largeInset: c, xlargeInset: u, strong: f, accordionList: d, accordionOpposite: p, tabs: h, tab: m, tabActive: g, noHairlines: b, noHairlinesMd: v, noHairlinesIos: y, noHairlinesAurora: w} = e;
            return Oe("block", {
                inset: o,
                "xsmall-inset": i,
                "small-inset": s,
                "medium-inset": l,
                "large-inset": c,
                "xlarge-inset": u,
                "block-strong": f,
                "accordion-list": d,
                "accordion-opposite": p,
                tabs: h,
                tab: m,
                "tab-active": g,
                "no-hairlines": b,
                "no-hairlines-md": v,
                "no-hairlines-ios": y,
                "no-hairlines-aurora": w
            }, je(e))
        }
        );
        return {
            elRef: a,
            classes: r
        }
    }
}
  , rw = {
    ref: "elRef",
    class: "breadcrumbs-collapsed"
}
  , ow = V("span", null, null, -1);
function iw(e, t) {
    return O(),
    G("div", rw, [ow, ce(e.$slots, "default")], 512)
}
const sw = {
    name: "f7-breadcrumbs-collapsed",
    render: iw,
    props: {},
    setup() {
        return {
            elRef: oe(null)
        }
    }
};
function lw(e, t) {
    return O(),
    G("div", {
        ref: "elRef",
        class: Ae({
            "breadcrumbs-item": !0,
            "breadcrumbs-item-active": e.active
        })
    }, [ce(e.$slots, "default")], 2)
}
const cw = {
    name: "f7-breadcrumbs-item",
    render: lw,
    props: {
        active: Boolean
    },
    setup() {
        return {
            elRef: oe(null)
        }
    }
}
  , uw = {
    ref: "elRef",
    class: "breadcrumbs-separator"
};
function fw(e, t) {
    return O(),
    G("div", uw, null, 512)
}
const dw = {
    name: "f7-breadcrumbs-separator",
    render: fw,
    props: {},
    setup() {
        return {
            elRef: oe(null)
        }
    }
}
  , pw = {
    ref: "elRef",
    class: "breadcrumbs"
};
function hw(e, t) {
    return O(),
    G("div", pw, [ce(e.$slots, "default")], 512)
}
const mw = {
    name: "f7-breadcrumbs",
    render: hw,
    props: {},
    setup() {
        return {
            elRef: oe(null)
        }
    }
}
  , Xs = function(e) {
    e === void 0 && (e = {});
    const {icon: t, iconMaterial: n, iconF7: a, iconMd: r, iconIos: o, iconAurora: i, iconColor: s, iconSize: l, iconBadge: c, badgeColor: u, iconBadgeColor: f} = e;
    return t || n || a || r || o || i ? {
        props: {
            material: n,
            f7: a,
            icon: t,
            md: r,
            ios: o,
            aurora: i,
            color: s,
            size: l
        },
        badge: c || c === 0 ? {
            props: {
                color: u || f
            },
            content: c
        } : null
    } : null
}
  , Ci = function(e, t) {
    let {routeProps: n} = t === void 0 ? {} : t;
    Xe( () => {
        e.value && n && (e.value.f7RouteProps = n)
    }
    ),
    On( () => {
        e.value && n ? e.value.f7RouteProps = n : e.value && e.value.f7RouteProps && delete e.value.f7RouteProps
    }
    )
}
  , Ks = () => {
    const e = oe(D ? Ut : null);
    return D || ut( () => {
        e.value = Ut
    }
    ),
    e
}
  , gw = {
    key: 0,
    class: "preloader-inner"
}
  , vw = V("svg", {
    viewBox: "0 0 36 36"
}, [V("circle", {
    cx: "18",
    cy: "18",
    r: "16"
})], -1)
  , bw = [vw]
  , yw = {
    key: 1,
    class: "preloader-inner"
}
  , Cw = bf('<span class="preloader-inner-line"></span><span class="preloader-inner-line"></span><span class="preloader-inner-line"></span><span class="preloader-inner-line"></span><span class="preloader-inner-line"></span><span class="preloader-inner-line"></span><span class="preloader-inner-line"></span><span class="preloader-inner-line"></span>', 8)
  , ww = [Cw]
  , _w = {
    key: 2,
    class: "preloader-inner"
}
  , kw = V("span", {
    class: "preloader-inner-circle"
}, null, -1)
  , Sw = [kw]
  , $w = {
    key: 3,
    class: "preloader-inner"
};
function Ew(e, t) {
    return O(),
    G("div", {
        class: Ae(e.classes),
        style: Rt(e.style)
    }, [e.theme && e.theme.md ? (O(),
    G("span", gw, bw)) : e.theme && e.theme.ios ? (O(),
    G("span", yw, ww)) : e.theme && e.theme.aurora ? (O(),
    G("span", _w, Sw)) : e.theme ? pe("", !0) : (O(),
    G("span", $w))], 6)
}
const Mf = {
    name: "f7-preloader",
    render: Ew,
    props: {
        size: [Number, String],
        ...qe
    },
    setup(e) {
        const t = Ks()
          , n = ae( () => Oe("preloader", je(e)))
          , a = ae( () => {
            const r = {};
            let o = e.size;
            return o && typeof o == "string" && o.indexOf("px") >= 0 && (o = o.replace("px", "")),
            o && (r.width = `${o}px`,
            r.height = `${o}px`,
            r["--f7-preloader-size"] = `${o}px`),
            r
        }
        );
        return {
            classes: n,
            style: a,
            theme: t
        }
    }
};
function xw(e, t) {
    return O(),
    G("i", {
        ref: "elRef",
        style: Rt({
            fontSize: e.sizeComputed,
            width: e.sizeComputed,
            height: e.sizeComputed
        }),
        class: Ae(e.classesComputed)
    }, [J(Me(e.iconText) + " ", 1), ce(e.$slots, "default")], 6)
}
const i6 = {
    name: "f7-icon",
    render: xw,
    props: {
        material: String,
        f7: String,
        icon: String,
        ios: String,
        aurora: String,
        md: String,
        tooltip: String,
        tooltipTrigger: String,
        size: [String, Number],
        ...qe
    },
    setup(e) {
        const t = oe(null)
          , n = Ks();
        wa(t, e);
        const a = ae( () => {
            const {ios: i, md: s, aurora: l, f7: c, material: u, icon: f} = e;
            let d = {
                icon: !0
            }, p;
            if (n.value && n.value.ios ? p = i : n.value && n.value.md ? p = s : n.value && n.value.aurora && (p = l),
            p) {
                const h = p.split(":")
                  , m = h[0]
                  , g = h[1];
                (m === "material" || m === "f7") && (d["material-icons"] = m === "material",
                d["f7-icons"] = m === "f7"),
                m === "icon" && (d[g] = !0)
            } else
                d = {
                    icon: !0,
                    "material-icons": u,
                    "f7-icons": c
                },
                f && (d[f] = !0);
            return Oe(d, je(e))
        }
        )
          , r = ae( () => {
            let i = e.size;
            return (typeof e.size == "number" || parseFloat(e.size) === e.size * 1) && (i = `${e.size}px`),
            i
        }
        )
          , o = ae( () => {
            const {ios: i, md: s, aurora: l, f7: c, material: u} = e;
            let f = u || c;
            return s && n.value && n.value.md && (s.indexOf("material:") >= 0 || s.indexOf("f7:") >= 0) ? f = s.split(":")[1] : i && n.value && n.value.ios && (i.indexOf("material:") >= 0 || i.indexOf("f7:") >= 0) ? f = i.split(":")[1] : l && n.value && n.value.aurora && (l.indexOf("material:") >= 0 || l.indexOf("f7:") >= 0) && (f = l.split(":")[1]),
            f
        }
        );
        return {
            elRef: t,
            sizeComputed: r,
            classesComputed: a,
            iconText: o
        }
    }
};
function Tw(e, t) {
    const n = P("f7-badge")
      , a = P("f7-icon");
    return O(),
    K(a, c1(Q1(e.icon.props)), {
        default: k( () => [e.icon.badge ? (O(),
        K(n, c1(Un({
            key: 0
        }, e.icon.badge.props)), {
            default: k( () => [J(Me(e.icon.badge.content), 1)]),
            _: 1
        }, 16)) : pe("", !0)]),
        _: 1
    }, 16)
}
const wi = {
    name: "f7-use-icon",
    render: Tw,
    components: {
        f7Icon: i6,
        f7Badge: oc
    },
    props: {
        icon: Object
    }
}
  , Mw = {
    key: 1
}
  , zw = {
    key: 1
};
function Aw(e, t) {
    const n = P("f7-preloader")
      , a = P("f7-use-icon");
    return O(),
    K(jn(e.tag), Un({
        ref: "elRef",
        class: e.classesComputed
    }, e.attrs), {
        default: k( () => [e.preloader ? (O(),
        G(Be, {
            key: 0
        }, [S(n, {
            size: e.preloaderSize,
            color: e.preloaderColor
        }, null, 8, ["size", "color"]), V("span", null, [e.icon ? (O(),
        K(a, {
            key: 0,
            icon: e.icon
        }, null, 8, ["icon"])) : pe("", !0), e.text ? (O(),
        G("span", Mw, Me(e.text), 1)) : pe("", !0), ce(e.$slots, "default")])], 64)) : (O(),
        G(Be, {
            key: 1
        }, [e.icon ? (O(),
        K(a, {
            key: 0,
            icon: e.icon
        }, null, 8, ["icon"])) : pe("", !0), e.text ? (O(),
        G("span", zw, Me(e.text), 1)) : pe("", !0), ce(e.$slots, "default")], 64))]),
        _: 3
    }, 16, ["class"])
}
const Ow = {
    name: "f7-button",
    render: Aw,
    components: {
        f7Preloader: Mf,
        f7UseIcon: wi
    },
    props: {
        text: String,
        tabLink: [Boolean, String],
        tabLinkActive: Boolean,
        type: String,
        href: {
            type: [String, Boolean],
            default: "#"
        },
        target: String,
        round: Boolean,
        roundMd: Boolean,
        roundIos: Boolean,
        roundAurora: Boolean,
        fill: Boolean,
        fillMd: Boolean,
        fillIos: Boolean,
        fillAurora: Boolean,
        large: Boolean,
        largeMd: Boolean,
        largeIos: Boolean,
        largeAurora: Boolean,
        small: Boolean,
        smallMd: Boolean,
        smallIos: Boolean,
        smallAurora: Boolean,
        raised: Boolean,
        raisedMd: Boolean,
        raisedIos: Boolean,
        raisedAurora: Boolean,
        outline: Boolean,
        outlineMd: Boolean,
        outlineIos: Boolean,
        outlineAurora: Boolean,
        active: Boolean,
        disabled: Boolean,
        tooltip: String,
        tooltipTrigger: String,
        preloader: Boolean,
        preloaderSize: [Number, String],
        preloaderColor: String,
        loading: Boolean,
        ...Ws,
        ...qe,
        ...Oo,
        ...Mo
    },
    setup(e) {
        const t = oe(null);
        wa(t, e),
        Ci(t, e);
        const n = ae( () => Xs(e))
          , a = ae( () => e.type === "submit" || e.type === "reset" || e.type === "button" ? "button" : "a")
          , r = ae( () => {
            const {href: i, tabLink: s, target: l, type: c} = e;
            let u = i;
            return i === !0 && (u = "#"),
            (i === !1 || a.value === "button") && (u = void 0),
            Tn({
                href: u,
                target: l,
                type: c,
                "data-tab": xt(s) && s || void 0
            }, zo(e), Po(e))
        }
        )
          , o = ae( () => {
            const {tabLink: i, tabLinkActive: s, round: l, roundMd: c, roundIos: u, roundAurora: f, fill: d, fillMd: p, fillIos: h, fillAurora: m, large: g, largeMd: b, largeIos: v, largeAurora: y, small: w, smallMd: C, smallIos: _, smallAurora: E, raised: z, raisedMd: T, raisedIos: A, raisedAurora: x, outline: M, outlineMd: L, outlineIos: U, outlineAurora: Y, active: H, disabled: W, preloader: j, loading: Q} = e;
            return Oe("button", {
                "tab-link": i || i === "",
                "tab-link-active": s,
                "button-round": l,
                "button-round-ios": u,
                "button-round-aurora": f,
                "button-round-md": c,
                "button-fill": d,
                "button-fill-ios": h,
                "button-fill-aurora": m,
                "button-fill-md": p,
                "button-large": g,
                "button-large-ios": v,
                "button-large-aurora": y,
                "button-large-md": b,
                "button-small": w,
                "button-small-ios": _,
                "button-small-aurora": E,
                "button-small-md": C,
                "button-raised": z,
                "button-raised-ios": A,
                "button-raised-aurora": x,
                "button-raised-md": T,
                "button-active": H,
                "button-outline": M,
                "button-outline-ios": U,
                "button-outline-aurora": Y,
                "button-outline-md": L,
                "button-preloader": j,
                "button-loading": Q,
                disabled: W
            }, je(e), Ao(e), Lo(e))
        }
        );
        return {
            tag: a,
            elRef: t,
            attrs: r,
            classesComputed: o,
            icon: n
        }
    }
};
function Pw(e, t) {
    return O(),
    G("div", {
        class: Ae(e.classes)
    }, [ce(e.$slots, "default")], 2)
}
const s6 = {
    name: "f7-card-content",
    render: Pw,
    props: {
        padding: {
            type: Boolean,
            default: !0
        },
        ...qe
    },
    setup(e) {
        return {
            classes: ae( () => Oe("card-content", {
                "card-content-padding": e.padding
            }, je(e)))
        }
    }
};
function Lw(e, t) {
    return O(),
    G("div", {
        class: Ae(e.classes)
    }, [ce(e.$slots, "default")], 2)
}
const l6 = {
    name: "f7-card-footer",
    render: Lw,
    props: {
        ...qe
    },
    setup(e) {
        return {
            classes: ae( () => Oe("card-footer", je(e)))
        }
    }
};
function Iw(e, t) {
    return O(),
    G("div", {
        class: Ae(e.classes)
    }, [ce(e.$slots, "default")], 2)
}
const c6 = {
    name: "f7-card-header",
    render: Iw,
    props: {
        ...qe
    },
    setup(e) {
        return {
            classes: ae( () => Oe("card-header", je(e)))
        }
    }
}
  , Bw = ["data-animate", "data-hide-navbar-on-open", "data-hide-toolbar-on-open", "data-hide-statusbar-on-open", "data-scrollable-el", "data-swipe-to-close", "data-close-by-backdrop-click", "data-backdrop", "data-backdrop-el"];
function Rw(e, t) {
    const n = P("f7-card-header")
      , a = P("f7-card-content")
      , r = P("f7-card-footer");
    return O(),
    G("div", {
        ref: "elRef",
        class: Ae(e.classes),
        "data-animate": typeof e.animate > "u" ? e.animate : e.animate.toString(),
        "data-hide-navbar-on-open": typeof e.hideNavbarOnOpen > "u" ? e.hideNavbarOnOpen : e.hideNavbarOnOpen.toString(),
        "data-hide-toolbar-on-open": typeof e.hideToolbarOnOpen > "u" ? e.hideToolbarOnOpen : e.hideToolbarOnOpen.toString(),
        "data-hide-statusbar-on-open": typeof e.hideStatusbarOnOpen > "u" ? e.hideStatusbarOnOpen : e.hideStatusbarOnOpen.toString(),
        "data-scrollable-el": e.scrollableEl,
        "data-swipe-to-close": typeof e.swipeToClose > "u" ? e.swipeToClose : e.swipeToClose.toString(),
        "data-close-by-backdrop-click": typeof e.closeByBackdropClick > "u" ? e.closeByBackdropClick : e.closeByBackdropClick.toString(),
        "data-backdrop": typeof e.backdrop > "u" ? e.backdrop : e.backdrop.toString(),
        "data-backdrop-el": e.backdropEl
    }, [e.hasHeader ? (O(),
    K(n, {
        key: 0
    }, {
        default: k( () => [J(Me(e.title) + " ", 1), ce(e.$slots, "header")]),
        _: 3
    })) : pe("", !0), e.hasContent ? (O(),
    K(a, {
        key: 1,
        padding: e.padding
    }, {
        default: k( () => [J(Me(e.content) + " ", 1), ce(e.$slots, "content")]),
        _: 3
    }, 8, ["padding"])) : pe("", !0), e.hasFooter ? (O(),
    K(r, {
        key: 2
    }, {
        default: k( () => [J(Me(e.footer) + " ", 1), ce(e.$slots, "footer")]),
        _: 3
    })) : pe("", !0), ce(e.$slots, "default")], 10, Bw)
}
const Dw = {
    name: "f7-card",
    render: Rw,
    components: {
        f7CardHeader: c6,
        f7CardContent: s6,
        f7CardFooter: l6
    },
    props: {
        title: [String, Number],
        content: [String, Number],
        footer: [String, Number],
        outline: Boolean,
        expandable: Boolean,
        expandableAnimateWidth: Boolean,
        expandableOpened: Boolean,
        animate: {
            type: Boolean,
            default: void 0
        },
        hideNavbarOnOpen: {
            type: Boolean,
            default: void 0
        },
        hideToolbarOnOpen: {
            type: Boolean,
            default: void 0
        },
        hideStatusbarOnOpen: {
            type: Boolean,
            default: void 0
        },
        scrollableEl: {
            type: String,
            default: void 0
        },
        swipeToClose: {
            type: Boolean,
            default: void 0
        },
        closeByBackdropClick: {
            type: Boolean,
            default: void 0
        },
        backdrop: {
            type: Boolean,
            default: void 0
        },
        backdropEl: {
            type: String,
            default: void 0
        },
        noShadow: Boolean,
        noBorder: Boolean,
        padding: {
            type: Boolean,
            default: !0
        },
        ...qe
    },
    emits: ["card:beforeopen", "card:open", "card:opened", "card:close", "card:closed", "update:expandableOpened"],
    setup(e, t) {
        let {emit: n, slots: a} = t;
        const r = oe(null)
          , o = () => {
            r.value && D.card.open(r.value)
        }
          , i = () => {
            r.value && D.card.close(r.value)
        }
          , s = (g, b) => {
            r.value === g && n("card:beforeopen", g, b)
        }
          , l = g => {
            r.value === g && (n("card:open", g),
            n("update:expandableOpened", !0))
        }
          , c = (g, b) => {
            r.value === g && n("card:opened", g, b)
        }
          , u = g => {
            r.value === g && n("card:close", g)
        }
          , f = (g, b) => {
            r.value === g && (n("card:closed", g, b),
            n("update:expandableOpened", !1))
        }
        ;
        Xe( () => {
            !e.expandable || !r.value || ut( () => {
                e.expandable && e.expandableOpened && D.card.open(r.value, !1),
                D.on("cardBeforeOpen", s),
                D.on("cardOpen", l),
                D.on("cardOpened", c),
                D.on("cardClose", u),
                D.on("cardClosed", f)
            }
            )
        }
        ),
        lt( () => {
            D.off("cardBeforeOpen", s),
            D.off("cardOpen", l),
            D.off("cardOpened", c),
            D.off("cardClose", u),
            D.off("cardClosed", f)
        }
        ),
        st( () => e.expandableOpened, g => {
            g ? o() : i()
        }
        );
        const d = ae( () => e.title || a.header)
          , p = ae( () => e.content || a.content)
          , h = ae( () => e.footer || a.footer)
          , m = ae( () => Oe("card", {
            "card-outline": e.outline,
            "card-expandable": e.expandable,
            "card-expandable-animate-width": e.expandableAnimateWidth,
            "no-shadow": e.noShadow,
            "no-border": e.noBorder
        }, je(e)));
        return {
            elRef: r,
            classes: m,
            hasHeader: d,
            hasContent: p,
            hasFooter: h
        }
    }
}
  , Nw = ["name", "value", "disabled", "readonly", "checked"]
  , Hw = V("i", {
    class: "icon-checkbox"
}, null, -1);
function Vw(e, t) {
    return O(),
    G("label", {
        class: Ae(e.classes)
    }, [V("input", {
        ref: "inputElRef",
        type: "checkbox",
        name: e.name,
        value: e.value,
        disabled: e.disabled,
        readonly: e.readonly,
        checked: e.checked,
        onChange: t[0] || (t[0] = function() {
            return e.onChange && e.onChange(...arguments)
        }
        )
    }, null, 40, Nw), Hw, ce(e.$slots, "default")], 2)
}
const Fw = {
    name: "f7-checkbox",
    render: Vw,
    props: {
        checked: Boolean,
        indeterminate: Boolean,
        name: [Number, String],
        value: {
            type: [Number, String, Boolean],
            default: void 0
        },
        disabled: Boolean,
        readonly: Boolean,
        ...qe
    },
    emits: ["update:checked", "change"],
    setup(e, t) {
        let {emit: n} = t;
        const a = oe(null)
          , r = i => {
            n("update:checked", i.target.checked),
            n("change", i)
        }
        ;
        Xe( () => {
            a.value && (a.value.indeterminate = !!e.indeterminate)
        }
        ),
        st( () => e.indeterminate, i => {
            a.value && (a.value.indeterminate = !!i)
        }
        );
        const o = ae( () => Oe({
            checkbox: !0,
            disabled: e.disabled
        }, je(e)));
        return {
            inputElRef: a,
            classes: o,
            onChange: r
        }
    }
}
  , jw = {
    key: 1,
    class: "chip-label"
};
function Uw(e, t) {
    const n = P("f7-use-icon");
    return O(),
    G("div", {
        ref: "elRef",
        class: Ae(e.classes)
    }, [e.hasMedia ? (O(),
    G("div", {
        key: 0,
        class: Ae(e.mediaClasses)
    }, [e.icon ? (O(),
    K(n, {
        key: 0,
        icon: e.icon
    }, null, 8, ["icon"])) : pe("", !0), J(" " + Me(e.media) + " ", 1), ce(e.$slots, "media")], 2)) : pe("", !0), e.hasLabel ? (O(),
    G("div", jw, [J(Me(e.text) + " ", 1), ce(e.$slots, "text"), ce(e.$slots, "default")])) : pe("", !0), e.deleteable ? (O(),
    G("a", {
        key: 2,
        class: "chip-delete",
        onClick: t[0] || (t[0] = function() {
            return e.onDeleteClick && e.onDeleteClick(...arguments)
        }
        )
    })) : pe("", !0)], 2)
}
const qw = {
    name: "f7-chip",
    render: Uw,
    components: {
        f7UseIcon: wi
    },
    props: {
        media: String,
        text: [String, Number],
        deleteable: Boolean,
        mediaBgColor: String,
        mediaTextColor: String,
        outline: Boolean,
        tooltip: String,
        tooltipTrigger: String,
        ...Ws,
        ...qe
    },
    emits: ["delete"],
    setup(e, t) {
        let {slots: n, emit: a} = t;
        const r = oe(null)
          , o = f => {
            a("delete", f)
        }
        ;
        wa(r, e);
        const i = ae( () => Xs(e))
          , s = ae( () => Oe("chip-media", e.mediaTextColor && `text-color-${e.mediaTextColor}`, e.mediaBgColor && `bg-color-${e.mediaBgColor}`))
          , l = ae( () => Oe("chip", {
            "chip-outline": e.outline
        }, je(e)))
          , c = ae( () => e.text || n && (n.text || n.default))
          , u = ae( () => e.media || i.value || n && n.media);
        return {
            classes: l,
            icon: i,
            mediaClasses: s,
            elRef: r,
            hasLabel: c,
            hasMedia: u,
            onDeleteClick: o
        }
    }
}
  , Ww = {
    key: 0,
    class: "resize-handler"
};
function Yw(e, t) {
    return O(),
    K(jn(e.tag), {
        ref: "elRef",
        class: Ae(e.classes)
    }, {
        default: k( () => [ce(e.$slots, "default"), e.resizable && e.resizableHandler ? (O(),
        G("span", Ww)) : pe("", !0)]),
        _: 3
    }, 8, ["class"])
}
const Gw = {
    name: "f7-col",
    render: Yw,
    props: {
        tag: {
            type: String,
            default: "div"
        },
        width: {
            type: [Number, String],
            default: "auto"
        },
        xsmall: {
            type: [Number, String]
        },
        small: {
            type: [Number, String]
        },
        medium: {
            type: [Number, String]
        },
        large: {
            type: [Number, String]
        },
        xlarge: {
            type: [Number, String]
        },
        resizable: Boolean,
        resizableFixed: Boolean,
        resizableAbsolute: Boolean,
        resizableHandler: {
            type: Boolean,
            default: !0
        },
        ...qe
    },
    emits: ["grid:resize"],
    setup(e, t) {
        let {emit: n} = t;
        const a = oe(null)
          , r = i => {
            i === a.value && n("grid:resize")
        }
        ;
        return Xe( () => {
            ut( () => {
                D.on("gridResize", r)
            }
            )
        }
        ),
        lt( () => {
            D.off("gridResize", r)
        }
        ),
        {
            classes: ae( () => Oe({
                col: e.width === "auto",
                [`col-${e.width}`]: e.width !== "auto",
                [`xsmall-${e.xsmall}`]: e.xsmall,
                [`small-${e.small}`]: e.small,
                [`medium-${e.medium}`]: e.medium,
                [`large-${e.large}`]: e.large,
                [`xlarge-${e.xlarge}`]: e.xlarge,
                resizable: e.resizable,
                "resizable-fixed": e.resizableFixed,
                "resizable-absolute": e.resizableAbsolute
            }, je(e))),
            elRef: a
        }
    }
};
function Xw(e, t) {
    return O(),
    G("div", {
        class: Ae(e.classes)
    }, [ce(e.$slots, "default")], 2)
}
const Kw = {
    name: "f7-fab-backdrop",
    render: Xw,
    props: {
        ...qe
    },
    setup(e) {
        return {
            classes: ae( () => Oe("fab-backdrop", je(e)))
        }
    }
}
  , Zw = ["target"]
  , Jw = {
    key: 0,
    class: "fab-label"
};
function Qw(e, t) {
    return O(),
    G("a", {
        ref: "elRef",
        class: Ae(e.classes),
        target: e.target,
        onClick: t[0] || (t[0] = function() {
            return e.onClick && e.onClick(...arguments)
        }
        )
    }, [ce(e.$slots, "default"), e.label ? (O(),
    G("span", Jw, Me(e.label), 1)) : pe("", !0)], 10, Zw)
}
const e_ = {
    name: "f7-fab-button",
    render: Qw,
    props: {
        fabClose: Boolean,
        label: String,
        target: String,
        tooltip: String,
        tooltipTrigger: String,
        ...qe
    },
    emits: ["click"],
    setup(e, t) {
        let {emit: n} = t;
        const a = oe(null)
          , r = i => {
            n("click", i)
        }
        ;
        return wa(a, e),
        {
            classes: ae( () => Oe({
                "fab-close": e.fabClose,
                "fab-label-button": e.label
            }, je(e))),
            onClick: r,
            elRef: a
        }
    }
};
function t_(e, t) {
    return O(),
    G("div", {
        class: Ae(e.classes)
    }, [ce(e.$slots, "default")], 2)
}
const n_ = {
    name: "f7-fab-buttons",
    render: t_,
    props: {
        position: {
            type: String,
            default: "top"
        },
        ...qe
    },
    setup(e) {
        return {
            classes: ae( () => Oe("fab-buttons", `fab-buttons-${e.position}`, je(e)))
        }
    }
}
  , a_ = {
    name: "f7-fab",
    props: {
        morphTo: String,
        href: [Boolean, String],
        target: String,
        text: String,
        position: {
            type: String,
            default: "right-bottom"
        },
        tooltip: String,
        tooltipTrigger: String,
        ...qe
    },
    emits: ["click"],
    setup(e, t) {
        let {emit: n, slots: a} = t;
        const r = oe(null)
          , o = s => {
            n("click", s)
        }
        ;
        wa(r, e);
        const i = ae( () => {
            let s = e.href;
            return s === !0 && (s = "#"),
            s === !1 && (s = void 0),
            s
        }
        );
        return () => {
            const s = []
              , l = [];
            let c, u;
            const {link: f, default: d, root: p, text: h} = a;
            d && d().forEach(g => {
                if (typeof g > "u")
                    return;
                const b = g.type && g.type.name ? g.type.name : g.type;
                b === "FabButtons" || b === "f7-fab-buttons" ? l.push(g) : s.push(g)
            }
            ),
            (e.text || h) && (c = Pe("div", {
                class: "fab-text"
            }, [e.text, h && h()])),
            (s.length || f || c) && (u = Pe("a", {
                target: e.target,
                href: i.value,
                onClick: o
            }, [s, c, f && f()]));
            const m = Oe("fab", `fab-${e.position}`, {
                "fab-morph": e.morphTo,
                "fab-extended": typeof c < "u"
            }, je(e));
            return Pe("div", {
                class: m,
                "data-morph-to": e.morphTo,
                ref: r
            }, [u, l, p && p()])
        }
    }
}
  , r_ = {
    class: "gauge"
}
  , o_ = ["width", "height", "viewBox"]
  , i_ = ["d", "stroke", "stroke-width", "fill"]
  , s_ = ["d", "stroke", "stroke-width", "stroke-dasharray", "stroke-dashoffset", "fill"]
  , l_ = ["stroke", "stroke-width", "fill", "cx", "cy", "r"]
  , c_ = ["transform", "stroke", "stroke-width", "stroke-dasharray", "stroke-dashoffset", "fill", "cx", "cy", "r"]
  , u_ = ["y", "font-weight", "font-size", "fill", "dy", "dominant-baseline"]
  , f_ = ["y", "font-weight", "font-size", "fill", "dy", "dominant-baseline"];
function d_(e, t) {
    return O(),
    G("div", r_, [(O(),
    G("svg", {
        class: "gauge-svg",
        width: `${e.size}px`,
        height: `${e.semiCircle ? e.size / 2 : e.size}px`,
        viewBox: `0 0 ${e.size} ${e.semiCircle ? e.size / 2 : e.size}`
    }, [e.semiCircle ? (O(),
    G("path", {
        key: 0,
        class: "gauge-back-semi",
        d: `M${e.size - e.borderWidth / 2},${e.size / 2} a1,1 0 0,0 -${e.size - e.borderWidth},0`,
        stroke: e.borderBgColor,
        "stroke-width": e.borderWidth,
        fill: e.bgColor || "none"
    }, null, 8, i_)) : pe("", !0), e.semiCircle ? (O(),
    G("path", {
        key: 1,
        class: "gauge-front-semi",
        d: `M${e.size - e.borderWidth / 2},${e.size / 2} a1,1 0 0,0 -${e.size - e.borderWidth},0`,
        stroke: e.borderColor,
        "stroke-width": e.borderWidth,
        "stroke-dasharray": e.length / 2,
        "stroke-dashoffset": e.length / 2 * (1 + e.progress),
        fill: e.borderBgColor ? "none" : e.bgColor || "none"
    }, null, 8, s_)) : pe("", !0), !e.semiCircle && e.borderBgColor ? (O(),
    G("circle", {
        key: 2,
        class: "gauge-back-circle",
        stroke: e.borderBgColor,
        "stroke-width": e.borderWidth,
        fill: e.bgColor || "none",
        cx: e.size / 2,
        cy: e.size / 2,
        r: e.radius
    }, null, 8, l_)) : pe("", !0), e.semiCircle ? pe("", !0) : (O(),
    G("circle", {
        key: 3,
        class: "gauge-front-circle",
        transform: `rotate(-90 ${e.size / 2} ${e.size / 2})`,
        stroke: e.borderColor,
        "stroke-width": e.borderWidth,
        "stroke-dasharray": e.length,
        "stroke-dashoffset": e.length * (1 - e.progress),
        fill: e.borderBgColor ? "none" : e.bgColor || "none",
        cx: e.size / 2,
        cy: e.size / 2,
        r: e.radius
    }, null, 8, c_)), e.valueText ? (O(),
    G("text", {
        key: 4,
        class: "gauge-value-text",
        x: "50%",
        y: e.semiCircle ? "100%" : "50%",
        "font-weight": e.valueFontWeight,
        "font-size": e.valueFontSize,
        fill: e.valueTextColor,
        dy: e.semiCircle ? e.labelText ? -e.labelFontSize - 15 : -5 : 0,
        "text-anchor": "middle",
        "dominant-baseline": e.semiCircle ? null : "middle"
    }, Me(e.valueText), 9, u_)) : pe("", !0), e.labelText ? (O(),
    G("text", {
        key: 5,
        class: "gauge-label-text",
        x: "50%",
        y: e.semiCircle ? "100%" : "50%",
        "font-weight": e.labelFontWeight,
        "font-size": e.labelFontSize,
        fill: e.labelTextColor,
        dy: e.semiCircle ? -5 : e.valueText ? e.valueFontSize / 2 + 10 : 0,
        "text-anchor": "middle",
        "dominant-baseline": e.semiCircle ? null : "middle"
    }, Me(e.labelText), 9, f_)) : pe("", !0)], 8, o_))])
}
const p_ = {
    name: "f7-gauge",
    render: d_,
    props: {
        type: {
            type: String,
            default: "circle"
        },
        value: {
            type: [Number, String],
            default: 0
        },
        size: {
            type: [Number, String],
            default: 200
        },
        bgColor: {
            type: String,
            default: "transparent"
        },
        borderBgColor: {
            type: String,
            default: "#eeeeee"
        },
        borderColor: {
            type: String,
            default: "#000000"
        },
        borderWidth: {
            type: [Number, String],
            default: 10
        },
        valueText: [Number, String],
        valueTextColor: {
            type: String,
            default: "#000000"
        },
        valueFontSize: {
            type: [Number, String],
            default: 31
        },
        valueFontWeight: {
            type: [Number, String],
            default: 500
        },
        labelText: String,
        labelTextColor: {
            type: String,
            default: "#888888"
        },
        labelFontSize: {
            type: [Number, String],
            default: 14
        },
        labelFontWeight: {
            type: [Number, String],
            default: 400
        }
    },
    setup(e) {
        const t = ae( () => e.type === "semicircle")
          , n = ae( () => e.size / 2 - e.borderWidth / 2)
          , a = ae( () => 2 * Math.PI * n.value)
          , r = ae( () => Math.max(Math.min(e.value, 1), 0));
        return {
            semiCircle: t,
            radius: n,
            length: a,
            progress: r
        }
    }
}
  , h_ = ["name", "disabled", "readonly", "checked", "value"]
  , m_ = V("span", {
    class: "toggle-icon"
}, null, -1);
function g_(e, t) {
    return O(),
    G("label", {
        ref: "elRef",
        class: Ae(e.classes)
    }, [V("input", {
        type: "checkbox",
        name: e.name,
        disabled: e.disabled,
        readonly: e.readonly,
        checked: e.checked,
        value: e.value,
        onChange: t[0] || (t[0] = function() {
            return e.onChange && e.onChange(...arguments)
        }
        )
    }, null, 40, h_), m_], 2)
}
const u6 = {
    name: "f7-toggle",
    render: g_,
    props: {
        init: {
            type: Boolean,
            default: !0
        },
        checked: Boolean,
        disabled: Boolean,
        readonly: Boolean,
        name: String,
        value: [String, Number, Array],
        tooltip: String,
        tooltipTrigger: String,
        ...qe
    },
    emits: ["change", "toggle:change", "update:checked"],
    setup(e, t) {
        let {emit: n} = t
          , a = null;
        const r = oe(null);
        wa(r, e);
        const o = s => {
            n("change", s)
        }
        ;
        return st( () => e.checked, s => {
            a && (a.checked = s)
        }
        ),
        Xe( () => {
            ut( () => {
                !e.init || !r.value || (a = D.toggle.create({
                    el: r.value,
                    on: {
                        change(s) {
                            n("toggle:change", s.checked),
                            n("update:checked", s.checked)
                        }
                    }
                }))
            }
            )
        }
        ),
        lt( () => {
            a && a.destroy && a.$el && a.destroy(),
            a = null
        }
        ),
        {
            classes: ae( () => Oe("toggle", {
                disabled: e.disabled
            }, je(e))),
            elRef: r,
            f7Toggle: a,
            onChange: o
        }
    }
}
  , v_ = ["name"];
function b_(e, t) {
    return O(),
    G("div", {
        ref: "elRef",
        class: Ae(e.classes)
    }, [e.input ? (O(),
    G("input", {
        key: 0,
        id: "inputId",
        type: "range",
        name: e.name
    }, null, 8, v_)) : pe("", !0), ce(e.$slots, "default")], 2)
}
const f6 = {
    name: "f7-range",
    render: b_,
    props: {
        init: {
            type: Boolean,
            default: !0
        },
        value: {
            type: [Number, Array, String],
            default: 0
        },
        min: {
            type: [Number, String],
            default: 0
        },
        max: {
            type: [Number, String],
            default: 100
        },
        step: {
            type: [Number, String],
            default: 1
        },
        label: {
            type: Boolean,
            default: !1
        },
        dual: {
            type: Boolean,
            default: !1
        },
        vertical: {
            type: Boolean,
            default: !1
        },
        verticalReversed: {
            type: Boolean,
            default: !1
        },
        draggableBar: {
            type: Boolean,
            default: !0
        },
        formatLabel: Function,
        scale: {
            type: Boolean,
            default: !1
        },
        scaleSteps: {
            type: Number,
            default: 5
        },
        scaleSubSteps: {
            type: Number,
            default: 0
        },
        formatScaleLabel: Function,
        limitKnobPosition: {
            type: Boolean,
            default: void 0
        },
        name: String,
        input: Boolean,
        inputId: String,
        disabled: Boolean,
        ...qe
    },
    emits: ["range:change", "range:changed", "rangeChange", "rangeChanged", "update:value"],
    setup(e, t) {
        let {emit: n} = t
          , a = null;
        const r = oe(null);
        st( () => e.value, i => {
            if (!a)
                return;
            const s = a.value;
            Array.isArray(i) && Array.isArray(s) ? (s[0] !== i[0] || s[1] !== i[1]) && a.setValue(i) : a.setValue(i)
        }
        ),
        Xe( () => {
            ut( () => {
                !e.init || !r.value || (a = D.range.create(aa({
                    el: r.value,
                    ...e,
                    on: {
                        change(i, s) {
                            n("range:change", s),
                            n("rangeChange", s)
                        },
                        changed(i, s) {
                            n("range:changed", s),
                            n("rangeChanged", s),
                            n("update:value", s)
                        }
                    }
                })))
            }
            )
        }
        ),
        lt( () => {
            a && a.destroy && a.destroy(),
            a = null
        }
        );
        const o = ae( () => Oe("range-slider", {
            "range-slider-horizontal": !e.vertical,
            "range-slider-vertical": e.vertical,
            "range-slider-vertical-reversed": e.vertical && e.verticalReversed,
            disabled: e.disabled
        }, je(e)));
        return {
            elRef: r,
            classes: o
        }
    }
}
  , y_ = {
    class: "text-editor-content",
    contenteditable: ""
};
function C_(e, t) {
    return O(),
    G("div", {
        ref: "elRef",
        class: Ae(e.classes)
    }, [ce(e.$slots, "root-start"), V("div", y_, [ce(e.$slots, "default")]), ce(e.$slots, "root-end"), ce(e.$slots, "root")], 2)
}
const zf = {
    name: "f7-text-editor",
    render: C_,
    props: {
        mode: {
            type: String,
            default: void 0
        },
        value: {
            type: String,
            default: void 0
        },
        buttons: Array,
        customButtons: Object,
        dividers: {
            type: Boolean,
            default: void 0
        },
        imageUrlText: {
            type: String,
            default: void 0
        },
        linkUrlText: {
            type: String,
            default: void 0
        },
        placeholder: {
            type: String,
            default: void 0
        },
        clearFormattingOnPaste: {
            type: Boolean,
            default: void 0
        },
        resizable: {
            type: Boolean,
            default: !1
        },
        ...qe
    },
    emits: ["texteditor:change", "texteditor:input", "texteditor:focus", "texteditor:blur", "texteditor:buttonclick", "texteditor:keyboardopen", "texteditor:keyboardclose", "texteditor:popoveropen", "texteditor:popoverclose", "texteditor:insertlink", "texteditor:insertimage", "texteditorChange", "texteditorInput", "texteditorFocus", "texteditorBlur"],
    setup(e, t) {
        let {emit: n} = t
          , a = null;
        const r = oe(null)
          , o = (b, v) => {
            n("texteditor:change", v),
            n("texteditorChange", v)
        }
          , i = (b, v) => {
            n("texteditor:input", v),
            n("texteditorInput", v)
        }
          , s = () => {
            n("texteditor:focus"),
            n("texteditorFocus")
        }
          , l = () => {
            n("texteditor:blur"),
            n("texteditorBlur")
        }
          , c = (b, v) => {
            n("texteditor:buttonclick", v)
        }
          , u = () => {
            n("texteditor:keyboardopen")
        }
          , f = () => {
            n("texteditor:keyboardclose")
        }
          , d = () => {
            n("texteditor:popoveropen")
        }
          , p = () => {
            n("texteditor:popoverclose")
        }
          , h = (b, v) => {
            n("texteditor:insertlink", v)
        }
          , m = (b, v) => {
            n("texteditor:insertimage", v)
        }
        ;
        st( () => e.value, b => {
            a && a.setValue(b)
        }
        ),
        Xe( () => {
            const b = aa({
                el: r.value,
                mode: e.mode,
                value: e.value,
                buttons: e.buttons,
                customButtons: e.customButtons,
                dividers: e.dividers,
                imageUrlText: e.imageUrlText,
                linkUrlText: e.linkUrlText,
                placeholder: e.placeholder,
                clearFormattingOnPaste: e.clearFormattingOnPaste,
                on: {
                    change: o,
                    input: i,
                    focus: s,
                    blur: l,
                    buttonClick: c,
                    keyboardOpen: u,
                    keyboardClose: f,
                    popoverOpen: d,
                    popoverClose: p,
                    insertLink: h,
                    insertImage: m
                }
            });
            ut( () => {
                a = D.textEditor.create(b)
            }
            )
        }
        ),
        lt( () => {
            a && a.destroy && a.destroy(),
            a = null
        }
        );
        const g = ae( () => Oe("text-editor", e.resizable && "text-editor-resizable", je(e)));
        return {
            elRef: r,
            classes: g
        }
    }
}
  , d6 = {
    name: "f7-input",
    props: {
        type: String,
        name: String,
        value: {
            type: [String, Number, Array, Date, Object],
            default: void 0
        },
        inputmode: String,
        placeholder: String,
        inputId: [String, Number],
        size: [String, Number],
        accept: [String, Number],
        autocomplete: [String],
        autocorrect: [String],
        autocapitalize: [String],
        spellcheck: [String],
        autofocus: Boolean,
        autosave: String,
        checked: Boolean,
        disabled: Boolean,
        max: [String, Number],
        min: [String, Number],
        step: [String, Number],
        maxlength: [String, Number],
        minlength: [String, Number],
        multiple: Boolean,
        readonly: Boolean,
        required: Boolean,
        inputStyle: [String, Object],
        pattern: String,
        validate: [Boolean, String],
        validateOnBlur: Boolean,
        onValidate: Function,
        tabindex: [String, Number],
        resizable: Boolean,
        clearButton: Boolean,
        noFormStoreData: Boolean,
        noStoreData: Boolean,
        ignoreStoreData: Boolean,
        errorMessage: String,
        errorMessageForce: Boolean,
        info: String,
        outline: Boolean,
        wrap: {
            type: Boolean,
            default: !0
        },
        dropdown: {
            type: [String, Boolean],
            default: "auto"
        },
        calendarParams: Object,
        colorPickerParams: Object,
        textEditorParams: Object,
        ...qe
    },
    emits: ["input", "focus", "blur", "change", "textarea:resize", "input:notempty", "input:empty", "input:clear", "texteditor:change", "calendar:change", "colorpicker:change", "update:value"],
    setup(e, t) {
        let {emit: n, slots: a} = t
          , r = null
          , o = null;
        const i = oe(!1)
          , s = oe(!1)
          , l = oe(null)
          , c = oe(null);
        let u = !1;
        const d = oe(( () => {
            if (c.value)
                return c.value.value
        }
        )())
          , p = ae( () => e.type === "datepicker" && Array.isArray(e.value) && e.value.length === 0 ? !1 : typeof e.value > "u" ? d.value || d.value === 0 : e.value || e.value === 0)
          , h = () => {
            if (!D || !c.value)
                return;
            const T = c.value.validity;
            T && (T.valid ? (e.onValidate && e.onValidate(!0),
            i.value !== !1 && (i.value = !1)) : (e.onValidate && e.onValidate(!1),
            i.value !== !0 && (i.value = !0)))
        }
          , m = T => {
            n("textarea:resize", T)
        }
          , g = T => {
            n("input:notempty", T)
        }
          , b = T => {
            n("input:empty", T)
        }
          , v = T => {
            n("input:clear", T)
        }
          , y = function() {
            for (var T = arguments.length, A = new Array(T), x = 0; x < T; x++)
                A[x] = arguments[x];
            n("input", ...A),
            c.value && (d.value = c.value.value),
            !(e.validateOnBlur || e.validateOnBlur === "") && (e.validate || e.validate === "") && c.value && h(),
            c.value && e.type !== "texteditor" && e.type !== "colorpicker" && e.type !== "datepicker" && n("update:value", c.value.value)
        }
          , w = function() {
            for (var T = arguments.length, A = new Array(T), x = 0; x < T; x++)
                A[x] = arguments[x];
            n("focus", ...A),
            s.value = !0
        }
          , C = function() {
            for (var T = arguments.length, A = new Array(T), x = 0; x < T; x++)
                A[x] = arguments[x];
            n("blur", ...A),
            (e.validate || e.validate === "" || e.validateOnBlur || e.validateOnBlur === "") && c.value && h(),
            s.value = !1
        }
          , _ = function() {
            for (var T = arguments.length, A = new Array(T), x = 0; x < T; x++)
                A[x] = arguments[x];
            n("change", ...A),
            e.type === "texteditor" && (n("texteditor:change", A[1]),
            n("update:value", A[1]))
        };
        Xe( () => {
            const {type: T, resizable: A, clearButton: x, value: M, calendarParams: L, colorPickerParams: U, validate: Y, validateOnBlur: H} = e;
            ut( () => {
                T === "range" || T === "toggle" || c.value && (c.value.addEventListener("input:notempty", g, !1),
                T === "textarea" && A && c.value.addEventListener("textarea:resize", m, !1),
                x && (c.value.addEventListener("input:empty", b, !1),
                c.value.addEventListener("input:clear", v, !1)),
                T === "datepicker" && (r = D.calendar.create({
                    inputEl: c.value,
                    value: M,
                    on: {
                        change(W, j) {
                            n("calendar:change", j),
                            n("update:value", j)
                        }
                    },
                    ...L || {}
                })),
                T === "colorpicker" && (o = D.colorPicker.create({
                    inputEl: c.value,
                    value: M,
                    on: {
                        change(W, j) {
                            n("colorpicker:change", j),
                            n("update:value", j)
                        }
                    },
                    ...U || {}
                })),
                D.input.checkEmptyState(c.value),
                !(H || H === "") && (Y || Y === "") && typeof M < "u" && M !== null && M !== "" && setTimeout( () => {
                    h()
                }
                , 0),
                A && D.input.resizeTextarea(c.value))
            }
            )
        }
        ),
        lt( () => {
            e.type === "range" || e.type === "toggle" || c.value && (c.value.removeEventListener("input:notempty", g, !1),
            e.type === "textarea" && e.resizable && c.value.removeEventListener("textarea:resize", m, !1),
            e.clearButton && (c.value.removeEventListener("input:empty", b, !1),
            c.value.removeEventListener("input:clear", v, !1)),
            r && r.destroy && (r.destroy(),
            r = null),
            o && o.destroy && (o.destroy(),
            o = null))
        }
        ),
        On( () => {
            if (D && u) {
                if (!c.value)
                    return;
                u = !1,
                D.input.checkEmptyState(c.value),
                e.validate && !e.validateOnBlur && h(),
                e.resizable && D.input.resizeTextarea(c.value)
            }
        }
        ),
        st( () => e.colorPickerParams, T => {
            !D || !o || Tn(o.params, T || {})
        }
        ),
        st( () => e.calendarParams, T => {
            !D || !r || Tn(r.params, T || {})
        }
        ),
        st( () => e.value, T => {
            e.type === "range" || e.type === "toggle" || !D || (u = !0,
            r && r.setValue(T),
            o && o.setValue(T))
        }
        );
        const E = (T, A) => {
            const x = e.type !== "file" && e.type !== "datepicker" && e.type !== "colorpicker"
              , M = T === "input";
            let L = e.type;
            (L === "datepicker" || L === "colorpicker") && (L = "text");
            const U = Oe({
                resizable: L === "textarea" && e.resizable,
                "no-store-data": e.noFormStoreData || e.noStoreData || e.ignoreStoreData,
                "input-invalid": e.errorMessage && e.errorMessageForce || i.value,
                "input-with-value": p.value,
                "input-focused": s.value
            });
            let Y;
            x && (typeof e.value < "u" ? Y = e.value : Y = d.value);
            const H = {};
            e.type !== "datepicker" && e.type !== "colorpicker" && "value"in e && (H.value = Y);
            const W = aa({
                name: e.name,
                type: M ? L : void 0,
                placeholder: e.placeholder,
                inputmode: e.inputmode,
                id: e.inputId,
                size: e.size,
                accept: e.accept,
                autocomplete: e.autocomplete,
                autoCorrect: e.autocorrect,
                autocapitalize: e.autocapitalize,
                spellcheck: e.spellcheck,
                autofocus: e.autofocus,
                autoSave: e.autosave,
                checked: e.checked,
                disabled: e.disabled,
                max: e.max,
                maxlength: e.maxlength,
                min: e.min,
                minlength: e.minlength,
                step: e.step,
                multiple: e.multiple,
                readonly: e.readonly,
                required: e.required,
                pattern: e.pattern,
                validate: typeof e.validate == "string" && e.validate.length ? e.validate : void 0,
                tabindex: e.tabindex
            });
            return Pe(T, {
                ref: c,
                style: e.inputStyle,
                ...W,
                "data-validate": e.validate === !0 || e.validate === "" || e.validateOnBlur === !0 || e.validateOnBlur === "" ? !0 : void 0,
                "data-validate-on-blur": e.validateOnBlur === !0 || e.validateOnBlur === "" ? !0 : void 0,
                "data-error-message": e.errorMessageForce ? void 0 : e.errorMessage,
                class: U,
                onFocus: w,
                onBlur: C,
                onInput: y,
                onChange: _,
                ...H
            }, [A])
        }
          , z = ae( () => Oe("input", {
            "input-outline": e.outline,
            "input-dropdown": e.dropdown === "auto" ? e.type === "select" : e.dropdown,
            "input-invalid": e.errorMessage && e.errorMessageForce || i.value
        }, je(e)));
        return () => {
            let T;
            return e.type === "select" || e.type === "textarea" || e.type === "file" ? e.type === "select" ? T = E("select", a.default && a.default()) : e.type === "file" ? T = E("input") : T = E("textarea") : a.default || !e.type ? T = a.default() : e.type === "toggle" ? T = Pe(u6, {
                checked: e.checked,
                readonly: e.readonly,
                name: e.name,
                value: e.value,
                disabled: e.disabled,
                id: e.inputId,
                onChange: _
            }) : e.type === "range" ? T = Pe(f6, {
                value: e.value,
                disabled: e.disabled,
                min: e.min,
                max: e.max,
                step: e.step,
                name: e.name,
                id: e.inputId,
                input: !0,
                onRangeChange: _
            }) : e.type === "texteditor" ? T = Pe(zf, {
                value: e.value,
                resizable: e.resizable,
                placeholder: e.placeholder,
                onTextEditorFocus: w,
                onTextEditorBlur: C,
                onTextEditorInput: y,
                onTextEditorChange: _,
                ...e.textEditorParams || {}
            }) : T = E("input"),
            e.wrap ? Pe("div", {
                class: z.value,
                ref: l
            }, [T, (e.errorMessage || a["error-message"]) && e.errorMessageForce && Pe("div", {
                class: "input-error-message"
            }, [e.errorMessage, a["error-message"] && a["error-message"]()]), e.clearButton && Pe("span", {
                class: "input-clear-button"
            }), (e.info || a.info) && Pe("div", {
                class: "input-info"
            }, [e.info, a.info && a.info()])]) : T
        }
    }
}
  , p6 = (e, t, n) => {
    let a;
    Xe( () => {
        ut( () => {
            if (e.smartSelect) {
                const r = Tn({
                    el: n()
                }, e.smartSelectParams || {});
                a = D.smartSelect.create(r),
                t(a)
            }
        }
        )
    }
    ),
    lt( () => {
        a && a.destroy && a.destroy(),
        a = null,
        t(a)
    }
    )
}
;
function w_(e, t) {
    const n = P("f7-use-icon")
      , a = P("f7-badge");
    return O(),
    G("a", Un({
        ref: "elRef",
        class: e.classes
    }, e.attrs), [e.icon ? (O(),
    K(n, {
        key: 0,
        icon: e.icon
    }, null, 8, ["icon"])) : pe("", !0), e.text ? (O(),
    G("span", {
        key: 1,
        class: Ae(e.isTabbarLabel ? "tabbar-label" : "")
    }, [J(Me(e.text) + " ", 1), e.badge ? (O(),
    K(a, {
        key: 0,
        color: e.badgeColor
    }, {
        default: k( () => [J(Me(e.badge), 1)]),
        _: 1
    }, 8, ["color"])) : pe("", !0)], 2)) : pe("", !0), ce(e.$slots, "default")], 16)
}
const Af = {
    name: "f7-link",
    render: w_,
    components: {
        f7Badge: oc,
        f7UseIcon: wi
    },
    props: {
        noLinkClass: Boolean,
        text: String,
        tabLink: [Boolean, String],
        tabLinkActive: Boolean,
        tabbarLabel: Boolean,
        iconOnly: Boolean,
        badge: [String, Number],
        badgeColor: [String],
        href: {
            type: [String, Boolean],
            default: "#"
        },
        target: String,
        tooltip: String,
        tooltipTrigger: String,
        smartSelect: Boolean,
        smartSelectParams: Object,
        ...Ws,
        ...qe,
        ...Oo,
        ...Mo
    },
    setup(e, t) {
        let {slots: n} = t;
        const a = oe(null);
        let r = null;
        wa(a, e),
        Ci(a, e),
        p6(e, u => {
            r = u
        }
        , () => a.value);
        const o = Qn("TabbarContext", {
            value: {}
        })
          , i = ae( () => e.tabbarLabel || o.value.tabbarHasLabels)
          , s = ae( () => {
            const {href: u, tabLink: f, target: d} = e;
            let p = u;
            return u === !0 && (p = "#"),
            u === !1 && (p = void 0),
            {
                href: p,
                target: d,
                "data-tab": xt(f) && f || void 0,
                ...zo(e),
                ...Po(e)
            }
        }
        )
          , l = ae( () => {
            const {iconOnly: u, text: f, noLinkClass: d, tabLink: p, tabLinkActive: h, smartSelect: m} = e;
            let g;
            const b = n && n.default;
            return u || !f && !b ? g = !0 : g = !1,
            Oe({
                link: !(d || i.value),
                "icon-only": g,
                "tab-link": p || p === "",
                "tab-link-active": h,
                "smart-select": m
            }, je(e), Ao(e), Lo(e))
        }
        )
          , c = ae( () => Xs(e));
        return {
            elRef: a,
            icon: c,
            isTabbarLabel: i,
            attrs: s,
            classes: l,
            f7SmartSelect: r
        }
    }
};
function __(e, t) {
    return O(),
    G("li", null, [V("a", Un({
        ref: "linkElRef",
        class: e.linkClasses
    }, e.linkAttrs, {
        onClick: t[0] || (t[0] = function() {
            return e.onClick && e.onClick(...arguments)
        }
        )
    }), [J(Me(e.title) + " " + Me(e.text) + " ", 1), ce(e.$slots, "default")], 16)])
}
const k_ = {
    name: "f7-list-button",
    render: __,
    props: {
        title: [String, Number],
        text: [String, Number],
        tabLink: [Boolean, String],
        tabLinkActive: Boolean,
        link: [Boolean, String],
        href: [Boolean, String],
        target: String,
        tooltip: String,
        tooltipTrigger: String,
        ...qe,
        ...Oo,
        ...Mo
    },
    emits: ["click"],
    setup(e, t) {
        let {emit: n} = t;
        const a = oe(null)
          , r = s => {
            n("click", s)
        }
        ;
        wa(a, e),
        Ci(a, e);
        const o = ae( () => ({
            href: typeof e.link == "boolean" && typeof e.href == "boolean" ? "#" : e.link || e.href,
            target: e.target,
            "data-tab": xt(e.tabLink) && e.tabLink,
            ...zo(e),
            ...Po(e)
        }))
          , i = ae( () => Oe({
            "list-button": !0,
            "tab-link": e.tabLink || e.tabLink === "",
            "tab-link-active": e.tabLinkActive,
            ...je(e),
            ...Ao(e),
            ...Lo(e)
        }));
        return {
            linkAttrs: o,
            linkClasses: i,
            onClick: r,
            linkElRef: a
        }
    }
}
  , S_ = ["data-sortable-move-elements"];
function $_(e, t) {
    return O(),
    G("div", {
        class: Ae(e.classes),
        "data-sortable-move-elements": typeof e.sortableMoveElements < "u" ? e.sortableMoveElements.toString() : void 0
    }, [V("ul", null, [ce(e.$slots, "default")])], 10, S_)
}
const E_ = {
    name: "f7-list-group",
    render: $_,
    props: {
        mediaList: Boolean,
        simpleList: Boolean,
        sortable: Boolean,
        sortableOpposite: Boolean,
        sortableTapHold: Boolean,
        sortableMoveElements: {
            type: Boolean,
            default: void 0
        },
        ...qe
    },
    setup(e) {
        const t = Qn("ListContext", {
            value: {
                listIsMedia: e.mediaList,
                listIsSimple: e.simpleList,
                listIsSortable: e.sortable,
                listIsSortableOpposite: e.sortableOpposite
            }
        })
          , n = ae( () => ({
            listIsMedia: e.mediaList || t.value.listIsMedia,
            listIsSimple: e.simpleList || t.value.listIsSimple,
            listIsSortable: e.sortable || t.value.listIsSortable,
            listIsSortableOpposite: e.sortableOpposite || t.value.listIsSortableOpposite
        }));
        return To("ListContext", n),
        {
            classes: ae( () => Oe("list-group", {
                "media-list": e.mediaList,
                sortable: e.sortable,
                "sortable-tap-hold": e.sortableTapHold,
                "sortable-opposite": e.sortableOpposite
            }, je(e)))
        }
    }
};
function x_(e, t) {
    return O(),
    G("div", {
        ref: "elRef",
        class: Ae(e.classes)
    }, [ce(e.$slots, "default")], 2)
}
const T_ = {
    name: "f7-list-index",
    render: x_,
    props: {
        init: {
            type: Boolean,
            default: !0
        },
        listEl: [String, Object],
        indexes: {
            type: [String, Array],
            default: "auto"
        },
        scrollList: {
            type: Boolean,
            default: !0
        },
        label: {
            type: Boolean,
            default: !1
        },
        iosItemHeight: {
            type: Number,
            default: 14
        },
        mdItemHeight: {
            type: Number,
            default: 14
        },
        auroraItemHeight: {
            type: Number,
            default: 14
        },
        ...qe
    },
    emits: ["listindex:select"],
    setup(e, t) {
        let {emit: n} = t
          , a = null;
        const r = oe(null)
          , o = () => {
            a && a.update()
        }
          , i = l => {
            a && a.scrollListToIndex(l)
        }
        ;
        st( () => e.indexes, l => {
            a && (a.params.indexes = l,
            o())
        }
        ),
        Xe( () => {
            e.init && ut( () => {
                a = D.listIndex.create({
                    el: r.value,
                    listEl: e.listEl,
                    indexes: e.indexes,
                    iosItemHeight: e.iosItemHeight,
                    mdItemHeight: e.mdItemHeight,
                    auroraItemHeight: e.auroraItemHeight,
                    scrollList: e.scrollList,
                    label: e.label,
                    on: {
                        select(l, c, u) {
                            n("listindex:select", c, u)
                        }
                    }
                })
            }
            )
        }
        ),
        lt( () => {
            a && a.destroy && a.destroy(),
            a = null
        }
        );
        const s = ae( () => Oe("list-index", je(e)));
        return {
            elRef: r,
            classes: s,
            update: o,
            scrollListToIndex: i
        }
    }
}
  , M_ = {
    name: "f7-list-input",
    props: {
        sortable: {
            type: Boolean,
            default: void 0
        },
        media: String,
        dropdown: {
            type: [String, Boolean],
            default: "auto"
        },
        wrap: {
            type: Boolean,
            default: !0
        },
        input: {
            type: Boolean,
            default: !0
        },
        type: {
            type: String,
            default: "text"
        },
        name: String,
        value: {
            type: [String, Number, Array, Date, Object],
            default: void 0
        },
        inputmode: String,
        readonly: Boolean,
        required: Boolean,
        disabled: Boolean,
        placeholder: String,
        inputId: [String, Number],
        size: [String, Number],
        accept: [String, Number],
        autocomplete: [String],
        autocorrect: [String],
        autocapitalize: [String],
        spellcheck: [String],
        autofocus: Boolean,
        autosave: String,
        max: [String, Number],
        min: [String, Number],
        step: [String, Number],
        maxlength: [String, Number],
        minlength: [String, Number],
        multiple: Boolean,
        inputStyle: [String, Object],
        pattern: String,
        validate: [Boolean, String],
        validateOnBlur: Boolean,
        onValidate: Function,
        tabindex: [String, Number],
        resizable: Boolean,
        clearButton: Boolean,
        noFormStoreData: Boolean,
        noStoreData: Boolean,
        ignoreStoreData: Boolean,
        errorMessage: String,
        errorMessageForce: Boolean,
        info: String,
        outline: Boolean,
        label: [String, Number],
        inlineLabel: Boolean,
        floatingLabel: Boolean,
        calendarParams: Object,
        colorPickerParams: Object,
        textEditorParams: Object,
        ...qe
    },
    emits: ["textarea:resize", "input:notempty", "input:empty", "input:clear", "texteditor:change", "calendar:change", "colorpicker:change", "change", "focus", "blur", "input", "update:value"],
    setup(e, t) {
        let {emit: n, slots: a} = t;
        const r = oe(!1)
          , o = oe(!1)
          , i = Qn("ListContext", {
            value: {
                listIsMedia: !1,
                listIsSortable: !1,
                listIsSortableOpposite: !1,
                listIsSimple: !1
            }
        });
        let s = null
          , l = null;
        const c = oe(null)
          , u = oe(null)
          , f = oe(null);
        let d = !1;
        const h = oe(( () => {
            if (u.value)
                return u.value.value
        }
        )())
          , m = ae( () => e.type === "datepicker" && Array.isArray(e.value) && e.value.length === 0 ? !1 : typeof e.value > "u" ? h.value || h.value === 0 : e.value || e.value === 0)
          , g = () => {
            if (!D || !u.value)
                return;
            const x = u.value.validity;
            x && (x.valid ? (e.onValidate && e.onValidate(!0),
            r.value !== !1 && (r.value = !1)) : (e.onValidate && e.onValidate(!1),
            r.value !== !0 && (r.value = !0)))
        }
          , b = x => {
            n("textarea:resize", x)
        }
          , v = x => {
            n("input:notempty", x)
        }
          , y = x => {
            n("input:empty", x)
        }
          , w = x => {
            n("input:clear", x)
        }
          , C = function() {
            for (var x = arguments.length, M = new Array(x), L = 0; L < x; L++)
                M[L] = arguments[L];
            n("input", ...M),
            u.value && (h.value = u.value.value),
            !(e.validateOnBlur || e.validateOnBlur === "") && (e.validate || e.validate === "") && u.value && g(u.value),
            u.value && e.type !== "texteditor" && e.type !== "colorpicker" && e.type !== "datepicker" && n("update:value", u.value.value)
        }
          , _ = function() {
            for (var x = arguments.length, M = new Array(x), L = 0; L < x; L++)
                M[L] = arguments[L];
            n("focus", ...M),
            o.value = !0
        }
          , E = function() {
            for (var x = arguments.length, M = new Array(x), L = 0; L < x; L++)
                M[L] = arguments[L];
            n("blur", ...M),
            (e.validate || e.validate === "" || e.validateOnBlur || e.validateOnBlur === "") && u.value && g(u.value),
            o.value = !1
        }
          , z = function() {
            for (var x = arguments.length, M = new Array(x), L = 0; L < x; L++)
                M[L] = arguments[L];
            n("change", ...M),
            e.type === "texteditor" && (n("texteditor:change", M[0]),
            n("update:value", M[0]))
        };
        Xe( () => {
            !c.value && !f.value || ut( () => {
                u.value && (u.value.addEventListener("input:notempty", v, !1),
                u.value.addEventListener("textarea:resize", b, !1),
                u.value.addEventListener("input:empty", y, !1),
                u.value.addEventListener("input:clear", w, !1),
                e.type === "datepicker" && (s = D.calendar.create({
                    inputEl: u.value,
                    value: e.value,
                    on: {
                        change(x, M) {
                            n("update:value", M),
                            n("calendar:change", M)
                        }
                    },
                    ...e.calendarParams || {}
                })),
                e.type === "colorpicker" && (l = D.colorPicker.create({
                    inputEl: u.value,
                    value: e.value,
                    on: {
                        change(x, M) {
                            n("update:value", M),
                            n("colorpicker:change", M)
                        }
                    },
                    ...e.colorPickerParams || {}
                })),
                !(e.validateOnBlur || e.validateOnBlur === "") && (e.validate || e.validate === "") && typeof e.value < "u" && e.value !== null && e.value !== "" && setTimeout( () => {
                    g()
                }
                , 0),
                e.type === "textarea" && e.resizable && D.input.resizeTextarea(u.value))
            }
            )
        }
        ),
        lt( () => {
            u.value && (u.value.removeEventListener("input:notempty", v, !1),
            u.value.removeEventListener("textarea:resize", b, !1),
            u.value.removeEventListener("input:empty", y, !1),
            u.value.removeEventListener("input:clear", w, !1)),
            s && s.destroy && (s.destroy(),
            s = null),
            l && l.destroy && (l.destroy(),
            l = null)
        }
        ),
        On( () => {
            if (D && d) {
                if (!u.value)
                    return;
                d = !1,
                e.validate && !e.validateOnBlur && g(),
                e.type === "textarea" && e.resizable && D.input.resizeTextarea(u.value)
            }
        }
        ),
        st( () => e.colorPickerParams, x => {
            !D || !l || Tn(l.params, x || {})
        }
        ),
        st( () => e.calendarParams, x => {
            !D || !s || Tn(s.params, x || {})
        }
        ),
        st( () => e.value, x => {
            D && (d = !0,
            s && s.setValue(x),
            l && l.setValue(x))
        }
        );
        const T = ae( () => e.sortable === !0 || e.sortable === !1 ? e.sortable : i.value.listIsSortable || !1)
          , A = (x, M) => {
            const L = e.type !== "file" && e.type !== "datepicker" && e.type !== "colorpicker"
              , U = x === "input";
            let Y = e.type;
            (Y === "datepicker" || Y === "colorpicker") && (Y = "text");
            const H = Oe({
                resizable: Y === "textarea" && e.resizable,
                "no-store-data": e.noFormStoreData || e.noStoreData || e.ignoreStoreData,
                "input-invalid": e.errorMessage && e.errorMessageForce || r.value,
                "input-with-value": m.value,
                "input-focused": o.value
            });
            let W;
            L && (typeof e.value < "u" ? W = e.value : W = h.value);
            const j = {};
            e.type !== "datepicker" && e.type !== "colorpicker" && "value"in e && (j.value = W);
            const Q = aa({
                name: e.name,
                type: U ? Y : void 0,
                placeholder: e.placeholder,
                inputmode: e.inputmode,
                id: e.inputId,
                size: e.size,
                accept: e.accept,
                autocomplete: e.autocomplete,
                autocorrect: e.autocorrect,
                autocapitalize: e.autocapitalize,
                spellcheck: e.spellcheck,
                autofocus: e.autofocus,
                autosave: e.autosave,
                disabled: e.disabled,
                max: e.max,
                maxlength: e.maxlength,
                min: e.min,
                minlength: e.minlength,
                step: e.step,
                multiple: e.multiple,
                readonly: e.readonly,
                required: e.required,
                pattern: e.pattern,
                validate: typeof e.validate == "string" && e.validate.length ? e.validate : void 0,
                tabindex: e.tabindex
            });
            return Pe(x, {
                ref: u,
                style: e.inputStyle,
                ...Q,
                "data-validate": e.validate === !0 || e.validate === "" || e.validateOnBlur === !0 || e.validateOnBlur === "" ? !0 : void 0,
                "data-validate-on-blur": e.validateOnBlur === !0 || e.validateOnBlur === "" ? !0 : void 0,
                "data-error-message": e.errorMessageForce ? void 0 : e.errorMessage,
                class: H,
                onFocus: _,
                onBlur: E,
                onInput: C,
                onChange: z,
                ...j
            }, [M])
        }
        ;
        return () => {
            let x;
            e.input && (e.type === "select" || e.type === "textarea" || e.type === "file" ? e.type === "select" ? x = A("select", a.default && a.default()) : e.type === "file" ? x = A("input") : x = A("textarea") : e.type === "texteditor" ? x = Pe(zf, {
                value: e.value,
                resizable: e.resizable,
                placeholder: e.placeholder,
                onTexteditorFocus: _,
                onTexteditorBlur: E,
                onTexteditorInput: C,
                onTexteditorChange: z,
                ...e.textEditorParams || {}
            }) : x = A("input"));
            const M = !!e.errorMessage || a["error-message"]
              , L = Pe("div", {
                ref: f,
                class: Oe("item-content item-input", !e.wrap && {
                    disabled: e.disabled
                }, !e.wrap && je(e), {
                    "inline-label": e.inlineLabel,
                    "item-input-outline": e.outline,
                    "item-input-focused": o.value,
                    "item-input-with-info": !!e.info || a.info,
                    "item-input-with-value": m.value,
                    "item-input-with-error-message": M && e.errorMessageForce || r.value,
                    "item-input-invalid": M && e.errorMessageForce || r.value
                })
            }, [a["content-start"] && a["content-start"](), (e.media || a.media) && Pe("div", {
                class: "item-media"
            }, [e.media && Pe("img", {
                src: e.media
            }), a.media && a.media()]), Pe("div", {
                class: "item-inner"
            }, [a["inner-start"] && a["inner-start"](), (e.label || a.label) && Pe("div", {
                class: Oe("item-title item-label", {
                    "item-floating-label": e.floatingLabel
                })
            }, [e.label, a.label && a.label()]), Pe("div", {
                class: Oe("item-input-wrap", {
                    "input-dropdown": e.dropdown === "auto" ? e.type === "select" : e.dropdown
                })
            }, [x, a.input && a.input(), M && e.errorMessageForce && Pe("div", {
                class: "item-input-error-message"
            }, [e.errorMessage, a["error-message"] && a["error-message"]()]), e.clearButton && Pe("span", {
                class: "input-clear-button"
            }), (e.info || a.info) && Pe("div", {
                class: "item-input-info"
            }, [e.info, a.info && a.info()])]), a.inner && a.inner(), a["inner-end"] && a["inner-end"]()]), a.content && a.content(), a["content-end"] && a["content-end"]()]);
            return e.wrap ? Pe("li", {
                ref: c,
                class: Oe({
                    disabled: e.disabled
                }, je(e))
            }, [a["root-start"] && a["root-start"](), L, T.value && Pe("div", {
                class: "sortable-handler"
            }), a.root && a.root(), a["root-end"] && a["root-end"]()]) : L
        }
    }
};
function z_(e, t) {
    return O(),
    G("div", {
        class: Ae(e.classes)
    }, [ce(e.$slots, "default")], 2)
}
const A_ = {
    name: "f7-list-item-cell",
    render: z_,
    props: {
        ...qe
    },
    setup(e) {
        return {
            classes: ae( () => Oe("item-cell", je(e)))
        }
    }
};
function O_(e, t) {
    return O(),
    G("div", {
        class: Ae(e.classes)
    }, [ce(e.$slots, "default")], 2)
}
const P_ = {
    name: "f7-list-item-row",
    render: O_,
    props: {
        ...qe
    },
    setup(e) {
        return {
            classes: ae( () => Oe("item-row", je(e)))
        }
    }
}
  , L_ = function(e) {
    let {props: t, slots: n, inputElRef: a, onChange: r, onClick: o, isMediaComputed: i, isSortableComputed: s, isSortableOppositeComputed: l, itemContentClasses: c} = e === void 0 ? {} : e;
    const {radio: u, checkbox: f, value: d, name: p, readonly: h, disabled: m, checked: g, required: b, media: v, header: y, footer: w, title: C, subtitle: _, text: E, after: z, badge: T, badgeColor: A, swipeout: x, sortable: M, accordionItem: L} = t;
    let U, Y, H, W, j, Q, ne, re, ve, Ne, Ge, Ye, tt;
    if ((u || f) && (Ne = Pe("input", {
        ref: a,
        value: d,
        name: p,
        checked: g,
        readonly: h,
        disabled: m,
        required: b,
        type: u ? "radio" : "checkbox",
        onChange: r
    }),
    Ge = Pe("i", {
        class: `icon icon-${u ? "radio" : "checkbox"}`
    })),
    v || n.media) {
        let ye;
        v && (ye = Pe("img", {
            src: v
        })),
        ve = Pe("div", {
            class: "item-media"
        }, [ye, n.media && n.media()])
    }
    return (y || n.header) && (Ye = Pe("div", {
        class: "item-header"
    }, [y, n.header && n.header()])),
    (w || n.footer) && (tt = Pe("div", {
        class: "item-footer"
    }, [w, n.footer && n.footer()])),
    (C || n.title || !i.value && Ye || !i.value && tt) && (U = Pe("div", {
        class: "item-title"
    }, [!i.value && Ye, C, n.title && n.title(), !i.value && tt])),
    (_ || n.subtitle) && (ne = Pe("div", {
        class: "item-subtitle"
    }, [_, n.subtitle && n.subtitle()])),
    (E || n.text) && (re = Pe("div", {
        class: "item-text"
    }, [E, n.text && n.text()])),
    (z || T || n.after) && (z && (H = Pe("span", [z])),
    T && (W = Pe(oc, {
        color: A
    }, () => T)),
    Y = Pe("div", {
        class: "item-after"
    }, [n["after-start"] && n["after-start"](), H, W, n.after && n.after(), n["after-end"] && n["after-end"]()])),
    i.value ? (Q = Pe("div", {
        class: "item-title-row"
    }, [n["before-title"] && n["before-title"](), U, n["after-title"] && n["after-title"](), Y]),
    j = Pe("div", {
        class: "item-inner"
    }, [n["inner-start"] && n["inner-start"], Ye, Q, ne, re, x || L ? null : n.default && n.default(), n.inner && n.inner(), tt, n["inner-end"] && n["inner-end"]])) : j = Pe("div", {
        class: "item-inner"
    }, [n["inner-start"] && n["inner-start"](), n["before-title"] && n["before-title"](), U, n["after-title"] && n["after-title"](), Y, x || L ? null : n.default && n.default(), n.inner && n.inner(), n["inner-end"] && n["inner-end"]()]),
    Pe(f || u ? "label" : "div", {
        class: c.value,
        onClick: o
    }, [s.value && M !== !1 && l.value && Pe("div", {
        class: "sortable-handler"
    }), n["content-start"] && n["content-start"](), Ne, Ge, ve, j, n.content && n.content(), n["content-end"] && n["content-end"]()])
}
  , I_ = {
    name: "f7-list-item",
    props: {
        title: [String, Number],
        text: [String, Number],
        media: String,
        subtitle: [String, Number],
        header: [String, Number],
        footer: [String, Number],
        tooltip: String,
        tooltipTrigger: String,
        link: [Boolean, String],
        target: String,
        tabLink: [Boolean, String],
        tabLinkActive: Boolean,
        selected: Boolean,
        after: [String, Number],
        badge: [String, Number],
        badgeColor: String,
        mediaItem: Boolean,
        mediaList: Boolean,
        divider: Boolean,
        groupTitle: Boolean,
        swipeout: Boolean,
        swipeoutOpened: Boolean,
        sortable: {
            type: Boolean,
            default: void 0
        },
        sortableOpposite: {
            type: Boolean,
            default: void 0
        },
        accordionItem: Boolean,
        accordionItemOpened: Boolean,
        smartSelect: Boolean,
        smartSelectParams: Object,
        noChevron: Boolean,
        chevronCenter: Boolean,
        checkbox: Boolean,
        radio: Boolean,
        radioIcon: String,
        checked: Boolean,
        indeterminate: Boolean,
        name: String,
        value: {
            type: [String, Number, Array],
            default: void 0
        },
        readonly: Boolean,
        required: Boolean,
        disabled: Boolean,
        virtualListIndex: Number,
        ...qe,
        ...Oo,
        ...Mo
    },
    emits: ["click", "swipeout", "swipeout:overswipeenter", "swipeout:overswipeexit", "swipeout:deleted", "swipeout:delete", "swipeout:close", "swipeout:closed", "swipeout:open", "swipeout:opened", "accordion:beforeclose", "accordion:close", "accordion:closed", "accordion:beforeopen", "accordion:open", "accordion:opened", "change", "update:checked"],
    setup(e, t) {
        let {slots: n, emit: a} = t;
        const r = Qn("ListContext", {
            value: {
                listIsMedia: !1,
                listIsSortable: !1,
                listIsSortableOpposite: !1,
                listIsSimple: !1
            }
        })
          , o = ae( () => r.value.listIsMedia || !1)
          , i = ae( () => r.value.listIsSortable || !1)
          , s = ae( () => r.value.listIsSortableOpposite || !1)
          , l = ae( () => r.value.listIsSimple || !1)
          , c = oe(null)
          , u = oe(null)
          , f = oe(null)
          , d = ne => {
            ne.target.tagName.toLowerCase() !== "input" && a("click", ne)
        }
          , p = ne => {
            c.value === ne && a("swipeout:overswipeenter")
        }
          , h = ne => {
            c.value === ne && a("swipeout:overswipeexit")
        }
          , m = ne => {
            c.value === ne && a("swipeout:deleted")
        }
          , g = ne => {
            c.value === ne && a("swipeout:delete")
        }
          , b = ne => {
            c.value === ne && a("swipeout:close")
        }
          , v = ne => {
            c.value === ne && a("swipeout:closed")
        }
          , y = ne => {
            c.value === ne && a("swipeout:open")
        }
          , w = ne => {
            c.value === ne && a("swipeout:opened")
        }
          , C = (ne, re) => {
            c.value === ne && a("swipeout", re)
        }
          , _ = (ne, re) => {
            c.value === ne && a("accordion:beforeclose", re)
        }
          , E = ne => {
            c.value === ne && a("accordion:close")
        }
          , z = ne => {
            c.value === ne && a("accordion:closed")
        }
          , T = (ne, re) => {
            c.value === ne && a("accordion:beforeopen", re)
        }
          , A = ne => {
            c.value === ne && a("accordion:open")
        }
          , x = ne => {
            c.value === ne && a("accordion:opened")
        }
          , M = ne => {
            a("change", ne),
            a("update:checked", ne.target.checked)
        }
        ;
        wa(c, e),
        Ci(u, e),
        p6(e, () => {}
        , () => c.value.querySelector("a.smart-select")),
        st( () => e.swipeoutOpened, ne => {
            !e.swipeout || !c.value || !D || (ne ? D.swipeout.open(c.value) : D.swipeout.close(c.value))
        }
        ),
        Xe( () => {
            ut( () => {
                e.swipeout && (D.on("swipeoutOpen", y),
                D.on("swipeoutOpened", w),
                D.on("swipeoutClose", b),
                D.on("swipeoutClosed", v),
                D.on("swipeoutDelete", g),
                D.on("swipeoutDeleted", m),
                D.on("swipeoutOverswipeEnter", p),
                D.on("swipeoutOverswipeExit", h),
                D.on("swipeout", C)),
                e.accordionItem && (D.on("accordionBeforeOpen", T),
                D.on("accordionOpen", A),
                D.on("accordionOpened", x),
                D.on("accordionBeforeClose", _),
                D.on("accordionClose", E),
                D.on("accordionClosed", z)),
                e.swipeout && e.swipeoutOpened && D.swipeout.open(c.value)
            }
            ),
            e.checkbox && f.value && (f.value.indeterminate = !!e.indeterminate)
        }
        ),
        lt( () => {
            D && (D.off("swipeoutOpen", y),
            D.off("swipeoutOpened", w),
            D.off("swipeoutClose", b),
            D.off("swipeoutClosed", v),
            D.off("swipeoutDelete", g),
            D.off("swipeoutDeleted", m),
            D.off("swipeoutOverswipeEnter", p),
            D.off("swipeoutOverswipeExit", h),
            D.off("swipeout", C),
            D.off("accordionBeforeOpen", T),
            D.off("accordionOpen", A),
            D.off("accordionOpened", x),
            D.off("accordionBeforeClose", _),
            D.off("accordionClose", E),
            D.off("accordionClosed", z))
        }
        ),
        st( () => e.indeterminate, ne => {
            f.value && (f.value.indeterminate = !!ne)
        }
        );
        const L = ae( () => e.mediaItem || e.mediaList || o.value)
          , U = ae( () => e.sortable === !0 || e.sortable === !1 ? e.sortable : i.value)
          , Y = ae( () => U.value && (e.sortableOpposite || s.value))
          , H = ae( () => ({
            href: e.link === !0 ? "" : e.link || e.href,
            target: e.target,
            "data-tab": xt(e.tabLink) && e.tabLink || void 0,
            ...zo(e),
            ...Po(e)
        }))
          , W = ae( () => Oe({
            "item-link": !0,
            "smart-select": e.smartSelect,
            "tab-link": e.tabLink || e.tabLink === "",
            "tab-link-active": e.tabLinkActive,
            "item-selected": e.selected
        }, Ao(e), Lo(e)))
          , j = ae( () => Oe("item-content", {
            "item-checkbox": e.checkbox,
            "item-radio": e.radio,
            "item-radio-icon-start": e.radio && e.radioIcon === "start",
            "item-radio-icon-end": e.radio && e.radioIcon === "end"
        }, je(e)))
          , Q = ae( () => Oe({
            "item-divider": e.divider,
            "list-group-title": e.groupTitle,
            "media-item": L.value,
            swipeout: e.swipeout,
            "accordion-item": e.accordionItem,
            "accordion-item-opened": e.accordionItemOpened,
            disabled: e.disabled && !(e.radio || e.checkbox),
            "no-chevron": e.noChevron,
            "chevron-center": e.chevronCenter,
            "disallow-sorting": e.sortable === !1
        }, je(e)));
        return () => {
            let ne, re;
            if (l.value || (re = L_({
                props: e,
                slots: n,
                inputElRef: f,
                onChange: M,
                onClick: e.link || e.href || e.accordionItem || e.smartSelect ? void 0 : d,
                isMediaComputed: L,
                isSortableComputed: U,
                isSortableOppositeComputed: Y,
                itemContentClasses: j
            }),
            (e.link || e.href || e.accordionItem || e.smartSelect) && (ne = Pe("a", {
                ref: u,
                class: W.value,
                ...H.value,
                onClick: d
            }, [re]))),
            e.divider || e.groupTitle)
                return Pe("li", {
                    ref: c,
                    class: Q.value,
                    "data-virtual-list-index": e.virtualListIndex,
                    onClick: d
                }, [e.title, n.default && n.default()]);
            if (l.value)
                return Pe("li", {
                    ref: c,
                    class: Q.value,
                    onClick: d,
                    "data-virtual-list-index": e.virtualListIndex
                }, [e.title, n.default && n.default()]);
            const ve = e.link || e.href || e.smartSelect || e.accordionItem ? ne : re;
            return Pe("li", {
                ref: c,
                class: Q.value,
                "data-virtual-list-index": e.virtualListIndex
            }, [n["root-start"] && n["root-start"](), e.swipeout ? Pe("div", {
                class: "swipeout-content"
            }, [ve]) : ve, U.value && e.sortable !== !1 && !Y.value && Pe("div", {
                class: "sortable-handler"
            }), (e.swipeout || e.accordionItem) && n.default(), n.root && n.root(), n["root-end"] && n["root-end"]()])
        }
    }
}
  , B_ = {
    name: "f7-list",
    props: {
        inset: Boolean,
        xsmallInset: Boolean,
        smallInset: Boolean,
        mediumInset: Boolean,
        largeInset: Boolean,
        xlargeInset: Boolean,
        mediaList: Boolean,
        sortable: Boolean,
        sortableTapHold: Boolean,
        sortableEnabled: Boolean,
        sortableMoveElements: {
            type: Boolean,
            default: void 0
        },
        sortableOpposite: Boolean,
        accordionList: Boolean,
        accordionOpposite: Boolean,
        contactsList: Boolean,
        simpleList: Boolean,
        linksList: Boolean,
        menuList: Boolean,
        noHairlines: Boolean,
        noHairlinesBetween: Boolean,
        noHairlinesMd: Boolean,
        noHairlinesBetweenMd: Boolean,
        noHairlinesIos: Boolean,
        noHairlinesBetweenIos: Boolean,
        noHairlinesAurora: Boolean,
        noHairlinesBetweenAurora: Boolean,
        noChevron: Boolean,
        chevronCenter: Boolean,
        tab: Boolean,
        tabActive: Boolean,
        form: Boolean,
        formStoreData: Boolean,
        inlineLabels: Boolean,
        virtualList: Boolean,
        virtualListParams: Object,
        ...qe
    },
    emits: ["submit", "sortable:enable", "sortable:disable", "sortable:sort", "sortable:move", "virtual:itembeforeinsert", "virtual:beforeclear", "virtual:itemsbeforeinsert", "virtual:itemsafterinsert", "tab:hide", "tab:show"],
    setup(e, t) {
        let {emit: n, slots: a} = t
          , r = null;
        const o = oe(null)
          , i = h => {
            n("submit", h)
        }
          , s = h => {
            o.value === h && n("sortable:enable")
        }
          , l = h => {
            o.value === h && n("sortable:disable")
        }
          , c = (h, m, g) => {
            o.value === g && n("sortable:sort", m)
        }
          , u = (h, m) => {
            o.value === m && n("sortable:move", h, m)
        }
        ;
        Gs(o, n),
        Xe( () => {
            ut( () => {
                if (D.on("sortableEnable", s),
                D.on("sortableDisable", l),
                D.on("sortableSort", c),
                D.on("sortableMove", u),
                !e.virtualList)
                    return;
                const h = e.virtualListParams || {};
                !h.renderItem && !h.renderExternal || (h.items && (h.items = rt(h.items)),
                r = D.virtualList.create(Tn({
                    el: o.value,
                    on: {
                        itemBeforeInsert(m, g) {
                            n("virtual:itembeforeinsert", this, m, g)
                        },
                        beforeClear(m) {
                            n("virtual:beforeclear", this, m)
                        },
                        itemsBeforeInsert(m) {
                            n("virtual:itemsbeforeinsert", this, m)
                        },
                        itemsAfterInsert(m) {
                            n("virtual:itemsafterinsert", this, m)
                        }
                    }
                }, h)))
            }
            )
        }
        ),
        lt( () => {
            D && (D.off("sortableEnable", s),
            D.off("sortableDisable", l),
            D.off("sortableSort", c),
            D.off("sortableMove", u),
            e.virtualList && r && (r.destroy && r.destroy(),
            r = null))
        }
        );
        const f = ae( () => Oe("list", {
            inset: e.inset,
            "xsmall-inset": e.xsmallInset,
            "small-inset": e.smallInset,
            "medium-inset": e.mediumInset,
            "large-inset": e.largeInset,
            "xlarge-inset": e.xlargeInset,
            "media-list": e.mediaList,
            "simple-list": e.simpleList,
            "links-list": e.linksList,
            "menu-list": e.menuList,
            sortable: e.sortable,
            "sortable-tap-hold": e.sortableTapHold,
            "sortable-enabled": e.sortableEnabled,
            "sortable-opposite": e.sortableOpposite,
            "accordion-list": e.accordionList,
            "accordion-opposite": e.accordionOpposite,
            "contacts-list": e.contactsList,
            "virtual-list": e.virtualList,
            tab: e.tab,
            "tab-active": e.tabActive,
            "no-hairlines": e.noHairlines,
            "no-hairlines-md": e.noHairlinesMd,
            "no-hairlines-ios": e.noHairlinesIos,
            "no-hairlines-aurora": e.noHairlinesAurora,
            "no-hairlines-between": e.noHairlinesBetween,
            "no-hairlines-between-md": e.noHairlinesBetweenMd,
            "no-hairlines-between-ios": e.noHairlinesBetweenIos,
            "no-hairlines-between-aurora": e.noHairlinesBetweenAurora,
            "form-store-data": e.formStoreData,
            "inline-labels": e.inlineLabels,
            "no-chevron": e.noChevron,
            "chevron-center": e.chevronCenter
        }, je(e)))
          , d = ae( () => e.form ? "form" : "div")
          , p = ae( () => ({
            listIsMedia: e.mediaList,
            listIsSimple: e.simpleList,
            listIsSortable: e.sortable,
            listIsSortableOpposite: e.sortableOpposite
        }));
        return To("ListContext", p),
        () => {
            const {list: h, default: m} = a
              , g = []
              , b = []
              , v = h || [];
            let y = !1;
            return m && m().forEach(w => {
                if (typeof w > "u")
                    return;
                const C = w.type && w.type.name ? w.type.name : w.type;
                C && typeof C == "symbol" ? (y = !0,
                v.push(w)) : !C || C && !(C === "li" || C.indexOf("f7-list-item") >= 0 || C.indexOf("f7-list-button") >= 0 || C.indexOf("f7-list-input") >= 0) ? y ? b.push(w) : g.push(w) : C && (y = !0,
                v.push(w))
            }
            ),
            Pe(d.value, {
                ref: o,
                class: f.value,
                "data-sortable-move-elements": typeof e.sortableMoveElements < "u" ? e.sortableMoveElements.toString() : void 0,
                onSubmit: i
            }, [a["before-list"] && a["before-list"](), g, v.length > 0 && Pe("ul", v), a["after-list"] && a["after-list"](), b])
        }
    }
};
function R_(e, t) {
    return O(),
    G("div", {
        class: Ae(e.classes)
    }, [ce(e.$slots, "default")], 2)
}
const D_ = {
    name: "f7-login-screen-title",
    render: R_,
    props: {
        ...qe
    },
    setup(e) {
        return {
            classes: ae( () => Oe("login-screen-title", je(e)))
        }
    }
};
function N_(e, t) {
    return O(),
    G("div", Un({
        ref: "elRef",
        class: e.classes
    }, e.attrs, {
        onClick: t[0] || (t[0] = function() {
            return e.onClick && e.onClick(...arguments)
        }
        )
    }), [J(Me(e.text) + " ", 1), ce(e.$slots, "default")], 16)
}
const H_ = {
    name: "f7-menu-dropdown-item",
    render: N_,
    props: {
        text: String,
        link: Boolean,
        href: String,
        target: String,
        divider: Boolean,
        ...qe,
        ...Mo,
        ...Oo
    },
    emits: ["click"],
    setup(e, t) {
        let {emit: n} = t;
        const a = oe(null)
          , r = c => {
            n("click", c)
        }
        ;
        Ci(a, e);
        const o = ae( () => e.link || e.href || e.href === "")
          , i = ae( () => o.value ? "a" : "div")
          , s = ae( () => Oe({
            "menu-dropdown-link": o.value && !e.divider,
            "menu-dropdown-item": !o.value && !e.divider,
            "menu-dropdown-divider": e.divider
        }, je(e), Ao(e), Lo(e), {
            "menu-close": typeof e.menuClose > "u"
        }))
          , l = ae( () => {
            let c = e.href;
            return typeof c > "u" && e.link && (c = "#"),
            {
                href: c,
                target: e.target,
                ...zo(e),
                ...Po(e)
            }
        }
        );
        return {
            classes: s,
            attrs: l,
            tag: i,
            onClick: r,
            elRef: a
        }
    }
};
function V_(e, t) {
    return O(),
    G("div", {
        class: Ae(e.classes)
    }, [V("div", {
        class: "menu-dropdown-content",
        style: Rt({
            height: e.contentHeight
        })
    }, [ce(e.$slots, "default")], 4)], 2)
}
const F_ = {
    name: "f7-menu-dropdown",
    render: V_,
    props: {
        contentHeight: String,
        position: String,
        left: Boolean,
        center: Boolean,
        right: Boolean,
        ...qe
    },
    setup(e) {
        return {
            classes: ae( () => {
                let n = e.position || "left";
                return e.left && (n = "left"),
                e.center && (n = "center"),
                e.right && (n = "right"),
                Oe("menu-dropdown", `menu-dropdown-${n}`, je(e))
            }
            )
        }
    }
}
  , j_ = {
    key: 0,
    class: "menu-item-content"
};
function U_(e, t) {
    const n = P("f7-use-icon");
    return O(),
    K(jn(e.tag), Un({
        ref: "elRef",
        class: e.classes
    }, e.attrs, {
        onClick: e.onClick
    }), {
        default: k( () => [e.text || e.$slots.text || e.icon ? (O(),
        G("div", j_, [J(Me(e.text) + " ", 1), e.icon ? (O(),
        K(n, {
            key: 0,
            icon: e.icon
        }, null, 8, ["icon"])) : pe("", !0), ce(e.$slots, "text")])) : pe("", !0), ce(e.$slots, "default")]),
        _: 3
    }, 16, ["class", "onClick"])
}
const q_ = {
    name: "f7-menu-item",
    render: U_,
    components: {
        f7UseIcon: wi
    },
    props: {
        text: String,
        iconOnly: Boolean,
        href: String,
        link: Boolean,
        target: String,
        dropdown: Boolean,
        tooltip: String,
        tooltipTrigger: String,
        ...qe,
        ...Mo,
        ...Oo,
        ...Ws
    },
    emits: ["click", "menu:opened", "menu:closed"],
    setup(e, t) {
        let {slots: n, emit: a} = t;
        const r = oe(null);
        wa(r, e);
        const o = h => {
            a("click", h)
        }
          , i = h => {
            r.value === h && a("menu:opened", h)
        }
          , s = h => {
            r.value === h && a("menu:closed", h)
        }
        ;
        Ci(r, e);
        const l = () => {
            ut( () => {
                D.on("menuOpened", i),
                D.on("menuClosed", s)
            }
            )
        }
          , c = () => {
            D.off("menuOpened", i),
            D.off("menuClosed", i)
        }
        ;
        Xe( () => l()),
        lt( () => c());
        const u = ae( () => Xs(e))
          , f = ae( () => e.link || e.href || e.href === "" ? "a" : "div")
          , d = ae( () => {
            let h;
            e.iconOnly || !e.text && !n.text ? h = !0 : h = !1;
            const m = e.dropdown || e.dropdown === "";
            return Oe({
                "menu-item": !0,
                "menu-item-dropdown": m,
                "icon-only": h
            }, je(e), Ao(e), Lo(e))
        }
        )
          , p = ae( () => {
            let h = e.href;
            return typeof h > "u" && e.link && (h = "#"),
            {
                href: h,
                target: e.target,
                ...zo(e),
                ...Po(e)
            }
        }
        );
        return {
            tag: f,
            classes: d,
            attrs: p,
            icon: u,
            onClick: o,
            elRef: r
        }
    }
}
  , W_ = {
    class: "menu-inner"
};
function Y_(e, t) {
    return O(),
    G("div", {
        class: Ae(e.classes)
    }, [V("div", W_, [ce(e.$slots, "default")])], 2)
}
const G_ = {
    name: "f7-menu",
    render: Y_,
    props: {
        ...qe
    },
    setup(e) {
        return {
            classes: ae( () => Oe("menu", je(e)))
        }
    }
}
  , X_ = {
    class: "message-content"
}
  , K_ = {
    key: 0,
    class: "message-image"
}
  , Z_ = ["src"]
  , J_ = {
    key: 1,
    class: "message-text-header"
}
  , Q_ = {
    key: 0,
    class: "message-typing-indicator"
}
  , ek = V("div", null, null, -1)
  , tk = V("div", null, null, -1)
  , nk = V("div", null, null, -1)
  , ak = [ek, tk, nk]
  , rk = {
    key: 3,
    class: "message-text-footer"
};
function ok(e, t) {
    return O(),
    G("div", {
        class: Ae(e.classes),
        onClick: t[6] || (t[6] = function() {
            return e.onClick && e.onClick(...arguments)
        }
        )
    }, [ce(e.$slots, "start"), e.hasAvatar ? (O(),
    G("div", {
        key: 0,
        class: "message-avatar",
        style: Rt({
            backgroundImage: e.avatar && `url(${e.avatar})`
        }),
        onClick: t[0] || (t[0] = function() {
            return e.onAvatarClick && e.onAvatarClick(...arguments)
        }
        )
    }, [ce(e.$slots, "avatar")], 4)) : pe("", !0), V("div", X_, [ce(e.$slots, "content-start"), e.hasName ? (O(),
    G("div", {
        key: 0,
        class: "message-name",
        onClick: t[1] || (t[1] = function() {
            return e.onNameClick && e.onNameClick(...arguments)
        }
        )
    }, [J(Me(e.name) + " ", 1), ce(e.$slots, "name")])) : pe("", !0), e.hasHeader ? (O(),
    G("div", {
        key: 1,
        class: "message-header",
        onClick: t[2] || (t[2] = function() {
            return e.onHeaderClick && e.onHeaderClick(...arguments)
        }
        )
    }, [J(Me(e.header) + " ", 1), ce(e.$slots, "header")])) : pe("", !0), V("div", {
        class: "message-bubble",
        onClick: t[4] || (t[4] = function() {
            return e.onBubbleClick && e.onBubbleClick(...arguments)
        }
        )
    }, [ce(e.$slots, "bubble-start"), e.hasImage ? (O(),
    G("div", K_, [ce(e.$slots, "image", {}, () => [V("img", {
        src: e.image
    }, null, 8, Z_)])])) : pe("", !0), e.hasTextHeader ? (O(),
    G("div", J_, [J(Me(e.textHeader) + " ", 1), ce(e.$slots, "text-header")])) : pe("", !0), e.hasText ? (O(),
    G("div", {
        key: 2,
        class: "message-text",
        onClick: t[3] || (t[3] = function() {
            return e.onTextClick && e.onTextClick(...arguments)
        }
        )
    }, [J(Me(e.text) + " ", 1), ce(e.$slots, "text"), e.typing ? (O(),
    G("div", Q_, ak)) : pe("", !0)])) : pe("", !0), e.hasTextFooter ? (O(),
    G("div", rk, [J(Me(e.textFooter) + " ", 1), ce(e.$slots, "text-footer")])) : pe("", !0), ce(e.$slots, "bubble-end"), ce(e.$slots, "default")]), e.hasFooter ? (O(),
    G("div", {
        key: 2,
        class: "message-footer",
        onClick: t[5] || (t[5] = function() {
            return e.onFooterClick && e.onFooterClick(...arguments)
        }
        )
    }, [J(Me(e.footer) + " ", 1), ce(e.$slots, "footer")])) : pe("", !0), ce(e.$slots, "content-end")]), ce(e.$slots, "end")], 2)
}
const ik = {
    name: "f7-message",
    render: ok,
    props: {
        text: String,
        name: String,
        avatar: String,
        type: {
            type: String,
            default: "sent"
        },
        image: String,
        header: String,
        footer: String,
        textHeader: String,
        textFooter: String,
        first: Boolean,
        last: Boolean,
        tail: Boolean,
        sameName: Boolean,
        sameHeader: Boolean,
        sameFooter: Boolean,
        sameAvatar: Boolean,
        typing: Boolean,
        ...qe
    },
    emits: ["click", "click:name", "click:text", "click:avatar", "click:header", "click:footer", "click:bubble"],
    setup(e, t) {
        let {emit: n, slots: a} = t;
        const r = w => {
            n("click", w)
        }
          , o = w => {
            n("click:name", w)
        }
          , i = w => {
            n("click:text", w)
        }
          , s = w => {
            n("click:avatar", w)
        }
          , l = w => {
            n("click:header", w)
        }
          , c = w => {
            n("click:footer", w)
        }
          , u = w => {
            n("click:bubble", w)
        }
          , f = ae( () => Oe("message", {
            "message-sent": e.type === "sent",
            "message-received": e.type === "received",
            "message-typing": e.typing,
            "message-first": e.first,
            "message-last": e.last,
            "message-tail": e.tail,
            "message-same-name": e.sameName,
            "message-same-header": e.sameHeader,
            "message-same-footer": e.sameFooter,
            "message-same-avatar": e.sameAvatar
        }, je(e)))
          , d = ae( () => a.avatar || e.avatar)
          , p = ae( () => a.name || e.name)
          , h = ae( () => a.header || e.header)
          , m = ae( () => a.image || e.image)
          , g = ae( () => a["text-header"] || e.textHeader)
          , b = ae( () => a.text || e.text || e.typing)
          , v = ae( () => a["text-footer"] || e.textFooter)
          , y = ae( () => a.footer || e.footer);
        return {
            classes: f,
            onClick: r,
            onNameClick: o,
            onTextClick: i,
            onAvatarClick: s,
            onHeaderClick: l,
            onFooterClick: c,
            onBubbleClick: u,
            hasAvatar: d,
            hasName: p,
            hasHeader: h,
            hasImage: m,
            hasTextHeader: g,
            hasText: b,
            hasTextFooter: v,
            hasFooter: y
        }
    }
}
  , sk = ["src"];
function lk(e, t) {
    return O(),
    G("div", {
        class: Ae(e.classes),
        onClick: t[1] || (t[1] = function() {
            return e.onClick && e.onClick(...arguments)
        }
        )
    }, [e.image ? (O(),
    G("img", {
        key: 0,
        src: e.image
    }, null, 8, sk)) : pe("", !0), e.deletable ? (O(),
    G("span", {
        key: 1,
        class: "messagebar-attachment-delete",
        onClick: t[0] || (t[0] = function() {
            return e.onDeleteClick && e.onDeleteClick(...arguments)
        }
        )
    })) : pe("", !0), ce(e.$slots, "default")], 2)
}
const ck = {
    name: "f7-messagebar-attachment",
    render: lk,
    props: {
        image: String,
        deletable: {
            type: Boolean,
            default: !0
        },
        ...qe
    },
    emits: ["attachment:click", "attachment:delete"],
    setup(e, t) {
        let {emit: n} = t;
        const a = i => {
            n("attachment:click", i)
        }
          , r = i => {
            n("attachment:delete", i)
        }
        ;
        return {
            classes: ae( () => Oe("messagebar-attachment", je(e))),
            onClick: a,
            onDeleteClick: r
        }
    }
};
function uk(e, t) {
    return O(),
    G("div", {
        class: Ae(e.classes)
    }, [ce(e.$slots, "default")], 2)
}
const fk = {
    name: "f7-messagebar-attachments",
    render: uk,
    props: {
        ...qe
    },
    setup(e) {
        return {
            classes: ae( () => Oe("messagebar-attachments", je(e)))
        }
    }
}
  , dk = ["checked"]
  , pk = V("i", {
    class: "icon icon-checkbox"
}, null, -1);
function hk(e, t) {
    return O(),
    G("label", {
        class: Ae(e.classes),
        style: Rt(e.styles)
    }, [V("input", {
        type: "checkbox",
        checked: e.checked,
        onChange: t[0] || (t[0] = function() {
            return e.onChange && e.onChange(...arguments)
        }
        )
    }, null, 40, dk), pk, ce(e.$slots, "default")], 6)
}
const mk = {
    name: "f7-messagebar-sheet-image",
    render: hk,
    props: {
        image: String,
        checked: Boolean,
        ...qe
    },
    emits: ["checked", "unchecked", "change", "update:checked"],
    setup(e, t) {
        let {emit: n} = t;
        const a = i => {
            i.target.checked ? n("checked", i) : n("unchecked", i),
            n("update:checked", i.target.checked),
            n("change", i)
        }
          , r = ae( () => Oe("messagebar-sheet-image", "checkbox", je(e)))
          , o = ae( () => ({
            backgroundImage: e.image && `url(${e.image})`
        }));
        return {
            classes: r,
            styles: o,
            onChange: a
        }
    }
};
function gk(e, t) {
    return O(),
    G("div", {
        class: Ae(e.classes)
    }, [ce(e.$slots, "default")], 2)
}
const vk = {
    name: "f7-messagebar-sheet-item",
    render: gk,
    props: {
        ...qe
    },
    setup(e) {
        return {
            classes: ae( () => Oe("messagebar-sheet-item", je(e)))
        }
    }
};
function bk(e, t) {
    return O(),
    G("div", {
        class: Ae(e.classes)
    }, [ce(e.$slots, "default")], 2)
}
const yk = {
    name: "f7-messagebar-sheet",
    render: bk,
    props: {
        ...qe
    },
    setup(e) {
        return {
            classes: ae( () => Oe("messagebar-sheet", je(e)))
        }
    }
}
  , Ck = {
    name: "f7-messagebar",
    props: {
        sheetVisible: Boolean,
        attachmentsVisible: Boolean,
        top: Boolean,
        resizable: {
            type: Boolean,
            default: !0
        },
        bottomOffset: {
            type: Number,
            default: 0
        },
        topOffset: {
            type: Number,
            default: 0
        },
        maxHeight: Number,
        resizePage: {
            type: Boolean,
            default: !0
        },
        sendLink: String,
        value: [String, Number, Array],
        disabled: Boolean,
        readonly: Boolean,
        textareaId: [Number, String],
        name: String,
        placeholder: {
            type: String,
            default: "Message"
        },
        init: {
            type: Boolean,
            default: !0
        },
        ...qe
    },
    emits: ["change", "input", "focus", "blur", "submit", "send", "click", "messagebar:attachmentdelete", "messagebar:attachmentclick", "messagebar:resizepage", "update:value"],
    setup(e, t) {
        let {emit: n, slots: a} = t;
        const r = oe(null)
          , o = oe(null);
        let i = null
          , s = !1
          , l = !1;
        const c = v => {
            n("change", v)
        }
          , u = v => {
            n("input", v),
            n("update:value", v.target.value)
        }
          , f = v => {
            n("focus", v)
        }
          , d = v => {
            n("blur", v)
        }
          , p = v => {
            const y = o.value.$el
              , w = i ? () => {
                i.clear()
            }
            : () => {}
            ;
            n("submit", y, w),
            n("send", y, w),
            n("click", v)
        }
          , h = (v, y, w) => {
            n("messagebar:attachmentdelete", v, y, w)
        }
          , m = (v, y, w) => {
            n("messagebar:attachmentclick", v, y, w)
        }
          , g = v => {
            n("messagebar:resizepage", v)
        }
        ;
        st( () => e.sheetVisible, () => {
            !e.resizable || !i || (s = !0)
        }
        ),
        st( () => e.attachmentsVisible, () => {
            !e.resizable || !i || (l = !0)
        }
        ),
        Xe( () => {
            if (!e.init || !r.value)
                return;
            const v = aa({
                el: r.value,
                top: e.top,
                resizePage: e.resizePage,
                bottomOffset: e.bottomOffset,
                topOffset: e.topOffset,
                maxHeight: e.maxHeight,
                on: {
                    attachmentDelete: h,
                    attachmentClick: m,
                    resizePage: g
                }
            });
            ut( () => {
                i = D.messagebar.create(v)
            }
            )
        }
        ),
        On( () => {
            i && (s && (s = !1,
            i.sheetVisible = e.sheetVisible,
            i.resizePage()),
            l && (l = !1,
            i.attachmentsVisible = e.attachmentsVisible,
            i.resizePage()))
        }
        ),
        lt( () => {
            i && i.destroy && i.destroy(),
            i = null
        }
        );
        const b = ae( () => Oe("toolbar", "messagebar", {
            "messagebar-attachments-visible": e.attachmentsVisible,
            "messagebar-sheet-visible": e.sheetVisible
        }, je(e)));
        return () => {
            const v = {};
            "value"in e && (v.value = e.value);
            const {default: y, "before-inner": w, "after-inner": C, "send-link": _, "inner-start": E, "inner-end": z, "before-area": T, "after-area": A} = a
              , x = [];
            let M, L;
            return y && y().forEach(U => {
                if (typeof U > "u")
                    return;
                const Y = U.type && U.type.name ? U.type.name : U.type;
                Y && (Y.indexOf("messagebar-attachments") >= 0 || Y === "F7MessagebarAttachments" || Y === "f7-messagebar-attachments") ? M = U : Y && (Y.indexOf("messagebar-sheet") >= 0 || Y === "F7MessagebarSheet" || Y === "f7-messagebar-sheet") ? L = U : x.push(U)
            }
            ),
            Pe("div", {
                class: b.value,
                ref: r
            }, [w && w(), Pe("div", {
                class: "toolbar-inner"
            }, [E && E(), Pe("div", {
                class: "messagebar-area"
            }, [T && T(), M, Pe(d6, {
                id: e.textareaId,
                ref: o,
                type: "textarea",
                wrap: !1,
                placeholder: e.placeholder,
                disabled: e.disabled,
                name: e.name,
                readonly: e.readonly,
                resizable: e.resizable,
                onInput: u,
                onChange: c,
                onFocus: f,
                onBlur: d,
                ...v
            }), A && A()]), (e.sendLink && e.sendLink.length > 0 || _) && Pe(Af, {
                onClick: p
            }, [_ ? _() : e.sendLink]), z && z(), x]), C && C(), L])
        }
    }
};
function wk(e, t) {
    return O(),
    G("div", {
        class: Ae(e.classes)
    }, [ce(e.$slots, "default")], 2)
}
const _k = {
    name: "f7-messages-title",
    render: wk,
    props: {
        ...qe
    },
    setup(e) {
        return {
            classes: ae( () => Oe("messages-title", je(e)))
        }
    }
};
function kk(e, t) {
    return O(),
    G("div", {
        ref: "elRef",
        class: Ae(e.classes)
    }, [ce(e.$slots, "default")], 2)
}
const Sk = {
    name: "f7-messages",
    render: kk,
    props: {
        autoLayout: {
            type: Boolean,
            default: !1
        },
        messages: {
            type: Array,
            default() {
                return []
            }
        },
        newMessagesFirst: {
            type: Boolean,
            default: !1
        },
        scrollMessages: {
            type: Boolean,
            default: !0
        },
        scrollMessagesOnEdge: {
            type: Boolean,
            default: !0
        },
        typing: {
            type: Boolean,
            default: !1
        },
        firstMessageRule: Function,
        lastMessageRule: Function,
        tailMessageRule: Function,
        sameNameMessageRule: Function,
        sameHeaderMessageRule: Function,
        sameFooterMessageRule: Function,
        sameAvatarMessageRule: Function,
        customClassMessageRule: Function,
        renderMessage: Function,
        init: {
            type: Boolean,
            default: !0
        },
        ...qe
    },
    setup(e, t) {
        let {slots: n} = t
          , a = null
          , r = null;
        const o = oe(null);
        Xe( () => {
            e.init && ut( () => {
                a = D.messages.create(aa({
                    el: o.value,
                    autoLayout: e.autoLayout,
                    messages: e.messages,
                    newMessagesFirst: e.newMessagesFirst,
                    scrollMessages: e.scrollMessages,
                    scrollMessagesOnEdge: e.scrollMessagesOnEdge,
                    firstMessageRule: e.firstMessageRule,
                    lastMessageRule: e.lastMessageRule,
                    tailMessageRule: e.tailMessageRule,
                    sameNameMessageRule: e.sameNameMessageRule,
                    sameHeaderMessageRule: e.sameHeaderMessageRule,
                    sameFooterMessageRule: e.sameFooterMessageRule,
                    sameAvatarMessageRule: e.sameAvatarMessageRule,
                    customClassMessageRule: e.customClassMessageRule,
                    renderMessage: e.renderMessage
                })),
                a && e.typing && a.showTyping()
            }
            )
        }
        ),
        Z1( () => {
            if (!e.init || !o.value)
                return;
            const s = o.value.children;
            if (!s)
                return;
            r = s.length;
            for (let c = 0; c < s.length; c += 1)
                s[c].classList.add("message-appeared");
            const l = rC(n);
            a && e.scrollMessages && r !== l && a.setScrollData()
        }
        ),
        On( () => {
            if (!e.init || !o.value)
                return;
            const s = o.value.children;
            if (!s)
                return;
            const l = s.length;
            for (let c = 0; c < s.length; c += 1)
                s[c].classList.contains("message-appeared") || s[c].classList.add("message-appear-from-bottom");
            a && a.layout && e.autoLayout && a.layout(),
            l !== r && a && a.scroll && a.scrollData && e.scrollMessages && a.scrollWithEdgeCheck(!0)
        }
        ),
        lt( () => {
            a && a.destroy && a.destroy(),
            a = null
        }
        ),
        st( () => e.typing, s => {
            a && (s ? a.showTyping() : a.hideTyping())
        }
        );
        const i = ae( () => Oe("messages", je(e)));
        return {
            elRef: o,
            classes: i
        }
    }
};
function $k(e, t) {
    const n = P("f7-link");
    return O(),
    G("div", {
        class: Ae(e.classes)
    }, [e.backLink ? (O(),
    K(n, {
        key: 0,
        href: e.backLinkUrl || "#",
        back: "",
        icon: "icon-back",
        force: e.backLinkForce || void 0,
        class: Ae(e.text ? void 0 : "icon-only"),
        text: e.text,
        onClick: e.onBackClick
    }, null, 8, ["href", "force", "class", "text", "onClick"])) : pe("", !0), ce(e.$slots, "default")], 2)
}
const h6 = {
    name: "f7-nav-left",
    render: $k,
    components: {
        f7Link: Af
    },
    props: {
        backLink: [Boolean, String],
        backLinkUrl: String,
        backLinkForce: Boolean,
        backLinkShowText: {
            type: Boolean,
            default: void 0
        },
        sliding: Boolean,
        ...qe
    },
    emits: ["back:click", "click:back"],
    setup(e, t) {
        let {emit: n} = t;
        const a = s => {
            n("back:click", s),
            n("click:back", s)
        }
          , r = Ks()
          , o = ae( () => {
            let s = e.backLinkShowText;
            if (typeof s > "u" && (s = !r.value.md),
            e.backLink)
                return e.backLink !== !0 && s ? e.backLink : void 0
        }
        );
        return {
            classes: ae( () => Oe("left", {
                sliding: e.sliding
            }, je(e))),
            onBackClick: a,
            text: o
        }
    }
};
function Ek(e, t) {
    return O(),
    G("div", {
        class: Ae(e.classes)
    }, [ce(e.$slots, "default")], 2)
}
const m6 = {
    name: "f7-nav-right",
    render: Ek,
    props: {
        sliding: Boolean,
        ...qe
    },
    setup(e) {
        return {
            classes: ae( () => Oe("right", {
                sliding: e.sliding
            }, je(e)))
        }
    }
}
  , xk = {
    class: "title-large-text"
};
function Tk(e, t) {
    return O(),
    G("div", {
        class: Ae(e.classes)
    }, [V("div", xk, [ce(e.$slots, "default")])], 2)
}
const Mk = {
    name: "f7-nav-title-large",
    render: Tk,
    props: {
        ...qe
    },
    setup(e) {
        return {
            classes: ae( () => Oe("title-large", je(e)))
        }
    }
}
  , zk = {
    key: 0,
    class: "subtitle"
};
function Ak(e, t) {
    return O(),
    G("div", {
        class: Ae(e.classes)
    }, [ce(e.$slots, "default"), J(" " + Me(e.title) + " ", 1), e.subtitle ? (O(),
    G("span", zk, Me(e.subtitle), 1)) : pe("", !0)], 2)
}
const g6 = {
    name: "f7-nav-title",
    render: Ak,
    props: {
        title: String,
        subtitle: String,
        sliding: Boolean,
        ...qe
    },
    setup(e) {
        return {
            classes: ae( () => Oe("title", {
                sliding: e.sliding
            }, je(e)))
        }
    }
}
  , Ok = V("div", {
    class: "navbar-bg"
}, null, -1)
  , Pk = {
    key: 3,
    className: "title-large"
}
  , Lk = {
    className: "title-large-text"
};
function Ik(e, t) {
    const n = P("f7-nav-left")
      , a = P("f7-nav-title")
      , r = P("f7-nav-right");
    return O(),
    G("div", {
        ref: "elRef",
        class: Ae(e.classes)
    }, [Ok, ce(e.$slots, "before-inner"), V("div", {
        class: Ae(e.innerClasses)
    }, [e.hasLeft ? (O(),
    K(n, {
        key: 0,
        "back-link": e.backLink,
        "back-link-url": e.backLinkUrl,
        "back-link-force": e.backLinkForce,
        "back-link-show-text": e.backLinkShowText,
        "onBack:click": e.onBackClick
    }, {
        default: k( () => [ce(e.$slots, "nav-left"), ce(e.$slots, "left")]),
        _: 3
    }, 8, ["back-link", "back-link-url", "back-link-force", "back-link-show-text", "onBack:click"])) : pe("", !0), e.hasTitle ? (O(),
    K(a, {
        key: 1,
        title: e.title,
        subtitle: e.subtitle
    }, {
        default: k( () => [ce(e.$slots, "title")]),
        _: 3
    }, 8, ["title", "subtitle"])) : pe("", !0), e.hasRight ? (O(),
    K(r, {
        key: 2
    }, {
        default: k( () => [ce(e.$slots, "nav-right"), ce(e.$slots, "right")]),
        _: 3
    })) : pe("", !0), e.hasLargeTitle ? (O(),
    G("div", Pk, [V("div", Lk, [J(Me(e.largeTitle) + " ", 1), ce(e.$slots, "title-large")])])) : pe("", !0), ce(e.$slots, "default")], 2), ce(e.$slots, "after-inner")], 2)
}
const Bk = {
    name: "f7-navbar",
    render: Ik,
    components: {
        f7NavLeft: h6,
        f7NavTitle: g6,
        f7NavRight: m6
    },
    props: {
        backLink: [Boolean, String],
        backLinkUrl: String,
        backLinkForce: Boolean,
        backLinkShowText: {
            type: Boolean,
            default: void 0
        },
        sliding: {
            type: Boolean,
            default: !0
        },
        title: String,
        subtitle: String,
        hidden: Boolean,
        noShadow: Boolean,
        noHairline: Boolean,
        innerClass: String,
        innerClassName: String,
        large: Boolean,
        largeTransparent: Boolean,
        transparent: Boolean,
        titleLarge: String,
        ...qe
    },
    emits: ["navbar:hide", "navbar:show", "navbar:expand", "navbar:collapse", "navbar:transparentshow", "navbar:transparenthide", "click:back", "back:click"],
    setup(e, t) {
        let {emit: n, slots: a} = t
          , r = ""
          , o = !1
          , i = null
          , s = !1
          , l = !1
          , c = !1;
        const u = oe(null)
          , f = Ks()
          , d = ve => {
            u.value === ve && n("navbar:hide")
        }
          , p = ve => {
            u.value === ve && n("navbar:show")
        }
          , h = ve => {
            u.value === ve && (o = !1,
            n("navbar:expand"))
        }
          , m = ve => {
            u.value === ve && (o = !0,
            n("navbar:collapse"))
        }
          , g = ve => {
            u.value === ve && (c = !0,
            n("navbar:transparentshow"))
        }
          , b = ve => {
            u.value === ve && (c = !1,
            n("navbar:transparenthide"))
        }
          , v = (ve, Ne) => {
            u.value === ve && (r = Ne ? `navbar-${Ne}` : "")
        }
          , y = (ve, Ne) => {
            u.value === ve && (i = Ne.role,
            s = Ne.detailRoot)
        }
          , w = ve => {
            u.value === ve && (l = !0)
        }
          , C = ve => {
            u.value === ve && (l = !1)
        }
          , _ = ve => {
            D && D.navbar.hide(u.value, ve)
        }
          , E = ve => {
            D && D.navbar.show(u.value, ve)
        }
          , z = () => {
            D && D.navbar.size(u.value)
        }
          , T = ve => {
            n("back:click", ve),
            n("click:back", ve)
        }
        ;
        Xe( () => {
            u.value && ut( () => {
                D.navbar.size(u.value),
                D.on("navbarShow", p),
                D.on("navbarHide", d),
                D.on("navbarCollapse", m),
                D.on("navbarExpand", h),
                D.on("navbarPosition", v),
                D.on("navbarRole", y),
                D.on("navbarMasterStack", w),
                D.on("navbarMasterUnstack", C),
                D.on("navbarTransparentShow", g),
                D.on("navbarTransparentHide", b)
            }
            )
        }
        ),
        lt( () => {
            D && (D.off("navbarShow", p),
            D.off("navbarHide", d),
            D.off("navbarCollapse", m),
            D.off("navbarExpand", h),
            D.off("navbarPosition", v),
            D.off("navbarRole", y),
            D.off("navbarMasterStack", w),
            D.off("navbarMasterUnstack", C),
            D.off("navbarTransparentShow", g),
            D.off("navbarTransparentHide", b))
        }
        );
        const A = ae( () => f.value && f.value.ios && D && !D.params.navbar.iosCenterTitle)
          , x = ae( () => f.value && f.value.md && D && D.params.navbar.mdCenterTitle || f.value && f.value.aurora && D && D.params.navbar.auroraCenterTitle)
          , M = ae( () => e.large || e.largeTransparent)
          , L = ae( () => e.transparent || M.value && e.largeTransparent)
          , U = ae( () => L.value && c)
          , Y = ae( () => Oe("navbar", r, {
            "navbar-hidden": e.hidden,
            "navbar-large": M.value,
            "navbar-large-collapsed": M.value && o,
            "navbar-transparent": L.value,
            "navbar-transparent-visible": U.value,
            "navbar-master": i === "master",
            "navbar-master-detail": i === "detail",
            "navbar-master-detail-root": s === !0,
            "navbar-master-stacked": l === !0,
            "no-shadow": e.noShadow,
            "no-hairline": e.noHairline
        }, je(e)))
          , H = ae( () => {
            let ve = e.titleLarge;
            return !ve && e.large && e.title && (ve = e.title),
            ve
        }
        )
          , W = ae( () => e.backLink || a["nav-left"] || a.left)
          , j = ae( () => e.title || e.subtitle || a.title)
          , Q = ae( () => a["nav-right"] || a.right)
          , ne = ae( () => H.value || a["title-large"])
          , re = ae( () => Oe("navbar-inner", e.innerClass, e.innerClassName, {
            sliding: e.sliding,
            "navbar-inner-left-title": A.value,
            "navbar-inner-centered-title": x.value
        }));
        return {
            elRef: u,
            classes: Y,
            innerClasses: re,
            hide: _,
            show: E,
            size: z,
            largeTitle: H,
            hasLeft: W,
            hasTitle: j,
            hasRight: Q,
            hasLargeTitle: ne,
            onBackClick: T
        }
    }
}
  , Rk = ["data-ptr-distance", "data-ptr-mousewheel", "data-infinite-distance"]
  , Dk = {
    key: 0,
    class: "ptr-preloader"
}
  , Nk = V("div", {
    class: "ptr-arrow"
}, null, -1)
  , Hk = {
    key: 3,
    class: "ptr-preloader"
}
  , Vk = V("div", {
    class: "ptr-arrow"
}, null, -1);
function Fk(e, t) {
    const n = P("f7-preloader");
    return O(),
    G("div", {
        ref: "elRef",
        class: Ae(e.classes),
        "data-ptr-distance": e.ptrDistance || void 0,
        "data-ptr-mousewheel": e.ptrMousewheel || void 0,
        "data-infinite-distance": e.infiniteDistance || void 0
    }, [e.ptr && e.ptrPreloader && !e.ptrBottom ? (O(),
    G("div", Dk, [S(n), Nk])) : pe("", !0), e.infinite && e.infinitePreloader && e.infiniteTop ? (O(),
    K(n, {
        key: 1,
        class: "infinite-scroll-preloader"
    })) : pe("", !0), ce(e.$slots, "default"), e.infinite && e.infinitePreloader && !e.infiniteTop ? (O(),
    K(n, {
        key: 2,
        class: "infinite-scroll-preloader"
    })) : pe("", !0), e.ptr && e.ptrPreloader && e.ptrBottom ? (O(),
    G("div", Hk, [S(n), Vk])) : pe("", !0)], 10, Rk)
}
const v6 = {
    name: "f7-page-content",
    render: Fk,
    components: {
        f7Preloader: Mf
    },
    props: {
        tab: Boolean,
        tabActive: Boolean,
        ptr: Boolean,
        ptrDistance: Number,
        ptrPreloader: {
            type: Boolean,
            default: !0
        },
        ptrBottom: Boolean,
        ptrMousewheel: Boolean,
        infinite: Boolean,
        infiniteTop: Boolean,
        infiniteDistance: Number,
        infinitePreloader: {
            type: Boolean,
            default: !0
        },
        hideBarsOnScroll: Boolean,
        hideNavbarOnScroll: Boolean,
        hideToolbarOnScroll: Boolean,
        messagesContent: Boolean,
        loginScreen: Boolean,
        ...qe
    },
    emits: ["ptr:pullstart", "ptr:pullmove", "ptr:pullend", "ptr:refresh", "ptr:done", "infinite", "ptrPullStart", "ptrPullMove", "ptrPullEnd", "ptrRefresh", "ptrDone", "tab:hide", "tab:show"],
    setup(e, t) {
        let {emit: n} = t;
        const a = oe(null)
          , r = f => {
            a.value === f && (n("ptr:pullstart"),
            n("ptrPullStart"))
        }
          , o = f => {
            a.value === f && (n("ptr:pullmove"),
            n("ptrPullMove"))
        }
          , i = f => {
            a.value === f && (n("ptr:pullend"),
            n("ptrPullEnd"))
        }
          , s = (f, d) => {
            a.value === f && (n("ptr:refresh", d),
            n("ptrRefresh", d))
        }
          , l = f => {
            a.value === f && (n("ptr:done"),
            n("ptrDone"))
        }
          , c = f => {
            a.value === f && n("infinite")
        }
        ;
        Gs(a, n),
        Xe( () => {
            ut( () => {
                e.ptr && (D.on("ptrPullStart", r),
                D.on("ptrPullMove", o),
                D.on("ptrPullEnd", i),
                D.on("ptrRefresh", s),
                D.on("ptrDone", l)),
                e.infinite && D.on("infinite", c)
            }
            )
        }
        ),
        lt( () => {
            D && (D.off("ptrPullStart", r),
            D.off("ptrPullMove", o),
            D.off("ptrPullEnd", i),
            D.off("ptrRefresh", s),
            D.off("ptrDone", l),
            D.off("infinite", c))
        }
        );
        const u = ae( () => Oe("page-content", {
            tab: e.tab,
            "tab-active": e.tabActive,
            "ptr-content": e.ptr,
            "ptr-bottom": e.ptrBottom,
            "infinite-scroll-content": e.infinite,
            "infinite-scroll-top": e.infiniteTop,
            "hide-bars-on-scroll": e.hideBarsOnScroll,
            "hide-navbar-on-scroll": e.hideNavbarOnScroll,
            "hide-toolbar-on-scroll": e.hideToolbarOnScroll,
            "messages-content": e.messagesContent,
            "login-screen-content": e.loginScreen
        }, je(e)));
        return {
            elRef: a,
            classes: u
        }
    }
}
  , jk = {
    name: "f7-page",
    props: {
        name: String,
        stacked: Boolean,
        withSubnavbar: {
            type: Boolean,
            default: void 0
        },
        subnavbar: {
            type: Boolean,
            default: void 0
        },
        withNavbarLarge: {
            type: Boolean,
            default: void 0
        },
        navbarLarge: {
            type: Boolean,
            default: void 0
        },
        noNavbar: Boolean,
        noToolbar: Boolean,
        tabs: Boolean,
        pageContent: {
            type: Boolean,
            default: !0
        },
        noSwipeback: Boolean,
        ptr: Boolean,
        ptrDistance: Number,
        ptrPreloader: {
            type: Boolean,
            default: !0
        },
        ptrBottom: Boolean,
        ptrMousewheel: Boolean,
        infinite: Boolean,
        infiniteTop: Boolean,
        infiniteDistance: Number,
        infinitePreloader: {
            type: Boolean,
            default: !0
        },
        hideBarsOnScroll: Boolean,
        hideNavbarOnScroll: Boolean,
        hideToolbarOnScroll: Boolean,
        messagesContent: Boolean,
        loginScreen: Boolean,
        ...qe
    },
    emits: ["page:mounted", "page:init", "page:reinit", "page:beforein", "page:beforeout", "page:afterout", "page:afterin", "page:beforeremove", "page:beforeunmount", "page:tabshow", "page:tabhide", "ptr:pullstart", "ptr:pullmove", "ptr:pullend", "ptr:refresh", "ptr:done", "infinite"],
    setup(e, t) {
        let {emit: n, slots: a} = t
          , r = !1
          , o = !1
          , i = !1
          , s = !1
          , l = ""
          , c = !1
          , u = null
          , f = !1
          , d = !1;
        const p = oe(null)
          , h = ee => {
            p.value === ee.el && n("page:mounted", ee)
        }
          , m = ee => {
            p.value === ee.el && (typeof e.withSubnavbar > "u" && typeof e.subnavbar > "u" && (ee.$navbarEl && ee.$navbarEl.length && ee.$navbarEl.find(".subnavbar").length || ee.$el.children(".navbar").find(".subnavbar").length) && (r = !0),
            typeof e.withNavbarLarge > "u" && typeof e.navbarLarge > "u" && ee.$navbarEl && ee.$navbarEl.hasClass("navbar-large") && (o = !0),
            n("page:init", ee))
        }
          , g = ee => {
            p.value === ee.el && n("page:reinit", ee)
        }
          , b = ee => {
            p.value === ee.el && (ee.swipeBack || (ee.from === "next" && (l = "page-next"),
            ee.from === "previous" && (l = "page-previous")),
            n("page:beforein", ee))
        }
          , v = ee => {
            p.value === ee.el && n("page:beforeout", ee)
        }
          , y = ee => {
            p.value === ee.el && (ee.to === "next" && (l = "page-next"),
            ee.to === "previous" && (l = "page-previous"),
            n("page:afterout", ee))
        }
          , w = ee => {
            p.value === ee.el && (l = "page-current",
            n("page:afterin", ee))
        }
          , C = ee => {
            p.value === ee.el && n("page:beforeremove", ee)
        }
          , _ = ee => {
            p.value === ee.el && n("page:beforeunmount", ee)
        }
          , E = ee => {
            p.value === ee && (c = !1)
        }
          , z = ee => {
            p.value === ee && (c = !0)
        }
          , T = (ee, ye) => {
            p.value === ee && (l = `page-${ye}`)
        }
          , A = (ee, ye) => {
            p.value === ee && (u = ye.role,
            f = ye.detailRoot)
        }
          , x = ee => {
            p.value === ee && (d = !0)
        }
          , M = ee => {
            p.value === ee && (d = !1)
        }
          , L = ee => {
            p.value === ee && (i = !0)
        }
          , U = ee => {
            p.value === ee && (i = !1)
        }
          , Y = (ee, ye) => {
            p.value === ye && (s = !0)
        }
          , H = (ee, ye) => {
            p.value === ye && (s = !1)
        }
          , W = ee => {
            p.value === ee && n("page:tabshow")
        }
          , j = ee => {
            p.value === ee && n("page:tabhide")
        }
          , Q = () => {
            n("ptr:pullstart")
        }
          , ne = () => {
            n("ptr:pullmove")
        }
          , re = () => {
            n("ptr:pullend")
        }
          , ve = ee => {
            n("ptr:refresh", ee)
        }
          , Ne = () => {
            n("ptr:done")
        }
          , Ge = () => {
            n("infinite")
        }
        ;
        Xe( () => {
            ut( () => {
                D.on("pageMounted", h),
                D.on("pageInit", m),
                D.on("pageReinit", g),
                D.on("pageBeforeIn", b),
                D.on("pageBeforeOut", v),
                D.on("pageAfterOut", y),
                D.on("pageAfterIn", w),
                D.on("pageBeforeRemove", C),
                D.on("pageBeforeUnmount", _),
                D.on("pageStack", E),
                D.on("pageUnstack", z),
                D.on("pagePosition", T),
                D.on("pageRole", A),
                D.on("pageMasterStack", x),
                D.on("pageMasterUnstack", M),
                D.on("pageNavbarLargeCollapsed", L),
                D.on("pageNavbarLargeExpanded", U),
                D.on("cardOpened", Y),
                D.on("cardClose", H),
                D.on("pageTabShow", W),
                D.on("pageTabHide", j)
            }
            )
        }
        ),
        lt( () => {
            D && (D.off("pageMounted", h),
            D.off("pageInit", m),
            D.off("pageReinit", g),
            D.off("pageBeforeIn", b),
            D.off("pageBeforeOut", v),
            D.off("pageAfterOut", y),
            D.off("pageAfterIn", w),
            D.off("pageBeforeRemove", C),
            D.off("pageBeforeUnmount", _),
            D.off("pageStack", E),
            D.off("pageUnstack", z),
            D.off("pagePosition", T),
            D.off("pageRole", A),
            D.off("pageMasterStack", x),
            D.off("pageMasterUnstack", M),
            D.off("pageNavbarLargeCollapsed", L),
            D.off("pageNavbarLargeExpanded", U),
            D.off("cardOpened", Y),
            D.off("cardClose", H),
            D.off("pageTabShow", W),
            D.off("pageTabHide", j))
        }
        );
        const Ye = ae( () => Oe("page", l, {
            stacked: e.stacked && !c,
            tabs: e.tabs,
            "page-with-subnavbar": e.subnavbar || e.withSubnavbar,
            "page-with-navbar-large": e.navbarLarge || e.withNavbarLarge,
            "no-navbar": e.noNavbar,
            "no-toolbar": e.noToolbar,
            "no-swipeback": e.noSwipeback,
            "page-master": u === "master",
            "page-master-detail": u === "detail",
            "page-master-detail-root": f === !0,
            "page-master-stacked": d === !0,
            "page-with-navbar-large-collapsed": i === !0,
            "page-with-card-opened": s === !0,
            "login-screen-page": e.loginScreen
        }, je(e)))
          , tt = "navbar toolbar tabbar subnavbar searchbar messagebar fab list-index panel".split(" ").map(ee => `f7-${ee}`);
        return () => {
            const ee = []
              , ye = []
              , {static: Le, fixed: Se, default: Re} = a;
            let Ve = !1
              , Ze = !1
              , q = e.messagesContent;
            const Z = Re && Re();
            Z && Z.forEach(me => {
                if (typeof me > "u")
                    return;
                const ge = me.type && me.type.name ? me.type.name : me.type;
                let ie = !1;
                if (!ge) {
                    (e.pageContent || e.pageContent === "") && ye.push(me);
                    return
                }
                ge === "f7-subnavbar" && (Ve = !0),
                ge === "f7-navbar" && me.props && (me.props.large || me.props.large === "") && (Ze = !0),
                typeof q > "u" && ge === "f7-messages" && (q = !0),
                tt.indexOf(ge) >= 0 && (ie = !0),
                e.pageContent && (ie ? ee.push(me) : ye.push(me))
            }
            );
            let de = Ye.value;
            return (Ve || r) && typeof e.subnavbar > "u" && typeof e.withSubnavbar > "u" && de.indexOf("page-with-subnavbar") < 0 && (de += " page-with-subnavbar"),
            (Ze || o) && typeof e.navbarLarge > "u" && typeof e.withNavbarLarge > "u" && de.indexOf("page-with-navbar-large") < 0 && (de += " page-with-navbar-large"),
            e.pageContent ? Pe("div", {
                class: de,
                ref: p,
                "data-name": e.name
            }, [ee, Se && Se(), Pe(v6, {
                ptr: e.ptr,
                ptrDistance: e.ptrDistance,
                ptrPreloader: e.ptrPreloader,
                ptrBottom: e.ptrBottom,
                ptrMousewheel: e.ptrMousewheel,
                infinite: e.infinite,
                infiniteTop: e.infiniteTop,
                infiniteDistance: e.infiniteDistance,
                infinitePreloader: e.infinitePreloader,
                hideBarsOnScroll: e.hideBarsOnScroll,
                hideNavbarOnScroll: e.hideNavbarOnScroll,
                hideToolbarOnScroll: e.hideToolbarOnScroll,
                messagesContent: e.messagesContent || q,
                loginScreen: e.loginScreen,
                onPtrPullStart: Q,
                onPtrPullMove: ne,
                onPtrPullEnd: re,
                onPtrRefresh: ve,
                onPtrDone: Ne,
                onInfinite: Ge
            }, () => [Le && Le(), ye])]) : Pe("div", {
                class: de,
                ref: p,
                "data-name": e.name
            }, [Se && Se(), Le && Le(), Re && Z])
        }
    }
}
  , Uk = {
    name: "f7-photo-browser",
    props: {
        init: {
            type: Boolean,
            default: !0
        },
        params: Object,
        photos: Array,
        exposition: {
            type: Boolean,
            default: !0
        },
        expositionHideCaptions: {
            type: Boolean,
            default: !1
        },
        type: {
            type: String
        },
        navbar: {
            type: Boolean,
            default: !0
        },
        toolbar: {
            type: Boolean,
            default: !0
        },
        theme: {
            type: String
        },
        captionsTheme: {
            type: String
        },
        iconsColor: {
            type: String
        },
        swipeToClose: {
            type: Boolean,
            default: !0
        },
        pageBackLinkText: {
            type: String,
            default: void 0
        },
        popupCloseLinkText: {
            type: String,
            default: void 0
        },
        navbarOfText: {
            type: String,
            default: void 0
        },
        navbarShowCount: {
            type: Boolean,
            default: void 0
        },
        swiper: {
            type: Object
        },
        url: {
            type: String
        },
        routableModals: {
            type: Boolean,
            default: !1
        },
        virtualSlides: {
            type: Boolean,
            default: !0
        },
        view: [String, Object],
        renderNavbar: Function,
        renderToolbar: Function,
        renderCaption: Function,
        renderObject: Function,
        renderLazyPhoto: Function,
        renderPhoto: Function,
        renderPage: Function,
        renderPopup: Function,
        renderStandalone: Function
    },
    emits: ["photobrowser:open", "photobrowser:close", "photobrowser:opened", "photobrowser:closed", "photobrowser:swipetoclose"],
    setup(e, t) {
        let {emit: n} = t
          , a = null;
        const r = c => a.open(c)
          , o = () => a.close()
          , i = () => a.expositionToggle()
          , s = () => a.expositionEnable()
          , l = () => a.expositionDisable();
        return st( () => e.photos, c => {
            const u = a;
            u && (u.params.photos = c,
            u.opened && u.swiper && u.swiper.update())
        }
        ),
        Xe( () => {
            e.init && ut( () => {
                let c;
                typeof e.params < "u" ? c = e.params : (c = {
                    ...e
                },
                delete c.params),
                Object.keys(c).forEach(u => {
                    (typeof c[u] > "u" || c[u] === "") && delete c[u]
                }
                ),
                c = Tn({}, c, {
                    on: {
                        open() {
                            n("photobrowser:open")
                        },
                        close() {
                            n("photobrowser:close")
                        },
                        opened() {
                            n("photobrowser:opened")
                        },
                        closed() {
                            n("photobrowser:closed")
                        },
                        swipeToClose() {
                            n("photobrowser:swipetoclose")
                        }
                    }
                }),
                a = D.photoBrowser.create(c)
            }
            )
        }
        ),
        lt( () => {
            a && a.destroy && a.destroy(),
            a = null
        }
        ),
        {
            open: r,
            close: o,
            expositionToggle: i,
            expositionEnable: s,
            expositionDisable: l
        }
    },
    render() {
        return null
    }
}
  , qk = ["width", "height", "viewBox"]
  , Wk = ["d", "fill", "data-index", "onClick", "onMouseenter"];
function Yk(e, t) {
    return O(),
    G("div", {
        ref: "elRef",
        class: Ae(e.classes)
    }, [(O(),
    G("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        width: e.size,
        height: e.size,
        viewBox: `-${e.size / 3} -${e.size / 3} ${e.size * 2 / 3} ${e.size * 2 / 3}`,
        style: Rt({
            transform: "rotate(-90deg)"
        })
    }, [(O(!0),
    G(Be, null, vt(e.paths, (n, a) => (O(),
    G("path", {
        key: n.label || a,
        d: n.points,
        fill: n.color,
        "data-index": a,
        class: Ae(e.classNames({
            "pie-chart-hidden": e.currentIndex !== null && e.currentIndex !== a
        })),
        onClick: r => e.setCurrentIndex(a),
        onMouseenter: r => e.setCurrentIndex(a),
        onMouseleave: t[0] || (t[0] = r => e.setCurrentIndex(null))
    }, null, 42, Wk))), 128))], 12, qk)), ce(e.$slots, "default")], 2)
}
const Gk = {
    name: "f7-pie-chart",
    render: Yk,
    props: {
        size: {
            type: Number,
            default: 320
        },
        tooltip: Boolean,
        datasets: {
            type: Array,
            default: () => []
        },
        formatTooltip: Function
    },
    emits: ["select"],
    setup(e, t) {
        let {emit: n} = t;
        const a = oe(null);
        let r = null;
        const o = oe(null)
          , i = d => {
            o.value = d
        }
          , s = ae( () => {
            let d = 0;
            return e.datasets.map(p => p.value || 0).forEach(p => {
                d += p
            }
            ),
            d
        }
        )
          , l = ae( () => {
            const d = [];
            let p = 0;
            function h(m) {
                const g = Math.cos(2 * Math.PI * m) * (e.size / 3)
                  , b = Math.sin(2 * Math.PI * m) * (e.size / 3);
                return [g, b]
            }
            return e.datasets.forEach(m => {
                let {value: g, label: b, color: v} = m;
                const y = g / s.value
                  , [w,C] = h(p);
                p += y;
                const [_,E] = h(p)
                  , z = y > .5 ? 1 : 0
                  , T = [`M ${w} ${C}`, `A ${e.size / 3} ${e.size / 3} 0 ${z} 1 ${_} ${E}`, "L 0 0"].join(" ");
                d.push({
                    points: T,
                    label: b,
                    color: v
                })
            }
            ),
            d
        }
        )
          , c = () => {
            if (o.value === null)
                return "";
            const {value: d, label: p, color: h} = e.datasets[o.value]
              , m = d / s.value * 100
              , g = v => parseInt(v, 10) === v ? v : Math.round(v * 100) / 100;
            if (e.formatTooltip)
                return e.formatTooltip({
                    index: o.value,
                    value: d,
                    label: p,
                    color: h,
                    percentage: m
                });
            const b = `${p ? `${p}: ` : ""}${g(d)} (${g(m)}%)`;
            return `
      <div class="pie-chart-tooltip-label">
        <span class="pie-chart-tooltip-color" style="background-color: ${h};"></span> ${b}
      </div>
    `
        }
          , u = () => {
            const d = o.value;
            if (!(d === null && !r) && !(!e.tooltip || !a.value || !D)) {
                if (d !== null && !r) {
                    r = D.tooltip.create({
                        trigger: "manual",
                        containerEl: a.value,
                        targetEl: a.value.querySelector(`path[data-index="${d}"]`),
                        text: c(),
                        cssClass: "pie-chart-tooltip"
                    }),
                    r.show();
                    return
                }
                r && (d !== null ? (r.setText(c()),
                r.setTargetEl(a.value.querySelector(`path[data-index="${d}"]`)),
                r.show()) : r.hide())
            }
        }
        ;
        st( () => o.value, () => {
            n("select", o.value, e.datasets[o.value]),
            u()
        }
        ),
        lt( () => {
            r && r.destroy && r.destroy(),
            r = null
        }
        );
        const f = ae( () => Oe("pie-chart"));
        return {
            elRef: a,
            currentIndex: o,
            classes: f,
            paths: l,
            classNames: Oe,
            setCurrentIndex: i
        }
    }
}
  , Xk = ["data-progress"];
function Kk(e, t) {
    return O(),
    G("span", {
        ref: "elRef",
        class: Ae(e.classes),
        "data-progress": e.progress
    }, [V("span", {
        style: Rt(e.transformStyle)
    }, null, 4)], 10, Xk)
}
const Zk = {
    name: "f7-progressbar",
    render: Kk,
    props: {
        progress: Number,
        infinite: Boolean,
        ...qe
    },
    setup(e) {
        const t = oe(null)
          , n = (o, i) => {
            D && D.progressbar.set(t.value, o, i)
        }
          , a = ae( () => ({
            transform: e.progress ? `translate3d(${-100 + e.progress}%, 0, 0)` : "",
            WebkitTransform: e.progress ? `translate3d(${-100 + e.progress}%, 0, 0)` : ""
        }));
        return {
            classes: ae( () => Oe("progressbar", {
                "progressbar-infinite": e.infinite
            }, je(e))),
            set: n,
            transformStyle: a,
            elRef: t
        }
    }
}
  , Jk = ["name", "value", "disabled", "readonly", "checked"]
  , Qk = V("i", {
    class: "icon-radio"
}, null, -1);
function eS(e, t) {
    return O(),
    G("label", {
        class: Ae(e.classes)
    }, [V("input", {
        ref: "inputElRef",
        type: "radio",
        name: e.name,
        value: e.value,
        disabled: e.disabled,
        readonly: e.readonly,
        checked: e.checked,
        onChange: t[0] || (t[0] = function() {
            return e.onChange && e.onChange(...arguments)
        }
        )
    }, null, 40, Jk), Qk, ce(e.$slots, "default")], 2)
}
const tS = {
    name: "f7-radio",
    render: eS,
    props: {
        checked: Boolean,
        name: [Number, String],
        value: {
            type: [Number, String, Boolean],
            default: void 0
        },
        disabled: Boolean,
        readonly: Boolean,
        ...qe
    },
    emits: ["update:checked", "change"],
    setup(e, t) {
        let {emit: n} = t;
        const a = oe(null)
          , r = i => {
            n("update:checked", i.target.checked),
            n("change", i)
        }
          , o = ae( () => Oe({
            radio: !0,
            disabled: e.disabled
        }, je(e)));
        return {
            inputElRef: a,
            classes: o,
            onChange: r
        }
    }
}
  , nS = {
    key: 0,
    class: "resize-handler"
};
function aS(e, t) {
    return O(),
    K(jn(e.tag), {
        ref: "elRef",
        class: Ae(e.classes)
    }, {
        default: k( () => [ce(e.$slots, "default"), e.resizable && e.resizableHandler ? (O(),
        G("span", nS)) : pe("", !0)]),
        _: 3
    }, 8, ["class"])
}
const rS = {
    name: "f7-row",
    render: aS,
    props: {
        noGap: Boolean,
        tag: {
            type: String,
            default: "div"
        },
        resizable: Boolean,
        resizableFixed: Boolean,
        resizableAbsolute: Boolean,
        resizableHandler: {
            type: Boolean,
            default: !0
        },
        ...qe
    },
    emits: ["grid:resize"],
    setup(e, t) {
        let {emit: n} = t;
        const a = oe(null)
          , r = i => {
            i === a.value && n("grid:resize")
        }
        ;
        return Xe( () => {
            ut( () => {
                D.on("gridResize", r)
            }
            )
        }
        ),
        lt( () => {
            D.off("gridResize", r)
        }
        ),
        {
            classes: ae( () => Oe("row", {
                "no-gap": e.noGap,
                resizable: e.resizable,
                "resizable-fixed": e.resizableFixed,
                "resizable-absolute": e.resizableAbsolute
            }, je(e))),
            elRef: a
        }
    }
}
  , oS = {
    class: "searchbar-inner"
}
  , iS = {
    class: "searchbar-input-wrap"
}
  , sS = ["value", "placeholder", "spellcheck"]
  , lS = V("i", {
    class: "searchbar-icon"
}, null, -1);
function cS(e, t) {
    return O(),
    K(jn(e.tag), {
        ref: "elRef",
        class: Ae(e.classes),
        onSubmit: e.onSubmit
    }, {
        default: k( () => [ce(e.$slots, "before-inner"), V("div", oS, [ce(e.$slots, "inner-start"), V("div", iS, [ce(e.$slots, "input-wrap-start"), V("input", {
            value: e.value,
            placeholder: e.placeholder,
            spellcheck: e.spellcheck,
            type: "search",
            onInput: t[0] || (t[0] = function() {
                return e.onInput && e.onInput(...arguments)
            }
            ),
            onChange: t[1] || (t[1] = function() {
                return e.onChange && e.onChange(...arguments)
            }
            ),
            onFocus: t[2] || (t[2] = function() {
                return e.onFocus && e.onFocus(...arguments)
            }
            ),
            onBlur: t[3] || (t[3] = function() {
                return e.onBlur && e.onBlur(...arguments)
            }
            )
        }, null, 40, sS), lS, e.clearButton ? (O(),
        G("span", {
            key: 0,
            class: "input-clear-button",
            onClick: t[4] || (t[4] = function() {
                return e.onClearButtonClick && e.onClearButtonClick(...arguments)
            }
            )
        })) : pe("", !0), ce(e.$slots, "input-wrap-end")]), e.disableButton ? (O(),
        G("span", {
            key: 0,
            class: "searchbar-disable-button",
            onClick: t[5] || (t[5] = function() {
                return e.onDisableButtonClick && e.onDisableButtonClick(...arguments)
            }
            )
        }, Me(e.disableButtonText), 1)) : pe("", !0), ce(e.$slots, "inner-end"), ce(e.$slots, "default")]), ce(e.$slots, "after-inner")]),
        _: 3
    }, 8, ["class", "onSubmit"])
}
const uS = {
    name: "f7-searchbar",
    render: cS,
    props: {
        noShadow: Boolean,
        noHairline: Boolean,
        form: {
            type: Boolean,
            default: !0
        },
        placeholder: {
            type: String,
            default: "Search"
        },
        spellcheck: {
            type: Boolean,
            default: void 0
        },
        disableButton: {
            type: Boolean,
            default: !0
        },
        disableButtonText: {
            type: String,
            default: "Cancel"
        },
        clearButton: {
            type: Boolean,
            default: !0
        },
        value: [String, Number, Array],
        inputEvents: {
            type: String,
            default: "change input compositionend"
        },
        expandable: Boolean,
        inline: Boolean,
        searchContainer: [String, Object],
        searchIn: {
            type: String,
            default: ".item-title"
        },
        searchItem: {
            type: String,
            default: "li"
        },
        searchGroup: {
            type: String,
            default: ".list-group"
        },
        searchGroupTitle: {
            type: String,
            default: ".item-divider, .list-group-title"
        },
        foundEl: {
            type: [String, Object],
            default: ".searchbar-found"
        },
        notFoundEl: {
            type: [String, Object],
            default: ".searchbar-not-found"
        },
        backdrop: {
            type: Boolean,
            default: void 0
        },
        backdropEl: [String, Object],
        hideOnEnableEl: {
            type: [String, Object],
            default: ".searchbar-hide-on-enable"
        },
        hideOnSearchEl: {
            type: [String, Object],
            default: ".searchbar-hide-on-search"
        },
        ignore: {
            type: String,
            default: ".searchbar-ignore"
        },
        customSearch: {
            type: Boolean,
            default: !1
        },
        removeDiacritics: {
            type: Boolean,
            default: !1
        },
        hideDividers: {
            type: Boolean,
            default: !0
        },
        hideGroups: {
            type: Boolean,
            default: !0
        },
        init: {
            type: Boolean,
            default: !0
        },
        ...qe
    },
    emits: ["change", "input", "focus", "blur", "submit", "click:clear", "click:disable", "searchbar:search", "searchbar:clear", "searchbar:enable", "searchbar:disable", "update:value"],
    setup(e, t) {
        let {emit: n} = t
          , a = null;
        const r = oe(null)
          , o = y => {
            if (a)
                return a.search(y)
        }
          , i = () => {
            if (a)
                return a.enable()
        }
          , s = () => {
            if (a)
                return a.disable()
        }
          , l = () => {
            if (a)
                return a.toggle()
        }
          , c = () => {
            if (a)
                return a.clear()
        }
          , u = y => {
            n("change", y)
        }
          , f = y => {
            n("input", y),
            n("update:value", y.target.value)
        }
          , d = y => {
            n("focus", y)
        }
          , p = y => {
            n("blur", y)
        }
          , h = y => {
            n("submit", y)
        }
          , m = y => {
            n("click:clear", y)
        }
          , g = y => {
            n("click:disable", y)
        }
        ;
        Xe( () => {
            e.init && ut( () => {
                const y = aa({
                    el: r.value,
                    inputEvents: e.inputEvents,
                    searchContainer: e.searchContainer,
                    searchIn: e.searchIn,
                    searchItem: e.searchItem,
                    searchGroup: e.searchGroup,
                    searchGroupTitle: e.searchGroupTitle,
                    hideOnEnableEl: e.hideOnEnableEl,
                    hideOnSearchEl: e.hideOnSearchEl,
                    foundEl: e.foundEl,
                    notFoundEl: e.notFoundEl,
                    backdrop: e.backdrop,
                    backdropEl: e.backdropEl,
                    disableButton: e.disableButton,
                    ignore: e.ignore,
                    customSearch: e.customSearch,
                    removeDiacritics: e.removeDiacritics,
                    hideDividers: e.hideDividers,
                    hideGroups: e.hideGroups,
                    expandable: e.expandable,
                    inline: e.inline,
                    on: {
                        search(w, C, _) {
                            n("searchbar:search", w, C, _)
                        },
                        clear(w, C) {
                            n("searchbar:clear", w, C)
                        },
                        enable(w) {
                            n("searchbar:enable", w)
                        },
                        disable(w) {
                            n("searchbar:disable", w)
                        }
                    }
                });
                Object.keys(y).forEach(w => {
                    y[w] === "" && delete y[w]
                }
                ),
                a = D.searchbar.create(y)
            }
            )
        }
        ),
        lt( () => {
            a && a.destroy && a.destroy(),
            a = null
        }
        );
        const b = ae( () => Oe("searchbar", {
            "searchbar-inline": e.inline,
            "no-shadow": e.noShadow,
            "no-hairline": e.noHairline,
            "searchbar-expandable": e.expandable
        }, je(e)))
          , v = ae( () => e.form ? "form" : "div");
        return {
            elRef: r,
            tag: v,
            classes: b,
            search: o,
            enable: i,
            disable: s,
            toggle: l,
            clear: c,
            onChange: u,
            onInput: f,
            onFocus: d,
            onBlur: p,
            onSubmit: h,
            onClearButtonClick: m,
            onDisableButtonClick: g
        }
    }
}
  , fS = {
    key: 0,
    class: "segmented-highlight"
};
function dS(e, t) {
    return O(),
    K(jn(e.tag), {
        class: Ae(e.classes)
    }, {
        default: k( () => [ce(e.$slots, "default"), e.strong || e.strongIos || e.strongMd || e.strongAurora ? (O(),
        G("span", fS)) : pe("", !0)]),
        _: 3
    }, 8, ["class"])
}
const pS = {
    name: "f7-segmented",
    render: dS,
    props: {
        raised: Boolean,
        raisedIos: Boolean,
        raisedMd: Boolean,
        raisedAurora: Boolean,
        round: Boolean,
        roundIos: Boolean,
        roundMd: Boolean,
        roundAurora: Boolean,
        strong: Boolean,
        strongIos: Boolean,
        strongMd: Boolean,
        strongAurora: Boolean,
        tag: {
            type: String,
            default: "div"
        },
        ...qe
    },
    setup(e) {
        return {
            classes: ae( () => Oe({
                segmented: !0,
                "segmented-raised": e.raised,
                "segmented-raised-ios": e.raisedIos,
                "segmented-raised-aurora": e.raisedAurora,
                "segmented-raised-md": e.raisedMd,
                "segmented-round": e.round,
                "segmented-round-ios": e.roundIos,
                "segmented-round-aurora": e.roundAurora,
                "segmented-round-md": e.roundMd,
                "segmented-strong": e.strong,
                "segmented-strong-ios": e.strongIos,
                "segmented-strong-md": e.strongMd,
                "segmented-strong-aurora": e.strongAurora
            }, je(e)))
        }
    }
}
  , hS = {
    name: "skeleton-block",
    props: {
        tag: {
            type: String,
            default: "div"
        },
        width: [String, Number],
        height: [String, Number],
        borderRadius: String,
        effect: String
    },
    render() {
        return Pe(this.tag, {
            class: {
                "skeleton-block": !0,
                [`skeleton-effect-${this.effect}`]: this.effect
            },
            style: {
                width: this.width,
                height: this.height,
                borderRadius: this.borderRadius
            }
        }, this.$slots.default && this.$slots.default())
    }
}
  , mS = {
    name: "skeleton-text",
    props: {
        tag: {
            type: String,
            default: "span"
        },
        effect: String
    },
    render() {
        return Pe(this.tag, {
            class: {
                "skeleton-text": !0,
                [`skeleton-effect-${this.effect}`]: this.effect
            }
        }, this.$slots.default && this.$slots.default())
    }
};
function b6(e, t, n, a) {
    const r = Math.min(n, a) * .5
      , o = r / t;
    return e.replace(/([0-9,\.]{1,})/g, i => {
        i = i.split(",").map(c => parseFloat(c));
        const s = i[0] * o + n / 2 - t * o / 2
          , l = i[1] * o + a / 2 - t * o / 2;
        return r >= 100 ? `${Math.round(s)},${Math.round(l)}` : `${s},${l}`
    }
    )
}
const gS = {
    name: "skeleton-image",
    props: {
        tag: {
            type: String,
            default: "span"
        },
        width: {
            type: Number,
            default: 1200
        },
        height: {
            type: Number,
            default: 600
        },
        color: String,
        iconColor: String,
        showIcon: {
            type: Boolean,
            default: !0
        },
        effect: String,
        borderRadius: String
    },
    render() {
        const {tag: e, color: t, iconColor: n, showIcon: a, width: r, height: o, effect: i, borderRadius: s} = this;
        return Pe(e, {
            class: {
                "skeleton-image": !0,
                [`skeleton-effect-${i}`]: i
            }
        }, [Pe("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            width: r,
            height: o,
            viewBox: `0 0 ${r} ${o}`,
            style: {
                borderRadius: s
            },
            preserveAspectRatio: "none"
        }, [Pe("polygon", {
            style: {
                fill: t
            },
            fillRule: "evenodd",
            points: `0 0 ${r} 0 ${r} ${o} 0 ${o}`
        }), a && Pe("path", {
            style: {
                fill: n
            },
            d: b6("M7.7148,49.5742 L48.2852,49.5742 C53.1836,49.5742 55.6446,47.1367 55.6446,42.3086 L55.6446,13.6914 C55.6446,8.8633 53.1836,6.4258 48.2852,6.4258 L7.7148,6.4258 C2.8398,6.4258 0.3554,8.8398 0.3554,13.6914 L0.3554,42.3086 C0.3554,47.1602 2.8398,49.5742 7.7148,49.5742 Z M39.2851,27.9414 C38.2304,27.0039 37.0351,26.5118 35.7695,26.5118 C34.457,26.5118 33.3085,26.9571 32.2304,27.918 L21.6366,37.3867 L17.3007,33.4492 C16.3163,32.582 15.2617,32.1133 14.1366,32.1133 C13.1054,32.1133 12.0976,32.5586 11.1366,33.4258 L4.1288,39.7305 L4.1288,13.8789 C4.1288,11.4414 5.4413,10.1992 7.7851,10.1992 L48.2147,10.1992 C50.535,10.1992 51.8708,11.4414 51.8708,13.8789 L51.8708,39.7539 L39.2851,27.9414 Z M17.8163,28.1992 C20.8398,28.1992 23.3241,25.7149 23.3241,22.668 C23.3241,19.6445 20.8398,17.1367 17.8163,17.1367 C14.7695,17.1367 12.2851,19.6445 12.2851,22.668 C12.2851,25.7149 14.7695,28.1992 17.8163,28.1992 Z", 56, r, o)
        })]), this.$slots.default && this.$slots.default()])
    }
}
  , vS = {
    name: "skeleton-avatar",
    props: {
        tag: {
            type: String,
            default: "span"
        },
        size: {
            type: Number,
            default: 48
        },
        borderRadius: {
            type: [String, Number],
            default: "50%"
        },
        color: String,
        iconColor: String,
        showIcon: {
            type: Boolean,
            default: !0
        },
        effect: String
    },
    render() {
        const {tag: e, color: t, iconColor: n, showIcon: a, size: r, borderRadius: o, effect: i} = this;
        return Pe(e, {
            class: {
                "skeleton-avatar": !0,
                [`skeleton-effect-${i}`]: i
            }
        }, [Pe("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            width: r,
            height: r,
            viewBox: `0 0 ${r} ${r}`,
            preserveAspectRatio: "none"
        }, [Pe("rect", {
            style: {
                fill: t
            },
            fillRule: "evenodd",
            width: r,
            height: r,
            rx: o
        }), a && Pe("path", {
            style: {
                fill: n
            },
            d: b6("M28.22461,27.1590817 C34.9209931,27.1590817 40.6829044,21.1791004 40.6829044,13.3926332 C40.6829044,5.69958662 34.8898972,0 28.22461,0 C21.5594557,0 15.7663156,5.82423601 15.7663156,13.4549579 C15.7663156,21.1791004 21.5594557,27.1590817 28.22461,27.1590817 Z M8.66515427,56 L47.7841986,56 C52.6739629,56 54.4181241,54.5984253 54.4181241,51.8576005 C54.4181241,43.8219674 44.358068,32.7341519 28.22461,32.7341519 C12.0600561,32.7341519 2,43.8219674 2,51.8576005 C2,54.5984253 3.74402832,56 8.66515427,56 Z", 56, r, r)
        })]), this.$slots.default && this.$slots.default()])
    }
}
  , bS = {
    key: 0,
    class: "stepper-input-wrap"
}
  , yS = ["id", "name", "type", "min", "max", "step", "value", "readonly"]
  , CS = {
    key: 1,
    class: "stepper-value"
};
function wS(e, t) {
    return O(),
    G("div", {
        ref: "elRef",
        class: Ae(e.classes)
    }, [V("div", {
        class: "stepper-button-minus",
        onClick: t[0] || (t[0] = function() {
            return e.onMinusClick && e.onMinusClick(...arguments)
        }
        )
    }), e.input && !e.buttonsOnly ? (O(),
    G("div", bS, [V("input", {
        id: e.inputId,
        name: e.name,
        type: e.inputType,
        min: e.inputType === "number" ? e.min : void 0,
        max: e.inputType === "number" ? e.max : void 0,
        step: e.inputType === "number" ? e.step : void 0,
        value: e.value,
        readonly: e.inputReadonly,
        onInput: t[1] || (t[1] = function() {
            return e.onInput && e.onInput(...arguments)
        }
        ),
        onChange: t[2] || (t[2] = function() {
            return e.onChange && e.onChange(...arguments)
        }
        )
    }, null, 40, yS)])) : pe("", !0), !e.input && !e.buttonsOnly ? (O(),
    G("div", CS, Me(e.value), 1)) : pe("", !0), V("div", {
        class: "stepper-button-plus",
        onClick: t[3] || (t[3] = function() {
            return e.onPlusClick && e.onPlusClick(...arguments)
        }
        )
    })], 2)
}
const _S = {
    name: "f7-stepper",
    render: wS,
    props: {
        init: {
            type: Boolean,
            default: !0
        },
        value: {
            type: Number,
            default: 0
        },
        min: {
            type: Number,
            default: 0
        },
        max: {
            type: Number,
            default: 100
        },
        step: {
            type: Number,
            default: 1
        },
        formatValue: Function,
        name: String,
        inputId: String,
        input: {
            type: Boolean,
            default: !0
        },
        inputType: {
            type: String,
            default: "text"
        },
        inputReadonly: {
            type: Boolean,
            default: !1
        },
        autorepeat: {
            type: Boolean,
            default: !1
        },
        autorepeatDynamic: {
            type: Boolean,
            default: !1
        },
        wraps: {
            type: Boolean,
            default: !1
        },
        manualInputMode: {
            type: Boolean,
            default: !1
        },
        decimalPoint: {
            type: Number,
            default: 4
        },
        buttonsEndInputMode: {
            type: Boolean,
            default: !0
        },
        disabled: Boolean,
        buttonsOnly: Boolean,
        round: Boolean,
        roundMd: Boolean,
        roundIos: Boolean,
        roundAurora: Boolean,
        fill: Boolean,
        fillMd: Boolean,
        fillIos: Boolean,
        fillAurora: Boolean,
        large: Boolean,
        largeMd: Boolean,
        largeIos: Boolean,
        largeAurora: Boolean,
        small: Boolean,
        smallMd: Boolean,
        smallIos: Boolean,
        smallAurora: Boolean,
        raised: Boolean,
        raisedMd: Boolean,
        raisedIos: Boolean,
        raisedAurora: Boolean,
        ...qe
    },
    emits: ["input", "change", "stepper:minusclick", "stepper:plusclick", "stepper:change", "update:value"],
    setup(e, t) {
        let {emit: n} = t
          , a = null;
        const r = oe(null)
          , o = () => {
            a && a.increment()
        }
          , i = () => {
            a && a.decrement()
        }
          , s = h => {
            a && a.setValue && a.setValue(h)
        }
          , l = () => {
            if (a && a.getValue)
                return a.getValue()
        }
          , c = h => {
            n("input", h, a)
        }
          , u = h => {
            n("change", h, a)
        }
          , f = h => {
            n("stepper:minusclick", h, a)
        }
          , d = h => {
            n("stepper:plusclick", h, a)
        }
        ;
        st( () => e.value, h => {
            a && a.setValue(h)
        }
        ),
        Xe( () => {
            ut( () => {
                !e.init || !r.value || (a = D.stepper.create(aa({
                    el: r.value,
                    min: e.min,
                    max: e.max,
                    value: e.value,
                    step: e.step,
                    formatValue: e.formatValue,
                    autorepeat: e.autorepeat,
                    autorepeatDynamic: e.autorepeatDynamic,
                    wraps: e.wraps,
                    manualInputMode: e.manualInputMode,
                    decimalPoint: e.decimalPoint,
                    buttonsEndInputMode: e.buttonsEndInputMode,
                    on: {
                        change(h, m) {
                            n("stepper:change", m),
                            n("update:value", m)
                        }
                    }
                })))
            }
            )
        }
        ),
        lt( () => {
            a && a.destroy && a.destroy(),
            a = null
        }
        );
        const p = ae( () => Oe("stepper", {
            disabled: e.disabled,
            "stepper-round": e.round,
            "stepper-round-ios": e.roundIos,
            "stepper-round-md": e.roundMd,
            "stepper-round-aurora": e.roundAurora,
            "stepper-fill": e.fill,
            "stepper-fill-ios": e.fillIos,
            "stepper-fill-md": e.fillMd,
            "stepper-fill-aurora": e.fillAurora,
            "stepper-large": e.large,
            "stepper-large-ios": e.largeIos,
            "stepper-large-md": e.largeMd,
            "stepper-large-aurora": e.largeAurora,
            "stepper-small": e.small,
            "stepper-small-ios": e.smallIos,
            "stepper-small-md": e.smallMd,
            "stepper-small-aurora": e.smallAurora,
            "stepper-raised": e.raised,
            "stepper-raised-ios": e.raisedIos,
            "stepper-raised-md": e.raisedMd,
            "stepper-raised-aurora": e.raisedAurora
        }, je(e)));
        return {
            elRef: r,
            classes: p,
            increment: o,
            decrement: i,
            setValue: s,
            getValue: l,
            onInput: c,
            onChange: u,
            onMinusClick: f,
            onPlusClick: d
        }
    }
}
  , kS = {
    key: 0,
    class: "subnavbar-inner"
}
  , SS = {
    key: 0,
    class: "subnavbar-title"
};
function $S(e, t) {
    return O(),
    G("div", {
        class: Ae(e.classes)
    }, [e.inner ? (O(),
    G("div", kS, [e.title ? (O(),
    G("div", SS, Me(e.title), 1)) : pe("", !0), ce(e.$slots, "default")])) : ce(e.$slots, "default", {
        key: 1
    })], 2)
}
const ES = {
    name: "f7-subnavbar",
    render: $S,
    props: {
        sliding: Boolean,
        title: String,
        inner: {
            type: Boolean,
            default: !0
        },
        ...qe
    },
    setup(e) {
        return {
            classes: ae( () => Oe("subnavbar", {
                sliding: e.sliding
            }, je(e)))
        }
    }
};
function xS(e, t) {
    return O(),
    G("div", {
        class: Ae(e.classes)
    }, [ce(e.$slots, "default")], 2)
}
const TS = {
    name: "f7-swipeout-actions",
    render: xS,
    props: {
        left: Boolean,
        right: Boolean,
        side: String,
        ...qe
    },
    setup(e) {
        const t = ae( () => {
            let a = e.side;
            return a || (e.left && (a = "left"),
            e.right && (a = "right")),
            a
        }
        );
        return {
            classes: ae( () => Oe(`swipeout-actions-${t.value}`, je(e)))
        }
    }
}
  , MS = ["href", "data-confirm", "data-confirm-title"];
function zS(e, t) {
    return O(),
    G("a", {
        href: e.href || "#",
        "data-confirm": e.confirmText || void 0,
        "data-confirm-title": e.confirmTitle || void 0,
        class: Ae(e.classes),
        onClick: t[0] || (t[0] = function() {
            return e.onClick && e.onClick(...arguments)
        }
        )
    }, [J(Me(e.text) + " ", 1), ce(e.$slots, "default")], 10, MS)
}
const AS = {
    name: "f7-swipeout-button",
    render: zS,
    props: {
        text: String,
        confirmTitle: String,
        confirmText: String,
        overswipe: Boolean,
        close: Boolean,
        delete: Boolean,
        href: String,
        ...qe
    },
    emits: ["click"],
    setup(e, t) {
        let {emit: n} = t;
        const a = o => {
            n("click", o)
        }
        ;
        return {
            classes: ae( () => Oe({
                "swipeout-overswipe": e.overswipe,
                "swipeout-delete": e.delete,
                "swipeout-close": e.close
            }, je(e))),
            onClick: a
        }
    }
}
  , A3 = {
    addClass: u7,
    removeClass: f7,
    hasClass: p7,
    toggleClass: d7,
    attr: h7,
    removeAttr: m7,
    transform: g7,
    transition: v7,
    on: b7,
    off: y7,
    trigger: C7,
    transitionEnd: w7,
    outerWidth: _7,
    outerHeight: k7,
    styles: $7,
    offset: S7,
    css: E7,
    each: x7,
    html: M7,
    text: z7,
    is: A7,
    index: O7,
    eq: P7,
    append: L7,
    prepend: I7,
    next: B7,
    nextAll: R7,
    prev: D7,
    prevAll: N7,
    parent: H7,
    parents: V7,
    closest: F7,
    find: j7,
    children: U7,
    filter: T7,
    remove: q7
};
Object.keys(A3).forEach(e => {
    Object.defineProperty(_e.fn, e, {
        value: A3[e],
        writable: !0
    })
}
);
function OS(e) {
    const t = e;
    Object.keys(t).forEach(n => {
        try {
            t[n] = null
        } catch {}
        try {
            delete t[n]
        } catch {}
    }
    )
}
function Lr(e, t=0) {
    return setTimeout(e, t)
}
function Vn() {
    return Date.now()
}
function PS(e) {
    const t = He();
    let n;
    return t.getComputedStyle && (n = t.getComputedStyle(e, null)),
    !n && e.currentStyle && (n = e.currentStyle),
    n || (n = e.style),
    n
}
function J2(e, t="x") {
    const n = He();
    let a, r, o;
    const i = PS(e, null);
    return n.WebKitCSSMatrix ? (r = i.transform || i.webkitTransform,
    r.split(",").length > 6 && (r = r.split(", ").map(s => s.replace(",", ".")).join(", ")),
    o = new n.WebKitCSSMatrix(r === "none" ? "" : r)) : (o = i.MozTransform || i.OTransform || i.MsTransform || i.msTransform || i.transform || i.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"),
    a = o.toString().split(",")),
    t === "x" && (n.WebKitCSSMatrix ? r = o.m41 : a.length === 16 ? r = parseFloat(a[12]) : r = parseFloat(a[4])),
    t === "y" && (n.WebKitCSSMatrix ? r = o.m42 : a.length === 16 ? r = parseFloat(a[13]) : r = parseFloat(a[5])),
    r || 0
}
function Zi(e) {
    return typeof e == "object" && e !== null && e.constructor && Object.prototype.toString.call(e).slice(8, -1) === "Object"
}
function LS(e) {
    return typeof window < "u" && typeof window.HTMLElement < "u" ? e instanceof HTMLElement : e && (e.nodeType === 1 || e.nodeType === 11)
}
function Rn(...e) {
    const t = Object(e[0])
      , n = ["__proto__", "constructor", "prototype"];
    for (let a = 1; a < e.length; a += 1) {
        const r = e[a];
        if (r != null && !LS(r)) {
            const o = Object.keys(Object(r)).filter(i => n.indexOf(i) < 0);
            for (let i = 0, s = o.length; i < s; i += 1) {
                const l = o[i]
                  , c = Object.getOwnPropertyDescriptor(r, l);
                c !== void 0 && c.enumerable && (Zi(t[l]) && Zi(r[l]) ? r[l].__swiper__ ? t[l] = r[l] : Rn(t[l], r[l]) : !Zi(t[l]) && Zi(r[l]) ? (t[l] = {},
                r[l].__swiper__ ? t[l] = r[l] : Rn(t[l], r[l])) : t[l] = r[l])
            }
        }
    }
    return t
}
function Ji(e, t, n) {
    e.style.setProperty(t, n)
}
function y6({swiper: e, targetPosition: t, side: n}) {
    const a = He()
      , r = -e.translate;
    let o = null, i;
    const s = e.params.speed;
    e.wrapperEl.style.scrollSnapType = "none",
    a.cancelAnimationFrame(e.cssModeFrameID);
    const l = t > r ? "next" : "prev"
      , c = (f, d) => l === "next" && f >= d || l === "prev" && f <= d
      , u = () => {
        i = new Date().getTime(),
        o === null && (o = i);
        const f = Math.max(Math.min((i - o) / s, 1), 0)
          , d = .5 - Math.cos(f * Math.PI) / 2;
        let p = r + d * (t - r);
        if (c(p, t) && (p = t),
        e.wrapperEl.scrollTo({
            [n]: p
        }),
        c(p, t)) {
            e.wrapperEl.style.overflow = "hidden",
            e.wrapperEl.style.scrollSnapType = "",
            setTimeout( () => {
                e.wrapperEl.style.overflow = "",
                e.wrapperEl.scrollTo({
                    [n]: p
                })
            }
            ),
            a.cancelAnimationFrame(e.cssModeFrameID);
            return
        }
        e.cssModeFrameID = a.requestAnimationFrame(u)
    }
    ;
    u()
}
let Wc;
function IS() {
    const e = He()
      , t = Qe();
    return {
        smoothScroll: t.documentElement && "scrollBehavior"in t.documentElement.style,
        touch: !!("ontouchstart"in e || e.DocumentTouch && t instanceof e.DocumentTouch),
        passiveListener: function() {
            let a = !1;
            try {
                const r = Object.defineProperty({}, "passive", {
                    get() {
                        a = !0
                    }
                });
                e.addEventListener("testPassiveListener", null, r)
            } catch {}
            return a
        }(),
        gestures: function() {
            return "ongesturestart"in e
        }()
    }
}
function C6() {
    return Wc || (Wc = IS()),
    Wc
}
let Yc;
function BS({userAgent: e}={}) {
    const t = C6()
      , n = He()
      , a = n.navigator.platform
      , r = e || n.navigator.userAgent
      , o = {
        ios: !1,
        android: !1
    }
      , i = n.screen.width
      , s = n.screen.height
      , l = r.match(/(Android);?[\s\/]+([\d.]+)?/);
    let c = r.match(/(iPad).*OS\s([\d_]+)/);
    const u = r.match(/(iPod)(.*OS\s([\d_]+))?/)
      , f = !c && r.match(/(iPhone\sOS|iOS)\s([\d_]+)/)
      , d = a === "Win32";
    let p = a === "MacIntel";
    const h = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
    return !c && p && t.touch && h.indexOf(`${i}x${s}`) >= 0 && (c = r.match(/(Version)\/([\d.]+)/),
    c || (c = [0, 1, "13_0_0"]),
    p = !1),
    l && !d && (o.os = "android",
    o.android = !0),
    (c || f || u) && (o.os = "ios",
    o.ios = !0),
    o
}
function RS(e={}) {
    return Yc || (Yc = BS(e)),
    Yc
}
let Gc;
function DS() {
    const e = He();
    function t() {
        const n = e.navigator.userAgent.toLowerCase();
        return n.indexOf("safari") >= 0 && n.indexOf("chrome") < 0 && n.indexOf("android") < 0
    }
    return {
        isSafari: t(),
        isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent)
    }
}
function NS() {
    return Gc || (Gc = DS()),
    Gc
}
function HS({swiper: e, on: t, emit: n}) {
    const a = He();
    let r = null
      , o = null;
    const i = () => {
        !e || e.destroyed || !e.initialized || (n("beforeResize"),
        n("resize"))
    }
      , s = () => {
        !e || e.destroyed || !e.initialized || (r = new ResizeObserver(u => {
            o = a.requestAnimationFrame( () => {
                const {width: f, height: d} = e;
                let p = f
                  , h = d;
                u.forEach( ({contentBoxSize: m, contentRect: g, target: b}) => {
                    b && b !== e.el || (p = g ? g.width : (m[0] || m).inlineSize,
                    h = g ? g.height : (m[0] || m).blockSize)
                }
                ),
                (p !== f || h !== d) && i()
            }
            )
        }
        ),
        r.observe(e.el))
    }
      , l = () => {
        o && a.cancelAnimationFrame(o),
        r && r.unobserve && e.el && (r.unobserve(e.el),
        r = null)
    }
      , c = () => {
        !e || e.destroyed || !e.initialized || n("orientationchange")
    }
    ;
    t("init", () => {
        if (e.params.resizeObserver && typeof a.ResizeObserver < "u") {
            s();
            return
        }
        a.addEventListener("resize", i),
        a.addEventListener("orientationchange", c)
    }
    ),
    t("destroy", () => {
        l(),
        a.removeEventListener("resize", i),
        a.removeEventListener("orientationchange", c)
    }
    )
}
function VS({swiper: e, extendParams: t, on: n, emit: a}) {
    const r = []
      , o = He()
      , i = (c, u={}) => {
        const f = o.MutationObserver || o.WebkitMutationObserver
          , d = new f(p => {
            if (p.length === 1) {
                a("observerUpdate", p[0]);
                return
            }
            const h = function() {
                a("observerUpdate", p[0])
            };
            o.requestAnimationFrame ? o.requestAnimationFrame(h) : o.setTimeout(h, 0)
        }
        );
        d.observe(c, {
            attributes: typeof u.attributes > "u" ? !0 : u.attributes,
            childList: typeof u.childList > "u" ? !0 : u.childList,
            characterData: typeof u.characterData > "u" ? !0 : u.characterData
        }),
        r.push(d)
    }
      , s = () => {
        if (e.params.observer) {
            if (e.params.observeParents) {
                const c = e.$el.parents();
                for (let u = 0; u < c.length; u += 1)
                    i(c[u])
            }
            i(e.$el[0], {
                childList: e.params.observeSlideChildren
            }),
            i(e.$wrapperEl[0], {
                attributes: !1
            })
        }
    }
      , l = () => {
        r.forEach(c => {
            c.disconnect()
        }
        ),
        r.splice(0, r.length)
    }
    ;
    t({
        observer: !1,
        observeParents: !1,
        observeSlideChildren: !1
    }),
    n("init", s),
    n("destroy", l)
}
const FS = {
    on(e, t, n) {
        const a = this;
        if (!a.eventsListeners || a.destroyed || typeof t != "function")
            return a;
        const r = n ? "unshift" : "push";
        return e.split(" ").forEach(o => {
            a.eventsListeners[o] || (a.eventsListeners[o] = []),
            a.eventsListeners[o][r](t)
        }
        ),
        a
    },
    once(e, t, n) {
        const a = this;
        if (!a.eventsListeners || a.destroyed || typeof t != "function")
            return a;
        function r(...o) {
            a.off(e, r),
            r.__emitterProxy && delete r.__emitterProxy,
            t.apply(a, o)
        }
        return r.__emitterProxy = t,
        a.on(e, r, n)
    },
    onAny(e, t) {
        const n = this;
        if (!n.eventsListeners || n.destroyed || typeof e != "function")
            return n;
        const a = t ? "unshift" : "push";
        return n.eventsAnyListeners.indexOf(e) < 0 && n.eventsAnyListeners[a](e),
        n
    },
    offAny(e) {
        const t = this;
        if (!t.eventsListeners || t.destroyed || !t.eventsAnyListeners)
            return t;
        const n = t.eventsAnyListeners.indexOf(e);
        return n >= 0 && t.eventsAnyListeners.splice(n, 1),
        t
    },
    off(e, t) {
        const n = this;
        return !n.eventsListeners || n.destroyed || !n.eventsListeners || e.split(" ").forEach(a => {
            typeof t > "u" ? n.eventsListeners[a] = [] : n.eventsListeners[a] && n.eventsListeners[a].forEach( (r, o) => {
                (r === t || r.__emitterProxy && r.__emitterProxy === t) && n.eventsListeners[a].splice(o, 1)
            }
            )
        }
        ),
        n
    },
    emit(...e) {
        const t = this;
        if (!t.eventsListeners || t.destroyed || !t.eventsListeners)
            return t;
        let n, a, r;
        return typeof e[0] == "string" || Array.isArray(e[0]) ? (n = e[0],
        a = e.slice(1, e.length),
        r = t) : (n = e[0].events,
        a = e[0].data,
        r = e[0].context || t),
        a.unshift(r),
        (Array.isArray(n) ? n : n.split(" ")).forEach(i => {
            t.eventsAnyListeners && t.eventsAnyListeners.length && t.eventsAnyListeners.forEach(s => {
                s.apply(r, [i, ...a])
            }
            ),
            t.eventsListeners && t.eventsListeners[i] && t.eventsListeners[i].forEach(s => {
                s.apply(r, a)
            }
            )
        }
        ),
        t
    }
};
function jS() {
    const e = this;
    let t, n;
    const a = e.$el;
    typeof e.params.width < "u" && e.params.width !== null ? t = e.params.width : t = a[0].clientWidth,
    typeof e.params.height < "u" && e.params.height !== null ? n = e.params.height : n = a[0].clientHeight,
    !(t === 0 && e.isHorizontal() || n === 0 && e.isVertical()) && (t = t - parseInt(a.css("padding-left") || 0, 10) - parseInt(a.css("padding-right") || 0, 10),
    n = n - parseInt(a.css("padding-top") || 0, 10) - parseInt(a.css("padding-bottom") || 0, 10),
    Number.isNaN(t) && (t = 0),
    Number.isNaN(n) && (n = 0),
    Object.assign(e, {
        width: t,
        height: n,
        size: e.isHorizontal() ? t : n
    }))
}
function US() {
    const e = this;
    function t(A) {
        return e.isHorizontal() ? A : {
            width: "height",
            "margin-top": "margin-left",
            "margin-bottom ": "margin-right",
            "margin-left": "margin-top",
            "margin-right": "margin-bottom",
            "padding-left": "padding-top",
            "padding-right": "padding-bottom",
            marginRight: "marginBottom"
        }[A]
    }
    function n(A, x) {
        return parseFloat(A.getPropertyValue(t(x)) || 0)
    }
    const a = e.params
      , {$wrapperEl: r, size: o, rtlTranslate: i, wrongRTL: s} = e
      , l = e.virtual && a.virtual.enabled
      , c = l ? e.virtual.slides.length : e.slides.length
      , u = r.children(`.${e.params.slideClass}`)
      , f = l ? e.virtual.slides.length : u.length;
    let d = [];
    const p = []
      , h = [];
    let m = a.slidesOffsetBefore;
    typeof m == "function" && (m = a.slidesOffsetBefore.call(e));
    let g = a.slidesOffsetAfter;
    typeof g == "function" && (g = a.slidesOffsetAfter.call(e));
    const b = e.snapGrid.length
      , v = e.slidesGrid.length;
    let y = a.spaceBetween
      , w = -m
      , C = 0
      , _ = 0;
    if (typeof o > "u")
        return;
    typeof y == "string" && y.indexOf("%") >= 0 && (y = parseFloat(y.replace("%", "")) / 100 * o),
    e.virtualSize = -y,
    i ? u.css({
        marginLeft: "",
        marginBottom: "",
        marginTop: ""
    }) : u.css({
        marginRight: "",
        marginBottom: "",
        marginTop: ""
    }),
    a.centeredSlides && a.cssMode && (Ji(e.wrapperEl, "--swiper-centered-offset-before", ""),
    Ji(e.wrapperEl, "--swiper-centered-offset-after", ""));
    const E = a.grid && a.grid.rows > 1 && e.grid;
    E && e.grid.initSlides(f);
    let z;
    const T = a.slidesPerView === "auto" && a.breakpoints && Object.keys(a.breakpoints).filter(A => typeof a.breakpoints[A].slidesPerView < "u").length > 0;
    for (let A = 0; A < f; A += 1) {
        z = 0;
        const x = u.eq(A);
        if (E && e.grid.updateSlide(A, x, f, t),
        x.css("display") !== "none") {
            if (a.slidesPerView === "auto") {
                T && (u[A].style[t("width")] = "");
                const M = getComputedStyle(x[0])
                  , L = x[0].style.transform
                  , U = x[0].style.webkitTransform;
                if (L && (x[0].style.transform = "none"),
                U && (x[0].style.webkitTransform = "none"),
                a.roundLengths)
                    z = e.isHorizontal() ? x.outerWidth(!0) : x.outerHeight(!0);
                else {
                    const Y = n(M, "width")
                      , H = n(M, "padding-left")
                      , W = n(M, "padding-right")
                      , j = n(M, "margin-left")
                      , Q = n(M, "margin-right")
                      , ne = M.getPropertyValue("box-sizing");
                    if (ne && ne === "border-box")
                        z = Y + j + Q;
                    else {
                        const {clientWidth: re, offsetWidth: ve} = x[0];
                        z = Y + H + W + j + Q + (ve - re)
                    }
                }
                L && (x[0].style.transform = L),
                U && (x[0].style.webkitTransform = U),
                a.roundLengths && (z = Math.floor(z))
            } else
                z = (o - (a.slidesPerView - 1) * y) / a.slidesPerView,
                a.roundLengths && (z = Math.floor(z)),
                u[A] && (u[A].style[t("width")] = `${z}px`);
            u[A] && (u[A].swiperSlideSize = z),
            h.push(z),
            a.centeredSlides ? (w = w + z / 2 + C / 2 + y,
            C === 0 && A !== 0 && (w = w - o / 2 - y),
            A === 0 && (w = w - o / 2 - y),
            Math.abs(w) < 1 / 1e3 && (w = 0),
            a.roundLengths && (w = Math.floor(w)),
            _ % a.slidesPerGroup === 0 && d.push(w),
            p.push(w)) : (a.roundLengths && (w = Math.floor(w)),
            (_ - Math.min(e.params.slidesPerGroupSkip, _)) % e.params.slidesPerGroup === 0 && d.push(w),
            p.push(w),
            w = w + z + y),
            e.virtualSize += z + y,
            C = z,
            _ += 1
        }
    }
    if (e.virtualSize = Math.max(e.virtualSize, o) + g,
    i && s && (a.effect === "slide" || a.effect === "coverflow") && r.css({
        width: `${e.virtualSize + a.spaceBetween}px`
    }),
    a.setWrapperSize && r.css({
        [t("width")]: `${e.virtualSize + a.spaceBetween}px`
    }),
    E && e.grid.updateWrapperSize(z, d, t),
    !a.centeredSlides) {
        const A = [];
        for (let x = 0; x < d.length; x += 1) {
            let M = d[x];
            a.roundLengths && (M = Math.floor(M)),
            d[x] <= e.virtualSize - o && A.push(M)
        }
        d = A,
        Math.floor(e.virtualSize - o) - Math.floor(d[d.length - 1]) > 1 && d.push(e.virtualSize - o)
    }
    if (d.length === 0 && (d = [0]),
    a.spaceBetween !== 0) {
        const A = e.isHorizontal() && i ? "marginLeft" : t("marginRight");
        u.filter( (x, M) => a.cssMode ? M !== u.length - 1 : !0).css({
            [A]: `${y}px`
        })
    }
    if (a.centeredSlides && a.centeredSlidesBounds) {
        let A = 0;
        h.forEach(M => {
            A += M + (a.spaceBetween ? a.spaceBetween : 0)
        }
        ),
        A -= a.spaceBetween;
        const x = A - o;
        d = d.map(M => M < 0 ? -m : M > x ? x + g : M)
    }
    if (a.centerInsufficientSlides) {
        let A = 0;
        if (h.forEach(x => {
            A += x + (a.spaceBetween ? a.spaceBetween : 0)
        }
        ),
        A -= a.spaceBetween,
        A < o) {
            const x = (o - A) / 2;
            d.forEach( (M, L) => {
                d[L] = M - x
            }
            ),
            p.forEach( (M, L) => {
                p[L] = M + x
            }
            )
        }
    }
    if (Object.assign(e, {
        slides: u,
        snapGrid: d,
        slidesGrid: p,
        slidesSizesGrid: h
    }),
    a.centeredSlides && a.cssMode && !a.centeredSlidesBounds) {
        Ji(e.wrapperEl, "--swiper-centered-offset-before", `${-d[0]}px`),
        Ji(e.wrapperEl, "--swiper-centered-offset-after", `${e.size / 2 - h[h.length - 1] / 2}px`);
        const A = -e.snapGrid[0]
          , x = -e.slidesGrid[0];
        e.snapGrid = e.snapGrid.map(M => M + A),
        e.slidesGrid = e.slidesGrid.map(M => M + x)
    }
    if (f !== c && e.emit("slidesLengthChange"),
    d.length !== b && (e.params.watchOverflow && e.checkOverflow(),
    e.emit("snapGridLengthChange")),
    p.length !== v && e.emit("slidesGridLengthChange"),
    a.watchSlidesProgress && e.updateSlidesOffset(),
    !l && !a.cssMode && (a.effect === "slide" || a.effect === "fade")) {
        const A = `${a.containerModifierClass}backface-hidden`
          , x = e.$el.hasClass(A);
        f <= a.maxBackfaceHiddenSlides ? x || e.$el.addClass(A) : x && e.$el.removeClass(A)
    }
}
function qS(e) {
    const t = this
      , n = []
      , a = t.virtual && t.params.virtual.enabled;
    let r = 0, o;
    typeof e == "number" ? t.setTransition(e) : e === !0 && t.setTransition(t.params.speed);
    const i = s => a ? t.slides.filter(l => parseInt(l.getAttribute("data-swiper-slide-index"), 10) === s)[0] : t.slides.eq(s)[0];
    if (t.params.slidesPerView !== "auto" && t.params.slidesPerView > 1)
        if (t.params.centeredSlides)
            (t.visibleSlides || _e([])).each(s => {
                n.push(s)
            }
            );
        else
            for (o = 0; o < Math.ceil(t.params.slidesPerView); o += 1) {
                const s = t.activeIndex + o;
                if (s > t.slides.length && !a)
                    break;
                n.push(i(s))
            }
    else
        n.push(i(t.activeIndex));
    for (o = 0; o < n.length; o += 1)
        if (typeof n[o] < "u") {
            const s = n[o].offsetHeight;
            r = s > r ? s : r
        }
    (r || r === 0) && t.$wrapperEl.css("height", `${r}px`)
}
function WS() {
    const e = this
      , t = e.slides;
    for (let n = 0; n < t.length; n += 1)
        t[n].swiperSlideOffset = e.isHorizontal() ? t[n].offsetLeft : t[n].offsetTop
}
function YS(e=this && this.translate || 0) {
    const t = this
      , n = t.params
      , {slides: a, rtlTranslate: r, snapGrid: o} = t;
    if (a.length === 0)
        return;
    typeof a[0].swiperSlideOffset > "u" && t.updateSlidesOffset();
    let i = -e;
    r && (i = e),
    a.removeClass(n.slideVisibleClass),
    t.visibleSlidesIndexes = [],
    t.visibleSlides = [];
    for (let s = 0; s < a.length; s += 1) {
        const l = a[s];
        let c = l.swiperSlideOffset;
        n.cssMode && n.centeredSlides && (c -= a[0].swiperSlideOffset);
        const u = (i + (n.centeredSlides ? t.minTranslate() : 0) - c) / (l.swiperSlideSize + n.spaceBetween)
          , f = (i - o[0] + (n.centeredSlides ? t.minTranslate() : 0) - c) / (l.swiperSlideSize + n.spaceBetween)
          , d = -(i - c)
          , p = d + t.slidesSizesGrid[s];
        (d >= 0 && d < t.size - 1 || p > 1 && p <= t.size || d <= 0 && p >= t.size) && (t.visibleSlides.push(l),
        t.visibleSlidesIndexes.push(s),
        a.eq(s).addClass(n.slideVisibleClass)),
        l.progress = r ? -u : u,
        l.originalProgress = r ? -f : f
    }
    t.visibleSlides = _e(t.visibleSlides)
}
function GS(e) {
    const t = this;
    if (typeof e > "u") {
        const c = t.rtlTranslate ? -1 : 1;
        e = t && t.translate && t.translate * c || 0
    }
    const n = t.params
      , a = t.maxTranslate() - t.minTranslate();
    let {progress: r, isBeginning: o, isEnd: i} = t;
    const s = o
      , l = i;
    a === 0 ? (r = 0,
    o = !0,
    i = !0) : (r = (e - t.minTranslate()) / a,
    o = r <= 0,
    i = r >= 1),
    Object.assign(t, {
        progress: r,
        isBeginning: o,
        isEnd: i
    }),
    (n.watchSlidesProgress || n.centeredSlides && n.autoHeight) && t.updateSlidesProgress(e),
    o && !s && t.emit("reachBeginning toEdge"),
    i && !l && t.emit("reachEnd toEdge"),
    (s && !o || l && !i) && t.emit("fromEdge"),
    t.emit("progress", r)
}
function XS() {
    const e = this
      , {slides: t, params: n, $wrapperEl: a, activeIndex: r, realIndex: o} = e
      , i = e.virtual && n.virtual.enabled;
    t.removeClass(`${n.slideActiveClass} ${n.slideNextClass} ${n.slidePrevClass} ${n.slideDuplicateActiveClass} ${n.slideDuplicateNextClass} ${n.slideDuplicatePrevClass}`);
    let s;
    i ? s = e.$wrapperEl.find(`.${n.slideClass}[data-swiper-slide-index="${r}"]`) : s = t.eq(r),
    s.addClass(n.slideActiveClass),
    n.loop && (s.hasClass(n.slideDuplicateClass) ? a.children(`.${n.slideClass}:not(.${n.slideDuplicateClass})[data-swiper-slide-index="${o}"]`).addClass(n.slideDuplicateActiveClass) : a.children(`.${n.slideClass}.${n.slideDuplicateClass}[data-swiper-slide-index="${o}"]`).addClass(n.slideDuplicateActiveClass));
    let l = s.nextAll(`.${n.slideClass}`).eq(0).addClass(n.slideNextClass);
    n.loop && l.length === 0 && (l = t.eq(0),
    l.addClass(n.slideNextClass));
    let c = s.prevAll(`.${n.slideClass}`).eq(0).addClass(n.slidePrevClass);
    n.loop && c.length === 0 && (c = t.eq(-1),
    c.addClass(n.slidePrevClass)),
    n.loop && (l.hasClass(n.slideDuplicateClass) ? a.children(`.${n.slideClass}:not(.${n.slideDuplicateClass})[data-swiper-slide-index="${l.attr("data-swiper-slide-index")}"]`).addClass(n.slideDuplicateNextClass) : a.children(`.${n.slideClass}.${n.slideDuplicateClass}[data-swiper-slide-index="${l.attr("data-swiper-slide-index")}"]`).addClass(n.slideDuplicateNextClass),
    c.hasClass(n.slideDuplicateClass) ? a.children(`.${n.slideClass}:not(.${n.slideDuplicateClass})[data-swiper-slide-index="${c.attr("data-swiper-slide-index")}"]`).addClass(n.slideDuplicatePrevClass) : a.children(`.${n.slideClass}.${n.slideDuplicateClass}[data-swiper-slide-index="${c.attr("data-swiper-slide-index")}"]`).addClass(n.slideDuplicatePrevClass)),
    e.emitSlidesClasses()
}
function KS(e) {
    const t = this
      , n = t.rtlTranslate ? t.translate : -t.translate
      , {slidesGrid: a, snapGrid: r, params: o, activeIndex: i, realIndex: s, snapIndex: l} = t;
    let c = e, u;
    if (typeof c > "u") {
        for (let d = 0; d < a.length; d += 1)
            typeof a[d + 1] < "u" ? n >= a[d] && n < a[d + 1] - (a[d + 1] - a[d]) / 2 ? c = d : n >= a[d] && n < a[d + 1] && (c = d + 1) : n >= a[d] && (c = d);
        o.normalizeSlideIndex && (c < 0 || typeof c > "u") && (c = 0)
    }
    if (r.indexOf(n) >= 0)
        u = r.indexOf(n);
    else {
        const d = Math.min(o.slidesPerGroupSkip, c);
        u = d + Math.floor((c - d) / o.slidesPerGroup)
    }
    if (u >= r.length && (u = r.length - 1),
    c === i) {
        u !== l && (t.snapIndex = u,
        t.emit("snapIndexChange"));
        return
    }
    const f = parseInt(t.slides.eq(c).attr("data-swiper-slide-index") || c, 10);
    Object.assign(t, {
        snapIndex: u,
        realIndex: f,
        previousIndex: i,
        activeIndex: c
    }),
    t.emit("activeIndexChange"),
    t.emit("snapIndexChange"),
    s !== f && t.emit("realIndexChange"),
    (t.initialized || t.params.runCallbacksOnInit) && t.emit("slideChange")
}
function ZS(e) {
    const t = this
      , n = t.params
      , a = _e(e).closest(`.${n.slideClass}`)[0];
    let r = !1, o;
    if (a) {
        for (let i = 0; i < t.slides.length; i += 1)
            if (t.slides[i] === a) {
                r = !0,
                o = i;
                break
            }
    }
    if (a && r)
        t.clickedSlide = a,
        t.virtual && t.params.virtual.enabled ? t.clickedIndex = parseInt(_e(a).attr("data-swiper-slide-index"), 10) : t.clickedIndex = o;
    else {
        t.clickedSlide = void 0,
        t.clickedIndex = void 0;
        return
    }
    n.slideToClickedSlide && t.clickedIndex !== void 0 && t.clickedIndex !== t.activeIndex && t.slideToClickedSlide()
}
const JS = {
    updateSize: jS,
    updateSlides: US,
    updateAutoHeight: qS,
    updateSlidesOffset: WS,
    updateSlidesProgress: YS,
    updateProgress: GS,
    updateSlidesClasses: XS,
    updateActiveIndex: KS,
    updateClickedSlide: ZS
};
function QS(e=this.isHorizontal() ? "x" : "y") {
    const t = this
      , {params: n, rtlTranslate: a, translate: r, $wrapperEl: o} = t;
    if (n.virtualTranslate)
        return a ? -r : r;
    if (n.cssMode)
        return r;
    let i = J2(o[0], e);
    return a && (i = -i),
    i || 0
}
function e$(e, t) {
    const n = this
      , {rtlTranslate: a, params: r, $wrapperEl: o, wrapperEl: i, progress: s} = n;
    let l = 0
      , c = 0;
    const u = 0;
    n.isHorizontal() ? l = a ? -e : e : c = e,
    r.roundLengths && (l = Math.floor(l),
    c = Math.floor(c)),
    r.cssMode ? i[n.isHorizontal() ? "scrollLeft" : "scrollTop"] = n.isHorizontal() ? -l : -c : r.virtualTranslate || o.transform(`translate3d(${l}px, ${c}px, ${u}px)`),
    n.previousTranslate = n.translate,
    n.translate = n.isHorizontal() ? l : c;
    let f;
    const d = n.maxTranslate() - n.minTranslate();
    d === 0 ? f = 0 : f = (e - n.minTranslate()) / d,
    f !== s && n.updateProgress(e),
    n.emit("setTranslate", n.translate, t)
}
function t$() {
    return -this.snapGrid[0]
}
function n$() {
    return -this.snapGrid[this.snapGrid.length - 1]
}
function a$(e=0, t=this.params.speed, n=!0, a=!0, r) {
    const o = this
      , {params: i, wrapperEl: s} = o;
    if (o.animating && i.preventInteractionOnTransition)
        return !1;
    const l = o.minTranslate()
      , c = o.maxTranslate();
    let u;
    if (a && e > l ? u = l : a && e < c ? u = c : u = e,
    o.updateProgress(u),
    i.cssMode) {
        const f = o.isHorizontal();
        if (t === 0)
            s[f ? "scrollLeft" : "scrollTop"] = -u;
        else {
            if (!o.support.smoothScroll)
                return y6({
                    swiper: o,
                    targetPosition: -u,
                    side: f ? "left" : "top"
                }),
                !0;
            s.scrollTo({
                [f ? "left" : "top"]: -u,
                behavior: "smooth"
            })
        }
        return !0
    }
    return t === 0 ? (o.setTransition(0),
    o.setTranslate(u),
    n && (o.emit("beforeTransitionStart", t, r),
    o.emit("transitionEnd"))) : (o.setTransition(t),
    o.setTranslate(u),
    n && (o.emit("beforeTransitionStart", t, r),
    o.emit("transitionStart")),
    o.animating || (o.animating = !0,
    o.onTranslateToWrapperTransitionEnd || (o.onTranslateToWrapperTransitionEnd = function(d) {
        !o || o.destroyed || d.target === this && (o.$wrapperEl[0].removeEventListener("transitionend", o.onTranslateToWrapperTransitionEnd),
        o.$wrapperEl[0].removeEventListener("webkitTransitionEnd", o.onTranslateToWrapperTransitionEnd),
        o.onTranslateToWrapperTransitionEnd = null,
        delete o.onTranslateToWrapperTransitionEnd,
        n && o.emit("transitionEnd"))
    }
    ),
    o.$wrapperEl[0].addEventListener("transitionend", o.onTranslateToWrapperTransitionEnd),
    o.$wrapperEl[0].addEventListener("webkitTransitionEnd", o.onTranslateToWrapperTransitionEnd))),
    !0
}
const r$ = {
    getTranslate: QS,
    setTranslate: e$,
    minTranslate: t$,
    maxTranslate: n$,
    translateTo: a$
};
function o$(e, t) {
    const n = this;
    n.params.cssMode || n.$wrapperEl.transition(e),
    n.emit("setTransition", e, t)
}
function w6({swiper: e, runCallbacks: t, direction: n, step: a}) {
    const {activeIndex: r, previousIndex: o} = e;
    let i = n;
    if (i || (r > o ? i = "next" : r < o ? i = "prev" : i = "reset"),
    e.emit(`transition${a}`),
    t && r !== o) {
        if (i === "reset") {
            e.emit(`slideResetTransition${a}`);
            return
        }
        e.emit(`slideChangeTransition${a}`),
        i === "next" ? e.emit(`slideNextTransition${a}`) : e.emit(`slidePrevTransition${a}`)
    }
}
function i$(e=!0, t) {
    const n = this
      , {params: a} = n;
    a.cssMode || (a.autoHeight && n.updateAutoHeight(),
    w6({
        swiper: n,
        runCallbacks: e,
        direction: t,
        step: "Start"
    }))
}
function s$(e=!0, t) {
    const n = this
      , {params: a} = n;
    n.animating = !1,
    !a.cssMode && (n.setTransition(0),
    w6({
        swiper: n,
        runCallbacks: e,
        direction: t,
        step: "End"
    }))
}
const l$ = {
    setTransition: o$,
    transitionStart: i$,
    transitionEnd: s$
};
function c$(e=0, t=this.params.speed, n=!0, a, r) {
    if (typeof e != "number" && typeof e != "string")
        throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof e}] given.`);
    if (typeof e == "string") {
        const y = parseInt(e, 10);
        if (!isFinite(y))
            throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${e}] given.`);
        e = y
    }
    const o = this;
    let i = e;
    i < 0 && (i = 0);
    const {params: s, snapGrid: l, slidesGrid: c, previousIndex: u, activeIndex: f, rtlTranslate: d, wrapperEl: p, enabled: h} = o;
    if (o.animating && s.preventInteractionOnTransition || !h && !a && !r)
        return !1;
    const m = Math.min(o.params.slidesPerGroupSkip, i);
    let g = m + Math.floor((i - m) / o.params.slidesPerGroup);
    g >= l.length && (g = l.length - 1);
    const b = -l[g];
    if (s.normalizeSlideIndex)
        for (let y = 0; y < c.length; y += 1) {
            const w = -Math.floor(b * 100)
              , C = Math.floor(c[y] * 100)
              , _ = Math.floor(c[y + 1] * 100);
            typeof c[y + 1] < "u" ? w >= C && w < _ - (_ - C) / 2 ? i = y : w >= C && w < _ && (i = y + 1) : w >= C && (i = y)
        }
    if (o.initialized && i !== f && (!o.allowSlideNext && b < o.translate && b < o.minTranslate() || !o.allowSlidePrev && b > o.translate && b > o.maxTranslate() && (f || 0) !== i))
        return !1;
    i !== (u || 0) && n && o.emit("beforeSlideChangeStart"),
    o.updateProgress(b);
    let v;
    if (i > f ? v = "next" : i < f ? v = "prev" : v = "reset",
    d && -b === o.translate || !d && b === o.translate)
        return o.updateActiveIndex(i),
        s.autoHeight && o.updateAutoHeight(),
        o.updateSlidesClasses(),
        s.effect !== "slide" && o.setTranslate(b),
        v !== "reset" && (o.transitionStart(n, v),
        o.transitionEnd(n, v)),
        !1;
    if (s.cssMode) {
        const y = o.isHorizontal()
          , w = d ? b : -b;
        if (t === 0) {
            const C = o.virtual && o.params.virtual.enabled;
            C && (o.wrapperEl.style.scrollSnapType = "none",
            o._immediateVirtual = !0),
            p[y ? "scrollLeft" : "scrollTop"] = w,
            C && requestAnimationFrame( () => {
                o.wrapperEl.style.scrollSnapType = "",
                o._swiperImmediateVirtual = !1
            }
            )
        } else {
            if (!o.support.smoothScroll)
                return y6({
                    swiper: o,
                    targetPosition: w,
                    side: y ? "left" : "top"
                }),
                !0;
            p.scrollTo({
                [y ? "left" : "top"]: w,
                behavior: "smooth"
            })
        }
        return !0
    }
    return o.setTransition(t),
    o.setTranslate(b),
    o.updateActiveIndex(i),
    o.updateSlidesClasses(),
    o.emit("beforeTransitionStart", t, a),
    o.transitionStart(n, v),
    t === 0 ? o.transitionEnd(n, v) : o.animating || (o.animating = !0,
    o.onSlideToWrapperTransitionEnd || (o.onSlideToWrapperTransitionEnd = function(w) {
        !o || o.destroyed || w.target === this && (o.$wrapperEl[0].removeEventListener("transitionend", o.onSlideToWrapperTransitionEnd),
        o.$wrapperEl[0].removeEventListener("webkitTransitionEnd", o.onSlideToWrapperTransitionEnd),
        o.onSlideToWrapperTransitionEnd = null,
        delete o.onSlideToWrapperTransitionEnd,
        o.transitionEnd(n, v))
    }
    ),
    o.$wrapperEl[0].addEventListener("transitionend", o.onSlideToWrapperTransitionEnd),
    o.$wrapperEl[0].addEventListener("webkitTransitionEnd", o.onSlideToWrapperTransitionEnd)),
    !0
}
function u$(e=0, t=this.params.speed, n=!0, a) {
    if (typeof e == "string") {
        const i = parseInt(e, 10);
        if (!isFinite(i))
            throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${e}] given.`);
        e = i
    }
    const r = this;
    let o = e;
    return r.params.loop && (o += r.loopedSlides),
    r.slideTo(o, t, n, a)
}
function f$(e=this.params.speed, t=!0, n) {
    const a = this
      , {animating: r, enabled: o, params: i} = a;
    if (!o)
        return a;
    let s = i.slidesPerGroup;
    i.slidesPerView === "auto" && i.slidesPerGroup === 1 && i.slidesPerGroupAuto && (s = Math.max(a.slidesPerViewDynamic("current", !0), 1));
    const l = a.activeIndex < i.slidesPerGroupSkip ? 1 : s;
    if (i.loop) {
        if (r && i.loopPreventsSlide)
            return !1;
        a.loopFix(),
        a._clientLeft = a.$wrapperEl[0].clientLeft
    }
    return i.rewind && a.isEnd ? a.slideTo(0, e, t, n) : a.slideTo(a.activeIndex + l, e, t, n)
}
function d$(e=this.params.speed, t=!0, n) {
    const a = this
      , {params: r, animating: o, snapGrid: i, slidesGrid: s, rtlTranslate: l, enabled: c} = a;
    if (!c)
        return a;
    if (r.loop) {
        if (o && r.loopPreventsSlide)
            return !1;
        a.loopFix(),
        a._clientLeft = a.$wrapperEl[0].clientLeft
    }
    const u = l ? a.translate : -a.translate;
    function f(g) {
        return g < 0 ? -Math.floor(Math.abs(g)) : Math.floor(g)
    }
    const d = f(u)
      , p = i.map(g => f(g));
    let h = i[p.indexOf(d) - 1];
    if (typeof h > "u" && r.cssMode) {
        let g;
        i.forEach( (b, v) => {
            d >= b && (g = v)
        }
        ),
        typeof g < "u" && (h = i[g > 0 ? g - 1 : g])
    }
    let m = 0;
    if (typeof h < "u" && (m = s.indexOf(h),
    m < 0 && (m = a.activeIndex - 1),
    r.slidesPerView === "auto" && r.slidesPerGroup === 1 && r.slidesPerGroupAuto && (m = m - a.slidesPerViewDynamic("previous", !0) + 1,
    m = Math.max(m, 0))),
    r.rewind && a.isBeginning) {
        const g = a.params.virtual && a.params.virtual.enabled && a.virtual ? a.virtual.slides.length - 1 : a.slides.length - 1;
        return a.slideTo(g, e, t, n)
    }
    return a.slideTo(m, e, t, n)
}
function p$(e=this.params.speed, t=!0, n) {
    const a = this;
    return a.slideTo(a.activeIndex, e, t, n)
}
function h$(e=this.params.speed, t=!0, n, a=.5) {
    const r = this;
    let o = r.activeIndex;
    const i = Math.min(r.params.slidesPerGroupSkip, o)
      , s = i + Math.floor((o - i) / r.params.slidesPerGroup)
      , l = r.rtlTranslate ? r.translate : -r.translate;
    if (l >= r.snapGrid[s]) {
        const c = r.snapGrid[s]
          , u = r.snapGrid[s + 1];
        l - c > (u - c) * a && (o += r.params.slidesPerGroup)
    } else {
        const c = r.snapGrid[s - 1]
          , u = r.snapGrid[s];
        l - c <= (u - c) * a && (o -= r.params.slidesPerGroup)
    }
    return o = Math.max(o, 0),
    o = Math.min(o, r.slidesGrid.length - 1),
    r.slideTo(o, e, t, n)
}
function m$() {
    const e = this
      , {params: t, $wrapperEl: n} = e
      , a = t.slidesPerView === "auto" ? e.slidesPerViewDynamic() : t.slidesPerView;
    let r = e.clickedIndex, o;
    if (t.loop) {
        if (e.animating)
            return;
        o = parseInt(_e(e.clickedSlide).attr("data-swiper-slide-index"), 10),
        t.centeredSlides ? r < e.loopedSlides - a / 2 || r > e.slides.length - e.loopedSlides + a / 2 ? (e.loopFix(),
        r = n.children(`.${t.slideClass}[data-swiper-slide-index="${o}"]:not(.${t.slideDuplicateClass})`).eq(0).index(),
        Lr( () => {
            e.slideTo(r)
        }
        )) : e.slideTo(r) : r > e.slides.length - a ? (e.loopFix(),
        r = n.children(`.${t.slideClass}[data-swiper-slide-index="${o}"]:not(.${t.slideDuplicateClass})`).eq(0).index(),
        Lr( () => {
            e.slideTo(r)
        }
        )) : e.slideTo(r)
    } else
        e.slideTo(r)
}
const g$ = {
    slideTo: c$,
    slideToLoop: u$,
    slideNext: f$,
    slidePrev: d$,
    slideReset: p$,
    slideToClosest: h$,
    slideToClickedSlide: m$
};
function v$() {
    const e = this
      , t = Qe()
      , {params: n, $wrapperEl: a} = e
      , r = a.children().length > 0 ? _e(a.children()[0].parentNode) : a;
    r.children(`.${n.slideClass}.${n.slideDuplicateClass}`).remove();
    let o = r.children(`.${n.slideClass}`);
    if (n.loopFillGroupWithBlank) {
        const l = n.slidesPerGroup - o.length % n.slidesPerGroup;
        if (l !== n.slidesPerGroup) {
            for (let c = 0; c < l; c += 1) {
                const u = _e(t.createElement("div")).addClass(`${n.slideClass} ${n.slideBlankClass}`);
                r.append(u)
            }
            o = r.children(`.${n.slideClass}`)
        }
    }
    n.slidesPerView === "auto" && !n.loopedSlides && (n.loopedSlides = o.length),
    e.loopedSlides = Math.ceil(parseFloat(n.loopedSlides || n.slidesPerView, 10)),
    e.loopedSlides += n.loopAdditionalSlides,
    e.loopedSlides > o.length && e.params.loopedSlidesLimit && (e.loopedSlides = o.length);
    const i = []
      , s = [];
    o.each( (l, c) => {
        _e(l).attr("data-swiper-slide-index", c)
    }
    );
    for (let l = 0; l < e.loopedSlides; l += 1) {
        const c = l - Math.floor(l / o.length) * o.length;
        s.push(o.eq(c)[0]),
        i.unshift(o.eq(o.length - c - 1)[0])
    }
    for (let l = 0; l < s.length; l += 1)
        r.append(_e(s[l].cloneNode(!0)).addClass(n.slideDuplicateClass));
    for (let l = i.length - 1; l >= 0; l -= 1)
        r.prepend(_e(i[l].cloneNode(!0)).addClass(n.slideDuplicateClass))
}
function b$() {
    const e = this;
    e.emit("beforeLoopFix");
    const {activeIndex: t, slides: n, loopedSlides: a, allowSlidePrev: r, allowSlideNext: o, snapGrid: i, rtlTranslate: s} = e;
    let l;
    e.allowSlidePrev = !0,
    e.allowSlideNext = !0;
    const u = -i[t] - e.getTranslate();
    t < a ? (l = n.length - a * 3 + t,
    l += a,
    e.slideTo(l, 0, !1, !0) && u !== 0 && e.setTranslate((s ? -e.translate : e.translate) - u)) : t >= n.length - a && (l = -n.length + t + a,
    l += a,
    e.slideTo(l, 0, !1, !0) && u !== 0 && e.setTranslate((s ? -e.translate : e.translate) - u)),
    e.allowSlidePrev = r,
    e.allowSlideNext = o,
    e.emit("loopFix")
}
function y$() {
    const e = this
      , {$wrapperEl: t, params: n, slides: a} = e;
    t.children(`.${n.slideClass}.${n.slideDuplicateClass},.${n.slideClass}.${n.slideBlankClass}`).remove(),
    a.removeAttr("data-swiper-slide-index")
}
const C$ = {
    loopCreate: v$,
    loopFix: b$,
    loopDestroy: y$
};
function w$(e) {
    const t = this;
    if (t.support.touch || !t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode)
        return;
    const n = t.params.touchEventsTarget === "container" ? t.el : t.wrapperEl;
    n.style.cursor = "move",
    n.style.cursor = e ? "grabbing" : "grab"
}
function _$() {
    const e = this;
    e.support.touch || e.params.watchOverflow && e.isLocked || e.params.cssMode || (e[e.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "")
}
const k$ = {
    setGrabCursor: w$,
    unsetGrabCursor: _$
};
function S$(e, t=this) {
    function n(a) {
        if (!a || a === Qe() || a === He())
            return null;
        a.assignedSlot && (a = a.assignedSlot);
        const r = a.closest(e);
        return !r && !a.getRootNode ? null : r || n(a.getRootNode().host)
    }
    return n(t)
}
function $$(e) {
    const t = this
      , n = Qe()
      , a = He()
      , r = t.touchEventsData
      , {params: o, touches: i, enabled: s} = t;
    if (!s || t.animating && o.preventInteractionOnTransition)
        return;
    !t.animating && o.cssMode && o.loop && t.loopFix();
    let l = e;
    l.originalEvent && (l = l.originalEvent);
    let c = _e(l.target);
    if (o.touchEventsTarget === "wrapper" && !c.closest(t.wrapperEl).length || (r.isTouchEvent = l.type === "touchstart",
    !r.isTouchEvent && "which"in l && l.which === 3) || !r.isTouchEvent && "button"in l && l.button > 0 || r.isTouched && r.isMoved)
        return;
    const u = !!o.noSwipingClass && o.noSwipingClass !== ""
      , f = e.composedPath ? e.composedPath() : e.path;
    u && l.target && l.target.shadowRoot && f && (c = _e(f[0]));
    const d = o.noSwipingSelector ? o.noSwipingSelector : `.${o.noSwipingClass}`
      , p = !!(l.target && l.target.shadowRoot);
    if (o.noSwiping && (p ? S$(d, c[0]) : c.closest(d)[0])) {
        t.allowClick = !0;
        return
    }
    if (o.swipeHandler && !c.closest(o.swipeHandler)[0])
        return;
    i.currentX = l.type === "touchstart" ? l.targetTouches[0].pageX : l.pageX,
    i.currentY = l.type === "touchstart" ? l.targetTouches[0].pageY : l.pageY;
    const h = i.currentX
      , m = i.currentY
      , g = o.edgeSwipeDetection || o.iOSEdgeSwipeDetection
      , b = o.edgeSwipeThreshold || o.iOSEdgeSwipeThreshold;
    if (g && (h <= b || h >= a.innerWidth - b))
        if (g === "prevent")
            e.preventDefault();
        else
            return;
    if (Object.assign(r, {
        isTouched: !0,
        isMoved: !1,
        allowTouchCallbacks: !0,
        isScrolling: void 0,
        startMoving: void 0
    }),
    i.startX = h,
    i.startY = m,
    r.touchStartTime = Vn(),
    t.allowClick = !0,
    t.updateSize(),
    t.swipeDirection = void 0,
    o.threshold > 0 && (r.allowThresholdMove = !1),
    l.type !== "touchstart") {
        let v = !0;
        c.is(r.focusableElements) && (v = !1,
        c[0].nodeName === "SELECT" && (r.isTouched = !1)),
        n.activeElement && _e(n.activeElement).is(r.focusableElements) && n.activeElement !== c[0] && n.activeElement.blur();
        const y = v && t.allowTouchMove && o.touchStartPreventDefault;
        (o.touchStartForcePreventDefault || y) && !c[0].isContentEditable && l.preventDefault()
    }
    t.params.freeMode && t.params.freeMode.enabled && t.freeMode && t.animating && !o.cssMode && t.freeMode.onTouchStart(),
    t.emit("touchStart", l)
}
function E$(e) {
    const t = Qe()
      , n = this
      , a = n.touchEventsData
      , {params: r, touches: o, rtlTranslate: i, enabled: s} = n;
    if (!s)
        return;
    let l = e;
    if (l.originalEvent && (l = l.originalEvent),
    !a.isTouched) {
        a.startMoving && a.isScrolling && n.emit("touchMoveOpposite", l);
        return
    }
    if (a.isTouchEvent && l.type !== "touchmove")
        return;
    const c = l.type === "touchmove" && l.targetTouches && (l.targetTouches[0] || l.changedTouches[0])
      , u = l.type === "touchmove" ? c.pageX : l.pageX
      , f = l.type === "touchmove" ? c.pageY : l.pageY;
    if (l.preventedByNestedSwiper) {
        o.startX = u,
        o.startY = f;
        return
    }
    if (!n.allowTouchMove) {
        _e(l.target).is(a.focusableElements) || (n.allowClick = !1),
        a.isTouched && (Object.assign(o, {
            startX: u,
            startY: f,
            currentX: u,
            currentY: f
        }),
        a.touchStartTime = Vn());
        return
    }
    if (a.isTouchEvent && r.touchReleaseOnEdges && !r.loop) {
        if (n.isVertical()) {
            if (f < o.startY && n.translate <= n.maxTranslate() || f > o.startY && n.translate >= n.minTranslate()) {
                a.isTouched = !1,
                a.isMoved = !1;
                return
            }
        } else if (u < o.startX && n.translate <= n.maxTranslate() || u > o.startX && n.translate >= n.minTranslate())
            return
    }
    if (a.isTouchEvent && t.activeElement && l.target === t.activeElement && _e(l.target).is(a.focusableElements)) {
        a.isMoved = !0,
        n.allowClick = !1;
        return
    }
    if (a.allowTouchCallbacks && n.emit("touchMove", l),
    l.targetTouches && l.targetTouches.length > 1)
        return;
    o.currentX = u,
    o.currentY = f;
    const d = o.currentX - o.startX
      , p = o.currentY - o.startY;
    if (n.params.threshold && Math.sqrt(d ** 2 + p ** 2) < n.params.threshold)
        return;
    if (typeof a.isScrolling > "u") {
        let b;
        n.isHorizontal() && o.currentY === o.startY || n.isVertical() && o.currentX === o.startX ? a.isScrolling = !1 : d * d + p * p >= 25 && (b = Math.atan2(Math.abs(p), Math.abs(d)) * 180 / Math.PI,
        a.isScrolling = n.isHorizontal() ? b > r.touchAngle : 90 - b > r.touchAngle)
    }
    if (a.isScrolling && n.emit("touchMoveOpposite", l),
    typeof a.startMoving > "u" && (o.currentX !== o.startX || o.currentY !== o.startY) && (a.startMoving = !0),
    a.isScrolling) {
        a.isTouched = !1;
        return
    }
    if (!a.startMoving)
        return;
    n.allowClick = !1,
    !r.cssMode && l.cancelable && l.preventDefault(),
    r.touchMoveStopPropagation && !r.nested && l.stopPropagation(),
    a.isMoved || (r.loop && !r.cssMode && n.loopFix(),
    a.startTranslate = n.getTranslate(),
    n.setTransition(0),
    n.animating && n.$wrapperEl.trigger("webkitTransitionEnd transitionend"),
    a.allowMomentumBounce = !1,
    r.grabCursor && (n.allowSlideNext === !0 || n.allowSlidePrev === !0) && n.setGrabCursor(!0),
    n.emit("sliderFirstMove", l)),
    n.emit("sliderMove", l),
    a.isMoved = !0;
    let h = n.isHorizontal() ? d : p;
    o.diff = h,
    h *= r.touchRatio,
    i && (h = -h),
    n.swipeDirection = h > 0 ? "prev" : "next",
    a.currentTranslate = h + a.startTranslate;
    let m = !0
      , g = r.resistanceRatio;
    if (r.touchReleaseOnEdges && (g = 0),
    h > 0 && a.currentTranslate > n.minTranslate() ? (m = !1,
    r.resistance && (a.currentTranslate = n.minTranslate() - 1 + (-n.minTranslate() + a.startTranslate + h) ** g)) : h < 0 && a.currentTranslate < n.maxTranslate() && (m = !1,
    r.resistance && (a.currentTranslate = n.maxTranslate() + 1 - (n.maxTranslate() - a.startTranslate - h) ** g)),
    m && (l.preventedByNestedSwiper = !0),
    !n.allowSlideNext && n.swipeDirection === "next" && a.currentTranslate < a.startTranslate && (a.currentTranslate = a.startTranslate),
    !n.allowSlidePrev && n.swipeDirection === "prev" && a.currentTranslate > a.startTranslate && (a.currentTranslate = a.startTranslate),
    !n.allowSlidePrev && !n.allowSlideNext && (a.currentTranslate = a.startTranslate),
    r.threshold > 0)
        if (Math.abs(h) > r.threshold || a.allowThresholdMove) {
            if (!a.allowThresholdMove) {
                a.allowThresholdMove = !0,
                o.startX = o.currentX,
                o.startY = o.currentY,
                a.currentTranslate = a.startTranslate,
                o.diff = n.isHorizontal() ? o.currentX - o.startX : o.currentY - o.startY;
                return
            }
        } else {
            a.currentTranslate = a.startTranslate;
            return
        }
    !r.followFinger || r.cssMode || ((r.freeMode && r.freeMode.enabled && n.freeMode || r.watchSlidesProgress) && (n.updateActiveIndex(),
    n.updateSlidesClasses()),
    n.params.freeMode && r.freeMode.enabled && n.freeMode && n.freeMode.onTouchMove(),
    n.updateProgress(a.currentTranslate),
    n.setTranslate(a.currentTranslate))
}
function x$(e) {
    const t = this
      , n = t.touchEventsData
      , {params: a, touches: r, rtlTranslate: o, slidesGrid: i, enabled: s} = t;
    if (!s)
        return;
    let l = e;
    if (l.originalEvent && (l = l.originalEvent),
    n.allowTouchCallbacks && t.emit("touchEnd", l),
    n.allowTouchCallbacks = !1,
    !n.isTouched) {
        n.isMoved && a.grabCursor && t.setGrabCursor(!1),
        n.isMoved = !1,
        n.startMoving = !1;
        return
    }
    a.grabCursor && n.isMoved && n.isTouched && (t.allowSlideNext === !0 || t.allowSlidePrev === !0) && t.setGrabCursor(!1);
    const c = Vn()
      , u = c - n.touchStartTime;
    if (t.allowClick) {
        const v = l.path || l.composedPath && l.composedPath();
        t.updateClickedSlide(v && v[0] || l.target),
        t.emit("tap click", l),
        u < 300 && c - n.lastClickTime < 300 && t.emit("doubleTap doubleClick", l)
    }
    if (n.lastClickTime = Vn(),
    Lr( () => {
        t.destroyed || (t.allowClick = !0)
    }
    ),
    !n.isTouched || !n.isMoved || !t.swipeDirection || r.diff === 0 || n.currentTranslate === n.startTranslate) {
        n.isTouched = !1,
        n.isMoved = !1,
        n.startMoving = !1;
        return
    }
    n.isTouched = !1,
    n.isMoved = !1,
    n.startMoving = !1;
    let f;
    if (a.followFinger ? f = o ? t.translate : -t.translate : f = -n.currentTranslate,
    a.cssMode)
        return;
    if (t.params.freeMode && a.freeMode.enabled) {
        t.freeMode.onTouchEnd({
            currentPos: f
        });
        return
    }
    let d = 0
      , p = t.slidesSizesGrid[0];
    for (let v = 0; v < i.length; v += v < a.slidesPerGroupSkip ? 1 : a.slidesPerGroup) {
        const y = v < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup;
        typeof i[v + y] < "u" ? f >= i[v] && f < i[v + y] && (d = v,
        p = i[v + y] - i[v]) : f >= i[v] && (d = v,
        p = i[i.length - 1] - i[i.length - 2])
    }
    let h = null
      , m = null;
    a.rewind && (t.isBeginning ? m = t.params.virtual && t.params.virtual.enabled && t.virtual ? t.virtual.slides.length - 1 : t.slides.length - 1 : t.isEnd && (h = 0));
    const g = (f - i[d]) / p
      , b = d < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup;
    if (u > a.longSwipesMs) {
        if (!a.longSwipes) {
            t.slideTo(t.activeIndex);
            return
        }
        t.swipeDirection === "next" && (g >= a.longSwipesRatio ? t.slideTo(a.rewind && t.isEnd ? h : d + b) : t.slideTo(d)),
        t.swipeDirection === "prev" && (g > 1 - a.longSwipesRatio ? t.slideTo(d + b) : m !== null && g < 0 && Math.abs(g) > a.longSwipesRatio ? t.slideTo(m) : t.slideTo(d))
    } else {
        if (!a.shortSwipes) {
            t.slideTo(t.activeIndex);
            return
        }
        t.navigation && (l.target === t.navigation.nextEl || l.target === t.navigation.prevEl) ? l.target === t.navigation.nextEl ? t.slideTo(d + b) : t.slideTo(d) : (t.swipeDirection === "next" && t.slideTo(h !== null ? h : d + b),
        t.swipeDirection === "prev" && t.slideTo(m !== null ? m : d))
    }
}
function O3() {
    const e = this
      , {params: t, el: n} = e;
    if (n && n.offsetWidth === 0)
        return;
    t.breakpoints && e.setBreakpoint();
    const {allowSlideNext: a, allowSlidePrev: r, snapGrid: o} = e;
    e.allowSlideNext = !0,
    e.allowSlidePrev = !0,
    e.updateSize(),
    e.updateSlides(),
    e.updateSlidesClasses(),
    (t.slidesPerView === "auto" || t.slidesPerView > 1) && e.isEnd && !e.isBeginning && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0),
    e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.run(),
    e.allowSlidePrev = r,
    e.allowSlideNext = a,
    e.params.watchOverflow && o !== e.snapGrid && e.checkOverflow()
}
function T$(e) {
    const t = this;
    t.enabled && (t.allowClick || (t.params.preventClicks && e.preventDefault(),
    t.params.preventClicksPropagation && t.animating && (e.stopPropagation(),
    e.stopImmediatePropagation())))
}
function M$() {
    const e = this
      , {wrapperEl: t, rtlTranslate: n, enabled: a} = e;
    if (!a)
        return;
    e.previousTranslate = e.translate,
    e.isHorizontal() ? e.translate = -t.scrollLeft : e.translate = -t.scrollTop,
    e.translate === 0 && (e.translate = 0),
    e.updateActiveIndex(),
    e.updateSlidesClasses();
    let r;
    const o = e.maxTranslate() - e.minTranslate();
    o === 0 ? r = 0 : r = (e.translate - e.minTranslate()) / o,
    r !== e.progress && e.updateProgress(n ? -e.translate : e.translate),
    e.emit("setTranslate", e.translate, !1)
}
let P3 = !1;
function z$() {}
const _6 = (e, t) => {
    const n = Qe()
      , {params: a, touchEvents: r, el: o, wrapperEl: i, device: s, support: l} = e
      , c = !!a.nested
      , u = t === "on" ? "addEventListener" : "removeEventListener"
      , f = t;
    if (!l.touch)
        o[u](r.start, e.onTouchStart, !1),
        n[u](r.move, e.onTouchMove, c),
        n[u](r.end, e.onTouchEnd, !1);
    else {
        const d = r.start === "touchstart" && l.passiveListener && a.passiveListeners ? {
            passive: !0,
            capture: !1
        } : !1;
        o[u](r.start, e.onTouchStart, d),
        o[u](r.move, e.onTouchMove, l.passiveListener ? {
            passive: !1,
            capture: c
        } : c),
        o[u](r.end, e.onTouchEnd, d),
        r.cancel && o[u](r.cancel, e.onTouchEnd, d)
    }
    (a.preventClicks || a.preventClicksPropagation) && o[u]("click", e.onClick, !0),
    a.cssMode && i[u]("scroll", e.onScroll),
    a.updateOnWindowResize ? e[f](s.ios || s.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", O3, !0) : e[f]("observerUpdate", O3, !0)
}
;
function A$() {
    const e = this
      , t = Qe()
      , {params: n, support: a} = e;
    e.onTouchStart = $$.bind(e),
    e.onTouchMove = E$.bind(e),
    e.onTouchEnd = x$.bind(e),
    n.cssMode && (e.onScroll = M$.bind(e)),
    e.onClick = T$.bind(e),
    a.touch && !P3 && (t.addEventListener("touchstart", z$),
    P3 = !0),
    _6(e, "on")
}
function O$() {
    _6(this, "off")
}
const P$ = {
    attachEvents: A$,
    detachEvents: O$
}
  , L3 = (e, t) => e.grid && t.grid && t.grid.rows > 1;
function L$() {
    const e = this
      , {activeIndex: t, initialized: n, loopedSlides: a=0, params: r, $el: o} = e
      , i = r.breakpoints;
    if (!i || i && Object.keys(i).length === 0)
        return;
    const s = e.getBreakpoint(i, e.params.breakpointsBase, e.el);
    if (!s || e.currentBreakpoint === s)
        return;
    const c = (s in i ? i[s] : void 0) || e.originalParams
      , u = L3(e, r)
      , f = L3(e, c)
      , d = r.enabled;
    u && !f ? (o.removeClass(`${r.containerModifierClass}grid ${r.containerModifierClass}grid-column`),
    e.emitContainerClasses()) : !u && f && (o.addClass(`${r.containerModifierClass}grid`),
    (c.grid.fill && c.grid.fill === "column" || !c.grid.fill && r.grid.fill === "column") && o.addClass(`${r.containerModifierClass}grid-column`),
    e.emitContainerClasses()),
    ["navigation", "pagination", "scrollbar"].forEach(g => {
        const b = r[g] && r[g].enabled
          , v = c[g] && c[g].enabled;
        b && !v && e[g].disable(),
        !b && v && e[g].enable()
    }
    );
    const p = c.direction && c.direction !== r.direction
      , h = r.loop && (c.slidesPerView !== r.slidesPerView || p);
    p && n && e.changeDirection(),
    Rn(e.params, c);
    const m = e.params.enabled;
    Object.assign(e, {
        allowTouchMove: e.params.allowTouchMove,
        allowSlideNext: e.params.allowSlideNext,
        allowSlidePrev: e.params.allowSlidePrev
    }),
    d && !m ? e.disable() : !d && m && e.enable(),
    e.currentBreakpoint = s,
    e.emit("_beforeBreakpoint", c),
    h && n && (e.loopDestroy(),
    e.loopCreate(),
    e.updateSlides(),
    e.slideTo(t - a + e.loopedSlides, 0, !1)),
    e.emit("breakpoint", c)
}
function I$(e, t="window", n) {
    if (!e || t === "container" && !n)
        return;
    let a = !1;
    const r = He()
      , o = t === "window" ? r.innerHeight : n.clientHeight
      , i = Object.keys(e).map(s => {
        if (typeof s == "string" && s.indexOf("@") === 0) {
            const l = parseFloat(s.substr(1));
            return {
                value: o * l,
                point: s
            }
        }
        return {
            value: s,
            point: s
        }
    }
    );
    i.sort( (s, l) => parseInt(s.value, 10) - parseInt(l.value, 10));
    for (let s = 0; s < i.length; s += 1) {
        const {point: l, value: c} = i[s];
        t === "window" ? r.matchMedia(`(min-width: ${c}px)`).matches && (a = l) : c <= n.clientWidth && (a = l)
    }
    return a || "max"
}
const B$ = {
    setBreakpoint: L$,
    getBreakpoint: I$
};
function R$(e, t) {
    const n = [];
    return e.forEach(a => {
        typeof a == "object" ? Object.keys(a).forEach(r => {
            a[r] && n.push(t + r)
        }
        ) : typeof a == "string" && n.push(t + a)
    }
    ),
    n
}
function D$() {
    const e = this
      , {classNames: t, params: n, rtl: a, $el: r, device: o, support: i} = e
      , s = R$(["initialized", n.direction, {
        "pointer-events": !i.touch
    }, {
        "free-mode": e.params.freeMode && n.freeMode.enabled
    }, {
        autoheight: n.autoHeight
    }, {
        rtl: a
    }, {
        grid: n.grid && n.grid.rows > 1
    }, {
        "grid-column": n.grid && n.grid.rows > 1 && n.grid.fill === "column"
    }, {
        android: o.android
    }, {
        ios: o.ios
    }, {
        "css-mode": n.cssMode
    }, {
        centered: n.cssMode && n.centeredSlides
    }, {
        "watch-progress": n.watchSlidesProgress
    }], n.containerModifierClass);
    t.push(...s),
    r.addClass([...t].join(" ")),
    e.emitContainerClasses()
}
function N$() {
    const e = this
      , {$el: t, classNames: n} = e;
    t.removeClass(n.join(" ")),
    e.emitContainerClasses()
}
const H$ = {
    addClasses: D$,
    removeClasses: N$
};
function V$(e, t, n, a, r, o) {
    const i = He();
    let s;
    function l() {
        o && o()
    }
    !_e(e).parent("picture")[0] && (!e.complete || !r) && t ? (s = new i.Image,
    s.onload = l,
    s.onerror = l,
    a && (s.sizes = a),
    n && (s.srcset = n),
    t && (s.src = t)) : l()
}
function F$() {
    const e = this;
    e.imagesToLoad = e.$el.find("img");
    function t() {
        typeof e > "u" || e === null || !e || e.destroyed || (e.imagesLoaded !== void 0 && (e.imagesLoaded += 1),
        e.imagesLoaded === e.imagesToLoad.length && (e.params.updateOnImagesReady && e.update(),
        e.emit("imagesReady")))
    }
    for (let n = 0; n < e.imagesToLoad.length; n += 1) {
        const a = e.imagesToLoad[n];
        e.loadImage(a, a.currentSrc || a.getAttribute("src"), a.srcset || a.getAttribute("srcset"), a.sizes || a.getAttribute("sizes"), !0, t)
    }
}
const j$ = {
    loadImage: V$,
    preloadImages: F$
};
function U$() {
    const e = this
      , {isLocked: t, params: n} = e
      , {slidesOffsetBefore: a} = n;
    if (a) {
        const r = e.slides.length - 1
          , o = e.slidesGrid[r] + e.slidesSizesGrid[r] + a * 2;
        e.isLocked = e.size > o
    } else
        e.isLocked = e.snapGrid.length === 1;
    n.allowSlideNext === !0 && (e.allowSlideNext = !e.isLocked),
    n.allowSlidePrev === !0 && (e.allowSlidePrev = !e.isLocked),
    t && t !== e.isLocked && (e.isEnd = !1),
    t !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock")
}
const q$ = {
    checkOverflow: U$
}
  , I3 = {
    init: !0,
    direction: "horizontal",
    touchEventsTarget: "wrapper",
    initialSlide: 0,
    speed: 300,
    cssMode: !1,
    updateOnWindowResize: !0,
    resizeObserver: !0,
    nested: !1,
    createElements: !1,
    enabled: !0,
    focusableElements: "input, select, option, textarea, button, video, label",
    width: null,
    height: null,
    preventInteractionOnTransition: !1,
    userAgent: null,
    url: null,
    edgeSwipeDetection: !1,
    edgeSwipeThreshold: 20,
    autoHeight: !1,
    setWrapperSize: !1,
    virtualTranslate: !1,
    effect: "slide",
    breakpoints: void 0,
    breakpointsBase: "window",
    spaceBetween: 0,
    slidesPerView: 1,
    slidesPerGroup: 1,
    slidesPerGroupSkip: 0,
    slidesPerGroupAuto: !1,
    centeredSlides: !1,
    centeredSlidesBounds: !1,
    slidesOffsetBefore: 0,
    slidesOffsetAfter: 0,
    normalizeSlideIndex: !0,
    centerInsufficientSlides: !1,
    watchOverflow: !0,
    roundLengths: !1,
    touchRatio: 1,
    touchAngle: 45,
    simulateTouch: !0,
    shortSwipes: !0,
    longSwipes: !0,
    longSwipesRatio: .5,
    longSwipesMs: 300,
    followFinger: !0,
    allowTouchMove: !0,
    threshold: 0,
    touchMoveStopPropagation: !1,
    touchStartPreventDefault: !0,
    touchStartForcePreventDefault: !1,
    touchReleaseOnEdges: !1,
    uniqueNavElements: !0,
    resistance: !0,
    resistanceRatio: .85,
    watchSlidesProgress: !1,
    grabCursor: !1,
    preventClicks: !0,
    preventClicksPropagation: !0,
    slideToClickedSlide: !1,
    preloadImages: !0,
    updateOnImagesReady: !0,
    loop: !1,
    loopAdditionalSlides: 0,
    loopedSlides: null,
    loopedSlidesLimit: !0,
    loopFillGroupWithBlank: !1,
    loopPreventsSlide: !0,
    rewind: !1,
    allowSlidePrev: !0,
    allowSlideNext: !0,
    swipeHandler: null,
    noSwiping: !0,
    noSwipingClass: "swiper-no-swiping",
    noSwipingSelector: null,
    passiveListeners: !0,
    maxBackfaceHiddenSlides: 10,
    containerModifierClass: "swiper-",
    slideClass: "swiper-slide",
    slideBlankClass: "swiper-slide-invisible-blank",
    slideActiveClass: "swiper-slide-active",
    slideDuplicateActiveClass: "swiper-slide-duplicate-active",
    slideVisibleClass: "swiper-slide-visible",
    slideDuplicateClass: "swiper-slide-duplicate",
    slideNextClass: "swiper-slide-next",
    slideDuplicateNextClass: "swiper-slide-duplicate-next",
    slidePrevClass: "swiper-slide-prev",
    slideDuplicatePrevClass: "swiper-slide-duplicate-prev",
    wrapperClass: "swiper-wrapper",
    runCallbacksOnInit: !0,
    _emitClasses: !1
};
function W$(e, t) {
    return function(a={}) {
        const r = Object.keys(a)[0]
          , o = a[r];
        if (typeof o != "object" || o === null) {
            Rn(t, a);
            return
        }
        if (["navigation", "pagination", "scrollbar"].indexOf(r) >= 0 && e[r] === !0 && (e[r] = {
            auto: !0
        }),
        !(r in e && "enabled"in o)) {
            Rn(t, a);
            return
        }
        e[r] === !0 && (e[r] = {
            enabled: !0
        }),
        typeof e[r] == "object" && !("enabled"in e[r]) && (e[r].enabled = !0),
        e[r] || (e[r] = {
            enabled: !1
        }),
        Rn(t, a)
    }
}
const Xc = {
    eventsEmitter: FS,
    update: JS,
    translate: r$,
    transition: l$,
    slide: g$,
    loop: C$,
    grabCursor: k$,
    events: P$,
    breakpoints: B$,
    checkOverflow: q$,
    classes: H$,
    images: j$
}
  , Kc = {};
let ar = class Ga {
    constructor(...t) {
        let n, a;
        if (t.length === 1 && t[0].constructor && Object.prototype.toString.call(t[0]).slice(8, -1) === "Object" ? a = t[0] : [n,a] = t,
        a || (a = {}),
        a = Rn({}, a),
        n && !a.el && (a.el = n),
        a.el && _e(a.el).length > 1) {
            const s = [];
            return _e(a.el).each(l => {
                const c = Rn({}, a, {
                    el: l
                });
                s.push(new Ga(c))
            }
            ),
            s
        }
        const r = this;
        r.__swiper__ = !0,
        r.support = C6(),
        r.device = RS({
            userAgent: a.userAgent
        }),
        r.browser = NS(),
        r.eventsListeners = {},
        r.eventsAnyListeners = [],
        r.modules = [...r.__modules__],
        a.modules && Array.isArray(a.modules) && r.modules.push(...a.modules);
        const o = {};
        r.modules.forEach(s => {
            s({
                swiper: r,
                extendParams: W$(a, o),
                on: r.on.bind(r),
                once: r.once.bind(r),
                off: r.off.bind(r),
                emit: r.emit.bind(r)
            })
        }
        );
        const i = Rn({}, I3, o);
        return r.params = Rn({}, i, Kc, a),
        r.originalParams = Rn({}, r.params),
        r.passedParams = Rn({}, a),
        r.params && r.params.on && Object.keys(r.params.on).forEach(s => {
            r.on(s, r.params.on[s])
        }
        ),
        r.params && r.params.onAny && r.onAny(r.params.onAny),
        r.$ = _e,
        Object.assign(r, {
            enabled: r.params.enabled,
            el: n,
            classNames: [],
            slides: _e(),
            slidesGrid: [],
            snapGrid: [],
            slidesSizesGrid: [],
            isHorizontal() {
                return r.params.direction === "horizontal"
            },
            isVertical() {
                return r.params.direction === "vertical"
            },
            activeIndex: 0,
            realIndex: 0,
            isBeginning: !0,
            isEnd: !1,
            translate: 0,
            previousTranslate: 0,
            progress: 0,
            velocity: 0,
            animating: !1,
            allowSlideNext: r.params.allowSlideNext,
            allowSlidePrev: r.params.allowSlidePrev,
            touchEvents: function() {
                const l = ["touchstart", "touchmove", "touchend", "touchcancel"]
                  , c = ["pointerdown", "pointermove", "pointerup"];
                return r.touchEventsTouch = {
                    start: l[0],
                    move: l[1],
                    end: l[2],
                    cancel: l[3]
                },
                r.touchEventsDesktop = {
                    start: c[0],
                    move: c[1],
                    end: c[2]
                },
                r.support.touch || !r.params.simulateTouch ? r.touchEventsTouch : r.touchEventsDesktop
            }(),
            touchEventsData: {
                isTouched: void 0,
                isMoved: void 0,
                allowTouchCallbacks: void 0,
                touchStartTime: void 0,
                isScrolling: void 0,
                currentTranslate: void 0,
                startTranslate: void 0,
                allowThresholdMove: void 0,
                focusableElements: r.params.focusableElements,
                lastClickTime: Vn(),
                clickTimeout: void 0,
                velocities: [],
                allowMomentumBounce: void 0,
                isTouchEvent: void 0,
                startMoving: void 0
            },
            allowClick: !0,
            allowTouchMove: r.params.allowTouchMove,
            touches: {
                startX: 0,
                startY: 0,
                currentX: 0,
                currentY: 0,
                diff: 0
            },
            imagesToLoad: [],
            imagesLoaded: 0
        }),
        r.emit("_swiper"),
        r.params.init && r.init(),
        r
    }
    enable() {
        const t = this;
        t.enabled || (t.enabled = !0,
        t.params.grabCursor && t.setGrabCursor(),
        t.emit("enable"))
    }
    disable() {
        const t = this;
        t.enabled && (t.enabled = !1,
        t.params.grabCursor && t.unsetGrabCursor(),
        t.emit("disable"))
    }
    setProgress(t, n) {
        const a = this;
        t = Math.min(Math.max(t, 0), 1);
        const r = a.minTranslate()
          , i = (a.maxTranslate() - r) * t + r;
        a.translateTo(i, typeof n > "u" ? 0 : n),
        a.updateActiveIndex(),
        a.updateSlidesClasses()
    }
    emitContainerClasses() {
        const t = this;
        if (!t.params._emitClasses || !t.el)
            return;
        const n = t.el.className.split(" ").filter(a => a.indexOf("swiper") === 0 || a.indexOf(t.params.containerModifierClass) === 0);
        t.emit("_containerClasses", n.join(" "))
    }
    getSlideClasses(t) {
        const n = this;
        return n.destroyed ? "" : t.className.split(" ").filter(a => a.indexOf("swiper-slide") === 0 || a.indexOf(n.params.slideClass) === 0).join(" ")
    }
    emitSlidesClasses() {
        const t = this;
        if (!t.params._emitClasses || !t.el)
            return;
        const n = [];
        t.slides.each(a => {
            const r = t.getSlideClasses(a);
            n.push({
                slideEl: a,
                classNames: r
            }),
            t.emit("_slideClass", a, r)
        }
        ),
        t.emit("_slideClasses", n)
    }
    slidesPerViewDynamic(t="current", n=!1) {
        const a = this
          , {params: r, slides: o, slidesGrid: i, slidesSizesGrid: s, size: l, activeIndex: c} = a;
        let u = 1;
        if (r.centeredSlides) {
            let f = o[c].swiperSlideSize, d;
            for (let p = c + 1; p < o.length; p += 1)
                o[p] && !d && (f += o[p].swiperSlideSize,
                u += 1,
                f > l && (d = !0));
            for (let p = c - 1; p >= 0; p -= 1)
                o[p] && !d && (f += o[p].swiperSlideSize,
                u += 1,
                f > l && (d = !0))
        } else if (t === "current")
            for (let f = c + 1; f < o.length; f += 1)
                (n ? i[f] + s[f] - i[c] < l : i[f] - i[c] < l) && (u += 1);
        else
            for (let f = c - 1; f >= 0; f -= 1)
                i[c] - i[f] < l && (u += 1);
        return u
    }
    update() {
        const t = this;
        if (!t || t.destroyed)
            return;
        const {snapGrid: n, params: a} = t;
        a.breakpoints && t.setBreakpoint(),
        t.updateSize(),
        t.updateSlides(),
        t.updateProgress(),
        t.updateSlidesClasses();
        function r() {
            const i = t.rtlTranslate ? t.translate * -1 : t.translate
              , s = Math.min(Math.max(i, t.maxTranslate()), t.minTranslate());
            t.setTranslate(s),
            t.updateActiveIndex(),
            t.updateSlidesClasses()
        }
        let o;
        t.params.freeMode && t.params.freeMode.enabled ? (r(),
        t.params.autoHeight && t.updateAutoHeight()) : ((t.params.slidesPerView === "auto" || t.params.slidesPerView > 1) && t.isEnd && !t.params.centeredSlides ? o = t.slideTo(t.slides.length - 1, 0, !1, !0) : o = t.slideTo(t.activeIndex, 0, !1, !0),
        o || r()),
        a.watchOverflow && n !== t.snapGrid && t.checkOverflow(),
        t.emit("update")
    }
    changeDirection(t, n=!0) {
        const a = this
          , r = a.params.direction;
        return t || (t = r === "horizontal" ? "vertical" : "horizontal"),
        t === r || t !== "horizontal" && t !== "vertical" || (a.$el.removeClass(`${a.params.containerModifierClass}${r}`).addClass(`${a.params.containerModifierClass}${t}`),
        a.emitContainerClasses(),
        a.params.direction = t,
        a.slides.each(o => {
            t === "vertical" ? o.style.width = "" : o.style.height = ""
        }
        ),
        a.emit("changeDirection"),
        n && a.update()),
        a
    }
    changeLanguageDirection(t) {
        const n = this;
        n.rtl && t === "rtl" || !n.rtl && t === "ltr" || (n.rtl = t === "rtl",
        n.rtlTranslate = n.params.direction === "horizontal" && n.rtl,
        n.rtl ? (n.$el.addClass(`${n.params.containerModifierClass}rtl`),
        n.el.dir = "rtl") : (n.$el.removeClass(`${n.params.containerModifierClass}rtl`),
        n.el.dir = "ltr"),
        n.update())
    }
    mount(t) {
        const n = this;
        if (n.mounted)
            return !0;
        const a = _e(t || n.params.el);
        if (t = a[0],
        !t)
            return !1;
        t.swiper = n;
        const r = () => `.${(n.params.wrapperClass || "").trim().split(" ").join(".")}`;
        let i = ( () => {
            if (t && t.shadowRoot && t.shadowRoot.querySelector) {
                const s = _e(t.shadowRoot.querySelector(r()));
                return s.children = l => a.children(l),
                s
            }
            return a.children ? a.children(r()) : _e(a).children(r())
        }
        )();
        if (i.length === 0 && n.params.createElements) {
            const l = Qe().createElement("div");
            i = _e(l),
            l.className = n.params.wrapperClass,
            a.append(l),
            a.children(`.${n.params.slideClass}`).each(c => {
                i.append(c)
            }
            )
        }
        return Object.assign(n, {
            $el: a,
            el: t,
            $wrapperEl: i,
            wrapperEl: i[0],
            mounted: !0,
            rtl: t.dir.toLowerCase() === "rtl" || a.css("direction") === "rtl",
            rtlTranslate: n.params.direction === "horizontal" && (t.dir.toLowerCase() === "rtl" || a.css("direction") === "rtl"),
            wrongRTL: i.css("display") === "-webkit-box"
        }),
        !0
    }
    init(t) {
        const n = this;
        return n.initialized || n.mount(t) === !1 || (n.emit("beforeInit"),
        n.params.breakpoints && n.setBreakpoint(),
        n.addClasses(),
        n.params.loop && n.loopCreate(),
        n.updateSize(),
        n.updateSlides(),
        n.params.watchOverflow && n.checkOverflow(),
        n.params.grabCursor && n.enabled && n.setGrabCursor(),
        n.params.preloadImages && n.preloadImages(),
        n.params.loop ? n.slideTo(n.params.initialSlide + n.loopedSlides, 0, n.params.runCallbacksOnInit, !1, !0) : n.slideTo(n.params.initialSlide, 0, n.params.runCallbacksOnInit, !1, !0),
        n.attachEvents(),
        n.initialized = !0,
        n.emit("init"),
        n.emit("afterInit")),
        n
    }
    destroy(t=!0, n=!0) {
        const a = this
          , {params: r, $el: o, $wrapperEl: i, slides: s} = a;
        return typeof a.params > "u" || a.destroyed || (a.emit("beforeDestroy"),
        a.initialized = !1,
        a.detachEvents(),
        r.loop && a.loopDestroy(),
        n && (a.removeClasses(),
        o.removeAttr("style"),
        i.removeAttr("style"),
        s && s.length && s.removeClass([r.slideVisibleClass, r.slideActiveClass, r.slideNextClass, r.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index")),
        a.emit("destroy"),
        Object.keys(a.eventsListeners).forEach(l => {
            a.off(l)
        }
        ),
        t !== !1 && (a.$el[0].swiper = null,
        OS(a)),
        a.destroyed = !0),
        null
    }
    static extendDefaults(t) {
        Rn(Kc, t)
    }
    static get extendedDefaults() {
        return Kc
    }
    static get defaults() {
        return I3
    }
    static installModule(t) {
        Ga.prototype.__modules__ || (Ga.prototype.__modules__ = []);
        const n = Ga.prototype.__modules__;
        typeof t == "function" && n.indexOf(t) < 0 && n.push(t)
    }
    static use(t) {
        return Array.isArray(t) ? (t.forEach(n => Ga.installModule(n)),
        Ga) : (Ga.installModule(t),
        Ga)
    }
}
;
Object.keys(Xc).forEach(e => {
    Object.keys(Xc[e]).forEach(t => {
        ar.prototype[t] = Xc[e][t]
    }
    )
}
);
ar.use([HS, VS]);
function Y$({swiper: e, extendParams: t, on: n, emit: a}) {
    t({
        virtual: {
            enabled: !1,
            slides: [],
            cache: !0,
            renderSlide: null,
            renderExternal: null,
            renderExternalUpdate: !0,
            addSlidesBefore: 0,
            addSlidesAfter: 0
        }
    });
    let r;
    e.virtual = {
        cache: {},
        from: void 0,
        to: void 0,
        slides: [],
        offset: 0,
        slidesGrid: []
    };
    function o(f, d) {
        const p = e.params.virtual;
        if (p.cache && e.virtual.cache[d])
            return e.virtual.cache[d];
        const h = p.renderSlide ? _e(p.renderSlide.call(e, f, d)) : _e(`<div class="${e.params.slideClass}" data-swiper-slide-index="${d}">${f}</div>`);
        return h.attr("data-swiper-slide-index") || h.attr("data-swiper-slide-index", d),
        p.cache && (e.virtual.cache[d] = h),
        h
    }
    function i(f) {
        const {slidesPerView: d, slidesPerGroup: p, centeredSlides: h} = e.params
          , {addSlidesBefore: m, addSlidesAfter: g} = e.params.virtual
          , {from: b, to: v, slides: y, slidesGrid: w, offset: C} = e.virtual;
        e.params.cssMode || e.updateActiveIndex();
        const _ = e.activeIndex || 0;
        let E;
        e.rtlTranslate ? E = "right" : E = e.isHorizontal() ? "left" : "top";
        let z, T;
        h ? (z = Math.floor(d / 2) + p + g,
        T = Math.floor(d / 2) + p + m) : (z = d + (p - 1) + g,
        T = p + m);
        const A = Math.max((_ || 0) - T, 0)
          , x = Math.min((_ || 0) + z, y.length - 1)
          , M = (e.slidesGrid[A] || 0) - (e.slidesGrid[0] || 0);
        Object.assign(e.virtual, {
            from: A,
            to: x,
            offset: M,
            slidesGrid: e.slidesGrid
        });
        function L() {
            e.updateSlides(),
            e.updateProgress(),
            e.updateSlidesClasses(),
            e.lazy && e.params.lazy.enabled && e.lazy.load(),
            a("virtualUpdate")
        }
        if (b === A && v === x && !f) {
            e.slidesGrid !== w && M !== C && e.slides.css(E, `${M}px`),
            e.updateProgress(),
            a("virtualUpdate");
            return
        }
        if (e.params.virtual.renderExternal) {
            e.params.virtual.renderExternal.call(e, {
                offset: M,
                from: A,
                to: x,
                slides: function() {
                    const W = [];
                    for (let j = A; j <= x; j += 1)
                        W.push(y[j]);
                    return W
                }()
            }),
            e.params.virtual.renderExternalUpdate ? L() : a("virtualUpdate");
            return
        }
        const U = []
          , Y = [];
        if (f)
            e.$wrapperEl.find(`.${e.params.slideClass}`).remove();
        else
            for (let H = b; H <= v; H += 1)
                (H < A || H > x) && e.$wrapperEl.find(`.${e.params.slideClass}[data-swiper-slide-index="${H}"]`).remove();
        for (let H = 0; H < y.length; H += 1)
            H >= A && H <= x && (typeof v > "u" || f ? Y.push(H) : (H > v && Y.push(H),
            H < b && U.push(H)));
        Y.forEach(H => {
            e.$wrapperEl.append(o(y[H], H))
        }
        ),
        U.sort( (H, W) => W - H).forEach(H => {
            e.$wrapperEl.prepend(o(y[H], H))
        }
        ),
        e.$wrapperEl.children(".swiper-slide").css(E, `${M}px`),
        L()
    }
    function s(f) {
        if (typeof f == "object" && "length"in f)
            for (let d = 0; d < f.length; d += 1)
                f[d] && e.virtual.slides.push(f[d]);
        else
            e.virtual.slides.push(f);
        i(!0)
    }
    function l(f) {
        const d = e.activeIndex;
        let p = d + 1
          , h = 1;
        if (Array.isArray(f)) {
            for (let m = 0; m < f.length; m += 1)
                f[m] && e.virtual.slides.unshift(f[m]);
            p = d + f.length,
            h = f.length
        } else
            e.virtual.slides.unshift(f);
        if (e.params.virtual.cache) {
            const m = e.virtual.cache
              , g = {};
            Object.keys(m).forEach(b => {
                const v = m[b]
                  , y = v.attr("data-swiper-slide-index");
                y && v.attr("data-swiper-slide-index", parseInt(y, 10) + h),
                g[parseInt(b, 10) + h] = v
            }
            ),
            e.virtual.cache = g
        }
        i(!0),
        e.slideTo(p, 0)
    }
    function c(f) {
        if (typeof f > "u" || f === null)
            return;
        let d = e.activeIndex;
        if (Array.isArray(f))
            for (let p = f.length - 1; p >= 0; p -= 1)
                e.virtual.slides.splice(f[p], 1),
                e.params.virtual.cache && delete e.virtual.cache[f[p]],
                f[p] < d && (d -= 1),
                d = Math.max(d, 0);
        else
            e.virtual.slides.splice(f, 1),
            e.params.virtual.cache && delete e.virtual.cache[f],
            f < d && (d -= 1),
            d = Math.max(d, 0);
        i(!0),
        e.slideTo(d, 0)
    }
    function u() {
        e.virtual.slides = [],
        e.params.virtual.cache && (e.virtual.cache = {}),
        i(!0),
        e.slideTo(0, 0)
    }
    n("beforeInit", () => {
        e.params.virtual.enabled && (e.virtual.slides = e.params.virtual.slides,
        e.classNames.push(`${e.params.containerModifierClass}virtual`),
        e.params.watchSlidesProgress = !0,
        e.originalParams.watchSlidesProgress = !0,
        e.params.initialSlide || i())
    }
    ),
    n("setTranslate", () => {
        e.params.virtual.enabled && (e.params.cssMode && !e._immediateVirtual ? (clearTimeout(r),
        r = setTimeout( () => {
            i()
        }
        , 100)) : i())
    }
    ),
    n("init update resize", () => {
        e.params.virtual.enabled && e.params.cssMode && Ji(e.wrapperEl, "--swiper-virtual-size", `${e.virtualSize}px`)
    }
    ),
    Object.assign(e.virtual, {
        appendSlide: s,
        prependSlide: l,
        removeSlide: c,
        removeAllSlides: u,
        update: i
    })
}
function G$({swiper: e, extendParams: t, on: n, emit: a}) {
    const r = Qe()
      , o = He();
    e.keyboard = {
        enabled: !1
    },
    t({
        keyboard: {
            enabled: !1,
            onlyInViewport: !0,
            pageUpDown: !0
        }
    });
    function i(c) {
        if (!e.enabled)
            return;
        const {rtlTranslate: u} = e;
        let f = c;
        f.originalEvent && (f = f.originalEvent);
        const d = f.keyCode || f.charCode
          , p = e.params.keyboard.pageUpDown
          , h = p && d === 33
          , m = p && d === 34
          , g = d === 37
          , b = d === 39
          , v = d === 38
          , y = d === 40;
        if (!e.allowSlideNext && (e.isHorizontal() && b || e.isVertical() && y || m) || !e.allowSlidePrev && (e.isHorizontal() && g || e.isVertical() && v || h))
            return !1;
        if (!(f.shiftKey || f.altKey || f.ctrlKey || f.metaKey) && !(r.activeElement && r.activeElement.nodeName && (r.activeElement.nodeName.toLowerCase() === "input" || r.activeElement.nodeName.toLowerCase() === "textarea"))) {
            if (e.params.keyboard.onlyInViewport && (h || m || g || b || v || y)) {
                let w = !1;
                if (e.$el.parents(`.${e.params.slideClass}`).length > 0 && e.$el.parents(`.${e.params.slideActiveClass}`).length === 0)
                    return;
                const C = e.$el
                  , _ = C[0].clientWidth
                  , E = C[0].clientHeight
                  , z = o.innerWidth
                  , T = o.innerHeight
                  , A = e.$el.offset();
                u && (A.left -= e.$el[0].scrollLeft);
                const x = [[A.left, A.top], [A.left + _, A.top], [A.left, A.top + E], [A.left + _, A.top + E]];
                for (let M = 0; M < x.length; M += 1) {
                    const L = x[M];
                    if (L[0] >= 0 && L[0] <= z && L[1] >= 0 && L[1] <= T) {
                        if (L[0] === 0 && L[1] === 0)
                            continue;
                        w = !0
                    }
                }
                if (!w)
                    return
            }
            e.isHorizontal() ? ((h || m || g || b) && (f.preventDefault ? f.preventDefault() : f.returnValue = !1),
            ((m || b) && !u || (h || g) && u) && e.slideNext(),
            ((h || g) && !u || (m || b) && u) && e.slidePrev()) : ((h || m || v || y) && (f.preventDefault ? f.preventDefault() : f.returnValue = !1),
            (m || y) && e.slideNext(),
            (h || v) && e.slidePrev()),
            a("keyPress", d)
        }
    }
    function s() {
        e.keyboard.enabled || (_e(r).on("keydown", i),
        e.keyboard.enabled = !0)
    }
    function l() {
        e.keyboard.enabled && (_e(r).off("keydown", i),
        e.keyboard.enabled = !1)
    }
    n("init", () => {
        e.params.keyboard.enabled && s()
    }
    ),
    n("destroy", () => {
        e.keyboard.enabled && l()
    }
    ),
    Object.assign(e.keyboard, {
        enable: s,
        disable: l
    })
}
function X$({swiper: e, extendParams: t, on: n, emit: a}) {
    const r = He();
    t({
        mousewheel: {
            enabled: !1,
            releaseOnEdges: !1,
            invert: !1,
            forceToAxis: !1,
            sensitivity: 1,
            eventsTarget: "container",
            thresholdDelta: null,
            thresholdTime: null
        }
    }),
    e.mousewheel = {
        enabled: !1
    };
    let o, i = Vn(), s;
    const l = [];
    function c(v) {
        let _ = 0
          , E = 0
          , z = 0
          , T = 0;
        return "detail"in v && (E = v.detail),
        "wheelDelta"in v && (E = -v.wheelDelta / 120),
        "wheelDeltaY"in v && (E = -v.wheelDeltaY / 120),
        "wheelDeltaX"in v && (_ = -v.wheelDeltaX / 120),
        "axis"in v && v.axis === v.HORIZONTAL_AXIS && (_ = E,
        E = 0),
        z = _ * 10,
        T = E * 10,
        "deltaY"in v && (T = v.deltaY),
        "deltaX"in v && (z = v.deltaX),
        v.shiftKey && !z && (z = T,
        T = 0),
        (z || T) && v.deltaMode && (v.deltaMode === 1 ? (z *= 40,
        T *= 40) : (z *= 800,
        T *= 800)),
        z && !_ && (_ = z < 1 ? -1 : 1),
        T && !E && (E = T < 1 ? -1 : 1),
        {
            spinX: _,
            spinY: E,
            pixelX: z,
            pixelY: T
        }
    }
    function u() {
        e.enabled && (e.mouseEntered = !0)
    }
    function f() {
        e.enabled && (e.mouseEntered = !1)
    }
    function d(v) {
        return e.params.mousewheel.thresholdDelta && v.delta < e.params.mousewheel.thresholdDelta || e.params.mousewheel.thresholdTime && Vn() - i < e.params.mousewheel.thresholdTime ? !1 : v.delta >= 6 && Vn() - i < 60 ? !0 : (v.direction < 0 ? (!e.isEnd || e.params.loop) && !e.animating && (e.slideNext(),
        a("scroll", v.raw)) : (!e.isBeginning || e.params.loop) && !e.animating && (e.slidePrev(),
        a("scroll", v.raw)),
        i = new r.Date().getTime(),
        !1)
    }
    function p(v) {
        const y = e.params.mousewheel;
        if (v.direction < 0) {
            if (e.isEnd && !e.params.loop && y.releaseOnEdges)
                return !0
        } else if (e.isBeginning && !e.params.loop && y.releaseOnEdges)
            return !0;
        return !1
    }
    function h(v) {
        let y = v
          , w = !0;
        if (!e.enabled)
            return;
        const C = e.params.mousewheel;
        e.params.cssMode && y.preventDefault();
        let _ = e.$el;
        if (e.params.mousewheel.eventsTarget !== "container" && (_ = _e(e.params.mousewheel.eventsTarget)),
        !e.mouseEntered && !_[0].contains(y.target) && !C.releaseOnEdges)
            return !0;
        y.originalEvent && (y = y.originalEvent);
        let E = 0;
        const z = e.rtlTranslate ? -1 : 1
          , T = c(y);
        if (C.forceToAxis)
            if (e.isHorizontal())
                if (Math.abs(T.pixelX) > Math.abs(T.pixelY))
                    E = -T.pixelX * z;
                else
                    return !0;
            else if (Math.abs(T.pixelY) > Math.abs(T.pixelX))
                E = -T.pixelY;
            else
                return !0;
        else
            E = Math.abs(T.pixelX) > Math.abs(T.pixelY) ? -T.pixelX * z : -T.pixelY;
        if (E === 0)
            return !0;
        C.invert && (E = -E);
        let A = e.getTranslate() + E * C.sensitivity;
        if (A >= e.minTranslate() && (A = e.minTranslate()),
        A <= e.maxTranslate() && (A = e.maxTranslate()),
        w = e.params.loop ? !0 : !(A === e.minTranslate() || A === e.maxTranslate()),
        w && e.params.nested && y.stopPropagation(),
        !e.params.freeMode || !e.params.freeMode.enabled) {
            const x = {
                time: Vn(),
                delta: Math.abs(E),
                direction: Math.sign(E),
                raw: v
            };
            l.length >= 2 && l.shift();
            const M = l.length ? l[l.length - 1] : void 0;
            if (l.push(x),
            M ? (x.direction !== M.direction || x.delta > M.delta || x.time > M.time + 150) && d(x) : d(x),
            p(x))
                return !0
        } else {
            const x = {
                time: Vn(),
                delta: Math.abs(E),
                direction: Math.sign(E)
            }
              , M = s && x.time < s.time + 500 && x.delta <= s.delta && x.direction === s.direction;
            if (!M) {
                s = void 0,
                e.params.loop && e.loopFix();
                let L = e.getTranslate() + E * C.sensitivity;
                const U = e.isBeginning
                  , Y = e.isEnd;
                if (L >= e.minTranslate() && (L = e.minTranslate()),
                L <= e.maxTranslate() && (L = e.maxTranslate()),
                e.setTransition(0),
                e.setTranslate(L),
                e.updateProgress(),
                e.updateActiveIndex(),
                e.updateSlidesClasses(),
                (!U && e.isBeginning || !Y && e.isEnd) && e.updateSlidesClasses(),
                e.params.freeMode.sticky) {
                    clearTimeout(o),
                    o = void 0,
                    l.length >= 15 && l.shift();
                    const H = l.length ? l[l.length - 1] : void 0
                      , W = l[0];
                    if (l.push(x),
                    H && (x.delta > H.delta || x.direction !== H.direction))
                        l.splice(0);
                    else if (l.length >= 15 && x.time - W.time < 500 && W.delta - x.delta >= 1 && x.delta <= 6) {
                        const j = E > 0 ? .8 : .2;
                        s = x,
                        l.splice(0),
                        o = Lr( () => {
                            e.slideToClosest(e.params.speed, !0, void 0, j)
                        }
                        , 0)
                    }
                    o || (o = Lr( () => {
                        s = x,
                        l.splice(0),
                        e.slideToClosest(e.params.speed, !0, void 0, .5)
                    }
                    , 500))
                }
                if (M || a("scroll", y),
                e.params.autoplay && e.params.autoplayDisableOnInteraction && e.autoplay.stop(),
                L === e.minTranslate() || L === e.maxTranslate())
                    return !0
            }
        }
        return y.preventDefault ? y.preventDefault() : y.returnValue = !1,
        !1
    }
    function m(v) {
        let y = e.$el;
        e.params.mousewheel.eventsTarget !== "container" && (y = _e(e.params.mousewheel.eventsTarget)),
        y[v]("mouseenter", u),
        y[v]("mouseleave", f),
        y[v]("wheel", h)
    }
    function g() {
        return e.params.cssMode ? (e.wrapperEl.removeEventListener("wheel", h),
        !0) : e.mousewheel.enabled ? !1 : (m("on"),
        e.mousewheel.enabled = !0,
        !0)
    }
    function b() {
        return e.params.cssMode ? (e.wrapperEl.addEventListener(event, h),
        !0) : e.mousewheel.enabled ? (m("off"),
        e.mousewheel.enabled = !1,
        !0) : !1
    }
    n("init", () => {
        !e.params.mousewheel.enabled && e.params.cssMode && b(),
        e.params.mousewheel.enabled && g()
    }
    ),
    n("destroy", () => {
        e.params.cssMode && g(),
        e.mousewheel.enabled && b()
    }
    ),
    Object.assign(e.mousewheel, {
        enable: g,
        disable: b
    })
}
function Of(e, t, n, a) {
    const r = Qe();
    return e.params.createElements && Object.keys(a).forEach(o => {
        if (!n[o] && n.auto === !0) {
            let i = e.$el.children(`.${a[o]}`)[0];
            i || (i = r.createElement("div"),
            i.className = a[o],
            e.$el.append(i)),
            n[o] = i,
            t[o] = i
        }
    }
    ),
    n
}
function K$({swiper: e, extendParams: t, on: n, emit: a}) {
    t({
        navigation: {
            nextEl: null,
            prevEl: null,
            hideOnClick: !1,
            disabledClass: "swiper-button-disabled",
            hiddenClass: "swiper-button-hidden",
            lockClass: "swiper-button-lock",
            navigationDisabledClass: "swiper-navigation-disabled"
        }
    }),
    e.navigation = {
        nextEl: null,
        $nextEl: null,
        prevEl: null,
        $prevEl: null
    };
    function r(p) {
        let h;
        return p && (h = _e(p),
        e.params.uniqueNavElements && typeof p == "string" && h.length > 1 && e.$el.find(p).length === 1 && (h = e.$el.find(p))),
        h
    }
    function o(p, h) {
        const m = e.params.navigation;
        p && p.length > 0 && (p[h ? "addClass" : "removeClass"](m.disabledClass),
        p[0] && p[0].tagName === "BUTTON" && (p[0].disabled = h),
        e.params.watchOverflow && e.enabled && p[e.isLocked ? "addClass" : "removeClass"](m.lockClass))
    }
    function i() {
        if (e.params.loop)
            return;
        const {$nextEl: p, $prevEl: h} = e.navigation;
        o(h, e.isBeginning && !e.params.rewind),
        o(p, e.isEnd && !e.params.rewind)
    }
    function s(p) {
        p.preventDefault(),
        !(e.isBeginning && !e.params.loop && !e.params.rewind) && (e.slidePrev(),
        a("navigationPrev"))
    }
    function l(p) {
        p.preventDefault(),
        !(e.isEnd && !e.params.loop && !e.params.rewind) && (e.slideNext(),
        a("navigationNext"))
    }
    function c() {
        const p = e.params.navigation;
        if (e.params.navigation = Of(e, e.originalParams.navigation, e.params.navigation, {
            nextEl: "swiper-button-next",
            prevEl: "swiper-button-prev"
        }),
        !(p.nextEl || p.prevEl))
            return;
        const h = r(p.nextEl)
          , m = r(p.prevEl);
        h && h.length > 0 && h.on("click", l),
        m && m.length > 0 && m.on("click", s),
        Object.assign(e.navigation, {
            $nextEl: h,
            nextEl: h && h[0],
            $prevEl: m,
            prevEl: m && m[0]
        }),
        e.enabled || (h && h.addClass(p.lockClass),
        m && m.addClass(p.lockClass))
    }
    function u() {
        const {$nextEl: p, $prevEl: h} = e.navigation;
        p && p.length && (p.off("click", l),
        p.removeClass(e.params.navigation.disabledClass)),
        h && h.length && (h.off("click", s),
        h.removeClass(e.params.navigation.disabledClass))
    }
    n("init", () => {
        e.params.navigation.enabled === !1 ? d() : (c(),
        i())
    }
    ),
    n("toEdge fromEdge lock unlock", () => {
        i()
    }
    ),
    n("destroy", () => {
        u()
    }
    ),
    n("enable disable", () => {
        const {$nextEl: p, $prevEl: h} = e.navigation;
        p && p[e.enabled ? "removeClass" : "addClass"](e.params.navigation.lockClass),
        h && h[e.enabled ? "removeClass" : "addClass"](e.params.navigation.lockClass)
    }
    ),
    n("click", (p, h) => {
        const {$nextEl: m, $prevEl: g} = e.navigation
          , b = h.target;
        if (e.params.navigation.hideOnClick && !_e(b).is(g) && !_e(b).is(m)) {
            if (e.pagination && e.params.pagination && e.params.pagination.clickable && (e.pagination.el === b || e.pagination.el.contains(b)))
                return;
            let v;
            m ? v = m.hasClass(e.params.navigation.hiddenClass) : g && (v = g.hasClass(e.params.navigation.hiddenClass)),
            a(v === !0 ? "navigationShow" : "navigationHide"),
            m && m.toggleClass(e.params.navigation.hiddenClass),
            g && g.toggleClass(e.params.navigation.hiddenClass)
        }
    }
    );
    const f = () => {
        e.$el.removeClass(e.params.navigation.navigationDisabledClass),
        c(),
        i()
    }
      , d = () => {
        e.$el.addClass(e.params.navigation.navigationDisabledClass),
        u()
    }
    ;
    Object.assign(e.navigation, {
        enable: f,
        disable: d,
        update: i,
        init: c,
        destroy: u
    })
}
function Xa(e="") {
    return `.${e.trim().replace(/([\.:!\/])/g, "\\$1").replace(/ /g, ".")}`
}
function Z$({swiper: e, extendParams: t, on: n, emit: a}) {
    const r = "swiper-pagination";
    t({
        pagination: {
            el: null,
            bulletElement: "span",
            clickable: !1,
            hideOnClick: !1,
            renderBullet: null,
            renderProgressbar: null,
            renderFraction: null,
            renderCustom: null,
            progressbarOpposite: !1,
            type: "bullets",
            dynamicBullets: !1,
            dynamicMainBullets: 1,
            formatFractionCurrent: m => m,
            formatFractionTotal: m => m,
            bulletClass: `${r}-bullet`,
            bulletActiveClass: `${r}-bullet-active`,
            modifierClass: `${r}-`,
            currentClass: `${r}-current`,
            totalClass: `${r}-total`,
            hiddenClass: `${r}-hidden`,
            progressbarFillClass: `${r}-progressbar-fill`,
            progressbarOppositeClass: `${r}-progressbar-opposite`,
            clickableClass: `${r}-clickable`,
            lockClass: `${r}-lock`,
            horizontalClass: `${r}-horizontal`,
            verticalClass: `${r}-vertical`,
            paginationDisabledClass: `${r}-disabled`
        }
    }),
    e.pagination = {
        el: null,
        $el: null,
        bullets: []
    };
    let o, i = 0;
    function s() {
        return !e.params.pagination.el || !e.pagination.el || !e.pagination.$el || e.pagination.$el.length === 0
    }
    function l(m, g) {
        const {bulletActiveClass: b} = e.params.pagination;
        m[g]().addClass(`${b}-${g}`)[g]().addClass(`${b}-${g}-${g}`)
    }
    function c() {
        const m = e.rtl
          , g = e.params.pagination;
        if (s())
            return;
        const b = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length
          , v = e.pagination.$el;
        let y;
        const w = e.params.loop ? Math.ceil((b - e.loopedSlides * 2) / e.params.slidesPerGroup) : e.snapGrid.length;
        if (e.params.loop ? (y = Math.ceil((e.activeIndex - e.loopedSlides) / e.params.slidesPerGroup),
        y > b - 1 - e.loopedSlides * 2 && (y -= b - e.loopedSlides * 2),
        y > w - 1 && (y -= w),
        y < 0 && e.params.paginationType !== "bullets" && (y = w + y)) : typeof e.snapIndex < "u" ? y = e.snapIndex : y = e.activeIndex || 0,
        g.type === "bullets" && e.pagination.bullets && e.pagination.bullets.length > 0) {
            const C = e.pagination.bullets;
            let _, E, z;
            if (g.dynamicBullets && (o = C.eq(0)[e.isHorizontal() ? "outerWidth" : "outerHeight"](!0),
            v.css(e.isHorizontal() ? "width" : "height", `${o * (g.dynamicMainBullets + 4)}px`),
            g.dynamicMainBullets > 1 && e.previousIndex !== void 0 && (i += y - (e.previousIndex - e.loopedSlides || 0),
            i > g.dynamicMainBullets - 1 ? i = g.dynamicMainBullets - 1 : i < 0 && (i = 0)),
            _ = Math.max(y - i, 0),
            E = _ + (Math.min(C.length, g.dynamicMainBullets) - 1),
            z = (E + _) / 2),
            C.removeClass(["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map(T => `${g.bulletActiveClass}${T}`).join(" ")),
            v.length > 1)
                C.each(T => {
                    const A = _e(T)
                      , x = A.index();
                    x === y && A.addClass(g.bulletActiveClass),
                    g.dynamicBullets && (x >= _ && x <= E && A.addClass(`${g.bulletActiveClass}-main`),
                    x === _ && l(A, "prev"),
                    x === E && l(A, "next"))
                }
                );
            else {
                const T = C.eq(y)
                  , A = T.index();
                if (T.addClass(g.bulletActiveClass),
                g.dynamicBullets) {
                    const x = C.eq(_)
                      , M = C.eq(E);
                    for (let L = _; L <= E; L += 1)
                        C.eq(L).addClass(`${g.bulletActiveClass}-main`);
                    if (e.params.loop)
                        if (A >= C.length) {
                            for (let L = g.dynamicMainBullets; L >= 0; L -= 1)
                                C.eq(C.length - L).addClass(`${g.bulletActiveClass}-main`);
                            C.eq(C.length - g.dynamicMainBullets - 1).addClass(`${g.bulletActiveClass}-prev`)
                        } else
                            l(x, "prev"),
                            l(M, "next");
                    else
                        l(x, "prev"),
                        l(M, "next")
                }
            }
            if (g.dynamicBullets) {
                const T = Math.min(C.length, g.dynamicMainBullets + 4)
                  , A = (o * T - o) / 2 - z * o
                  , x = m ? "right" : "left";
                C.css(e.isHorizontal() ? x : "top", `${A}px`)
            }
        }
        if (g.type === "fraction" && (v.find(Xa(g.currentClass)).text(g.formatFractionCurrent(y + 1)),
        v.find(Xa(g.totalClass)).text(g.formatFractionTotal(w))),
        g.type === "progressbar") {
            let C;
            g.progressbarOpposite ? C = e.isHorizontal() ? "vertical" : "horizontal" : C = e.isHorizontal() ? "horizontal" : "vertical";
            const _ = (y + 1) / w;
            let E = 1
              , z = 1;
            C === "horizontal" ? E = _ : z = _,
            v.find(Xa(g.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${E}) scaleY(${z})`).transition(e.params.speed)
        }
        g.type === "custom" && g.renderCustom ? (v.html(g.renderCustom(e, y + 1, w)),
        a("paginationRender", v[0])) : a("paginationUpdate", v[0]),
        e.params.watchOverflow && e.enabled && v[e.isLocked ? "addClass" : "removeClass"](g.lockClass)
    }
    function u() {
        const m = e.params.pagination;
        if (s())
            return;
        const g = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length
          , b = e.pagination.$el;
        let v = "";
        if (m.type === "bullets") {
            let y = e.params.loop ? Math.ceil((g - e.loopedSlides * 2) / e.params.slidesPerGroup) : e.snapGrid.length;
            e.params.freeMode && e.params.freeMode.enabled && !e.params.loop && y > g && (y = g);
            for (let w = 0; w < y; w += 1)
                m.renderBullet ? v += m.renderBullet.call(e, w, m.bulletClass) : v += `<${m.bulletElement} class="${m.bulletClass}"></${m.bulletElement}>`;
            b.html(v),
            e.pagination.bullets = b.find(Xa(m.bulletClass))
        }
        m.type === "fraction" && (m.renderFraction ? v = m.renderFraction.call(e, m.currentClass, m.totalClass) : v = `<span class="${m.currentClass}"></span> / <span class="${m.totalClass}"></span>`,
        b.html(v)),
        m.type === "progressbar" && (m.renderProgressbar ? v = m.renderProgressbar.call(e, m.progressbarFillClass) : v = `<span class="${m.progressbarFillClass}"></span>`,
        b.html(v)),
        m.type !== "custom" && a("paginationRender", e.pagination.$el[0])
    }
    function f() {
        e.params.pagination = Of(e, e.originalParams.pagination, e.params.pagination, {
            el: "swiper-pagination"
        });
        const m = e.params.pagination;
        if (!m.el)
            return;
        let g = _e(m.el);
        g.length !== 0 && (e.params.uniqueNavElements && typeof m.el == "string" && g.length > 1 && (g = e.$el.find(m.el),
        g.length > 1 && (g = g.filter(b => _e(b).parents(".swiper")[0] === e.el))),
        m.type === "bullets" && m.clickable && g.addClass(m.clickableClass),
        g.addClass(m.modifierClass + m.type),
        g.addClass(e.isHorizontal() ? m.horizontalClass : m.verticalClass),
        m.type === "bullets" && m.dynamicBullets && (g.addClass(`${m.modifierClass}${m.type}-dynamic`),
        i = 0,
        m.dynamicMainBullets < 1 && (m.dynamicMainBullets = 1)),
        m.type === "progressbar" && m.progressbarOpposite && g.addClass(m.progressbarOppositeClass),
        m.clickable && g.on("click", Xa(m.bulletClass), function(v) {
            v.preventDefault();
            let y = _e(this).index() * e.params.slidesPerGroup;
            e.params.loop && (y += e.loopedSlides),
            e.slideTo(y)
        }),
        Object.assign(e.pagination, {
            $el: g,
            el: g[0]
        }),
        e.enabled || g.addClass(m.lockClass))
    }
    function d() {
        const m = e.params.pagination;
        if (s())
            return;
        const g = e.pagination.$el;
        g.removeClass(m.hiddenClass),
        g.removeClass(m.modifierClass + m.type),
        g.removeClass(e.isHorizontal() ? m.horizontalClass : m.verticalClass),
        e.pagination.bullets && e.pagination.bullets.removeClass && e.pagination.bullets.removeClass(m.bulletActiveClass),
        m.clickable && g.off("click", Xa(m.bulletClass))
    }
    n("init", () => {
        e.params.pagination.enabled === !1 ? h() : (f(),
        u(),
        c())
    }
    ),
    n("activeIndexChange", () => {
        (e.params.loop || typeof e.snapIndex > "u") && c()
    }
    ),
    n("snapIndexChange", () => {
        e.params.loop || c()
    }
    ),
    n("slidesLengthChange", () => {
        e.params.loop && (u(),
        c())
    }
    ),
    n("snapGridLengthChange", () => {
        e.params.loop || (u(),
        c())
    }
    ),
    n("destroy", () => {
        d()
    }
    ),
    n("enable disable", () => {
        const {$el: m} = e.pagination;
        m && m[e.enabled ? "removeClass" : "addClass"](e.params.pagination.lockClass)
    }
    ),
    n("lock unlock", () => {
        c()
    }
    ),
    n("click", (m, g) => {
        const b = g.target
          , {$el: v} = e.pagination;
        if (e.params.pagination.el && e.params.pagination.hideOnClick && v && v.length > 0 && !_e(b).hasClass(e.params.pagination.bulletClass)) {
            if (e.navigation && (e.navigation.nextEl && b === e.navigation.nextEl || e.navigation.prevEl && b === e.navigation.prevEl))
                return;
            const y = v.hasClass(e.params.pagination.hiddenClass);
            a(y === !0 ? "paginationShow" : "paginationHide"),
            v.toggleClass(e.params.pagination.hiddenClass)
        }
    }
    );
    const p = () => {
        e.$el.removeClass(e.params.pagination.paginationDisabledClass),
        e.pagination.$el && e.pagination.$el.removeClass(e.params.pagination.paginationDisabledClass),
        f(),
        u(),
        c()
    }
      , h = () => {
        e.$el.addClass(e.params.pagination.paginationDisabledClass),
        e.pagination.$el && e.pagination.$el.addClass(e.params.pagination.paginationDisabledClass),
        d()
    }
    ;
    Object.assign(e.pagination, {
        enable: p,
        disable: h,
        render: u,
        update: c,
        init: f,
        destroy: d
    })
}
function J$({swiper: e, extendParams: t, on: n, emit: a}) {
    const r = Qe();
    let o = !1, i = null, s = null, l, c, u, f;
    t({
        scrollbar: {
            el: null,
            dragSize: "auto",
            hide: !1,
            draggable: !1,
            snapOnRelease: !0,
            lockClass: "swiper-scrollbar-lock",
            dragClass: "swiper-scrollbar-drag",
            scrollbarDisabledClass: "swiper-scrollbar-disabled",
            horizontalClass: "swiper-scrollbar-horizontal",
            verticalClass: "swiper-scrollbar-vertical"
        }
    }),
    e.scrollbar = {
        el: null,
        dragEl: null,
        $el: null,
        $dragEl: null
    };
    function d() {
        if (!e.params.scrollbar.el || !e.scrollbar.el)
            return;
        const {scrollbar: x, rtlTranslate: M, progress: L} = e
          , {$dragEl: U, $el: Y} = x
          , H = e.params.scrollbar;
        let W = c
          , j = (u - c) * L;
        M ? (j = -j,
        j > 0 ? (W = c - j,
        j = 0) : -j + c > u && (W = u + j)) : j < 0 ? (W = c + j,
        j = 0) : j + c > u && (W = u - j),
        e.isHorizontal() ? (U.transform(`translate3d(${j}px, 0, 0)`),
        U[0].style.width = `${W}px`) : (U.transform(`translate3d(0px, ${j}px, 0)`),
        U[0].style.height = `${W}px`),
        H.hide && (clearTimeout(i),
        Y[0].style.opacity = 1,
        i = setTimeout( () => {
            Y[0].style.opacity = 0,
            Y.transition(400)
        }
        , 1e3))
    }
    function p(x) {
        !e.params.scrollbar.el || !e.scrollbar.el || e.scrollbar.$dragEl.transition(x)
    }
    function h() {
        if (!e.params.scrollbar.el || !e.scrollbar.el)
            return;
        const {scrollbar: x} = e
          , {$dragEl: M, $el: L} = x;
        M[0].style.width = "",
        M[0].style.height = "",
        u = e.isHorizontal() ? L[0].offsetWidth : L[0].offsetHeight,
        f = e.size / (e.virtualSize + e.params.slidesOffsetBefore - (e.params.centeredSlides ? e.snapGrid[0] : 0)),
        e.params.scrollbar.dragSize === "auto" ? c = u * f : c = parseInt(e.params.scrollbar.dragSize, 10),
        e.isHorizontal() ? M[0].style.width = `${c}px` : M[0].style.height = `${c}px`,
        f >= 1 ? L[0].style.display = "none" : L[0].style.display = "",
        e.params.scrollbar.hide && (L[0].style.opacity = 0),
        e.params.watchOverflow && e.enabled && x.$el[e.isLocked ? "addClass" : "removeClass"](e.params.scrollbar.lockClass)
    }
    function m(x) {
        return e.isHorizontal() ? x.type === "touchstart" || x.type === "touchmove" ? x.targetTouches[0].clientX : x.clientX : x.type === "touchstart" || x.type === "touchmove" ? x.targetTouches[0].clientY : x.clientY
    }
    function g(x) {
        const {scrollbar: M, rtlTranslate: L} = e
          , {$el: U} = M;
        let Y;
        Y = (m(x) - U.offset()[e.isHorizontal() ? "left" : "top"] - (l !== null ? l : c / 2)) / (u - c),
        Y = Math.max(Math.min(Y, 1), 0),
        L && (Y = 1 - Y);
        const H = e.minTranslate() + (e.maxTranslate() - e.minTranslate()) * Y;
        e.updateProgress(H),
        e.setTranslate(H),
        e.updateActiveIndex(),
        e.updateSlidesClasses()
    }
    function b(x) {
        const M = e.params.scrollbar
          , {scrollbar: L, $wrapperEl: U} = e
          , {$el: Y, $dragEl: H} = L;
        o = !0,
        l = x.target === H[0] || x.target === H ? m(x) - x.target.getBoundingClientRect()[e.isHorizontal() ? "left" : "top"] : null,
        x.preventDefault(),
        x.stopPropagation(),
        U.transition(100),
        H.transition(100),
        g(x),
        clearTimeout(s),
        Y.transition(0),
        M.hide && Y.css("opacity", 1),
        e.params.cssMode && e.$wrapperEl.css("scroll-snap-type", "none"),
        a("scrollbarDragStart", x)
    }
    function v(x) {
        const {scrollbar: M, $wrapperEl: L} = e
          , {$el: U, $dragEl: Y} = M;
        o && (x.preventDefault ? x.preventDefault() : x.returnValue = !1,
        g(x),
        L.transition(0),
        U.transition(0),
        Y.transition(0),
        a("scrollbarDragMove", x))
    }
    function y(x) {
        const M = e.params.scrollbar
          , {scrollbar: L, $wrapperEl: U} = e
          , {$el: Y} = L;
        o && (o = !1,
        e.params.cssMode && (e.$wrapperEl.css("scroll-snap-type", ""),
        U.transition("")),
        M.hide && (clearTimeout(s),
        s = Lr( () => {
            Y.css("opacity", 0),
            Y.transition(400)
        }
        , 1e3)),
        a("scrollbarDragEnd", x),
        M.snapOnRelease && e.slideToClosest())
    }
    function w(x) {
        const {scrollbar: M, touchEventsTouch: L, touchEventsDesktop: U, params: Y, support: H} = e
          , W = M.$el;
        if (!W)
            return;
        const j = W[0]
          , Q = H.passiveListener && Y.passiveListeners ? {
            passive: !1,
            capture: !1
        } : !1
          , ne = H.passiveListener && Y.passiveListeners ? {
            passive: !0,
            capture: !1
        } : !1;
        if (!j)
            return;
        const re = x === "on" ? "addEventListener" : "removeEventListener";
        H.touch ? (j[re](L.start, b, Q),
        j[re](L.move, v, Q),
        j[re](L.end, y, ne)) : (j[re](U.start, b, Q),
        r[re](U.move, v, Q),
        r[re](U.end, y, ne))
    }
    function C() {
        !e.params.scrollbar.el || !e.scrollbar.el || w("on")
    }
    function _() {
        !e.params.scrollbar.el || !e.scrollbar.el || w("off")
    }
    function E() {
        const {scrollbar: x, $el: M} = e;
        e.params.scrollbar = Of(e, e.originalParams.scrollbar, e.params.scrollbar, {
            el: "swiper-scrollbar"
        });
        const L = e.params.scrollbar;
        if (!L.el)
            return;
        let U = _e(L.el);
        e.params.uniqueNavElements && typeof L.el == "string" && U.length > 1 && M.find(L.el).length === 1 && (U = M.find(L.el)),
        U.addClass(e.isHorizontal() ? L.horizontalClass : L.verticalClass);
        let Y = U.find(`.${e.params.scrollbar.dragClass}`);
        Y.length === 0 && (Y = _e(`<div class="${e.params.scrollbar.dragClass}"></div>`),
        U.append(Y)),
        Object.assign(x, {
            $el: U,
            el: U[0],
            $dragEl: Y,
            dragEl: Y[0]
        }),
        L.draggable && C(),
        U && U[e.enabled ? "removeClass" : "addClass"](e.params.scrollbar.lockClass)
    }
    function z() {
        const x = e.params.scrollbar
          , M = e.scrollbar.$el;
        M && M.removeClass(e.isHorizontal() ? x.horizontalClass : x.verticalClass),
        _()
    }
    n("init", () => {
        e.params.scrollbar.enabled === !1 ? A() : (E(),
        h(),
        d())
    }
    ),
    n("update resize observerUpdate lock unlock", () => {
        h()
    }
    ),
    n("setTranslate", () => {
        d()
    }
    ),
    n("setTransition", (x, M) => {
        p(M)
    }
    ),
    n("enable disable", () => {
        const {$el: x} = e.scrollbar;
        x && x[e.enabled ? "removeClass" : "addClass"](e.params.scrollbar.lockClass)
    }
    ),
    n("destroy", () => {
        z()
    }
    );
    const T = () => {
        e.$el.removeClass(e.params.scrollbar.scrollbarDisabledClass),
        e.scrollbar.$el && e.scrollbar.$el.removeClass(e.params.scrollbar.scrollbarDisabledClass),
        E(),
        h(),
        d()
    }
      , A = () => {
        e.$el.addClass(e.params.scrollbar.scrollbarDisabledClass),
        e.scrollbar.$el && e.scrollbar.$el.addClass(e.params.scrollbar.scrollbarDisabledClass),
        z()
    }
    ;
    Object.assign(e.scrollbar, {
        enable: T,
        disable: A,
        updateSize: h,
        setTranslate: d,
        init: E,
        destroy: z
    })
}
function Q$({swiper: e, extendParams: t, on: n}) {
    t({
        parallax: {
            enabled: !1
        }
    });
    const a = (i, s) => {
        const {rtl: l} = e
          , c = _e(i)
          , u = l ? -1 : 1
          , f = c.attr("data-swiper-parallax") || "0";
        let d = c.attr("data-swiper-parallax-x")
          , p = c.attr("data-swiper-parallax-y");
        const h = c.attr("data-swiper-parallax-scale")
          , m = c.attr("data-swiper-parallax-opacity");
        if (d || p ? (d = d || "0",
        p = p || "0") : e.isHorizontal() ? (d = f,
        p = "0") : (p = f,
        d = "0"),
        d.indexOf("%") >= 0 ? d = `${parseInt(d, 10) * s * u}%` : d = `${d * s * u}px`,
        p.indexOf("%") >= 0 ? p = `${parseInt(p, 10) * s}%` : p = `${p * s}px`,
        typeof m < "u" && m !== null) {
            const g = m - (m - 1) * (1 - Math.abs(s));
            c[0].style.opacity = g
        }
        if (typeof h > "u" || h === null)
            c.transform(`translate3d(${d}, ${p}, 0px)`);
        else {
            const g = h - (h - 1) * (1 - Math.abs(s));
            c.transform(`translate3d(${d}, ${p}, 0px) scale(${g})`)
        }
    }
      , r = () => {
        const {$el: i, slides: s, progress: l, snapGrid: c} = e;
        i.children("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each(u => {
            a(u, l)
        }
        ),
        s.each( (u, f) => {
            let d = u.progress;
            e.params.slidesPerGroup > 1 && e.params.slidesPerView !== "auto" && (d += Math.ceil(f / 2) - l * (c.length - 1)),
            d = Math.min(Math.max(d, -1), 1),
            _e(u).find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each(p => {
                a(p, d)
            }
            )
        }
        )
    }
      , o = (i=e.params.speed) => {
        const {$el: s} = e;
        s.find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each(l => {
            const c = _e(l);
            let u = parseInt(c.attr("data-swiper-parallax-duration"), 10) || i;
            i === 0 && (u = 0),
            c.transition(u)
        }
        )
    }
    ;
    n("beforeInit", () => {
        e.params.parallax.enabled && (e.params.watchSlidesProgress = !0,
        e.originalParams.watchSlidesProgress = !0)
    }
    ),
    n("init", () => {
        e.params.parallax.enabled && r()
    }
    ),
    n("setTranslate", () => {
        e.params.parallax.enabled && r()
    }
    ),
    n("setTransition", (i, s) => {
        e.params.parallax.enabled && o(s)
    }
    )
}
function eE({swiper: e, extendParams: t, on: n, emit: a}) {
    const r = He();
    t({
        zoom: {
            enabled: !1,
            maxRatio: 3,
            minRatio: 1,
            toggle: !0,
            containerClass: "swiper-zoom-container",
            zoomedSlideClass: "swiper-slide-zoomed"
        }
    }),
    e.zoom = {
        enabled: !1
    };
    let o = 1, i = !1, s, l, c;
    const u = {
        $slideEl: void 0,
        slideWidth: void 0,
        slideHeight: void 0,
        $imageEl: void 0,
        $imageWrapEl: void 0,
        maxRatio: 3
    }
      , f = {
        isTouched: void 0,
        isMoved: void 0,
        currentX: void 0,
        currentY: void 0,
        minX: void 0,
        minY: void 0,
        maxX: void 0,
        maxY: void 0,
        width: void 0,
        height: void 0,
        startX: void 0,
        startY: void 0,
        touchesStart: {},
        touchesCurrent: {}
    }
      , d = {
        x: void 0,
        y: void 0,
        prevPositionX: void 0,
        prevPositionY: void 0,
        prevTime: void 0
    };
    let p = 1;
    Object.defineProperty(e.zoom, "scale", {
        get() {
            return p
        },
        set(H) {
            if (p !== H) {
                const W = u.$imageEl ? u.$imageEl[0] : void 0
                  , j = u.$slideEl ? u.$slideEl[0] : void 0;
                a("zoomChange", H, W, j)
            }
            p = H
        }
    });
    function h(H) {
        if (H.targetTouches.length < 2)
            return 1;
        const W = H.targetTouches[0].pageX
          , j = H.targetTouches[0].pageY
          , Q = H.targetTouches[1].pageX
          , ne = H.targetTouches[1].pageY;
        return Math.sqrt((Q - W) ** 2 + (ne - j) ** 2)
    }
    function m(H) {
        const W = e.support
          , j = e.params.zoom;
        if (l = !1,
        c = !1,
        !W.gestures) {
            if (H.type !== "touchstart" || H.type === "touchstart" && H.targetTouches.length < 2)
                return;
            l = !0,
            u.scaleStart = h(H)
        }
        if ((!u.$slideEl || !u.$slideEl.length) && (u.$slideEl = _e(H.target).closest(`.${e.params.slideClass}`),
        u.$slideEl.length === 0 && (u.$slideEl = e.slides.eq(e.activeIndex)),
        u.$imageEl = u.$slideEl.find(`.${j.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0),
        u.$imageWrapEl = u.$imageEl.parent(`.${j.containerClass}`),
        u.maxRatio = u.$imageWrapEl.attr("data-swiper-zoom") || j.maxRatio,
        u.$imageWrapEl.length === 0)) {
            u.$imageEl = void 0;
            return
        }
        u.$imageEl && u.$imageEl.transition(0),
        i = !0
    }
    function g(H) {
        const W = e.support
          , j = e.params.zoom
          , Q = e.zoom;
        if (!W.gestures) {
            if (H.type !== "touchmove" || H.type === "touchmove" && H.targetTouches.length < 2)
                return;
            c = !0,
            u.scaleMove = h(H)
        }
        if (!u.$imageEl || u.$imageEl.length === 0) {
            H.type === "gesturechange" && m(H);
            return
        }
        W.gestures ? Q.scale = H.scale * o : Q.scale = u.scaleMove / u.scaleStart * o,
        Q.scale > u.maxRatio && (Q.scale = u.maxRatio - 1 + (Q.scale - u.maxRatio + 1) ** .5),
        Q.scale < j.minRatio && (Q.scale = j.minRatio + 1 - (j.minRatio - Q.scale + 1) ** .5),
        u.$imageEl.transform(`translate3d(0,0,0) scale(${Q.scale})`)
    }
    function b(H) {
        const W = e.device
          , j = e.support
          , Q = e.params.zoom
          , ne = e.zoom;
        if (!j.gestures) {
            if (!l || !c || H.type !== "touchend" || H.type === "touchend" && H.changedTouches.length < 2 && !W.android)
                return;
            l = !1,
            c = !1
        }
        !u.$imageEl || u.$imageEl.length === 0 || (ne.scale = Math.max(Math.min(ne.scale, u.maxRatio), Q.minRatio),
        u.$imageEl.transition(e.params.speed).transform(`translate3d(0,0,0) scale(${ne.scale})`),
        o = ne.scale,
        i = !1,
        ne.scale === 1 && (u.$slideEl = void 0))
    }
    function v(H) {
        const W = e.device;
        !u.$imageEl || u.$imageEl.length === 0 || f.isTouched || (W.android && H.cancelable && H.preventDefault(),
        f.isTouched = !0,
        f.touchesStart.x = H.type === "touchstart" ? H.targetTouches[0].pageX : H.pageX,
        f.touchesStart.y = H.type === "touchstart" ? H.targetTouches[0].pageY : H.pageY)
    }
    function y(H) {
        const W = e.zoom;
        if (!u.$imageEl || u.$imageEl.length === 0 || (e.allowClick = !1,
        !f.isTouched || !u.$slideEl))
            return;
        f.isMoved || (f.width = u.$imageEl[0].offsetWidth,
        f.height = u.$imageEl[0].offsetHeight,
        f.startX = J2(u.$imageWrapEl[0], "x") || 0,
        f.startY = J2(u.$imageWrapEl[0], "y") || 0,
        u.slideWidth = u.$slideEl[0].offsetWidth,
        u.slideHeight = u.$slideEl[0].offsetHeight,
        u.$imageWrapEl.transition(0));
        const j = f.width * W.scale
          , Q = f.height * W.scale;
        if (!(j < u.slideWidth && Q < u.slideHeight)) {
            if (f.minX = Math.min(u.slideWidth / 2 - j / 2, 0),
            f.maxX = -f.minX,
            f.minY = Math.min(u.slideHeight / 2 - Q / 2, 0),
            f.maxY = -f.minY,
            f.touchesCurrent.x = H.type === "touchmove" ? H.targetTouches[0].pageX : H.pageX,
            f.touchesCurrent.y = H.type === "touchmove" ? H.targetTouches[0].pageY : H.pageY,
            !f.isMoved && !i) {
                if (e.isHorizontal() && (Math.floor(f.minX) === Math.floor(f.startX) && f.touchesCurrent.x < f.touchesStart.x || Math.floor(f.maxX) === Math.floor(f.startX) && f.touchesCurrent.x > f.touchesStart.x)) {
                    f.isTouched = !1;
                    return
                }
                if (!e.isHorizontal() && (Math.floor(f.minY) === Math.floor(f.startY) && f.touchesCurrent.y < f.touchesStart.y || Math.floor(f.maxY) === Math.floor(f.startY) && f.touchesCurrent.y > f.touchesStart.y)) {
                    f.isTouched = !1;
                    return
                }
            }
            H.cancelable && H.preventDefault(),
            H.stopPropagation(),
            f.isMoved = !0,
            f.currentX = f.touchesCurrent.x - f.touchesStart.x + f.startX,
            f.currentY = f.touchesCurrent.y - f.touchesStart.y + f.startY,
            f.currentX < f.minX && (f.currentX = f.minX + 1 - (f.minX - f.currentX + 1) ** .8),
            f.currentX > f.maxX && (f.currentX = f.maxX - 1 + (f.currentX - f.maxX + 1) ** .8),
            f.currentY < f.minY && (f.currentY = f.minY + 1 - (f.minY - f.currentY + 1) ** .8),
            f.currentY > f.maxY && (f.currentY = f.maxY - 1 + (f.currentY - f.maxY + 1) ** .8),
            d.prevPositionX || (d.prevPositionX = f.touchesCurrent.x),
            d.prevPositionY || (d.prevPositionY = f.touchesCurrent.y),
            d.prevTime || (d.prevTime = Date.now()),
            d.x = (f.touchesCurrent.x - d.prevPositionX) / (Date.now() - d.prevTime) / 2,
            d.y = (f.touchesCurrent.y - d.prevPositionY) / (Date.now() - d.prevTime) / 2,
            Math.abs(f.touchesCurrent.x - d.prevPositionX) < 2 && (d.x = 0),
            Math.abs(f.touchesCurrent.y - d.prevPositionY) < 2 && (d.y = 0),
            d.prevPositionX = f.touchesCurrent.x,
            d.prevPositionY = f.touchesCurrent.y,
            d.prevTime = Date.now(),
            u.$imageWrapEl.transform(`translate3d(${f.currentX}px, ${f.currentY}px,0)`)
        }
    }
    function w() {
        const H = e.zoom;
        if (!u.$imageEl || u.$imageEl.length === 0)
            return;
        if (!f.isTouched || !f.isMoved) {
            f.isTouched = !1,
            f.isMoved = !1;
            return
        }
        f.isTouched = !1,
        f.isMoved = !1;
        let W = 300
          , j = 300;
        const Q = d.x * W
          , ne = f.currentX + Q
          , re = d.y * j
          , ve = f.currentY + re;
        d.x !== 0 && (W = Math.abs((ne - f.currentX) / d.x)),
        d.y !== 0 && (j = Math.abs((ve - f.currentY) / d.y));
        const Ne = Math.max(W, j);
        f.currentX = ne,
        f.currentY = ve;
        const Ge = f.width * H.scale
          , Ye = f.height * H.scale;
        f.minX = Math.min(u.slideWidth / 2 - Ge / 2, 0),
        f.maxX = -f.minX,
        f.minY = Math.min(u.slideHeight / 2 - Ye / 2, 0),
        f.maxY = -f.minY,
        f.currentX = Math.max(Math.min(f.currentX, f.maxX), f.minX),
        f.currentY = Math.max(Math.min(f.currentY, f.maxY), f.minY),
        u.$imageWrapEl.transition(Ne).transform(`translate3d(${f.currentX}px, ${f.currentY}px,0)`)
    }
    function C() {
        const H = e.zoom;
        u.$slideEl && e.previousIndex !== e.activeIndex && (u.$imageEl && u.$imageEl.transform("translate3d(0,0,0) scale(1)"),
        u.$imageWrapEl && u.$imageWrapEl.transform("translate3d(0,0,0)"),
        H.scale = 1,
        o = 1,
        u.$slideEl = void 0,
        u.$imageEl = void 0,
        u.$imageWrapEl = void 0)
    }
    function _(H) {
        const W = e.zoom
          , j = e.params.zoom;
        if (u.$slideEl || (H && H.target && (u.$slideEl = _e(H.target).closest(`.${e.params.slideClass}`)),
        u.$slideEl || (e.params.virtual && e.params.virtual.enabled && e.virtual ? u.$slideEl = e.$wrapperEl.children(`.${e.params.slideActiveClass}`) : u.$slideEl = e.slides.eq(e.activeIndex)),
        u.$imageEl = u.$slideEl.find(`.${j.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0),
        u.$imageWrapEl = u.$imageEl.parent(`.${j.containerClass}`)),
        !u.$imageEl || u.$imageEl.length === 0 || !u.$imageWrapEl || u.$imageWrapEl.length === 0)
            return;
        e.params.cssMode && (e.wrapperEl.style.overflow = "hidden",
        e.wrapperEl.style.touchAction = "none"),
        u.$slideEl.addClass(`${j.zoomedSlideClass}`);
        let Q, ne, re, ve, Ne, Ge, Ye, tt, ee, ye, Le, Se, Re, Ve, Ze, q, Z, de;
        typeof f.touchesStart.x > "u" && H ? (Q = H.type === "touchend" ? H.changedTouches[0].pageX : H.pageX,
        ne = H.type === "touchend" ? H.changedTouches[0].pageY : H.pageY) : (Q = f.touchesStart.x,
        ne = f.touchesStart.y),
        W.scale = u.$imageWrapEl.attr("data-swiper-zoom") || j.maxRatio,
        o = u.$imageWrapEl.attr("data-swiper-zoom") || j.maxRatio,
        H ? (Z = u.$slideEl[0].offsetWidth,
        de = u.$slideEl[0].offsetHeight,
        re = u.$slideEl.offset().left + r.scrollX,
        ve = u.$slideEl.offset().top + r.scrollY,
        Ne = re + Z / 2 - Q,
        Ge = ve + de / 2 - ne,
        ee = u.$imageEl[0].offsetWidth,
        ye = u.$imageEl[0].offsetHeight,
        Le = ee * W.scale,
        Se = ye * W.scale,
        Re = Math.min(Z / 2 - Le / 2, 0),
        Ve = Math.min(de / 2 - Se / 2, 0),
        Ze = -Re,
        q = -Ve,
        Ye = Ne * W.scale,
        tt = Ge * W.scale,
        Ye < Re && (Ye = Re),
        Ye > Ze && (Ye = Ze),
        tt < Ve && (tt = Ve),
        tt > q && (tt = q)) : (Ye = 0,
        tt = 0),
        u.$imageWrapEl.transition(300).transform(`translate3d(${Ye}px, ${tt}px,0)`),
        u.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${W.scale})`)
    }
    function E() {
        const H = e.zoom
          , W = e.params.zoom;
        u.$slideEl || (e.params.virtual && e.params.virtual.enabled && e.virtual ? u.$slideEl = e.$wrapperEl.children(`.${e.params.slideActiveClass}`) : u.$slideEl = e.slides.eq(e.activeIndex),
        u.$imageEl = u.$slideEl.find(`.${W.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0),
        u.$imageWrapEl = u.$imageEl.parent(`.${W.containerClass}`)),
        !(!u.$imageEl || u.$imageEl.length === 0 || !u.$imageWrapEl || u.$imageWrapEl.length === 0) && (e.params.cssMode && (e.wrapperEl.style.overflow = "",
        e.wrapperEl.style.touchAction = ""),
        H.scale = 1,
        o = 1,
        u.$imageWrapEl.transition(300).transform("translate3d(0,0,0)"),
        u.$imageEl.transition(300).transform("translate3d(0,0,0) scale(1)"),
        u.$slideEl.removeClass(`${W.zoomedSlideClass}`),
        u.$slideEl = void 0)
    }
    function z(H) {
        const W = e.zoom;
        W.scale && W.scale !== 1 ? E() : _(H)
    }
    function T() {
        const H = e.support
          , W = e.touchEvents.start === "touchstart" && H.passiveListener && e.params.passiveListeners ? {
            passive: !0,
            capture: !1
        } : !1
          , j = H.passiveListener ? {
            passive: !1,
            capture: !0
        } : !0;
        return {
            passiveListener: W,
            activeListenerWithCapture: j
        }
    }
    function A() {
        return `.${e.params.slideClass}`
    }
    function x(H) {
        const {passiveListener: W} = T()
          , j = A();
        e.$wrapperEl[H]("gesturestart", j, m, W),
        e.$wrapperEl[H]("gesturechange", j, g, W),
        e.$wrapperEl[H]("gestureend", j, b, W)
    }
    function M() {
        s || (s = !0,
        x("on"))
    }
    function L() {
        s && (s = !1,
        x("off"))
    }
    function U() {
        const H = e.zoom;
        if (H.enabled)
            return;
        H.enabled = !0;
        const W = e.support
          , {passiveListener: j, activeListenerWithCapture: Q} = T()
          , ne = A();
        W.gestures ? (e.$wrapperEl.on(e.touchEvents.start, M, j),
        e.$wrapperEl.on(e.touchEvents.end, L, j)) : e.touchEvents.start === "touchstart" && (e.$wrapperEl.on(e.touchEvents.start, ne, m, j),
        e.$wrapperEl.on(e.touchEvents.move, ne, g, Q),
        e.$wrapperEl.on(e.touchEvents.end, ne, b, j),
        e.touchEvents.cancel && e.$wrapperEl.on(e.touchEvents.cancel, ne, b, j)),
        e.$wrapperEl.on(e.touchEvents.move, `.${e.params.zoom.containerClass}`, y, Q)
    }
    function Y() {
        const H = e.zoom;
        if (!H.enabled)
            return;
        const W = e.support;
        H.enabled = !1;
        const {passiveListener: j, activeListenerWithCapture: Q} = T()
          , ne = A();
        W.gestures ? (e.$wrapperEl.off(e.touchEvents.start, M, j),
        e.$wrapperEl.off(e.touchEvents.end, L, j)) : e.touchEvents.start === "touchstart" && (e.$wrapperEl.off(e.touchEvents.start, ne, m, j),
        e.$wrapperEl.off(e.touchEvents.move, ne, g, Q),
        e.$wrapperEl.off(e.touchEvents.end, ne, b, j),
        e.touchEvents.cancel && e.$wrapperEl.off(e.touchEvents.cancel, ne, b, j)),
        e.$wrapperEl.off(e.touchEvents.move, `.${e.params.zoom.containerClass}`, y, Q)
    }
    n("init", () => {
        e.params.zoom.enabled && U()
    }
    ),
    n("destroy", () => {
        Y()
    }
    ),
    n("touchStart", (H, W) => {
        e.zoom.enabled && v(W)
    }
    ),
    n("touchEnd", (H, W) => {
        e.zoom.enabled && w(W)
    }
    ),
    n("doubleTap", (H, W) => {
        !e.animating && e.params.zoom.enabled && e.zoom.enabled && e.params.zoom.toggle && z(W)
    }
    ),
    n("transitionEnd", () => {
        e.zoom.enabled && e.params.zoom.enabled && C()
    }
    ),
    n("slideChange", () => {
        e.zoom.enabled && e.params.zoom.enabled && e.params.cssMode && C()
    }
    ),
    Object.assign(e.zoom, {
        enable: U,
        disable: Y,
        in: _,
        out: E,
        toggle: z
    })
}
function tE({swiper: e, extendParams: t, on: n, emit: a}) {
    t({
        lazy: {
            checkInView: !1,
            enabled: !1,
            loadPrevNext: !1,
            loadPrevNextAmount: 1,
            loadOnTransitionStart: !1,
            scrollingElement: "",
            elementClass: "swiper-lazy",
            loadingClass: "swiper-lazy-loading",
            loadedClass: "swiper-lazy-loaded",
            preloaderClass: "swiper-lazy-preloader"
        }
    }),
    e.lazy = {};
    let r = !1
      , o = !1;
    function i(c, u=!0) {
        const f = e.params.lazy;
        if (typeof c > "u" || e.slides.length === 0)
            return;
        const p = e.virtual && e.params.virtual.enabled ? e.$wrapperEl.children(`.${e.params.slideClass}[data-swiper-slide-index="${c}"]`) : e.slides.eq(c)
          , h = p.find(`.${f.elementClass}:not(.${f.loadedClass}):not(.${f.loadingClass})`);
        p.hasClass(f.elementClass) && !p.hasClass(f.loadedClass) && !p.hasClass(f.loadingClass) && h.push(p[0]),
        h.length !== 0 && h.each(m => {
            const g = _e(m);
            g.addClass(f.loadingClass);
            const b = g.attr("data-background")
              , v = g.attr("data-src")
              , y = g.attr("data-srcset")
              , w = g.attr("data-sizes")
              , C = g.parent("picture");
            e.loadImage(g[0], v || b, y, w, !1, () => {
                if (!(typeof e > "u" || e === null || !e || e && !e.params || e.destroyed)) {
                    if (b ? (g.css("background-image", `url("${b}")`),
                    g.removeAttr("data-background")) : (y && (g.attr("srcset", y),
                    g.removeAttr("data-srcset")),
                    w && (g.attr("sizes", w),
                    g.removeAttr("data-sizes")),
                    C.length && C.children("source").each(_ => {
                        const E = _e(_);
                        E.attr("data-srcset") && (E.attr("srcset", E.attr("data-srcset")),
                        E.removeAttr("data-srcset"))
                    }
                    ),
                    v && (g.attr("src", v),
                    g.removeAttr("data-src"))),
                    g.addClass(f.loadedClass).removeClass(f.loadingClass),
                    p.find(`.${f.preloaderClass}`).remove(),
                    e.params.loop && u) {
                        const _ = p.attr("data-swiper-slide-index");
                        if (p.hasClass(e.params.slideDuplicateClass)) {
                            const E = e.$wrapperEl.children(`[data-swiper-slide-index="${_}"]:not(.${e.params.slideDuplicateClass})`);
                            i(E.index(), !1)
                        } else {
                            const E = e.$wrapperEl.children(`.${e.params.slideDuplicateClass}[data-swiper-slide-index="${_}"]`);
                            i(E.index(), !1)
                        }
                    }
                    a("lazyImageReady", p[0], g[0]),
                    e.params.autoHeight && e.updateAutoHeight()
                }
            }
            ),
            a("lazyImageLoad", p[0], g[0])
        }
        )
    }
    function s() {
        const {$wrapperEl: c, params: u, slides: f, activeIndex: d} = e
          , p = e.virtual && u.virtual.enabled
          , h = u.lazy;
        let m = u.slidesPerView;
        m === "auto" && (m = 0);
        function g(v) {
            if (p) {
                if (c.children(`.${u.slideClass}[data-swiper-slide-index="${v}"]`).length)
                    return !0
            } else if (f[v])
                return !0;
            return !1
        }
        function b(v) {
            return p ? _e(v).attr("data-swiper-slide-index") : _e(v).index()
        }
        if (o || (o = !0),
        e.params.watchSlidesProgress)
            c.children(`.${u.slideVisibleClass}`).each(v => {
                const y = p ? _e(v).attr("data-swiper-slide-index") : _e(v).index();
                i(y)
            }
            );
        else if (m > 1)
            for (let v = d; v < d + m; v += 1)
                g(v) && i(v);
        else
            i(d);
        if (h.loadPrevNext)
            if (m > 1 || h.loadPrevNextAmount && h.loadPrevNextAmount > 1) {
                const v = h.loadPrevNextAmount
                  , y = Math.ceil(m)
                  , w = Math.min(d + y + Math.max(v, y), f.length)
                  , C = Math.max(d - Math.max(y, v), 0);
                for (let _ = d + y; _ < w; _ += 1)
                    g(_) && i(_);
                for (let _ = C; _ < d; _ += 1)
                    g(_) && i(_)
            } else {
                const v = c.children(`.${u.slideNextClass}`);
                v.length > 0 && i(b(v));
                const y = c.children(`.${u.slidePrevClass}`);
                y.length > 0 && i(b(y))
            }
    }
    function l() {
        const c = He();
        if (!e || e.destroyed)
            return;
        const u = e.params.lazy.scrollingElement ? _e(e.params.lazy.scrollingElement) : _e(c)
          , f = u[0] === c
          , d = f ? c.innerWidth : u[0].offsetWidth
          , p = f ? c.innerHeight : u[0].offsetHeight
          , h = e.$el.offset()
          , {rtlTranslate: m} = e;
        let g = !1;
        m && (h.left -= e.$el[0].scrollLeft);
        const b = [[h.left, h.top], [h.left + e.width, h.top], [h.left, h.top + e.height], [h.left + e.width, h.top + e.height]];
        for (let y = 0; y < b.length; y += 1) {
            const w = b[y];
            if (w[0] >= 0 && w[0] <= d && w[1] >= 0 && w[1] <= p) {
                if (w[0] === 0 && w[1] === 0)
                    continue;
                g = !0
            }
        }
        const v = e.touchEvents.start === "touchstart" && e.support.passiveListener && e.params.passiveListeners ? {
            passive: !0,
            capture: !1
        } : !1;
        g ? (s(),
        u.off("scroll", l, v)) : r || (r = !0,
        u.on("scroll", l, v))
    }
    n("beforeInit", () => {
        e.params.lazy.enabled && e.params.preloadImages && (e.params.preloadImages = !1)
    }
    ),
    n("init", () => {
        e.params.lazy.enabled && (e.params.lazy.checkInView ? l() : s())
    }
    ),
    n("scroll", () => {
        e.params.freeMode && e.params.freeMode.enabled && !e.params.freeMode.sticky && s()
    }
    ),
    n("scrollbarDragMove resize _freeModeNoMomentumRelease", () => {
        e.params.lazy.enabled && (e.params.lazy.checkInView ? l() : s())
    }
    ),
    n("transitionStart", () => {
        e.params.lazy.enabled && (e.params.lazy.loadOnTransitionStart || !e.params.lazy.loadOnTransitionStart && !o) && (e.params.lazy.checkInView ? l() : s())
    }
    ),
    n("transitionEnd", () => {
        e.params.lazy.enabled && !e.params.lazy.loadOnTransitionStart && (e.params.lazy.checkInView ? l() : s())
    }
    ),
    n("slideChange", () => {
        const {lazy: c, cssMode: u, watchSlidesProgress: f, touchReleaseOnEdges: d, resistanceRatio: p} = e.params;
        c.enabled && (u || f && (d || p === 0)) && s()
    }
    ),
    n("destroy", () => {
        e.$el && e.$el.find(`.${e.params.lazy.loadingClass}`).removeClass(e.params.lazy.loadingClass)
    }
    ),
    Object.assign(e.lazy, {
        load: s,
        loadInSlide: i
    })
}
function nE({swiper: e, extendParams: t, on: n}) {
    t({
        controller: {
            control: void 0,
            inverse: !1,
            by: "slide"
        }
    }),
    e.controller = {
        control: void 0
    };
    function a(l, c) {
        const u = function() {
            let h, m, g;
            return (b, v) => {
                for (m = -1,
                h = b.length; h - m > 1; )
                    g = h + m >> 1,
                    b[g] <= v ? m = g : h = g;
                return h
            }
        }();
        this.x = l,
        this.y = c,
        this.lastIndex = l.length - 1;
        let f, d;
        return this.interpolate = function(h) {
            return h ? (d = u(this.x, h),
            f = d - 1,
            (h - this.x[f]) * (this.y[d] - this.y[f]) / (this.x[d] - this.x[f]) + this.y[f]) : 0
        }
        ,
        this
    }
    function r(l) {
        e.controller.spline || (e.controller.spline = e.params.loop ? new a(e.slidesGrid,l.slidesGrid) : new a(e.snapGrid,l.snapGrid))
    }
    function o(l, c) {
        const u = e.controller.control;
        let f, d;
        const p = e.constructor;
        function h(m) {
            const g = e.rtlTranslate ? -e.translate : e.translate;
            e.params.controller.by === "slide" && (r(m),
            d = -e.controller.spline.interpolate(-g)),
            (!d || e.params.controller.by === "container") && (f = (m.maxTranslate() - m.minTranslate()) / (e.maxTranslate() - e.minTranslate()),
            d = (g - e.minTranslate()) * f + m.minTranslate()),
            e.params.controller.inverse && (d = m.maxTranslate() - d),
            m.updateProgress(d),
            m.setTranslate(d, e),
            m.updateActiveIndex(),
            m.updateSlidesClasses()
        }
        if (Array.isArray(u))
            for (let m = 0; m < u.length; m += 1)
                u[m] !== c && u[m]instanceof p && h(u[m]);
        else
            u instanceof p && c !== u && h(u)
    }
    function i(l, c) {
        const u = e.constructor
          , f = e.controller.control;
        let d;
        function p(h) {
            h.setTransition(l, e),
            l !== 0 && (h.transitionStart(),
            h.params.autoHeight && Lr( () => {
                h.updateAutoHeight()
            }
            ),
            h.$wrapperEl.transitionEnd( () => {
                f && (h.params.loop && e.params.controller.by === "slide" && h.loopFix(),
                h.transitionEnd())
            }
            ))
        }
        if (Array.isArray(f))
            for (d = 0; d < f.length; d += 1)
                f[d] !== c && f[d]instanceof u && p(f[d]);
        else
            f instanceof u && c !== f && p(f)
    }
    function s() {
        e.controller.control && e.controller.spline && (e.controller.spline = void 0,
        delete e.controller.spline)
    }
    n("beforeInit", () => {
        e.controller.control = e.params.controller.control
    }
    ),
    n("update", () => {
        s()
    }
    ),
    n("resize", () => {
        s()
    }
    ),
    n("observerUpdate", () => {
        s()
    }
    ),
    n("setTranslate", (l, c, u) => {
        e.controller.control && e.controller.setTranslate(c, u)
    }
    ),
    n("setTransition", (l, c, u) => {
        e.controller.control && e.controller.setTransition(c, u)
    }
    ),
    Object.assign(e.controller, {
        setTranslate: o,
        setTransition: i
    })
}
function aE({swiper: e, extendParams: t, on: n}) {
    t({
        a11y: {
            enabled: !0,
            notificationClass: "swiper-notification",
            prevSlideMessage: "Previous slide",
            nextSlideMessage: "Next slide",
            firstSlideMessage: "This is the first slide",
            lastSlideMessage: "This is the last slide",
            paginationBulletMessage: "Go to slide {{index}}",
            slideLabelMessage: "{{index}} / {{slidesLength}}",
            containerMessage: null,
            containerRoleDescriptionMessage: null,
            itemRoleDescriptionMessage: null,
            slideRole: "group",
            id: null
        }
    }),
    e.a11y = {
        clicked: !1
    };
    let a = null;
    function r(M) {
        const L = a;
        L.length !== 0 && (L.html(""),
        L.html(M))
    }
    function o(M=16) {
        const L = () => Math.round(16 * Math.random()).toString(16);
        return "x".repeat(M).replace(/x/g, L)
    }
    function i(M) {
        M.attr("tabIndex", "0")
    }
    function s(M) {
        M.attr("tabIndex", "-1")
    }
    function l(M, L) {
        M.attr("role", L)
    }
    function c(M, L) {
        M.attr("aria-roledescription", L)
    }
    function u(M, L) {
        M.attr("aria-controls", L)
    }
    function f(M, L) {
        M.attr("aria-label", L)
    }
    function d(M, L) {
        M.attr("id", L)
    }
    function p(M, L) {
        M.attr("aria-live", L)
    }
    function h(M) {
        M.attr("aria-disabled", !0)
    }
    function m(M) {
        M.attr("aria-disabled", !1)
    }
    function g(M) {
        if (M.keyCode !== 13 && M.keyCode !== 32)
            return;
        const L = e.params.a11y
          , U = _e(M.target);
        e.navigation && e.navigation.$nextEl && U.is(e.navigation.$nextEl) && (e.isEnd && !e.params.loop || e.slideNext(),
        e.isEnd ? r(L.lastSlideMessage) : r(L.nextSlideMessage)),
        e.navigation && e.navigation.$prevEl && U.is(e.navigation.$prevEl) && (e.isBeginning && !e.params.loop || e.slidePrev(),
        e.isBeginning ? r(L.firstSlideMessage) : r(L.prevSlideMessage)),
        e.pagination && U.is(Xa(e.params.pagination.bulletClass)) && U[0].click()
    }
    function b() {
        if (e.params.loop || e.params.rewind || !e.navigation)
            return;
        const {$nextEl: M, $prevEl: L} = e.navigation;
        L && L.length > 0 && (e.isBeginning ? (h(L),
        s(L)) : (m(L),
        i(L))),
        M && M.length > 0 && (e.isEnd ? (h(M),
        s(M)) : (m(M),
        i(M)))
    }
    function v() {
        return e.pagination && e.pagination.bullets && e.pagination.bullets.length
    }
    function y() {
        return v() && e.params.pagination.clickable
    }
    function w() {
        const M = e.params.a11y;
        v() && e.pagination.bullets.each(L => {
            const U = _e(L);
            e.params.pagination.clickable && (i(U),
            e.params.pagination.renderBullet || (l(U, "button"),
            f(U, M.paginationBulletMessage.replace(/\{\{index\}\}/, U.index() + 1)))),
            U.is(`.${e.params.pagination.bulletActiveClass}`) ? U.attr("aria-current", "true") : U.removeAttr("aria-current")
        }
        )
    }
    const C = (M, L, U) => {
        i(M),
        M[0].tagName !== "BUTTON" && (l(M, "button"),
        M.on("keydown", g)),
        f(M, U),
        u(M, L)
    }
      , _ = () => {
        e.a11y.clicked = !0
    }
      , E = () => {
        requestAnimationFrame( () => {
            requestAnimationFrame( () => {
                e.destroyed || (e.a11y.clicked = !1)
            }
            )
        }
        )
    }
      , z = M => {
        if (e.a11y.clicked)
            return;
        const L = M.target.closest(`.${e.params.slideClass}`);
        if (!L || !e.slides.includes(L))
            return;
        const U = e.slides.indexOf(L) === e.activeIndex
          , Y = e.params.watchSlidesProgress && e.visibleSlides && e.visibleSlides.includes(L);
        U || Y || M.sourceCapabilities && M.sourceCapabilities.firesTouchEvents || (e.isHorizontal() ? e.el.scrollLeft = 0 : e.el.scrollTop = 0,
        e.slideTo(e.slides.indexOf(L), 0))
    }
      , T = () => {
        const M = e.params.a11y;
        M.itemRoleDescriptionMessage && c(_e(e.slides), M.itemRoleDescriptionMessage),
        M.slideRole && l(_e(e.slides), M.slideRole);
        const L = e.params.loop ? e.slides.filter(U => !U.classList.contains(e.params.slideDuplicateClass)).length : e.slides.length;
        M.slideLabelMessage && e.slides.each( (U, Y) => {
            const H = _e(U)
              , W = e.params.loop ? parseInt(H.attr("data-swiper-slide-index"), 10) : Y
              , j = M.slideLabelMessage.replace(/\{\{index\}\}/, W + 1).replace(/\{\{slidesLength\}\}/, L);
            f(H, j)
        }
        )
    }
      , A = () => {
        const M = e.params.a11y;
        e.$el.append(a);
        const L = e.$el;
        M.containerRoleDescriptionMessage && c(L, M.containerRoleDescriptionMessage),
        M.containerMessage && f(L, M.containerMessage);
        const U = e.$wrapperEl
          , Y = M.id || U.attr("id") || `swiper-wrapper-${o(16)}`
          , H = e.params.autoplay && e.params.autoplay.enabled ? "off" : "polite";
        d(U, Y),
        p(U, H),
        T();
        let W, j;
        e.navigation && e.navigation.$nextEl && (W = e.navigation.$nextEl),
        e.navigation && e.navigation.$prevEl && (j = e.navigation.$prevEl),
        W && W.length && C(W, Y, M.nextSlideMessage),
        j && j.length && C(j, Y, M.prevSlideMessage),
        y() && e.pagination.$el.on("keydown", Xa(e.params.pagination.bulletClass), g),
        e.$el.on("focus", z, !0),
        e.$el.on("pointerdown", _, !0),
        e.$el.on("pointerup", E, !0)
    }
    ;
    function x() {
        a && a.length > 0 && a.remove();
        let M, L;
        e.navigation && e.navigation.$nextEl && (M = e.navigation.$nextEl),
        e.navigation && e.navigation.$prevEl && (L = e.navigation.$prevEl),
        M && M.off("keydown", g),
        L && L.off("keydown", g),
        y() && e.pagination.$el.off("keydown", Xa(e.params.pagination.bulletClass), g),
        e.$el.off("focus", z, !0),
        e.$el.off("pointerdown", _, !0),
        e.$el.off("pointerup", E, !0)
    }
    n("beforeInit", () => {
        a = _e(`<span class="${e.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`)
    }
    ),
    n("afterInit", () => {
        e.params.a11y.enabled && A()
    }
    ),
    n("slidesLengthChange snapGridLengthChange slidesGridLengthChange", () => {
        e.params.a11y.enabled && T()
    }
    ),
    n("fromEdge toEdge afterInit lock unlock", () => {
        e.params.a11y.enabled && b()
    }
    ),
    n("paginationUpdate", () => {
        e.params.a11y.enabled && w()
    }
    ),
    n("destroy", () => {
        e.params.a11y.enabled && x()
    }
    )
}
function rE({swiper: e, extendParams: t, on: n}) {
    t({
        history: {
            enabled: !1,
            root: "",
            replaceState: !1,
            key: "slides",
            keepQuery: !1
        }
    });
    let a = !1
      , r = {};
    const o = d => d.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, "")
      , i = d => {
        const p = He();
        let h;
        d ? h = new URL(d) : h = p.location;
        const m = h.pathname.slice(1).split("/").filter(y => y !== "")
          , g = m.length
          , b = m[g - 2]
          , v = m[g - 1];
        return {
            key: b,
            value: v
        }
    }
      , s = (d, p) => {
        const h = He();
        if (!a || !e.params.history.enabled)
            return;
        let m;
        e.params.url ? m = new URL(e.params.url) : m = h.location;
        const g = e.slides.eq(p);
        let b = o(g.attr("data-history"));
        if (e.params.history.root.length > 0) {
            let y = e.params.history.root;
            y[y.length - 1] === "/" && (y = y.slice(0, y.length - 1)),
            b = `${y}/${d}/${b}`
        } else
            m.pathname.includes(d) || (b = `${d}/${b}`);
        e.params.history.keepQuery && (b += m.search);
        const v = h.history.state;
        v && v.value === b || (e.params.history.replaceState ? h.history.replaceState({
            value: b
        }, null, b) : h.history.pushState({
            value: b
        }, null, b))
    }
      , l = (d, p, h) => {
        if (p)
            for (let m = 0, g = e.slides.length; m < g; m += 1) {
                const b = e.slides.eq(m);
                if (o(b.attr("data-history")) === p && !b.hasClass(e.params.slideDuplicateClass)) {
                    const y = b.index();
                    e.slideTo(y, d, h)
                }
            }
        else
            e.slideTo(0, d, h)
    }
      , c = () => {
        r = i(e.params.url),
        l(e.params.speed, r.value, !1)
    }
      , u = () => {
        const d = He();
        if (e.params.history) {
            if (!d.history || !d.history.pushState) {
                e.params.history.enabled = !1,
                e.params.hashNavigation.enabled = !0;
                return
            }
            a = !0,
            r = i(e.params.url),
            !(!r.key && !r.value) && (l(0, r.value, e.params.runCallbacksOnInit),
            e.params.history.replaceState || d.addEventListener("popstate", c))
        }
    }
      , f = () => {
        const d = He();
        e.params.history.replaceState || d.removeEventListener("popstate", c)
    }
    ;
    n("init", () => {
        e.params.history.enabled && u()
    }
    ),
    n("destroy", () => {
        e.params.history.enabled && f()
    }
    ),
    n("transitionEnd _freeModeNoMomentumRelease", () => {
        a && s(e.params.history.key, e.activeIndex)
    }
    ),
    n("slideChange", () => {
        a && e.params.cssMode && s(e.params.history.key, e.activeIndex)
    }
    )
}
function oE({swiper: e, extendParams: t, emit: n, on: a}) {
    let r = !1;
    const o = Qe()
      , i = He();
    t({
        hashNavigation: {
            enabled: !1,
            replaceState: !1,
            watchState: !1
        }
    });
    const s = () => {
        n("hashChange");
        const f = o.location.hash.replace("#", "")
          , d = e.slides.eq(e.activeIndex).attr("data-hash");
        if (f !== d) {
            const p = e.$wrapperEl.children(`.${e.params.slideClass}[data-hash="${f}"]`).index();
            if (typeof p > "u")
                return;
            e.slideTo(p)
        }
    }
      , l = () => {
        if (!(!r || !e.params.hashNavigation.enabled))
            if (e.params.hashNavigation.replaceState && i.history && i.history.replaceState)
                i.history.replaceState(null, null, `#${e.slides.eq(e.activeIndex).attr("data-hash")}` || ""),
                n("hashSet");
            else {
                const f = e.slides.eq(e.activeIndex)
                  , d = f.attr("data-hash") || f.attr("data-history");
                o.location.hash = d || "",
                n("hashSet")
            }
    }
      , c = () => {
        if (!e.params.hashNavigation.enabled || e.params.history && e.params.history.enabled)
            return;
        r = !0;
        const f = o.location.hash.replace("#", "");
        if (f)
            for (let p = 0, h = e.slides.length; p < h; p += 1) {
                const m = e.slides.eq(p);
                if ((m.attr("data-hash") || m.attr("data-history")) === f && !m.hasClass(e.params.slideDuplicateClass)) {
                    const b = m.index();
                    e.slideTo(b, 0, e.params.runCallbacksOnInit, !0)
                }
            }
        e.params.hashNavigation.watchState && _e(i).on("hashchange", s)
    }
      , u = () => {
        e.params.hashNavigation.watchState && _e(i).off("hashchange", s)
    }
    ;
    a("init", () => {
        e.params.hashNavigation.enabled && c()
    }
    ),
    a("destroy", () => {
        e.params.hashNavigation.enabled && u()
    }
    ),
    a("transitionEnd _freeModeNoMomentumRelease", () => {
        r && l()
    }
    ),
    a("slideChange", () => {
        r && e.params.cssMode && l()
    }
    )
}
function iE({swiper: e, extendParams: t, on: n, emit: a}) {
    let r;
    e.autoplay = {
        running: !1,
        paused: !1
    },
    t({
        autoplay: {
            enabled: !1,
            delay: 3e3,
            waitForTransition: !0,
            disableOnInteraction: !0,
            stopOnLastSlide: !1,
            reverseDirection: !1,
            pauseOnMouseEnter: !1
        }
    });
    function o() {
        if (!e.size) {
            e.autoplay.running = !1,
            e.autoplay.paused = !1;
            return
        }
        const m = e.slides.eq(e.activeIndex);
        let g = e.params.autoplay.delay;
        m.attr("data-swiper-autoplay") && (g = m.attr("data-swiper-autoplay") || e.params.autoplay.delay),
        clearTimeout(r),
        r = Lr( () => {
            let b;
            e.params.autoplay.reverseDirection ? e.params.loop ? (e.loopFix(),
            b = e.slidePrev(e.params.speed, !0, !0),
            a("autoplay")) : e.isBeginning ? e.params.autoplay.stopOnLastSlide ? s() : (b = e.slideTo(e.slides.length - 1, e.params.speed, !0, !0),
            a("autoplay")) : (b = e.slidePrev(e.params.speed, !0, !0),
            a("autoplay")) : e.params.loop ? (e.loopFix(),
            b = e.slideNext(e.params.speed, !0, !0),
            a("autoplay")) : e.isEnd ? e.params.autoplay.stopOnLastSlide ? s() : (b = e.slideTo(0, e.params.speed, !0, !0),
            a("autoplay")) : (b = e.slideNext(e.params.speed, !0, !0),
            a("autoplay")),
            (e.params.cssMode && e.autoplay.running || b === !1) && o()
        }
        , g)
    }
    function i() {
        return typeof r < "u" || e.autoplay.running ? !1 : (e.autoplay.running = !0,
        a("autoplayStart"),
        o(),
        !0)
    }
    function s() {
        return !e.autoplay.running || typeof r > "u" ? !1 : (r && (clearTimeout(r),
        r = void 0),
        e.autoplay.running = !1,
        a("autoplayStop"),
        !0)
    }
    function l(m) {
        e.autoplay.running && (e.autoplay.paused || (r && clearTimeout(r),
        e.autoplay.paused = !0,
        m === 0 || !e.params.autoplay.waitForTransition ? (e.autoplay.paused = !1,
        o()) : ["transitionend", "webkitTransitionEnd"].forEach(g => {
            e.$wrapperEl[0].addEventListener(g, u)
        }
        )))
    }
    function c() {
        const m = Qe();
        m.visibilityState === "hidden" && e.autoplay.running && l(),
        m.visibilityState === "visible" && e.autoplay.paused && (o(),
        e.autoplay.paused = !1)
    }
    function u(m) {
        !e || e.destroyed || !e.$wrapperEl || m.target === e.$wrapperEl[0] && (["transitionend", "webkitTransitionEnd"].forEach(g => {
            e.$wrapperEl[0].removeEventListener(g, u)
        }
        ),
        e.autoplay.paused = !1,
        e.autoplay.running ? o() : s())
    }
    function f() {
        e.params.autoplay.disableOnInteraction ? s() : (a("autoplayPause"),
        l()),
        ["transitionend", "webkitTransitionEnd"].forEach(m => {
            e.$wrapperEl[0].removeEventListener(m, u)
        }
        )
    }
    function d() {
        e.params.autoplay.disableOnInteraction || (e.autoplay.paused = !1,
        a("autoplayResume"),
        o())
    }
    function p() {
        e.params.autoplay.pauseOnMouseEnter && (e.$el.on("mouseenter", f),
        e.$el.on("mouseleave", d))
    }
    function h() {
        e.$el.off("mouseenter", f),
        e.$el.off("mouseleave", d)
    }
    n("init", () => {
        e.params.autoplay.enabled && (i(),
        Qe().addEventListener("visibilitychange", c),
        p())
    }
    ),
    n("beforeTransitionStart", (m, g, b) => {
        e.autoplay.running && (b || !e.params.autoplay.disableOnInteraction ? e.autoplay.pause(g) : s())
    }
    ),
    n("sliderFirstMove", () => {
        e.autoplay.running && (e.params.autoplay.disableOnInteraction ? s() : l())
    }
    ),
    n("touchEnd", () => {
        e.params.cssMode && e.autoplay.paused && !e.params.autoplay.disableOnInteraction && o()
    }
    ),
    n("destroy", () => {
        h(),
        e.autoplay.running && s(),
        Qe().removeEventListener("visibilitychange", c)
    }
    ),
    Object.assign(e.autoplay, {
        pause: l,
        run: o,
        start: i,
        stop: s
    })
}
function sE({swiper: e, extendParams: t, on: n}) {
    t({
        thumbs: {
            swiper: null,
            multipleActiveThumbs: !0,
            autoScrollOffset: 0,
            slideThumbActiveClass: "swiper-slide-thumb-active",
            thumbsContainerClass: "swiper-thumbs"
        }
    });
    let a = !1
      , r = !1;
    e.thumbs = {
        swiper: null
    };
    function o() {
        const l = e.thumbs.swiper;
        if (!l || l.destroyed)
            return;
        const c = l.clickedIndex
          , u = l.clickedSlide;
        if (u && _e(u).hasClass(e.params.thumbs.slideThumbActiveClass) || typeof c > "u" || c === null)
            return;
        let f;
        if (l.params.loop ? f = parseInt(_e(l.clickedSlide).attr("data-swiper-slide-index"), 10) : f = c,
        e.params.loop) {
            let d = e.activeIndex;
            e.slides.eq(d).hasClass(e.params.slideDuplicateClass) && (e.loopFix(),
            e._clientLeft = e.$wrapperEl[0].clientLeft,
            d = e.activeIndex);
            const p = e.slides.eq(d).prevAll(`[data-swiper-slide-index="${f}"]`).eq(0).index()
              , h = e.slides.eq(d).nextAll(`[data-swiper-slide-index="${f}"]`).eq(0).index();
            typeof p > "u" ? f = h : typeof h > "u" ? f = p : h - d < d - p ? f = h : f = p
        }
        e.slideTo(f)
    }
    function i() {
        const {thumbs: l} = e.params;
        if (a)
            return !1;
        a = !0;
        const c = e.constructor;
        if (l.swiper instanceof c)
            e.thumbs.swiper = l.swiper,
            Object.assign(e.thumbs.swiper.originalParams, {
                watchSlidesProgress: !0,
                slideToClickedSlide: !1
            }),
            Object.assign(e.thumbs.swiper.params, {
                watchSlidesProgress: !0,
                slideToClickedSlide: !1
            });
        else if (Zi(l.swiper)) {
            const u = Object.assign({}, l.swiper);
            Object.assign(u, {
                watchSlidesProgress: !0,
                slideToClickedSlide: !1
            }),
            e.thumbs.swiper = new c(u),
            r = !0
        }
        return e.thumbs.swiper.$el.addClass(e.params.thumbs.thumbsContainerClass),
        e.thumbs.swiper.on("tap", o),
        !0
    }
    function s(l) {
        const c = e.thumbs.swiper;
        if (!c || c.destroyed)
            return;
        const u = c.params.slidesPerView === "auto" ? c.slidesPerViewDynamic() : c.params.slidesPerView;
        let f = 1;
        const d = e.params.thumbs.slideThumbActiveClass;
        if (e.params.slidesPerView > 1 && !e.params.centeredSlides && (f = e.params.slidesPerView),
        e.params.thumbs.multipleActiveThumbs || (f = 1),
        f = Math.floor(f),
        c.slides.removeClass(d),
        c.params.loop || c.params.virtual && c.params.virtual.enabled)
            for (let m = 0; m < f; m += 1)
                c.$wrapperEl.children(`[data-swiper-slide-index="${e.realIndex + m}"]`).addClass(d);
        else
            for (let m = 0; m < f; m += 1)
                c.slides.eq(e.realIndex + m).addClass(d);
        const p = e.params.thumbs.autoScrollOffset
          , h = p && !c.params.loop;
        if (e.realIndex !== c.realIndex || h) {
            let m = c.activeIndex, g, b;
            if (c.params.loop) {
                c.slides.eq(m).hasClass(c.params.slideDuplicateClass) && (c.loopFix(),
                c._clientLeft = c.$wrapperEl[0].clientLeft,
                m = c.activeIndex);
                const v = c.slides.eq(m).prevAll(`[data-swiper-slide-index="${e.realIndex}"]`).eq(0).index()
                  , y = c.slides.eq(m).nextAll(`[data-swiper-slide-index="${e.realIndex}"]`).eq(0).index();
                typeof v > "u" ? g = y : typeof y > "u" ? g = v : y - m === m - v ? g = c.params.slidesPerGroup > 1 ? y : m : y - m < m - v ? g = y : g = v,
                b = e.activeIndex > e.previousIndex ? "next" : "prev"
            } else
                g = e.realIndex,
                b = g > e.previousIndex ? "next" : "prev";
            h && (g += b === "next" ? p : -1 * p),
            c.visibleSlidesIndexes && c.visibleSlidesIndexes.indexOf(g) < 0 && (c.params.centeredSlides ? g > m ? g = g - Math.floor(u / 2) + 1 : g = g + Math.floor(u / 2) - 1 : g > m && c.params.slidesPerGroup,
            c.slideTo(g, l ? 0 : void 0))
        }
    }
    n("beforeInit", () => {
        const {thumbs: l} = e.params;
        !l || !l.swiper || (i(),
        s(!0))
    }
    ),
    n("slideChange update resize observerUpdate", () => {
        s()
    }
    ),
    n("setTransition", (l, c) => {
        const u = e.thumbs.swiper;
        !u || u.destroyed || u.setTransition(c)
    }
    ),
    n("beforeDestroy", () => {
        const l = e.thumbs.swiper;
        !l || l.destroyed || r && l.destroy()
    }
    ),
    Object.assign(e.thumbs, {
        init: i,
        update: s
    })
}
function lE({swiper: e, extendParams: t, emit: n, once: a}) {
    t({
        freeMode: {
            enabled: !1,
            momentum: !0,
            momentumRatio: 1,
            momentumBounce: !0,
            momentumBounceRatio: 1,
            momentumVelocityRatio: 1,
            sticky: !1,
            minimumVelocity: .02
        }
    });
    function r() {
        const s = e.getTranslate();
        e.setTranslate(s),
        e.setTransition(0),
        e.touchEventsData.velocities.length = 0,
        e.freeMode.onTouchEnd({
            currentPos: e.rtl ? e.translate : -e.translate
        })
    }
    function o() {
        const {touchEventsData: s, touches: l} = e;
        s.velocities.length === 0 && s.velocities.push({
            position: l[e.isHorizontal() ? "startX" : "startY"],
            time: s.touchStartTime
        }),
        s.velocities.push({
            position: l[e.isHorizontal() ? "currentX" : "currentY"],
            time: Vn()
        })
    }
    function i({currentPos: s}) {
        const {params: l, $wrapperEl: c, rtlTranslate: u, snapGrid: f, touchEventsData: d} = e
          , h = Vn() - d.touchStartTime;
        if (s < -e.minTranslate()) {
            e.slideTo(e.activeIndex);
            return
        }
        if (s > -e.maxTranslate()) {
            e.slides.length < f.length ? e.slideTo(f.length - 1) : e.slideTo(e.slides.length - 1);
            return
        }
        if (l.freeMode.momentum) {
            if (d.velocities.length > 1) {
                const _ = d.velocities.pop()
                  , E = d.velocities.pop()
                  , z = _.position - E.position
                  , T = _.time - E.time;
                e.velocity = z / T,
                e.velocity /= 2,
                Math.abs(e.velocity) < l.freeMode.minimumVelocity && (e.velocity = 0),
                (T > 150 || Vn() - _.time > 300) && (e.velocity = 0)
            } else
                e.velocity = 0;
            e.velocity *= l.freeMode.momentumVelocityRatio,
            d.velocities.length = 0;
            let m = 1e3 * l.freeMode.momentumRatio;
            const g = e.velocity * m;
            let b = e.translate + g;
            u && (b = -b);
            let v = !1, y;
            const w = Math.abs(e.velocity) * 20 * l.freeMode.momentumBounceRatio;
            let C;
            if (b < e.maxTranslate())
                l.freeMode.momentumBounce ? (b + e.maxTranslate() < -w && (b = e.maxTranslate() - w),
                y = e.maxTranslate(),
                v = !0,
                d.allowMomentumBounce = !0) : b = e.maxTranslate(),
                l.loop && l.centeredSlides && (C = !0);
            else if (b > e.minTranslate())
                l.freeMode.momentumBounce ? (b - e.minTranslate() > w && (b = e.minTranslate() + w),
                y = e.minTranslate(),
                v = !0,
                d.allowMomentumBounce = !0) : b = e.minTranslate(),
                l.loop && l.centeredSlides && (C = !0);
            else if (l.freeMode.sticky) {
                let _;
                for (let E = 0; E < f.length; E += 1)
                    if (f[E] > -b) {
                        _ = E;
                        break
                    }
                Math.abs(f[_] - b) < Math.abs(f[_ - 1] - b) || e.swipeDirection === "next" ? b = f[_] : b = f[_ - 1],
                b = -b
            }
            if (C && a("transitionEnd", () => {
                e.loopFix()
            }
            ),
            e.velocity !== 0) {
                if (u ? m = Math.abs((-b - e.translate) / e.velocity) : m = Math.abs((b - e.translate) / e.velocity),
                l.freeMode.sticky) {
                    const _ = Math.abs((u ? -b : b) - e.translate)
                      , E = e.slidesSizesGrid[e.activeIndex];
                    _ < E ? m = l.speed : _ < 2 * E ? m = l.speed * 1.5 : m = l.speed * 2.5
                }
            } else if (l.freeMode.sticky) {
                e.slideToClosest();
                return
            }
            l.freeMode.momentumBounce && v ? (e.updateProgress(y),
            e.setTransition(m),
            e.setTranslate(b),
            e.transitionStart(!0, e.swipeDirection),
            e.animating = !0,
            c.transitionEnd( () => {
                !e || e.destroyed || !d.allowMomentumBounce || (n("momentumBounce"),
                e.setTransition(l.speed),
                setTimeout( () => {
                    e.setTranslate(y),
                    c.transitionEnd( () => {
                        !e || e.destroyed || e.transitionEnd()
                    }
                    )
                }
                , 0))
            }
            )) : e.velocity ? (n("_freeModeNoMomentumRelease"),
            e.updateProgress(b),
            e.setTransition(m),
            e.setTranslate(b),
            e.transitionStart(!0, e.swipeDirection),
            e.animating || (e.animating = !0,
            c.transitionEnd( () => {
                !e || e.destroyed || e.transitionEnd()
            }
            ))) : e.updateProgress(b),
            e.updateActiveIndex(),
            e.updateSlidesClasses()
        } else if (l.freeMode.sticky) {
            e.slideToClosest();
            return
        } else
            l.freeMode && n("_freeModeNoMomentumRelease");
        (!l.freeMode.momentum || h >= l.longSwipesMs) && (e.updateProgress(),
        e.updateActiveIndex(),
        e.updateSlidesClasses())
    }
    Object.assign(e, {
        freeMode: {
            onTouchStart: r,
            onTouchMove: o,
            onTouchEnd: i
        }
    })
}
function cE({swiper: e, extendParams: t}) {
    t({
        grid: {
            rows: 1,
            fill: "column"
        }
    });
    let n, a, r;
    const o = l => {
        const {slidesPerView: c} = e.params
          , {rows: u, fill: f} = e.params.grid;
        a = n / u,
        r = Math.floor(l / u),
        Math.floor(l / u) === l / u ? n = l : n = Math.ceil(l / u) * u,
        c !== "auto" && f === "row" && (n = Math.max(n, c * u))
    }
      , i = (l, c, u, f) => {
        const {slidesPerGroup: d, spaceBetween: p} = e.params
          , {rows: h, fill: m} = e.params.grid;
        let g, b, v;
        if (m === "row" && d > 1) {
            const y = Math.floor(l / (d * h))
              , w = l - h * d * y
              , C = y === 0 ? d : Math.min(Math.ceil((u - y * h * d) / h), d);
            v = Math.floor(w / C),
            b = w - v * C + y * d,
            g = b + v * n / h,
            c.css({
                "-webkit-order": g,
                order: g
            })
        } else
            m === "column" ? (b = Math.floor(l / h),
            v = l - b * h,
            (b > r || b === r && v === h - 1) && (v += 1,
            v >= h && (v = 0,
            b += 1))) : (v = Math.floor(l / a),
            b = l - v * a);
        c.css(f("margin-top"), v !== 0 ? p && `${p}px` : "")
    }
      , s = (l, c, u) => {
        const {spaceBetween: f, centeredSlides: d, roundLengths: p} = e.params
          , {rows: h} = e.params.grid;
        if (e.virtualSize = (l + f) * n,
        e.virtualSize = Math.ceil(e.virtualSize / h) - f,
        e.$wrapperEl.css({
            [u("width")]: `${e.virtualSize + f}px`
        }),
        d) {
            c.splice(0, c.length);
            const m = [];
            for (let g = 0; g < c.length; g += 1) {
                let b = c[g];
                p && (b = Math.floor(b)),
                c[g] < e.virtualSize + c[0] && m.push(b)
            }
            c.push(...m)
        }
    }
    ;
    e.grid = {
        initSlides: o,
        updateSlide: i,
        updateWrapperSize: s
    }
}
function uE(e) {
    const t = this
      , {$wrapperEl: n, params: a} = t;
    if (a.loop && t.loopDestroy(),
    typeof e == "object" && "length"in e)
        for (let r = 0; r < e.length; r += 1)
            e[r] && n.append(e[r]);
    else
        n.append(e);
    a.loop && t.loopCreate(),
    a.observer || t.update()
}
function fE(e) {
    const t = this
      , {params: n, $wrapperEl: a, activeIndex: r} = t;
    n.loop && t.loopDestroy();
    let o = r + 1;
    if (typeof e == "object" && "length"in e) {
        for (let i = 0; i < e.length; i += 1)
            e[i] && a.prepend(e[i]);
        o = r + e.length
    } else
        a.prepend(e);
    n.loop && t.loopCreate(),
    n.observer || t.update(),
    t.slideTo(o, 0, !1)
}
function dE(e, t) {
    const n = this
      , {$wrapperEl: a, params: r, activeIndex: o} = n;
    let i = o;
    r.loop && (i -= n.loopedSlides,
    n.loopDestroy(),
    n.slides = a.children(`.${r.slideClass}`));
    const s = n.slides.length;
    if (e <= 0) {
        n.prependSlide(t);
        return
    }
    if (e >= s) {
        n.appendSlide(t);
        return
    }
    let l = i > e ? i + 1 : i;
    const c = [];
    for (let u = s - 1; u >= e; u -= 1) {
        const f = n.slides.eq(u);
        f.remove(),
        c.unshift(f)
    }
    if (typeof t == "object" && "length"in t) {
        for (let u = 0; u < t.length; u += 1)
            t[u] && a.append(t[u]);
        l = i > e ? i + t.length : i
    } else
        a.append(t);
    for (let u = 0; u < c.length; u += 1)
        a.append(c[u]);
    r.loop && n.loopCreate(),
    r.observer || n.update(),
    r.loop ? n.slideTo(l + n.loopedSlides, 0, !1) : n.slideTo(l, 0, !1)
}
function pE(e) {
    const t = this
      , {params: n, $wrapperEl: a, activeIndex: r} = t;
    let o = r;
    n.loop && (o -= t.loopedSlides,
    t.loopDestroy(),
    t.slides = a.children(`.${n.slideClass}`));
    let i = o, s;
    if (typeof e == "object" && "length"in e) {
        for (let l = 0; l < e.length; l += 1)
            s = e[l],
            t.slides[s] && t.slides.eq(s).remove(),
            s < i && (i -= 1);
        i = Math.max(i, 0)
    } else
        s = e,
        t.slides[s] && t.slides.eq(s).remove(),
        s < i && (i -= 1),
        i = Math.max(i, 0);
    n.loop && t.loopCreate(),
    n.observer || t.update(),
    n.loop ? t.slideTo(i + t.loopedSlides, 0, !1) : t.slideTo(i, 0, !1)
}
function hE() {
    const e = this
      , t = [];
    for (let n = 0; n < e.slides.length; n += 1)
        t.push(n);
    e.removeSlide(t)
}
function mE({swiper: e}) {
    Object.assign(e, {
        appendSlide: uE.bind(e),
        prependSlide: fE.bind(e),
        addSlide: dE.bind(e),
        removeSlide: pE.bind(e),
        removeAllSlides: hE.bind(e)
    })
}
function _i(e) {
    const {effect: t, swiper: n, on: a, setTranslate: r, setTransition: o, overwriteParams: i, perspective: s, recreateShadows: l, getEffectParams: c} = e;
    a("beforeInit", () => {
        if (n.params.effect !== t)
            return;
        n.classNames.push(`${n.params.containerModifierClass}${t}`),
        s && s() && n.classNames.push(`${n.params.containerModifierClass}3d`);
        const f = i ? i() : {};
        Object.assign(n.params, f),
        Object.assign(n.originalParams, f)
    }
    ),
    a("setTranslate", () => {
        n.params.effect === t && r()
    }
    ),
    a("setTransition", (f, d) => {
        n.params.effect === t && o(d)
    }
    ),
    a("transitionEnd", () => {
        if (n.params.effect === t && l) {
            if (!c || !c().slideShadows)
                return;
            n.slides.each(f => {
                n.$(f).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").remove()
            }
            ),
            l()
        }
    }
    );
    let u;
    a("virtualUpdate", () => {
        n.params.effect === t && (n.slides.length || (u = !0),
        requestAnimationFrame( () => {
            u && n.slides && n.slides.length && (r(),
            u = !1)
        }
        ))
    }
    )
}
function Zs(e, t) {
    return e.transformEl ? t.find(e.transformEl).css({
        "backface-visibility": "hidden",
        "-webkit-backface-visibility": "hidden"
    }) : t
}
function ic({swiper: e, duration: t, transformEl: n, allSlides: a}) {
    const {slides: r, activeIndex: o, $wrapperEl: i} = e;
    if (e.params.virtualTranslate && t !== 0) {
        let s = !1, l;
        a ? l = n ? r.find(n) : r : l = n ? r.eq(o).find(n) : r.eq(o),
        l.transitionEnd( () => {
            if (s || !e || e.destroyed)
                return;
            s = !0,
            e.animating = !1;
            const c = ["webkitTransitionEnd", "transitionend"];
            for (let u = 0; u < c.length; u += 1)
                i.trigger(c[u])
        }
        )
    }
}
function gE({swiper: e, extendParams: t, on: n}) {
    t({
        fadeEffect: {
            crossFade: !1,
            transformEl: null
        }
    }),
    _i({
        effect: "fade",
        swiper: e,
        on: n,
        setTranslate: () => {
            const {slides: o} = e
              , i = e.params.fadeEffect;
            for (let s = 0; s < o.length; s += 1) {
                const l = e.slides.eq(s);
                let u = -l[0].swiperSlideOffset;
                e.params.virtualTranslate || (u -= e.translate);
                let f = 0;
                e.isHorizontal() || (f = u,
                u = 0);
                const d = e.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(l[0].progress), 0) : 1 + Math.min(Math.max(l[0].progress, -1), 0);
                Zs(i, l).css({
                    opacity: d
                }).transform(`translate3d(${u}px, ${f}px, 0px)`)
            }
        }
        ,
        setTransition: o => {
            const {transformEl: i} = e.params.fadeEffect;
            (i ? e.slides.find(i) : e.slides).transition(o),
            ic({
                swiper: e,
                duration: o,
                transformEl: i,
                allSlides: !0
            })
        }
        ,
        overwriteParams: () => ({
            slidesPerView: 1,
            slidesPerGroup: 1,
            watchSlidesProgress: !0,
            spaceBetween: 0,
            virtualTranslate: !e.params.cssMode
        })
    })
}
function vE({swiper: e, extendParams: t, on: n}) {
    t({
        cubeEffect: {
            slideShadows: !0,
            shadow: !0,
            shadowOffset: 20,
            shadowScale: .94
        }
    });
    const a = (s, l, c) => {
        let u = c ? s.find(".swiper-slide-shadow-left") : s.find(".swiper-slide-shadow-top")
          , f = c ? s.find(".swiper-slide-shadow-right") : s.find(".swiper-slide-shadow-bottom");
        u.length === 0 && (u = _e(`<div class="swiper-slide-shadow-${c ? "left" : "top"}"></div>`),
        s.append(u)),
        f.length === 0 && (f = _e(`<div class="swiper-slide-shadow-${c ? "right" : "bottom"}"></div>`),
        s.append(f)),
        u.length && (u[0].style.opacity = Math.max(-l, 0)),
        f.length && (f[0].style.opacity = Math.max(l, 0))
    }
    ;
    _i({
        effect: "cube",
        swiper: e,
        on: n,
        setTranslate: () => {
            const {$el: s, $wrapperEl: l, slides: c, width: u, height: f, rtlTranslate: d, size: p, browser: h} = e
              , m = e.params.cubeEffect
              , g = e.isHorizontal()
              , b = e.virtual && e.params.virtual.enabled;
            let v = 0, y;
            m.shadow && (g ? (y = l.find(".swiper-cube-shadow"),
            y.length === 0 && (y = _e('<div class="swiper-cube-shadow"></div>'),
            l.append(y)),
            y.css({
                height: `${u}px`
            })) : (y = s.find(".swiper-cube-shadow"),
            y.length === 0 && (y = _e('<div class="swiper-cube-shadow"></div>'),
            s.append(y))));
            for (let C = 0; C < c.length; C += 1) {
                const _ = c.eq(C);
                let E = C;
                b && (E = parseInt(_.attr("data-swiper-slide-index"), 10));
                let z = E * 90
                  , T = Math.floor(z / 360);
                d && (z = -z,
                T = Math.floor(-z / 360));
                const A = Math.max(Math.min(_[0].progress, 1), -1);
                let x = 0
                  , M = 0
                  , L = 0;
                E % 4 === 0 ? (x = -T * 4 * p,
                L = 0) : (E - 1) % 4 === 0 ? (x = 0,
                L = -T * 4 * p) : (E - 2) % 4 === 0 ? (x = p + T * 4 * p,
                L = p) : (E - 3) % 4 === 0 && (x = -p,
                L = 3 * p + p * 4 * T),
                d && (x = -x),
                g || (M = x,
                x = 0);
                const U = `rotateX(${g ? 0 : -z}deg) rotateY(${g ? z : 0}deg) translate3d(${x}px, ${M}px, ${L}px)`;
                A <= 1 && A > -1 && (v = E * 90 + A * 90,
                d && (v = -E * 90 - A * 90)),
                _.transform(U),
                m.slideShadows && a(_, A, g)
            }
            if (l.css({
                "-webkit-transform-origin": `50% 50% -${p / 2}px`,
                "transform-origin": `50% 50% -${p / 2}px`
            }),
            m.shadow)
                if (g)
                    y.transform(`translate3d(0px, ${u / 2 + m.shadowOffset}px, ${-u / 2}px) rotateX(90deg) rotateZ(0deg) scale(${m.shadowScale})`);
                else {
                    const C = Math.abs(v) - Math.floor(Math.abs(v) / 90) * 90
                      , _ = 1.5 - (Math.sin(C * 2 * Math.PI / 360) / 2 + Math.cos(C * 2 * Math.PI / 360) / 2)
                      , E = m.shadowScale
                      , z = m.shadowScale / _
                      , T = m.shadowOffset;
                    y.transform(`scale3d(${E}, 1, ${z}) translate3d(0px, ${f / 2 + T}px, ${-f / 2 / z}px) rotateX(-90deg)`)
                }
            const w = h.isSafari || h.isWebView ? -p / 2 : 0;
            l.transform(`translate3d(0px,0,${w}px) rotateX(${e.isHorizontal() ? 0 : v}deg) rotateY(${e.isHorizontal() ? -v : 0}deg)`),
            l[0].style.setProperty("--swiper-cube-translate-z", `${w}px`)
        }
        ,
        setTransition: s => {
            const {$el: l, slides: c} = e;
            c.transition(s).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(s),
            e.params.cubeEffect.shadow && !e.isHorizontal() && l.find(".swiper-cube-shadow").transition(s)
        }
        ,
        recreateShadows: () => {
            const s = e.isHorizontal();
            e.slides.each(l => {
                const c = Math.max(Math.min(l.progress, 1), -1);
                a(_e(l), c, s)
            }
            )
        }
        ,
        getEffectParams: () => e.params.cubeEffect,
        perspective: () => !0,
        overwriteParams: () => ({
            slidesPerView: 1,
            slidesPerGroup: 1,
            watchSlidesProgress: !0,
            resistanceRatio: 0,
            spaceBetween: 0,
            centeredSlides: !1,
            virtualTranslate: !0
        })
    })
}
function mi(e, t, n) {
    const a = `swiper-slide-shadow${n ? `-${n}` : ""}`
      , r = e.transformEl ? t.find(e.transformEl) : t;
    let o = r.children(`.${a}`);
    return o.length || (o = _e(`<div class="swiper-slide-shadow${n ? `-${n}` : ""}"></div>`),
    r.append(o)),
    o
}
function bE({swiper: e, extendParams: t, on: n}) {
    t({
        flipEffect: {
            slideShadows: !0,
            limitRotation: !0,
            transformEl: null
        }
    });
    const a = (s, l, c) => {
        let u = e.isHorizontal() ? s.find(".swiper-slide-shadow-left") : s.find(".swiper-slide-shadow-top")
          , f = e.isHorizontal() ? s.find(".swiper-slide-shadow-right") : s.find(".swiper-slide-shadow-bottom");
        u.length === 0 && (u = mi(c, s, e.isHorizontal() ? "left" : "top")),
        f.length === 0 && (f = mi(c, s, e.isHorizontal() ? "right" : "bottom")),
        u.length && (u[0].style.opacity = Math.max(-l, 0)),
        f.length && (f[0].style.opacity = Math.max(l, 0))
    }
    ;
    _i({
        effect: "flip",
        swiper: e,
        on: n,
        setTranslate: () => {
            const {slides: s, rtlTranslate: l} = e
              , c = e.params.flipEffect;
            for (let u = 0; u < s.length; u += 1) {
                const f = s.eq(u);
                let d = f[0].progress;
                e.params.flipEffect.limitRotation && (d = Math.max(Math.min(f[0].progress, 1), -1));
                const p = f[0].swiperSlideOffset;
                let m = -180 * d
                  , g = 0
                  , b = e.params.cssMode ? -p - e.translate : -p
                  , v = 0;
                e.isHorizontal() ? l && (m = -m) : (v = b,
                b = 0,
                g = -m,
                m = 0),
                f[0].style.zIndex = -Math.abs(Math.round(d)) + s.length,
                c.slideShadows && a(f, d, c);
                const y = `translate3d(${b}px, ${v}px, 0px) rotateX(${g}deg) rotateY(${m}deg)`;
                Zs(c, f).transform(y)
            }
        }
        ,
        setTransition: s => {
            const {transformEl: l} = e.params.flipEffect;
            (l ? e.slides.find(l) : e.slides).transition(s).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(s),
            ic({
                swiper: e,
                duration: s,
                transformEl: l
            })
        }
        ,
        recreateShadows: () => {
            const s = e.params.flipEffect;
            e.slides.each(l => {
                const c = _e(l);
                let u = c[0].progress;
                e.params.flipEffect.limitRotation && (u = Math.max(Math.min(l.progress, 1), -1)),
                a(c, u, s)
            }
            )
        }
        ,
        getEffectParams: () => e.params.flipEffect,
        perspective: () => !0,
        overwriteParams: () => ({
            slidesPerView: 1,
            slidesPerGroup: 1,
            watchSlidesProgress: !0,
            spaceBetween: 0,
            virtualTranslate: !e.params.cssMode
        })
    })
}
function yE({swiper: e, extendParams: t, on: n}) {
    t({
        coverflowEffect: {
            rotate: 50,
            stretch: 0,
            depth: 100,
            scale: 1,
            modifier: 1,
            slideShadows: !0,
            transformEl: null
        }
    }),
    _i({
        effect: "coverflow",
        swiper: e,
        on: n,
        setTranslate: () => {
            const {width: o, height: i, slides: s, slidesSizesGrid: l} = e
              , c = e.params.coverflowEffect
              , u = e.isHorizontal()
              , f = e.translate
              , d = u ? -f + o / 2 : -f + i / 2
              , p = u ? c.rotate : -c.rotate
              , h = c.depth;
            for (let m = 0, g = s.length; m < g; m += 1) {
                const b = s.eq(m)
                  , v = l[m]
                  , y = b[0].swiperSlideOffset
                  , w = (d - y - v / 2) / v
                  , C = typeof c.modifier == "function" ? c.modifier(w) : w * c.modifier;
                let _ = u ? p * C : 0
                  , E = u ? 0 : p * C
                  , z = -h * Math.abs(C)
                  , T = c.stretch;
                typeof T == "string" && T.indexOf("%") !== -1 && (T = parseFloat(c.stretch) / 100 * v);
                let A = u ? 0 : T * C
                  , x = u ? T * C : 0
                  , M = 1 - (1 - c.scale) * Math.abs(C);
                Math.abs(x) < .001 && (x = 0),
                Math.abs(A) < .001 && (A = 0),
                Math.abs(z) < .001 && (z = 0),
                Math.abs(_) < .001 && (_ = 0),
                Math.abs(E) < .001 && (E = 0),
                Math.abs(M) < .001 && (M = 0);
                const L = `translate3d(${x}px,${A}px,${z}px)  rotateX(${E}deg) rotateY(${_}deg) scale(${M})`;
                if (Zs(c, b).transform(L),
                b[0].style.zIndex = -Math.abs(Math.round(C)) + 1,
                c.slideShadows) {
                    let Y = u ? b.find(".swiper-slide-shadow-left") : b.find(".swiper-slide-shadow-top")
                      , H = u ? b.find(".swiper-slide-shadow-right") : b.find(".swiper-slide-shadow-bottom");
                    Y.length === 0 && (Y = mi(c, b, u ? "left" : "top")),
                    H.length === 0 && (H = mi(c, b, u ? "right" : "bottom")),
                    Y.length && (Y[0].style.opacity = C > 0 ? C : 0),
                    H.length && (H[0].style.opacity = -C > 0 ? -C : 0)
                }
            }
        }
        ,
        setTransition: o => {
            const {transformEl: i} = e.params.coverflowEffect;
            (i ? e.slides.find(i) : e.slides).transition(o).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(o)
        }
        ,
        perspective: () => !0,
        overwriteParams: () => ({
            watchSlidesProgress: !0
        })
    })
}
function CE({swiper: e, extendParams: t, on: n}) {
    t({
        creativeEffect: {
            transformEl: null,
            limitProgress: 1,
            shadowPerProgress: !1,
            progressMultiplier: 1,
            perspective: !0,
            prev: {
                translate: [0, 0, 0],
                rotate: [0, 0, 0],
                opacity: 1,
                scale: 1
            },
            next: {
                translate: [0, 0, 0],
                rotate: [0, 0, 0],
                opacity: 1,
                scale: 1
            }
        }
    });
    const a = i => typeof i == "string" ? i : `${i}px`;
    _i({
        effect: "creative",
        swiper: e,
        on: n,
        setTranslate: () => {
            const {slides: i, $wrapperEl: s, slidesSizesGrid: l} = e
              , c = e.params.creativeEffect
              , {progressMultiplier: u} = c
              , f = e.params.centeredSlides;
            if (f) {
                const d = l[0] / 2 - e.params.slidesOffsetBefore || 0;
                s.transform(`translateX(calc(50% - ${d}px))`)
            }
            for (let d = 0; d < i.length; d += 1) {
                const p = i.eq(d)
                  , h = p[0].progress
                  , m = Math.min(Math.max(p[0].progress, -c.limitProgress), c.limitProgress);
                let g = m;
                f || (g = Math.min(Math.max(p[0].originalProgress, -c.limitProgress), c.limitProgress));
                const b = p[0].swiperSlideOffset
                  , v = [e.params.cssMode ? -b - e.translate : -b, 0, 0]
                  , y = [0, 0, 0];
                let w = !1;
                e.isHorizontal() || (v[1] = v[0],
                v[0] = 0);
                let C = {
                    translate: [0, 0, 0],
                    rotate: [0, 0, 0],
                    scale: 1,
                    opacity: 1
                };
                m < 0 ? (C = c.next,
                w = !0) : m > 0 && (C = c.prev,
                w = !0),
                v.forEach( (M, L) => {
                    v[L] = `calc(${M}px + (${a(C.translate[L])} * ${Math.abs(m * u)}))`
                }
                ),
                y.forEach( (M, L) => {
                    y[L] = C.rotate[L] * Math.abs(m * u)
                }
                ),
                p[0].style.zIndex = -Math.abs(Math.round(h)) + i.length;
                const _ = v.join(", ")
                  , E = `rotateX(${y[0]}deg) rotateY(${y[1]}deg) rotateZ(${y[2]}deg)`
                  , z = g < 0 ? `scale(${1 + (1 - C.scale) * g * u})` : `scale(${1 - (1 - C.scale) * g * u})`
                  , T = g < 0 ? 1 + (1 - C.opacity) * g * u : 1 - (1 - C.opacity) * g * u
                  , A = `translate3d(${_}) ${E} ${z}`;
                if (w && C.shadow || !w) {
                    let M = p.children(".swiper-slide-shadow");
                    if (M.length === 0 && C.shadow && (M = mi(c, p)),
                    M.length) {
                        const L = c.shadowPerProgress ? m * (1 / c.limitProgress) : m;
                        M[0].style.opacity = Math.min(Math.max(Math.abs(L), 0), 1)
                    }
                }
                const x = Zs(c, p);
                x.transform(A).css({
                    opacity: T
                }),
                C.origin && x.css("transform-origin", C.origin)
            }
        }
        ,
        setTransition: i => {
            const {transformEl: s} = e.params.creativeEffect;
            (s ? e.slides.find(s) : e.slides).transition(i).find(".swiper-slide-shadow").transition(i),
            ic({
                swiper: e,
                duration: i,
                transformEl: s,
                allSlides: !0
            })
        }
        ,
        perspective: () => e.params.creativeEffect.perspective,
        overwriteParams: () => ({
            watchSlidesProgress: !0,
            virtualTranslate: !e.params.cssMode
        })
    })
}
function wE({swiper: e, extendParams: t, on: n}) {
    t({
        cardsEffect: {
            slideShadows: !0,
            transformEl: null,
            rotate: !0,
            perSlideRotate: 2,
            perSlideOffset: 8
        }
    }),
    _i({
        effect: "cards",
        swiper: e,
        on: n,
        setTranslate: () => {
            const {slides: o, activeIndex: i} = e
              , s = e.params.cardsEffect
              , {startTranslate: l, isTouched: c} = e.touchEventsData
              , u = e.translate;
            for (let f = 0; f < o.length; f += 1) {
                const d = o.eq(f)
                  , p = d[0].progress
                  , h = Math.min(Math.max(p, -4), 4);
                let m = d[0].swiperSlideOffset;
                e.params.centeredSlides && !e.params.cssMode && e.$wrapperEl.transform(`translateX(${e.minTranslate()}px)`),
                e.params.centeredSlides && e.params.cssMode && (m -= o[0].swiperSlideOffset);
                let g = e.params.cssMode ? -m - e.translate : -m
                  , b = 0;
                const v = -100 * Math.abs(h);
                let y = 1
                  , w = -s.perSlideRotate * h
                  , C = s.perSlideOffset - Math.abs(h) * .75;
                const _ = e.virtual && e.params.virtual.enabled ? e.virtual.from + f : f
                  , E = (_ === i || _ === i - 1) && h > 0 && h < 1 && (c || e.params.cssMode) && u < l
                  , z = (_ === i || _ === i + 1) && h < 0 && h > -1 && (c || e.params.cssMode) && u > l;
                if (E || z) {
                    const M = (1 - Math.abs((Math.abs(h) - .5) / .5)) ** .5;
                    w += -28 * h * M,
                    y += -.5 * M,
                    C += 96 * M,
                    b = `${-25 * M * Math.abs(h)}%`
                }
                if (h < 0 ? g = `calc(${g}px + (${C * Math.abs(h)}%))` : h > 0 ? g = `calc(${g}px + (-${C * Math.abs(h)}%))` : g = `${g}px`,
                !e.isHorizontal()) {
                    const M = b;
                    b = g,
                    g = M
                }
                const T = h < 0 ? `${1 + (1 - y) * h}` : `${1 - (1 - y) * h}`
                  , A = `
        translate3d(${g}, ${b}, ${v}px)
        rotateZ(${s.rotate ? w : 0}deg)
        scale(${T})
      `;
                if (s.slideShadows) {
                    let M = d.find(".swiper-slide-shadow");
                    M.length === 0 && (M = mi(s, d)),
                    M.length && (M[0].style.opacity = Math.min(Math.max((Math.abs(h) - .5) / .5, 0), 1))
                }
                d[0].style.zIndex = -Math.abs(Math.round(p)) + o.length,
                Zs(s, d).transform(A)
            }
        }
        ,
        setTransition: o => {
            const {transformEl: i} = e.params.cardsEffect;
            (i ? e.slides.find(i) : e.slides).transition(o).find(".swiper-slide-shadow").transition(o),
            ic({
                swiper: e,
                duration: o,
                transformEl: i
            })
        }
        ,
        perspective: () => !0,
        overwriteParams: () => ({
            watchSlidesProgress: !0,
            virtualTranslate: !e.params.cssMode
        })
    })
}
function _o(e) {
    return typeof e == "object" && e !== null && e.constructor && Object.prototype.toString.call(e).slice(8, -1) === "Object"
}
function Tr(e, t) {
    const n = ["__proto__", "constructor", "prototype"];
    Object.keys(t).filter(a => n.indexOf(a) < 0).forEach(a => {
        typeof e[a] > "u" ? e[a] = t[a] : _o(t[a]) && _o(e[a]) && Object.keys(t[a]).length > 0 ? t[a].__swiper__ ? e[a] = t[a] : Tr(e[a], t[a]) : e[a] = t[a]
    }
    )
}
function k6(e={}) {
    return e.navigation && typeof e.navigation.nextEl > "u" && typeof e.navigation.prevEl > "u"
}
function S6(e={}) {
    return e.pagination && typeof e.pagination.el > "u"
}
function $6(e={}) {
    return e.scrollbar && typeof e.scrollbar.el > "u"
}
function E6(e="") {
    const t = e.split(" ").map(a => a.trim()).filter(a => !!a)
      , n = [];
    return t.forEach(a => {
        n.indexOf(a) < 0 && n.push(a)
    }
    ),
    n.join(" ")
}
const x6 = ["modules", "init", "_direction", "touchEventsTarget", "initialSlide", "_speed", "cssMode", "updateOnWindowResize", "resizeObserver", "nested", "focusableElements", "_enabled", "_width", "_height", "preventInteractionOnTransition", "userAgent", "url", "_edgeSwipeDetection", "_edgeSwipeThreshold", "_freeMode", "_autoHeight", "setWrapperSize", "virtualTranslate", "_effect", "breakpoints", "_spaceBetween", "_slidesPerView", "maxBackfaceHiddenSlides", "_grid", "_slidesPerGroup", "_slidesPerGroupSkip", "_slidesPerGroupAuto", "_centeredSlides", "_centeredSlidesBounds", "_slidesOffsetBefore", "_slidesOffsetAfter", "normalizeSlideIndex", "_centerInsufficientSlides", "_watchOverflow", "roundLengths", "touchRatio", "touchAngle", "simulateTouch", "_shortSwipes", "_longSwipes", "longSwipesRatio", "longSwipesMs", "_followFinger", "allowTouchMove", "_threshold", "touchMoveStopPropagation", "touchStartPreventDefault", "touchStartForcePreventDefault", "touchReleaseOnEdges", "uniqueNavElements", "_resistance", "_resistanceRatio", "_watchSlidesProgress", "_grabCursor", "preventClicks", "preventClicksPropagation", "_slideToClickedSlide", "_preloadImages", "updateOnImagesReady", "_loop", "_loopAdditionalSlides", "_loopedSlides", "_loopedSlidesLimit", "_loopFillGroupWithBlank", "loopPreventsSlide", "_rewind", "_allowSlidePrev", "_allowSlideNext", "_swipeHandler", "_noSwiping", "noSwipingClass", "noSwipingSelector", "passiveListeners", "containerModifierClass", "slideClass", "slideBlankClass", "slideActiveClass", "slideDuplicateActiveClass", "slideVisibleClass", "slideDuplicateClass", "slideNextClass", "slideDuplicateNextClass", "slidePrevClass", "slideDuplicatePrevClass", "wrapperClass", "runCallbacksOnInit", "observer", "observeParents", "observeSlideChildren", "a11y", "_autoplay", "_controller", "coverflowEffect", "cubeEffect", "fadeEffect", "flipEffect", "creativeEffect", "cardsEffect", "hashNavigation", "history", "keyboard", "lazy", "mousewheel", "_navigation", "_pagination", "parallax", "_scrollbar", "_thumbs", "virtual", "zoom"];
function B3(e={}, t=!0) {
    const n = {
        on: {}
    }
      , a = {}
      , r = {};
    Tr(n, ar.defaults),
    Tr(n, ar.extendedDefaults),
    n._emitClasses = !0,
    n.init = !1;
    const o = {}
      , i = x6.map(l => l.replace(/_/, ""))
      , s = Object.assign({}, e);
    return Object.keys(s).forEach(l => {
        typeof e[l] > "u" || (i.indexOf(l) >= 0 ? _o(e[l]) ? (n[l] = {},
        r[l] = {},
        Tr(n[l], e[l]),
        Tr(r[l], e[l])) : (n[l] = e[l],
        r[l] = e[l]) : l.search(/on[A-Z]/) === 0 && typeof e[l] == "function" ? t ? a[`${l[2].toLowerCase()}${l.substr(3)}`] = e[l] : n.on[`${l[2].toLowerCase()}${l.substr(3)}`] = e[l] : o[l] = e[l])
    }
    ),
    ["navigation", "pagination", "scrollbar"].forEach(l => {
        n[l] === !0 && (n[l] = {}),
        n[l] === !1 && delete n[l]
    }
    ),
    {
        params: n,
        passedParams: r,
        rest: o,
        events: a
    }
}
function _E({el: e, nextEl: t, prevEl: n, paginationEl: a, scrollbarEl: r, swiper: o}, i) {
    k6(i) && t && n && (o.params.navigation.nextEl = t,
    o.originalParams.navigation.nextEl = t,
    o.params.navigation.prevEl = n,
    o.originalParams.navigation.prevEl = n),
    S6(i) && a && (o.params.pagination.el = a,
    o.originalParams.pagination.el = a),
    $6(i) && r && (o.params.scrollbar.el = r,
    o.originalParams.scrollbar.el = r),
    o.init(e)
}
const T6 = (e, t) => {
    let n = t.slidesPerView;
    if (t.breakpoints) {
        const r = ar.prototype.getBreakpoint(t.breakpoints)
          , o = r in t.breakpoints ? t.breakpoints[r] : void 0;
        o && o.slidesPerView && (n = o.slidesPerView)
    }
    let a = Math.ceil(parseFloat(t.loopedSlides || n, 10));
    return a += t.loopAdditionalSlides,
    a > e.length && t.loopedSlidesLimit && (a = e.length),
    a
}
;
function kE(e, t, n) {
    const a = t.map( (l, c) => (l.props || (l.props = {}),
    l.props.swiperRef = e,
    l.props["data-swiper-slide-index"] = c,
    l));
    function r(l, c, u) {
        return l.props || (l.props = {}),
        Pe(l.type, {
            ...l.props,
            key: `${l.key}-duplicate-${c}-${u}`,
            class: `${l.props.className || ""} ${n.slideDuplicateClass} ${l.props.class || ""}`
        }, l.children)
    }
    if (n.loopFillGroupWithBlank) {
        const l = n.slidesPerGroup - a.length % n.slidesPerGroup;
        if (l !== n.slidesPerGroup)
            for (let c = 0; c < l; c += 1) {
                const u = Pe("div", {
                    class: `${n.slideClass} ${n.slideBlankClass}`
                });
                a.push(u)
            }
    }
    n.slidesPerView === "auto" && !n.loopedSlides && (n.loopedSlides = a.length);
    const o = T6(a, n)
      , i = []
      , s = [];
    for (let l = 0; l < o; l += 1) {
        const c = l - Math.floor(l / a.length) * a.length;
        s.push(r(a[c], l, "append")),
        i.unshift(r(a[a.length - c - 1], l, "prepend"))
    }
    return e.value && (e.value.loopedSlides = o),
    [...i, ...a, ...s]
}
function SE(e, t, n, a, r) {
    const o = [];
    if (!t)
        return o;
    const i = l => {
        o.indexOf(l) < 0 && o.push(l)
    }
    ;
    if (n && a) {
        const l = a.map(r)
          , c = n.map(r);
        l.join("") !== c.join("") && i("children"),
        a.length !== n.length && i("children")
    }
    return x6.filter(l => l[0] === "_").map(l => l.replace(/_/, "")).forEach(l => {
        if (l in e && l in t)
            if (_o(e[l]) && _o(t[l])) {
                const c = Object.keys(e[l])
                  , u = Object.keys(t[l]);
                c.length !== u.length ? i(l) : (c.forEach(f => {
                    e[l][f] !== t[l][f] && i(l)
                }
                ),
                u.forEach(f => {
                    e[l][f] !== t[l][f] && i(l)
                }
                ))
            } else
                e[l] !== t[l] && i(l)
    }
    ),
    o
}
function Zc(e, t, n) {
    e === void 0 && (e = {});
    const a = []
      , r = {
        "container-start": [],
        "container-end": [],
        "wrapper-start": [],
        "wrapper-end": []
    }
      , o = (i, s) => {
        Array.isArray(i) && i.forEach(l => {
            const c = typeof l.type == "symbol";
            s === "default" && (s = "container-end"),
            c && l.children ? o(l.children, "default") : l.type && (l.type.name === "SwiperSlide" || l.type.name === "AsyncComponentWrapper") ? a.push(l) : r[s] && r[s].push(l)
        }
        )
    }
    ;
    return Object.keys(e).forEach(i => {
        if (typeof e[i] != "function")
            return;
        const s = e[i]();
        o(s, i)
    }
    ),
    n.value = t.value,
    t.value = a,
    {
        slides: a,
        slots: r
    }
}
function $E({swiper: e, slides: t, passedParams: n, changedParams: a, nextEl: r, prevEl: o, scrollbarEl: i, paginationEl: s}) {
    const l = a.filter(C => C !== "children" && C !== "direction")
      , {params: c, pagination: u, navigation: f, scrollbar: d, virtual: p, thumbs: h} = e;
    let m, g, b, v, y;
    a.includes("thumbs") && n.thumbs && n.thumbs.swiper && c.thumbs && !c.thumbs.swiper && (m = !0),
    a.includes("controller") && n.controller && n.controller.control && c.controller && !c.controller.control && (g = !0),
    a.includes("pagination") && n.pagination && (n.pagination.el || s) && (c.pagination || c.pagination === !1) && u && !u.el && (b = !0),
    a.includes("scrollbar") && n.scrollbar && (n.scrollbar.el || i) && (c.scrollbar || c.scrollbar === !1) && d && !d.el && (v = !0),
    a.includes("navigation") && n.navigation && (n.navigation.prevEl || o) && (n.navigation.nextEl || r) && (c.navigation || c.navigation === !1) && f && !f.prevEl && !f.nextEl && (y = !0);
    const w = C => {
        e[C] && (e[C].destroy(),
        C === "navigation" ? (c[C].prevEl = void 0,
        c[C].nextEl = void 0,
        e[C].prevEl = void 0,
        e[C].nextEl = void 0) : (c[C].el = void 0,
        e[C].el = void 0))
    }
    ;
    l.forEach(C => {
        if (_o(c[C]) && _o(n[C]))
            Tr(c[C], n[C]);
        else {
            const _ = n[C];
            (_ === !0 || _ === !1) && (C === "navigation" || C === "pagination" || C === "scrollbar") ? _ === !1 && w(C) : c[C] = n[C]
        }
    }
    ),
    l.includes("controller") && !g && e.controller && e.controller.control && c.controller && c.controller.control && (e.controller.control = c.controller.control),
    a.includes("children") && t && p && c.virtual.enabled ? (p.slides = t,
    p.update(!0)) : a.includes("children") && e.lazy && e.params.lazy.enabled && e.lazy.load(),
    m && h.init() && h.update(!0),
    g && (e.controller.control = c.controller.control),
    b && (s && (c.pagination.el = s),
    u.init(),
    u.render(),
    u.update()),
    v && (i && (c.scrollbar.el = i),
    d.init(),
    d.updateSize(),
    d.setTranslate()),
    y && (r && (c.navigation.nextEl = r),
    o && (c.navigation.prevEl = o),
    f.init(),
    f.update()),
    a.includes("allowSlideNext") && (e.allowSlideNext = n.allowSlideNext),
    a.includes("allowSlidePrev") && (e.allowSlidePrev = n.allowSlidePrev),
    a.includes("direction") && e.changeDirection(n.direction, !1),
    e.update()
}
function EE(e, t, n) {
    if (!n)
        return null;
    const a = e.value.isHorizontal() ? {
        [e.value.rtlTranslate ? "right" : "left"]: `${n.offset}px`
    } : {
        top: `${n.offset}px`
    };
    return t.filter( (r, o) => o >= n.from && o <= n.to).map(r => (r.props || (r.props = {}),
    r.props.style || (r.props.style = {}),
    r.props.swiperRef = e,
    r.props.style = a,
    Pe(r.type, {
        ...r.props
    }, r.children)))
}
const xE = e => {
    !e || e.destroyed || !e.params.virtual || e.params.virtual && !e.params.virtual.enabled || (e.updateSlides(),
    e.updateProgress(),
    e.updateSlidesClasses(),
    e.lazy && e.params.lazy.enabled && e.lazy.load(),
    e.parallax && e.params.parallax && e.params.parallax.enabled && e.parallax.setTranslate())
}
  , TE = {
    name: "Swiper",
    props: {
        tag: {
            type: String,
            default: "div"
        },
        wrapperTag: {
            type: String,
            default: "div"
        },
        modules: {
            type: Array,
            default: void 0
        },
        init: {
            type: Boolean,
            default: void 0
        },
        direction: {
            type: String,
            default: void 0
        },
        touchEventsTarget: {
            type: String,
            default: void 0
        },
        initialSlide: {
            type: Number,
            default: void 0
        },
        speed: {
            type: Number,
            default: void 0
        },
        cssMode: {
            type: Boolean,
            default: void 0
        },
        updateOnWindowResize: {
            type: Boolean,
            default: void 0
        },
        resizeObserver: {
            type: Boolean,
            default: void 0
        },
        nested: {
            type: Boolean,
            default: void 0
        },
        focusableElements: {
            type: String,
            default: void 0
        },
        width: {
            type: Number,
            default: void 0
        },
        height: {
            type: Number,
            default: void 0
        },
        preventInteractionOnTransition: {
            type: Boolean,
            default: void 0
        },
        userAgent: {
            type: String,
            default: void 0
        },
        url: {
            type: String,
            default: void 0
        },
        edgeSwipeDetection: {
            type: [Boolean, String],
            default: void 0
        },
        edgeSwipeThreshold: {
            type: Number,
            default: void 0
        },
        autoHeight: {
            type: Boolean,
            default: void 0
        },
        setWrapperSize: {
            type: Boolean,
            default: void 0
        },
        virtualTranslate: {
            type: Boolean,
            default: void 0
        },
        effect: {
            type: String,
            default: void 0
        },
        breakpoints: {
            type: Object,
            default: void 0
        },
        spaceBetween: {
            type: Number,
            default: void 0
        },
        slidesPerView: {
            type: [Number, String],
            default: void 0
        },
        maxBackfaceHiddenSlides: {
            type: Number,
            default: void 0
        },
        slidesPerGroup: {
            type: Number,
            default: void 0
        },
        slidesPerGroupSkip: {
            type: Number,
            default: void 0
        },
        slidesPerGroupAuto: {
            type: Boolean,
            default: void 0
        },
        centeredSlides: {
            type: Boolean,
            default: void 0
        },
        centeredSlidesBounds: {
            type: Boolean,
            default: void 0
        },
        slidesOffsetBefore: {
            type: Number,
            default: void 0
        },
        slidesOffsetAfter: {
            type: Number,
            default: void 0
        },
        normalizeSlideIndex: {
            type: Boolean,
            default: void 0
        },
        centerInsufficientSlides: {
            type: Boolean,
            default: void 0
        },
        watchOverflow: {
            type: Boolean,
            default: void 0
        },
        roundLengths: {
            type: Boolean,
            default: void 0
        },
        touchRatio: {
            type: Number,
            default: void 0
        },
        touchAngle: {
            type: Number,
            default: void 0
        },
        simulateTouch: {
            type: Boolean,
            default: void 0
        },
        shortSwipes: {
            type: Boolean,
            default: void 0
        },
        longSwipes: {
            type: Boolean,
            default: void 0
        },
        longSwipesRatio: {
            type: Number,
            default: void 0
        },
        longSwipesMs: {
            type: Number,
            default: void 0
        },
        followFinger: {
            type: Boolean,
            default: void 0
        },
        allowTouchMove: {
            type: Boolean,
            default: void 0
        },
        threshold: {
            type: Number,
            default: void 0
        },
        touchMoveStopPropagation: {
            type: Boolean,
            default: void 0
        },
        touchStartPreventDefault: {
            type: Boolean,
            default: void 0
        },
        touchStartForcePreventDefault: {
            type: Boolean,
            default: void 0
        },
        touchReleaseOnEdges: {
            type: Boolean,
            default: void 0
        },
        uniqueNavElements: {
            type: Boolean,
            default: void 0
        },
        resistance: {
            type: Boolean,
            default: void 0
        },
        resistanceRatio: {
            type: Number,
            default: void 0
        },
        watchSlidesProgress: {
            type: Boolean,
            default: void 0
        },
        grabCursor: {
            type: Boolean,
            default: void 0
        },
        preventClicks: {
            type: Boolean,
            default: void 0
        },
        preventClicksPropagation: {
            type: Boolean,
            default: void 0
        },
        slideToClickedSlide: {
            type: Boolean,
            default: void 0
        },
        preloadImages: {
            type: Boolean,
            default: void 0
        },
        updateOnImagesReady: {
            type: Boolean,
            default: void 0
        },
        loop: {
            type: Boolean,
            default: void 0
        },
        loopAdditionalSlides: {
            type: Number,
            default: void 0
        },
        loopedSlides: {
            type: Number,
            default: void 0
        },
        loopedSlidesLimit: {
            type: Boolean,
            default: !0
        },
        loopFillGroupWithBlank: {
            type: Boolean,
            default: void 0
        },
        loopPreventsSlide: {
            type: Boolean,
            default: void 0
        },
        rewind: {
            type: Boolean,
            default: void 0
        },
        allowSlidePrev: {
            type: Boolean,
            default: void 0
        },
        allowSlideNext: {
            type: Boolean,
            default: void 0
        },
        swipeHandler: {
            type: Boolean,
            default: void 0
        },
        noSwiping: {
            type: Boolean,
            default: void 0
        },
        noSwipingClass: {
            type: String,
            default: void 0
        },
        noSwipingSelector: {
            type: String,
            default: void 0
        },
        passiveListeners: {
            type: Boolean,
            default: void 0
        },
        containerModifierClass: {
            type: String,
            default: void 0
        },
        slideClass: {
            type: String,
            default: void 0
        },
        slideBlankClass: {
            type: String,
            default: void 0
        },
        slideActiveClass: {
            type: String,
            default: void 0
        },
        slideDuplicateActiveClass: {
            type: String,
            default: void 0
        },
        slideVisibleClass: {
            type: String,
            default: void 0
        },
        slideDuplicateClass: {
            type: String,
            default: void 0
        },
        slideNextClass: {
            type: String,
            default: void 0
        },
        slideDuplicateNextClass: {
            type: String,
            default: void 0
        },
        slidePrevClass: {
            type: String,
            default: void 0
        },
        slideDuplicatePrevClass: {
            type: String,
            default: void 0
        },
        wrapperClass: {
            type: String,
            default: void 0
        },
        runCallbacksOnInit: {
            type: Boolean,
            default: void 0
        },
        observer: {
            type: Boolean,
            default: void 0
        },
        observeParents: {
            type: Boolean,
            default: void 0
        },
        observeSlideChildren: {
            type: Boolean,
            default: void 0
        },
        a11y: {
            type: [Boolean, Object],
            default: void 0
        },
        autoplay: {
            type: [Boolean, Object],
            default: void 0
        },
        controller: {
            type: Object,
            default: void 0
        },
        coverflowEffect: {
            type: Object,
            default: void 0
        },
        cubeEffect: {
            type: Object,
            default: void 0
        },
        fadeEffect: {
            type: Object,
            default: void 0
        },
        flipEffect: {
            type: Object,
            default: void 0
        },
        creativeEffect: {
            type: Object,
            default: void 0
        },
        cardsEffect: {
            type: Object,
            default: void 0
        },
        hashNavigation: {
            type: [Boolean, Object],
            default: void 0
        },
        history: {
            type: [Boolean, Object],
            default: void 0
        },
        keyboard: {
            type: [Boolean, Object],
            default: void 0
        },
        lazy: {
            type: [Boolean, Object],
            default: void 0
        },
        mousewheel: {
            type: [Boolean, Object],
            default: void 0
        },
        navigation: {
            type: [Boolean, Object],
            default: void 0
        },
        pagination: {
            type: [Boolean, Object],
            default: void 0
        },
        parallax: {
            type: [Boolean, Object],
            default: void 0
        },
        scrollbar: {
            type: [Boolean, Object],
            default: void 0
        },
        thumbs: {
            type: Object,
            default: void 0
        },
        virtual: {
            type: [Boolean, Object],
            default: void 0
        },
        zoom: {
            type: [Boolean, Object],
            default: void 0
        },
        grid: {
            type: [Object],
            default: void 0
        },
        freeMode: {
            type: [Boolean, Object],
            default: void 0
        },
        enabled: {
            type: Boolean,
            default: void 0
        }
    },
    emits: ["_beforeBreakpoint", "_containerClasses", "_slideClass", "_slideClasses", "_swiper", "_freeModeNoMomentumRelease", "activeIndexChange", "afterInit", "autoplay", "autoplayStart", "autoplayStop", "autoplayPause", "autoplayResume", "beforeDestroy", "beforeInit", "beforeLoopFix", "beforeResize", "beforeSlideChangeStart", "beforeTransitionStart", "breakpoint", "changeDirection", "click", "disable", "doubleTap", "doubleClick", "destroy", "enable", "fromEdge", "hashChange", "hashSet", "imagesReady", "init", "keyPress", "lazyImageLoad", "lazyImageReady", "lock", "loopFix", "momentumBounce", "navigationHide", "navigationShow", "navigationPrev", "navigationNext", "observerUpdate", "orientationchange", "paginationHide", "paginationRender", "paginationShow", "paginationUpdate", "progress", "reachBeginning", "reachEnd", "realIndexChange", "resize", "scroll", "scrollbarDragEnd", "scrollbarDragMove", "scrollbarDragStart", "setTransition", "setTranslate", "slideChange", "slideChangeTransitionEnd", "slideChangeTransitionStart", "slideNextTransitionEnd", "slideNextTransitionStart", "slidePrevTransitionEnd", "slidePrevTransitionStart", "slideResetTransitionStart", "slideResetTransitionEnd", "sliderMove", "sliderFirstMove", "slidesLengthChange", "slidesGridLengthChange", "snapGridLengthChange", "snapIndexChange", "swiper", "tap", "toEdge", "touchEnd", "touchMove", "touchMoveOpposite", "touchStart", "transitionEnd", "transitionStart", "unlock", "update", "virtualUpdate", "zoomChange"],
    setup(e, t) {
        let {slots: n, emit: a} = t;
        const {tag: r, wrapperTag: o} = e
          , i = oe("swiper")
          , s = oe(null)
          , l = oe(!1)
          , c = oe(!1)
          , u = oe(null)
          , f = oe(null)
          , d = oe(null)
          , p = {
            value: []
        }
          , h = {
            value: []
        }
          , m = oe(null)
          , g = oe(null)
          , b = oe(null)
          , v = oe(null)
          , {params: y, passedParams: w} = B3(e, !1);
        Zc(n, p, h),
        d.value = w,
        h.value = p.value;
        const C = () => {
            Zc(n, p, h),
            l.value = !0
        }
        ;
        if (y.onAny = function(E) {
            for (var z = arguments.length, T = new Array(z > 1 ? z - 1 : 0), A = 1; A < z; A++)
                T[A - 1] = arguments[A];
            a(E, ...T)
        }
        ,
        Object.assign(y.on, {
            _beforeBreakpoint: C,
            _containerClasses(E, z) {
                i.value = z
            }
        }),
        f.value = new ar(y),
        f.value.loopCreate = () => {}
        ,
        f.value.loopDestroy = () => {}
        ,
        y.loop && (f.value.loopedSlides = T6(p.value, y)),
        f.value.virtual && f.value.params.virtual.enabled) {
            f.value.virtual.slides = p.value;
            const E = {
                cache: !1,
                slides: p.value,
                renderExternal: z => {
                    s.value = z
                }
                ,
                renderExternalUpdate: !1
            };
            Tr(f.value.params.virtual, E),
            Tr(f.value.originalParams.virtual, E)
        }
        On( () => {
            !c.value && f.value && (f.value.emitSlidesClasses(),
            c.value = !0);
            const {passedParams: E} = B3(e, !1)
              , z = SE(E, d.value, p.value, h.value, T => T.props && T.props.key);
            d.value = E,
            (z.length || l.value) && f.value && !f.value.destroyed && $E({
                swiper: f.value,
                slides: p.value,
                passedParams: E,
                changedParams: z,
                nextEl: m.value,
                prevEl: g.value,
                scrollbarEl: v.value,
                paginationEl: b.value
            }),
            l.value = !1
        }
        ),
        To("swiper", f),
        st(s, () => {
            Zn( () => {
                xE(f.value)
            }
            )
        }
        ),
        Xe( () => {
            u.value && (_E({
                el: u.value,
                nextEl: m.value,
                prevEl: g.value,
                paginationEl: b.value,
                scrollbarEl: v.value,
                swiper: f.value
            }, y),
            a("swiper", f.value))
        }
        ),
        lt( () => {
            f.value && !f.value.destroyed && f.value.destroy(!0, !1)
        }
        );
        function _(E) {
            return y.virtual ? EE(f, E, s.value) : !y.loop || f.value && f.value.destroyed ? (E.forEach(z => {
                z.props || (z.props = {}),
                z.props.swiperRef = f
            }
            ),
            E) : kE(f, E, y)
        }
        return () => {
            const {slides: E, slots: z} = Zc(n, p, h);
            return Pe(r, {
                ref: u,
                class: E6(i.value)
            }, [z["container-start"], Pe(o, {
                class: "swiper-wrapper"
            }, [z["wrapper-start"], _(E), z["wrapper-end"]]), k6(e) && [Pe("div", {
                ref: g,
                class: "swiper-button-prev"
            }), Pe("div", {
                ref: m,
                class: "swiper-button-next"
            })], $6(e) && Pe("div", {
                ref: v,
                class: "swiper-scrollbar"
            }), S6(e) && Pe("div", {
                ref: b,
                class: "swiper-pagination"
            }), z["container-end"]])
        }
    }
}
  , ME = {
    name: "SwiperSlide",
    props: {
        tag: {
            type: String,
            default: "div"
        },
        swiperRef: {
            type: Object,
            required: !1
        },
        zoom: {
            type: Boolean,
            default: void 0
        },
        virtualIndex: {
            type: [String, Number],
            default: void 0
        }
    },
    setup(e, t) {
        let {slots: n} = t
          , a = !1;
        const {swiperRef: r} = e
          , o = oe(null)
          , i = oe("swiper-slide");
        function s(c, u, f) {
            u === o.value && (i.value = f)
        }
        Xe( () => {
            !r || !r.value || (r.value.on("_slideClass", s),
            a = !0)
        }
        ),
        Z1( () => {
            a || !r || !r.value || (r.value.on("_slideClass", s),
            a = !0)
        }
        ),
        On( () => {
            !o.value || !r || !r.value || r.value.destroyed && i.value !== "swiper-slide" && (i.value = "swiper-slide")
        }
        ),
        lt( () => {
            !r || !r.value || r.value.off("_slideClass", s)
        }
        );
        const l = ae( () => ({
            isActive: i.value.indexOf("swiper-slide-active") >= 0 || i.value.indexOf("swiper-slide-duplicate-active") >= 0,
            isVisible: i.value.indexOf("swiper-slide-visible") >= 0,
            isDuplicate: i.value.indexOf("swiper-slide-duplicate") >= 0,
            isPrev: i.value.indexOf("swiper-slide-prev") >= 0 || i.value.indexOf("swiper-slide-duplicate-prev") >= 0,
            isNext: i.value.indexOf("swiper-slide-next") >= 0 || i.value.indexOf("swiper-slide-duplicate-next") >= 0
        }));
        return To("swiperSlide", l),
        () => Pe(e.tag, {
            class: E6(`${i.value}`),
            ref: o,
            "data-swiper-slide-index": e.virtualIndex
        }, e.zoom ? Pe("div", {
            class: "swiper-zoom-container",
            "data-swiper-zoom": typeof e.zoom == "number" ? e.zoom : void 0
        }, n.default && n.default(l.value)) : n.default && n.default(l.value))
    }
};
function zE(e, t) {
    return O(),
    G("div", {
        ref: "elRef",
        class: Ae(e.classes)
    }, [e.tabContent ? (O(),
    K(jn(e.getComponent(e.tabContent)), Un({
        key: 0,
        key: e.tabContent.id
    }, e.getProps(e.tabContent)), null, 16)) : ce(e.$slots, "default", {
        key: 1
    })], 2)
}
const AE = {
    name: "f7-tab",
    render: zE,
    props: {
        tabActive: Boolean,
        ...qe
    },
    emits: ["tab:show", "tab:hide"],
    setup(e, t) {
        let {emit: n} = t;
        const a = oe(null)
          , r = oe(null)
          , o = Qn("f7route", null)
          , i = Qn("f7route", null);
        let s = null;
        if (!r.value && o && o.route && o.route.tab && o.route.tab.id === e.id) {
            const {component: p, asyncComponent: h, options: m} = o.route.tab;
            if (p || h) {
                const g = o.route.options && o.route.options.props;
                s = {
                    id: fs(),
                    component: p || h,
                    isAsync: !!h,
                    props: {
                        ...g || {},
                        ...m && m.props || {},
                        f7router: i,
                        f7route: o,
                        ...o.params
                    }
                }
            }
        }
        const l = oe(s || null)
          , c = p => {
            l.value = p
        }
        ;
        D && !r.value && (r.value = {
            setTabContent: c
        },
        tn.tabs.push(r.value)),
        Xe( () => {
            a.value && s && (a.value.f7RouterTabLoaded = !0),
            ut( () => {
                r.value ? r.value.el = a.value : (r.value = {
                    el: a.value,
                    setTabContent: c
                },
                tn.tabs.push(r.value))
            }
            )
        }
        ),
        lt( () => {
            r.value && (tn.tabs.splice(tn.tabs.indexOf(r.value), 1),
            r.value = null)
        }
        ),
        On( () => {
            !r.value || !D || Nn.emit("tabRouterDidUpdate", r.value)
        }
        ),
        Gs(a, n);
        const u = ae( () => Oe("tab", {
            "tab-active": e.tabActive
        }, je(e)));
        return {
            elRef: a,
            classes: u,
            tabContent: l,
            getComponent: p => rt(p.component),
            getProps: p => {
                const {component: h, props: m} = p;
                let g = [];
                const b = {};
                return h && h.props && (g = Object.keys(h.props)),
                g.forEach(v => {
                    v in m && (b[v] = m[v])
                }
                ),
                b
            }
        }
    }
};
function OE(e, t) {
    return e.animated || e.swipeable ? (O(),
    G("div", {
        key: 0,
        ref: "elRef",
        class: Ae(e.classNames(e.wrapClasses, e.classes))
    }, [V("div", {
        class: Ae(e.tabsClasses)
    }, [ce(e.$slots, "default")], 2)], 2)) : (O(),
    G("div", {
        key: 1,
        ref: "elRef",
        class: Ae(e.classNames(e.tabsClasses, e.classes))
    }, [ce(e.$slots, "default")], 2))
}
const PE = {
    name: "f7-tabs",
    render: OE,
    props: {
        animated: Boolean,
        swipeable: Boolean,
        routable: Boolean,
        swiperParams: {
            type: Object,
            default: void 0
        },
        ...qe
    },
    setup(e) {
        const t = oe(null);
        Xe( () => {
            !e.swipeable || !e.swiperParams || t.value && (t.value.f7SwiperParams = e.swiperParams)
        }
        );
        const n = ae( () => Oe(je(e)))
          , a = ae( () => Oe({
            "tabs-animated-wrap": e.animated,
            "tabs-swipeable-wrap": e.swipeable
        }))
          , r = ae( () => Oe({
            tabs: !0,
            "tabs-routable": e.routable
        }));
        return {
            elRef: t,
            classes: n,
            wrapClasses: a,
            tabsClasses: r,
            classNames: Oe
        }
    }
}
  , LE = {
    key: 0,
    className: "toolbar-inner"
};
function IE(e, t) {
    return O(),
    G("div", {
        ref: "elRef",
        class: Ae(e.classes)
    }, [ce(e.$slots, "before-inner"), e.inner ? (O(),
    G("div", LE, [ce(e.$slots, "default")])) : ce(e.$slots, "default", {
        key: 1
    }), ce(e.$slots, "after-inner")], 2)
}
const BE = {
    name: "f7-toolbar",
    render: IE,
    props: {
        tabbar: Boolean,
        labels: Boolean,
        scrollable: Boolean,
        hidden: Boolean,
        noShadow: Boolean,
        noHairline: Boolean,
        noBorder: Boolean,
        position: {
            type: String,
            default: void 0
        },
        topMd: {
            type: Boolean,
            default: void 0
        },
        topIos: {
            type: Boolean,
            default: void 0
        },
        topAurora: {
            type: Boolean,
            default: void 0
        },
        top: {
            type: Boolean,
            default: void 0
        },
        bottomMd: {
            type: Boolean,
            default: void 0
        },
        bottomIos: {
            type: Boolean,
            default: void 0
        },
        bottomAurora: {
            type: Boolean,
            default: void 0
        },
        bottom: {
            type: Boolean,
            default: void 0
        },
        inner: {
            type: Boolean,
            default: !0
        },
        ...qe
    },
    emits: ["toolbar:hide", "toolbar:show"],
    setup(e, t) {
        let {emit: n} = t;
        const a = oe(null)
          , r = Ks()
          , o = f => {
            a.value === f && n("toolbar:hide")
        }
          , i = f => {
            a.value === f && n("toolbar:show")
        }
          , s = f => {
            D && D.toolbar.hide(a.value, f)
        }
          , l = f => {
            D && D.toolbar.show(a.value, f)
        }
        ;
        Xe( () => {
            e.tabbar && D && a.value && D.toolbar.setHighlight(a.value),
            D.on("toolbarShow", i),
            D.on("toolbarHide", o)
        }
        ),
        lt( () => {
            D.off("toolbarShow", i),
            D.off("toolbarHide", o)
        }
        );
        const c = ae( () => ({
            tabbarHasLabels: e.labels
        }));
        return To("TabbarContext", c),
        {
            classes: ae( () => {
                const {tabbar: f, bottomMd: d, bottomIos: p, bottomAurora: h, bottom: m, position: g, topMd: b, topIos: v, topAurora: y, top: w, labels: C, scrollable: _, hidden: E, noShadow: z, noHairline: T, noBorder: A} = e;
                return Oe("toolbar", {
                    tabbar: f,
                    "toolbar-bottom": r.value && r.value.md && d || r.value && r.value.ios && p || r.value && r.value.aurora && h || m || g === "bottom",
                    "toolbar-top": r.value && r.value.md && b || r.value && r.value.ios && v || r.value && r.value.aurora && y || w || g === "top",
                    "tabbar-labels": C,
                    "tabbar-scrollable": _,
                    "toolbar-hidden": E,
                    "no-shadow": z,
                    "no-hairline": T || A
                }, je(e))
            }
            ),
            elRef: a,
            hide: s,
            show: l
        }
    }
}
  , RE = {
    key: 0,
    className: "treeview-toggle"
}
  , DE = {
    className: "treeview-item-content"
}
  , NE = {
    className: "treeview-item-label"
}
  , HE = {
    key: 0,
    className: "treeview-item-children"
};
function VE(e, t) {
    const n = P("f7-use-icon");
    return O(),
    G("div", {
        ref: "elRef",
        class: Ae(e.classes)
    }, [(O(),
    K(jn(e.itemRootTag), Un({
        class: e.itemRootClasses
    }, e.itemRootAttrs, {
        onClick: e.onClick
    }), {
        default: k( () => [ce(e.$slots, "root-start"), e.needToggle ? (O(),
        G("div", RE)) : pe("", !0), V("div", DE, [ce(e.$slots, "content-start"), e.icon ? (O(),
        K(n, {
            key: 0,
            icon: e.icon
        }, null, 8, ["icon"])) : pe("", !0), ce(e.$slots, "media"), V("div", NE, [ce(e.$slots, "label-start"), J(" " + Me(e.label) + " ", 1), ce(e.$slots, "label")]), ce(e.$slots, "content"), ce(e.$slots, "content-end")]), ce(e.$slots, "root"), ce(e.$slots, "root-end")]),
        _: 3
    }, 16, ["class", "onClick"])), e.hasChildren ? (O(),
    G("div", HE, [ce(e.$slots, "children-start"), ce(e.$slots, "default"), ce(e.$slots, "children")])) : pe("", !0)], 2)
}
const FE = {
    name: "f7-treeview-item",
    render: VE,
    components: {
        f7UseIcon: wi
    },
    props: {
        toggle: {
            type: Boolean,
            default: void 0
        },
        itemToggle: Boolean,
        selectable: Boolean,
        selected: Boolean,
        opened: Boolean,
        label: String,
        loadChildren: Boolean,
        link: {
            type: [Boolean, String],
            default: void 0
        },
        ...qe,
        ...Oo,
        ...Ws,
        ...Mo
    },
    emits: ["click", "treeview:open", "treeview:close", "treeview:loadchildren"],
    setup(e, t) {
        let {slots: n, emit: a} = t;
        const r = oe(null)
          , o = ae( () => n.default || n.children || n["children-start"])
          , i = ae( () => typeof e.toggle > "u" ? o.value : e.toggle)
          , s = ae( () => Xs(e))
          , l = v => {
            a("click", v)
        }
          , c = v => {
            r.value === v && a("treeview:open", v)
        }
          , u = v => {
            r.value === v && a("treeview:close", v)
        }
          , f = (v, y) => {
            r.value === v && a("treeview:loadchildren", v, y)
        }
          , d = () => {
            r.value && ut( () => {
                D.on("treeviewOpen", c),
                D.on("treeviewClose", u),
                D.on("treeviewLoadChildren", f)
            }
            )
        }
          , p = () => {
            D && (D.off("treeviewOpen", c),
            D.off("treeviewClose", u),
            D.off("treeviewLoadChildren", f))
        }
        ;
        Xe( () => d()),
        lt( () => p());
        const h = ae( () => Oe("treeview-item", {
            "treeview-item-opened": e.opened,
            "treeview-load-children": e.loadChildren
        }, je(e)))
          , m = ae( () => Oe("treeview-item-root", {
            "treeview-item-selectable": e.selectable,
            "treeview-item-selected": e.selected,
            "treeview-item-toggle": e.itemToggle
        }, Ao(e), Lo(e)))
          , g = ae( () => e.link || e.link === "" ? "a" : "div")
          , b = ae( () => {
            let v = e.link;
            return e.link === !0 && (v = "#"),
            e.link === !1 && (v = void 0),
            {
                href: v,
                ...zo(e),
                ...Po(e)
            }
        }
        );
        return {
            itemRootTag: g,
            itemRootAttrs: b,
            itemRootClasses: m,
            classes: h,
            icon: s,
            onClick: l,
            hasChildren: o,
            needToggle: i,
            elRef: r
        }
    }
};
function jE(e, t) {
    return O(),
    G("div", {
        class: Ae(e.classes)
    }, [ce(e.$slots, "default")], 2)
}
const UE = {
    name: "f7-treeview",
    render: jE,
    props: {
        ...qe
    },
    setup(e) {
        return {
            classes: ae( () => Oe("treeview", je(e)))
        }
    }
};
function qE(e, t) {
    return O(),
    G("div", {
        class: Ae(e.classes)
    }, [ce(e.$slots, "default")], 2)
}
const WE = {
    name: "f7-views",
    render: qE,
    props: {
        tabs: Boolean,
        ...qe
    },
    setup(e) {
        return {
            classes: ae( () => Oe("views", {
                tabs: e.tabs
            }, je(e)))
        }
    }
};
function YE(e) {
    e.component("f7-accordion-content", yC),
    e.component("f7-accordion-item", wC),
    e.component("f7-accordion-toggle", kC),
    e.component("f7-accordion", $C),
    e.component("f7-actions-button", MC),
    e.component("f7-actions-group", AC),
    e.component("f7-actions-label", PC),
    e.component("f7-actions", IC),
    e.component("f7-app", RC),
    e.component("f7-appbar", NC),
    e.component("f7-area-chart", WC),
    e.component("f7-badge", oc),
    e.component("f7-block-footer", XC),
    e.component("f7-block-header", ZC),
    e.component("f7-block-title", ew),
    e.component("f7-block", aw),
    e.component("f7-breadcrumbs-collapsed", sw),
    e.component("f7-breadcrumbs-item", cw),
    e.component("f7-breadcrumbs-separator", dw),
    e.component("f7-breadcrumbs", mw),
    e.component("f7-button", Ow),
    e.component("f7-card-content", s6),
    e.component("f7-card-footer", l6),
    e.component("f7-card-header", c6),
    e.component("f7-card", Dw),
    e.component("f7-checkbox", Fw),
    e.component("f7-chip", qw),
    e.component("f7-col", Gw),
    e.component("f7-fab-backdrop", Kw),
    e.component("f7-fab-button", e_),
    e.component("f7-fab-buttons", n_),
    e.component("f7-fab", a_),
    e.component("f7-gauge", p_),
    e.component("f7-icon", i6),
    e.component("f7-input", d6),
    e.component("f7-link", Af),
    e.component("f7-list-button", k_),
    e.component("f7-list-group", E_),
    e.component("f7-list-index", T_),
    e.component("f7-list-input", M_),
    e.component("f7-list-item-cell", A_),
    e.component("f7-list-item-row", P_),
    e.component("f7-list-item", I_),
    e.component("f7-list", B_),
    e.component("f7-login-screen-title", D_),
    e.component("f7-login-screen", t6),
    e.component("f7-menu-dropdown-item", H_),
    e.component("f7-menu-dropdown", F_),
    e.component("f7-menu-item", q_),
    e.component("f7-menu", G_),
    e.component("f7-message", ik),
    e.component("f7-messagebar-attachment", ck),
    e.component("f7-messagebar-attachments", fk),
    e.component("f7-messagebar-sheet-image", mk),
    e.component("f7-messagebar-sheet-item", vk),
    e.component("f7-messagebar-sheet", yk),
    e.component("f7-messagebar", Ck),
    e.component("f7-messages-title", _k),
    e.component("f7-messages", Sk),
    e.component("f7-nav-left", h6),
    e.component("f7-nav-right", m6),
    e.component("f7-nav-title-large", Mk),
    e.component("f7-nav-title", g6),
    e.component("f7-navbar", Bk),
    e.component("f7-page-content", v6),
    e.component("f7-page", jk),
    e.component("f7-panel", r6),
    e.component("f7-photo-browser", Uk),
    e.component("f7-pie-chart", Gk),
    e.component("f7-popover", a6),
    e.component("f7-popup", e6),
    e.component("f7-preloader", Mf),
    e.component("f7-progressbar", Zk),
    e.component("f7-radio", tS),
    e.component("f7-range", f6),
    e.component("f7-routable-modals", o6),
    e.component("f7-row", rS),
    e.component("f7-searchbar", uS),
    e.component("f7-segmented", pS),
    e.component("f7-sheet", n6),
    e.component("f7-skeleton-avatar", vS),
    e.component("f7-skeleton-block", hS),
    e.component("f7-skeleton-image", gS),
    e.component("f7-skeleton-text", mS),
    e.component("f7-stepper", _S),
    e.component("f7-subnavbar", ES),
    e.component("f7-swipeout-actions", TS),
    e.component("f7-swipeout-button", AS),
    e.component("f7-swiper-slide", ME),
    e.component("f7-swiper", TE),
    e.component("f7-tab", AE),
    e.component("f7-tabs", PE),
    e.component("f7-text-editor", zf),
    e.component("f7-toggle", u6),
    e.component("f7-toolbar", BE),
    e.component("f7-treeview-item", FE),
    e.component("f7-treeview", UE),
    e.component("f7-use-icon", wi),
    e.component("f7-view", Uo),
    e.component("f7-views", WE)
}
function R3(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var a = Object.getOwnPropertySymbols(e);
        t && (a = a.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable
        })),
        n.push.apply(n, a)
    }
    return n
}
function Ke(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? R3(Object(n), !0).forEach(function(a) {
            rn(e, a, n[a])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : R3(Object(n)).forEach(function(a) {
            Object.defineProperty(e, a, Object.getOwnPropertyDescriptor(n, a))
        })
    }
    return e
}
function S1(e) {
    return S1 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    }
    : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }
    ,
    S1(e)
}
function GE(e, t) {
    if (!(e instanceof t))
        throw new TypeError("Cannot call a class as a function")
}
function D3(e, t) {
    for (var n = 0; n < t.length; n++) {
        var a = t[n];
        a.enumerable = a.enumerable || !1,
        a.configurable = !0,
        "value"in a && (a.writable = !0),
        Object.defineProperty(e, a.key, a)
    }
}
function XE(e, t, n) {
    return t && D3(e.prototype, t),
    n && D3(e, n),
    Object.defineProperty(e, "prototype", {
        writable: !1
    }),
    e
}
function rn(e, t, n) {
    return t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n,
    e
}
function Pf(e, t) {
    return ZE(e) || QE(e, t) || M6(e, t) || tx()
}
function Js(e) {
    return KE(e) || JE(e) || M6(e) || ex()
}
function KE(e) {
    if (Array.isArray(e))
        return Q2(e)
}
function ZE(e) {
    if (Array.isArray(e))
        return e
}
function JE(e) {
    if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null)
        return Array.from(e)
}
function QE(e, t) {
    var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (n != null) {
        var a = [], r = !0, o = !1, i, s;
        try {
            for (n = n.call(e); !(r = (i = n.next()).done) && (a.push(i.value),
            !(t && a.length === t)); r = !0)
                ;
        } catch (l) {
            o = !0,
            s = l
        } finally {
            try {
                !r && n.return != null && n.return()
            } finally {
                if (o)
                    throw s
            }
        }
        return a
    }
}
function M6(e, t) {
    if (e) {
        if (typeof e == "string")
            return Q2(e, t);
        var n = Object.prototype.toString.call(e).slice(8, -1);
        if (n === "Object" && e.constructor && (n = e.constructor.name),
        n === "Map" || n === "Set")
            return Array.from(e);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return Q2(e, t)
    }
}
function Q2(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var n = 0, a = new Array(t); n < t; n++)
        a[n] = e[n];
    return a
}
function ex() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function tx() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
var N3 = function() {}
  , Lf = {}
  , z6 = {}
  , A6 = null
  , O6 = {
    mark: N3,
    measure: N3
};
try {
    typeof window < "u" && (Lf = window),
    typeof document < "u" && (z6 = document),
    typeof MutationObserver < "u" && (A6 = MutationObserver),
    typeof performance < "u" && (O6 = performance)
} catch {}
var nx = Lf.navigator || {}, H3 = nx.userAgent, V3 = H3 === void 0 ? "" : H3, Ir = Lf, At = z6, F3 = A6, $l = O6, oU = !!Ir.document, ur = !!At.documentElement && !!At.head && typeof At.addEventListener == "function" && typeof At.createElement == "function", P6 = ~V3.indexOf("MSIE") || ~V3.indexOf("Trident/"), El, xl, Tl, Ml, zl, rr = "___FONT_AWESOME___", eu = 16, L6 = "fa", I6 = "svg-inline--fa", ko = "data-fa-i2svg", tu = "data-fa-pseudo-element", ax = "data-fa-pseudo-element-pending", If = "data-prefix", Bf = "data-icon", j3 = "fontawesome-i2svg", rx = "async", ox = ["HTML", "HEAD", "STYLE", "SCRIPT"], B6 = function() {
    try {
        return !0
    } catch {
        return !1
    }
}(), zt = "classic", Nt = "sharp", Rf = [zt, Nt];
function Qs(e) {
    return new Proxy(e,{
        get: function(n, a) {
            return a in n ? n[a] : n[zt]
        }
    })
}
var Es = Qs((El = {},
rn(El, zt, {
    fa: "solid",
    fas: "solid",
    "fa-solid": "solid",
    far: "regular",
    "fa-regular": "regular",
    fal: "light",
    "fa-light": "light",
    fat: "thin",
    "fa-thin": "thin",
    fad: "duotone",
    "fa-duotone": "duotone",
    fab: "brands",
    "fa-brands": "brands",
    fak: "kit",
    "fa-kit": "kit"
}),
rn(El, Nt, {
    fa: "solid",
    fass: "solid",
    "fa-solid": "solid",
    fasr: "regular",
    "fa-regular": "regular"
}),
El))
  , xs = Qs((xl = {},
rn(xl, zt, {
    solid: "fas",
    regular: "far",
    light: "fal",
    thin: "fat",
    duotone: "fad",
    brands: "fab",
    kit: "fak"
}),
rn(xl, Nt, {
    solid: "fass",
    regular: "fasr"
}),
xl))
  , Ts = Qs((Tl = {},
rn(Tl, zt, {
    fab: "fa-brands",
    fad: "fa-duotone",
    fak: "fa-kit",
    fal: "fa-light",
    far: "fa-regular",
    fas: "fa-solid",
    fat: "fa-thin"
}),
rn(Tl, Nt, {
    fass: "fa-solid",
    fasr: "fa-regular"
}),
Tl))
  , ix = Qs((Ml = {},
rn(Ml, zt, {
    "fa-brands": "fab",
    "fa-duotone": "fad",
    "fa-kit": "fak",
    "fa-light": "fal",
    "fa-regular": "far",
    "fa-solid": "fas",
    "fa-thin": "fat"
}),
rn(Ml, Nt, {
    "fa-solid": "fass",
    "fa-regular": "fasr"
}),
Ml))
  , sx = /fa(s|r|l|t|d|b|k|ss|sr)?[\-\ ]/
  , R6 = "fa-layers-text"
  , lx = /Font ?Awesome ?([56 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp|Kit)?.*/i
  , cx = Qs((zl = {},
rn(zl, zt, {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal",
    100: "fat"
}),
rn(zl, Nt, {
    900: "fass",
    400: "fasr"
}),
zl))
  , D6 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
  , ux = D6.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20])
  , fx = ["class", "data-prefix", "data-icon", "data-fa-transform", "data-fa-mask"]
  , ro = {
    GROUP: "duotone-group",
    SWAP_OPACITY: "swap-opacity",
    PRIMARY: "primary",
    SECONDARY: "secondary"
}
  , Ms = new Set;
Object.keys(xs[zt]).map(Ms.add.bind(Ms));
Object.keys(xs[Nt]).map(Ms.add.bind(Ms));
var dx = [].concat(Rf, Js(Ms), ["2xs", "xs", "sm", "lg", "xl", "2xl", "beat", "border", "fade", "beat-fade", "bounce", "flip-both", "flip-horizontal", "flip-vertical", "flip", "fw", "inverse", "layers-counter", "layers-text", "layers", "li", "pull-left", "pull-right", "pulse", "rotate-180", "rotate-270", "rotate-90", "rotate-by", "shake", "spin-pulse", "spin-reverse", "spin", "stack-1x", "stack-2x", "stack", "ul", ro.GROUP, ro.SWAP_OPACITY, ro.PRIMARY, ro.SECONDARY]).concat(D6.map(function(e) {
    return "".concat(e, "x")
})).concat(ux.map(function(e) {
    return "w-".concat(e)
}))
  , ds = Ir.FontAwesomeConfig || {};
function px(e) {
    var t = At.querySelector("script[" + e + "]");
    if (t)
        return t.getAttribute(e)
}
function hx(e) {
    return e === "" ? !0 : e === "false" ? !1 : e === "true" ? !0 : e
}
if (At && typeof At.querySelector == "function") {
    var mx = [["data-family-prefix", "familyPrefix"], ["data-css-prefix", "cssPrefix"], ["data-family-default", "familyDefault"], ["data-style-default", "styleDefault"], ["data-replacement-class", "replacementClass"], ["data-auto-replace-svg", "autoReplaceSvg"], ["data-auto-add-css", "autoAddCss"], ["data-auto-a11y", "autoA11y"], ["data-search-pseudo-elements", "searchPseudoElements"], ["data-observe-mutations", "observeMutations"], ["data-mutate-approach", "mutateApproach"], ["data-keep-original-source", "keepOriginalSource"], ["data-measure-performance", "measurePerformance"], ["data-show-missing-icons", "showMissingIcons"]];
    mx.forEach(function(e) {
        var t = Pf(e, 2)
          , n = t[0]
          , a = t[1]
          , r = hx(px(n));
        r != null && (ds[a] = r)
    })
}
var N6 = {
    styleDefault: "solid",
    familyDefault: "classic",
    cssPrefix: L6,
    replacementClass: I6,
    autoReplaceSvg: !0,
    autoAddCss: !0,
    autoA11y: !0,
    searchPseudoElements: !1,
    observeMutations: !0,
    mutateApproach: "async",
    keepOriginalSource: !0,
    measurePerformance: !1,
    showMissingIcons: !0
};
ds.familyPrefix && (ds.cssPrefix = ds.familyPrefix);
var gi = Ke(Ke({}, N6), ds);
gi.autoReplaceSvg || (gi.observeMutations = !1);
var et = {};
Object.keys(N6).forEach(function(e) {
    Object.defineProperty(et, e, {
        enumerable: !0,
        set: function(n) {
            gi[e] = n,
            ps.forEach(function(a) {
                return a(et)
            })
        },
        get: function() {
            return gi[e]
        }
    })
});
Object.defineProperty(et, "familyPrefix", {
    enumerable: !0,
    set: function(t) {
        gi.cssPrefix = t,
        ps.forEach(function(n) {
            return n(et)
        })
    },
    get: function() {
        return gi.cssPrefix
    }
});
Ir.FontAwesomeConfig = et;
var ps = [];
function gx(e) {
    return ps.push(e),
    function() {
        ps.splice(ps.indexOf(e), 1)
    }
}
var yr = eu
  , Oa = {
    size: 16,
    x: 0,
    y: 0,
    rotate: 0,
    flipX: !1,
    flipY: !1
};
function vx(e) {
    if (!(!e || !ur)) {
        var t = At.createElement("style");
        t.setAttribute("type", "text/css"),
        t.innerHTML = e;
        for (var n = At.head.childNodes, a = null, r = n.length - 1; r > -1; r--) {
            var o = n[r]
              , i = (o.tagName || "").toUpperCase();
            ["STYLE", "LINK"].indexOf(i) > -1 && (a = o)
        }
        return At.head.insertBefore(t, a),
        e
    }
}
var bx = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
function zs() {
    for (var e = 12, t = ""; e-- > 0; )
        t += bx[Math.random() * 62 | 0];
    return t
}
function ki(e) {
    for (var t = [], n = (e || []).length >>> 0; n--; )
        t[n] = e[n];
    return t
}
function Df(e) {
    return e.classList ? ki(e.classList) : (e.getAttribute("class") || "").split(" ").filter(function(t) {
        return t
    })
}
function H6(e) {
    return "".concat(e).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;")
}
function yx(e) {
    return Object.keys(e || {}).reduce(function(t, n) {
        return t + "".concat(n, '="').concat(H6(e[n]), '" ')
    }, "").trim()
}
function sc(e) {
    return Object.keys(e || {}).reduce(function(t, n) {
        return t + "".concat(n, ": ").concat(e[n].trim(), ";")
    }, "")
}
function Nf(e) {
    return e.size !== Oa.size || e.x !== Oa.x || e.y !== Oa.y || e.rotate !== Oa.rotate || e.flipX || e.flipY
}
function Cx(e) {
    var t = e.transform
      , n = e.containerWidth
      , a = e.iconWidth
      , r = {
        transform: "translate(".concat(n / 2, " 256)")
    }
      , o = "translate(".concat(t.x * 32, ", ").concat(t.y * 32, ") ")
      , i = "scale(".concat(t.size / 16 * (t.flipX ? -1 : 1), ", ").concat(t.size / 16 * (t.flipY ? -1 : 1), ") ")
      , s = "rotate(".concat(t.rotate, " 0 0)")
      , l = {
        transform: "".concat(o, " ").concat(i, " ").concat(s)
    }
      , c = {
        transform: "translate(".concat(a / 2 * -1, " -256)")
    };
    return {
        outer: r,
        inner: l,
        path: c
    }
}
function wx(e) {
    var t = e.transform
      , n = e.width
      , a = n === void 0 ? eu : n
      , r = e.height
      , o = r === void 0 ? eu : r
      , i = e.startCentered
      , s = i === void 0 ? !1 : i
      , l = "";
    return s && P6 ? l += "translate(".concat(t.x / yr - a / 2, "em, ").concat(t.y / yr - o / 2, "em) ") : s ? l += "translate(calc(-50% + ".concat(t.x / yr, "em), calc(-50% + ").concat(t.y / yr, "em)) ") : l += "translate(".concat(t.x / yr, "em, ").concat(t.y / yr, "em) "),
    l += "scale(".concat(t.size / yr * (t.flipX ? -1 : 1), ", ").concat(t.size / yr * (t.flipY ? -1 : 1), ") "),
    l += "rotate(".concat(t.rotate, "deg) "),
    l
}
var _x = `:root, :host {
  --fa-font-solid: normal 900 1em/1 "Font Awesome 6 Solid";
  --fa-font-regular: normal 400 1em/1 "Font Awesome 6 Regular";
  --fa-font-light: normal 300 1em/1 "Font Awesome 6 Light";
  --fa-font-thin: normal 100 1em/1 "Font Awesome 6 Thin";
  --fa-font-duotone: normal 900 1em/1 "Font Awesome 6 Duotone";
  --fa-font-sharp-solid: normal 900 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-regular: normal 400 1em/1 "Font Awesome 6 Sharp";
  --fa-font-brands: normal 400 1em/1 "Font Awesome 6 Brands";
}

svg:not(:root).svg-inline--fa, svg:not(:host).svg-inline--fa {
  overflow: visible;
  box-sizing: content-box;
}

.svg-inline--fa {
  display: var(--fa-display, inline-block);
  height: 1em;
  overflow: visible;
  vertical-align: -0.125em;
}
.svg-inline--fa.fa-2xs {
  vertical-align: 0.1em;
}
.svg-inline--fa.fa-xs {
  vertical-align: 0em;
}
.svg-inline--fa.fa-sm {
  vertical-align: -0.0714285705em;
}
.svg-inline--fa.fa-lg {
  vertical-align: -0.2em;
}
.svg-inline--fa.fa-xl {
  vertical-align: -0.25em;
}
.svg-inline--fa.fa-2xl {
  vertical-align: -0.3125em;
}
.svg-inline--fa.fa-pull-left {
  margin-right: var(--fa-pull-margin, 0.3em);
  width: auto;
}
.svg-inline--fa.fa-pull-right {
  margin-left: var(--fa-pull-margin, 0.3em);
  width: auto;
}
.svg-inline--fa.fa-li {
  width: var(--fa-li-width, 2em);
  top: 0.25em;
}
.svg-inline--fa.fa-fw {
  width: var(--fa-fw-width, 1.25em);
}

.fa-layers svg.svg-inline--fa {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
}

.fa-layers-counter, .fa-layers-text {
  display: inline-block;
  position: absolute;
  text-align: center;
}

.fa-layers {
  display: inline-block;
  height: 1em;
  position: relative;
  text-align: center;
  vertical-align: -0.125em;
  width: 1em;
}
.fa-layers svg.svg-inline--fa {
  -webkit-transform-origin: center center;
          transform-origin: center center;
}

.fa-layers-text {
  left: 50%;
  top: 50%;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
  -webkit-transform-origin: center center;
          transform-origin: center center;
}

.fa-layers-counter {
  background-color: var(--fa-counter-background-color, #ff253a);
  border-radius: var(--fa-counter-border-radius, 1em);
  box-sizing: border-box;
  color: var(--fa-inverse, #fff);
  line-height: var(--fa-counter-line-height, 1);
  max-width: var(--fa-counter-max-width, 5em);
  min-width: var(--fa-counter-min-width, 1.5em);
  overflow: hidden;
  padding: var(--fa-counter-padding, 0.25em 0.5em);
  right: var(--fa-right, 0);
  text-overflow: ellipsis;
  top: var(--fa-top, 0);
  -webkit-transform: scale(var(--fa-counter-scale, 0.25));
          transform: scale(var(--fa-counter-scale, 0.25));
  -webkit-transform-origin: top right;
          transform-origin: top right;
}

.fa-layers-bottom-right {
  bottom: var(--fa-bottom, 0);
  right: var(--fa-right, 0);
  top: auto;
  -webkit-transform: scale(var(--fa-layers-scale, 0.25));
          transform: scale(var(--fa-layers-scale, 0.25));
  -webkit-transform-origin: bottom right;
          transform-origin: bottom right;
}

.fa-layers-bottom-left {
  bottom: var(--fa-bottom, 0);
  left: var(--fa-left, 0);
  right: auto;
  top: auto;
  -webkit-transform: scale(var(--fa-layers-scale, 0.25));
          transform: scale(var(--fa-layers-scale, 0.25));
  -webkit-transform-origin: bottom left;
          transform-origin: bottom left;
}

.fa-layers-top-right {
  top: var(--fa-top, 0);
  right: var(--fa-right, 0);
  -webkit-transform: scale(var(--fa-layers-scale, 0.25));
          transform: scale(var(--fa-layers-scale, 0.25));
  -webkit-transform-origin: top right;
          transform-origin: top right;
}

.fa-layers-top-left {
  left: var(--fa-left, 0);
  right: auto;
  top: var(--fa-top, 0);
  -webkit-transform: scale(var(--fa-layers-scale, 0.25));
          transform: scale(var(--fa-layers-scale, 0.25));
  -webkit-transform-origin: top left;
          transform-origin: top left;
}

.fa-1x {
  font-size: 1em;
}

.fa-2x {
  font-size: 2em;
}

.fa-3x {
  font-size: 3em;
}

.fa-4x {
  font-size: 4em;
}

.fa-5x {
  font-size: 5em;
}

.fa-6x {
  font-size: 6em;
}

.fa-7x {
  font-size: 7em;
}

.fa-8x {
  font-size: 8em;
}

.fa-9x {
  font-size: 9em;
}

.fa-10x {
  font-size: 10em;
}

.fa-2xs {
  font-size: 0.625em;
  line-height: 0.1em;
  vertical-align: 0.225em;
}

.fa-xs {
  font-size: 0.75em;
  line-height: 0.0833333337em;
  vertical-align: 0.125em;
}

.fa-sm {
  font-size: 0.875em;
  line-height: 0.0714285718em;
  vertical-align: 0.0535714295em;
}

.fa-lg {
  font-size: 1.25em;
  line-height: 0.05em;
  vertical-align: -0.075em;
}

.fa-xl {
  font-size: 1.5em;
  line-height: 0.0416666682em;
  vertical-align: -0.125em;
}

.fa-2xl {
  font-size: 2em;
  line-height: 0.03125em;
  vertical-align: -0.1875em;
}

.fa-fw {
  text-align: center;
  width: 1.25em;
}

.fa-ul {
  list-style-type: none;
  margin-left: var(--fa-li-margin, 2.5em);
  padding-left: 0;
}
.fa-ul > li {
  position: relative;
}

.fa-li {
  left: calc(var(--fa-li-width, 2em) * -1);
  position: absolute;
  text-align: center;
  width: var(--fa-li-width, 2em);
  line-height: inherit;
}

.fa-border {
  border-color: var(--fa-border-color, #eee);
  border-radius: var(--fa-border-radius, 0.1em);
  border-style: var(--fa-border-style, solid);
  border-width: var(--fa-border-width, 0.08em);
  padding: var(--fa-border-padding, 0.2em 0.25em 0.15em);
}

.fa-pull-left {
  float: left;
  margin-right: var(--fa-pull-margin, 0.3em);
}

.fa-pull-right {
  float: right;
  margin-left: var(--fa-pull-margin, 0.3em);
}

.fa-beat {
  -webkit-animation-name: fa-beat;
          animation-name: fa-beat;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, ease-in-out);
          animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-bounce {
  -webkit-animation-name: fa-bounce;
          animation-name: fa-bounce;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));
          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));
}

.fa-fade {
  -webkit-animation-name: fa-fade;
          animation-name: fa-fade;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-beat-fade {
  -webkit-animation-name: fa-beat-fade;
          animation-name: fa-beat-fade;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-flip {
  -webkit-animation-name: fa-flip;
          animation-name: fa-flip;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, ease-in-out);
          animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-shake {
  -webkit-animation-name: fa-shake;
          animation-name: fa-shake;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, linear);
          animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin {
  -webkit-animation-name: fa-spin;
          animation-name: fa-spin;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 2s);
          animation-duration: var(--fa-animation-duration, 2s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, linear);
          animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin-reverse {
  --fa-animation-direction: reverse;
}

.fa-pulse,
.fa-spin-pulse {
  -webkit-animation-name: fa-spin;
          animation-name: fa-spin;
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, steps(8));
          animation-timing-function: var(--fa-animation-timing, steps(8));
}

@media (prefers-reduced-motion: reduce) {
  .fa-beat,
.fa-bounce,
.fa-fade,
.fa-beat-fade,
.fa-flip,
.fa-pulse,
.fa-shake,
.fa-spin,
.fa-spin-pulse {
    -webkit-animation-delay: -1ms;
            animation-delay: -1ms;
    -webkit-animation-duration: 1ms;
            animation-duration: 1ms;
    -webkit-animation-iteration-count: 1;
            animation-iteration-count: 1;
    -webkit-transition-delay: 0s;
            transition-delay: 0s;
    -webkit-transition-duration: 0s;
            transition-duration: 0s;
  }
}
@-webkit-keyframes fa-beat {
  0%, 90% {
    -webkit-transform: scale(1);
            transform: scale(1);
  }
  45% {
    -webkit-transform: scale(var(--fa-beat-scale, 1.25));
            transform: scale(var(--fa-beat-scale, 1.25));
  }
}
@keyframes fa-beat {
  0%, 90% {
    -webkit-transform: scale(1);
            transform: scale(1);
  }
  45% {
    -webkit-transform: scale(var(--fa-beat-scale, 1.25));
            transform: scale(var(--fa-beat-scale, 1.25));
  }
}
@-webkit-keyframes fa-bounce {
  0% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
  10% {
    -webkit-transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
            transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
  }
  30% {
    -webkit-transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
            transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
  }
  50% {
    -webkit-transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
            transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
  }
  57% {
    -webkit-transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
            transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
  }
  64% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
  100% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
}
@keyframes fa-bounce {
  0% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
  10% {
    -webkit-transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
            transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
  }
  30% {
    -webkit-transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
            transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
  }
  50% {
    -webkit-transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
            transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
  }
  57% {
    -webkit-transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
            transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
  }
  64% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
  100% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
}
@-webkit-keyframes fa-fade {
  50% {
    opacity: var(--fa-fade-opacity, 0.4);
  }
}
@keyframes fa-fade {
  50% {
    opacity: var(--fa-fade-opacity, 0.4);
  }
}
@-webkit-keyframes fa-beat-fade {
  0%, 100% {
    opacity: var(--fa-beat-fade-opacity, 0.4);
    -webkit-transform: scale(1);
            transform: scale(1);
  }
  50% {
    opacity: 1;
    -webkit-transform: scale(var(--fa-beat-fade-scale, 1.125));
            transform: scale(var(--fa-beat-fade-scale, 1.125));
  }
}
@keyframes fa-beat-fade {
  0%, 100% {
    opacity: var(--fa-beat-fade-opacity, 0.4);
    -webkit-transform: scale(1);
            transform: scale(1);
  }
  50% {
    opacity: 1;
    -webkit-transform: scale(var(--fa-beat-fade-scale, 1.125));
            transform: scale(var(--fa-beat-fade-scale, 1.125));
  }
}
@-webkit-keyframes fa-flip {
  50% {
    -webkit-transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
            transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
  }
}
@keyframes fa-flip {
  50% {
    -webkit-transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
            transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
  }
}
@-webkit-keyframes fa-shake {
  0% {
    -webkit-transform: rotate(-15deg);
            transform: rotate(-15deg);
  }
  4% {
    -webkit-transform: rotate(15deg);
            transform: rotate(15deg);
  }
  8%, 24% {
    -webkit-transform: rotate(-18deg);
            transform: rotate(-18deg);
  }
  12%, 28% {
    -webkit-transform: rotate(18deg);
            transform: rotate(18deg);
  }
  16% {
    -webkit-transform: rotate(-22deg);
            transform: rotate(-22deg);
  }
  20% {
    -webkit-transform: rotate(22deg);
            transform: rotate(22deg);
  }
  32% {
    -webkit-transform: rotate(-12deg);
            transform: rotate(-12deg);
  }
  36% {
    -webkit-transform: rotate(12deg);
            transform: rotate(12deg);
  }
  40%, 100% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
}
@keyframes fa-shake {
  0% {
    -webkit-transform: rotate(-15deg);
            transform: rotate(-15deg);
  }
  4% {
    -webkit-transform: rotate(15deg);
            transform: rotate(15deg);
  }
  8%, 24% {
    -webkit-transform: rotate(-18deg);
            transform: rotate(-18deg);
  }
  12%, 28% {
    -webkit-transform: rotate(18deg);
            transform: rotate(18deg);
  }
  16% {
    -webkit-transform: rotate(-22deg);
            transform: rotate(-22deg);
  }
  20% {
    -webkit-transform: rotate(22deg);
            transform: rotate(22deg);
  }
  32% {
    -webkit-transform: rotate(-12deg);
            transform: rotate(-12deg);
  }
  36% {
    -webkit-transform: rotate(12deg);
            transform: rotate(12deg);
  }
  40%, 100% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
}
@-webkit-keyframes fa-spin {
  0% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
  100% {
    -webkit-transform: rotate(360deg);
            transform: rotate(360deg);
  }
}
@keyframes fa-spin {
  0% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
  100% {
    -webkit-transform: rotate(360deg);
            transform: rotate(360deg);
  }
}
.fa-rotate-90 {
  -webkit-transform: rotate(90deg);
          transform: rotate(90deg);
}

.fa-rotate-180 {
  -webkit-transform: rotate(180deg);
          transform: rotate(180deg);
}

.fa-rotate-270 {
  -webkit-transform: rotate(270deg);
          transform: rotate(270deg);
}

.fa-flip-horizontal {
  -webkit-transform: scale(-1, 1);
          transform: scale(-1, 1);
}

.fa-flip-vertical {
  -webkit-transform: scale(1, -1);
          transform: scale(1, -1);
}

.fa-flip-both,
.fa-flip-horizontal.fa-flip-vertical {
  -webkit-transform: scale(-1, -1);
          transform: scale(-1, -1);
}

.fa-rotate-by {
  -webkit-transform: rotate(var(--fa-rotate-angle, none));
          transform: rotate(var(--fa-rotate-angle, none));
}

.fa-stack {
  display: inline-block;
  vertical-align: middle;
  height: 2em;
  position: relative;
  width: 2.5em;
}

.fa-stack-1x,
.fa-stack-2x {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
  z-index: var(--fa-stack-z-index, auto);
}

.svg-inline--fa.fa-stack-1x {
  height: 1em;
  width: 1.25em;
}
.svg-inline--fa.fa-stack-2x {
  height: 2em;
  width: 2.5em;
}

.fa-inverse {
  color: var(--fa-inverse, #fff);
}

.sr-only,
.fa-sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.sr-only-focusable:not(:focus),
.fa-sr-only-focusable:not(:focus) {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.svg-inline--fa .fa-primary {
  fill: var(--fa-primary-color, currentColor);
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa .fa-secondary {
  fill: var(--fa-secondary-color, currentColor);
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-primary {
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-secondary {
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa mask .fa-primary,
.svg-inline--fa mask .fa-secondary {
  fill: black;
}

.fad.fa-inverse,
.fa-duotone.fa-inverse {
  color: var(--fa-inverse, #fff);
}`;
function V6() {
    var e = L6
      , t = I6
      , n = et.cssPrefix
      , a = et.replacementClass
      , r = _x;
    if (n !== e || a !== t) {
        var o = new RegExp("\\.".concat(e, "\\-"),"g")
          , i = new RegExp("\\--".concat(e, "\\-"),"g")
          , s = new RegExp("\\.".concat(t),"g");
        r = r.replace(o, ".".concat(n, "-")).replace(i, "--".concat(n, "-")).replace(s, ".".concat(a))
    }
    return r
}
var U3 = !1;
function Jc() {
    et.autoAddCss && !U3 && (vx(V6()),
    U3 = !0)
}
var kx = {
    mixout: function() {
        return {
            dom: {
                css: V6,
                insertCss: Jc
            }
        }
    },
    hooks: function() {
        return {
            beforeDOMElementCreation: function() {
                Jc()
            },
            beforeI2svg: function() {
                Jc()
            }
        }
    }
}
  , or = Ir || {};
or[rr] || (or[rr] = {});
or[rr].styles || (or[rr].styles = {});
or[rr].hooks || (or[rr].hooks = {});
or[rr].shims || (or[rr].shims = []);
var va = or[rr]
  , F6 = []
  , Sx = function e() {
    At.removeEventListener("DOMContentLoaded", e),
    $1 = 1,
    F6.map(function(t) {
        return t()
    })
}
  , $1 = !1;
ur && ($1 = (At.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(At.readyState),
$1 || At.addEventListener("DOMContentLoaded", Sx));
function $x(e) {
    ur && ($1 ? setTimeout(e, 0) : F6.push(e))
}
function el(e) {
    var t = e.tag
      , n = e.attributes
      , a = n === void 0 ? {} : n
      , r = e.children
      , o = r === void 0 ? [] : r;
    return typeof e == "string" ? H6(e) : "<".concat(t, " ").concat(yx(a), ">").concat(o.map(el).join(""), "</").concat(t, ">")
}
function q3(e, t, n) {
    if (e && e[t] && e[t][n])
        return {
            prefix: t,
            iconName: n,
            icon: e[t][n]
        }
}
var Ex = function(t, n) {
    return function(a, r, o, i) {
        return t.call(n, a, r, o, i)
    }
}
  , Qc = function(t, n, a, r) {
    var o = Object.keys(t), i = o.length, s = r !== void 0 ? Ex(n, r) : n, l, c, u;
    for (a === void 0 ? (l = 1,
    u = t[o[0]]) : (l = 0,
    u = a); l < i; l++)
        c = o[l],
        u = s(u, t[c], c, t);
    return u
};
function xx(e) {
    for (var t = [], n = 0, a = e.length; n < a; ) {
        var r = e.charCodeAt(n++);
        if (r >= 55296 && r <= 56319 && n < a) {
            var o = e.charCodeAt(n++);
            (o & 64512) == 56320 ? t.push(((r & 1023) << 10) + (o & 1023) + 65536) : (t.push(r),
            n--)
        } else
            t.push(r)
    }
    return t
}
function nu(e) {
    var t = xx(e);
    return t.length === 1 ? t[0].toString(16) : null
}
function Tx(e, t) {
    var n = e.length, a = e.charCodeAt(t), r;
    return a >= 55296 && a <= 56319 && n > t + 1 && (r = e.charCodeAt(t + 1),
    r >= 56320 && r <= 57343) ? (a - 55296) * 1024 + r - 56320 + 65536 : a
}
function W3(e) {
    return Object.keys(e).reduce(function(t, n) {
        var a = e[n]
          , r = !!a.icon;
        return r ? t[a.iconName] = a.icon : t[n] = a,
        t
    }, {})
}
function au(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}
      , a = n.skipHooks
      , r = a === void 0 ? !1 : a
      , o = W3(t);
    typeof va.hooks.addPack == "function" && !r ? va.hooks.addPack(e, W3(t)) : va.styles[e] = Ke(Ke({}, va.styles[e] || {}), o),
    e === "fas" && au("fa", t)
}
var Al, Ol, Pl, Xo = va.styles, Mx = va.shims, zx = (Al = {},
rn(Al, zt, Object.values(Ts[zt])),
rn(Al, Nt, Object.values(Ts[Nt])),
Al), Hf = null, j6 = {}, U6 = {}, q6 = {}, W6 = {}, Y6 = {}, Ax = (Ol = {},
rn(Ol, zt, Object.keys(Es[zt])),
rn(Ol, Nt, Object.keys(Es[Nt])),
Ol);
function Ox(e) {
    return ~dx.indexOf(e)
}
function Px(e, t) {
    var n = t.split("-")
      , a = n[0]
      , r = n.slice(1).join("-");
    return a === e && r !== "" && !Ox(r) ? r : null
}
var G6 = function() {
    var t = function(o) {
        return Qc(Xo, function(i, s, l) {
            return i[l] = Qc(s, o, {}),
            i
        }, {})
    };
    j6 = t(function(r, o, i) {
        if (o[3] && (r[o[3]] = i),
        o[2]) {
            var s = o[2].filter(function(l) {
                return typeof l == "number"
            });
            s.forEach(function(l) {
                r[l.toString(16)] = i
            })
        }
        return r
    }),
    U6 = t(function(r, o, i) {
        if (r[i] = i,
        o[2]) {
            var s = o[2].filter(function(l) {
                return typeof l == "string"
            });
            s.forEach(function(l) {
                r[l] = i
            })
        }
        return r
    }),
    Y6 = t(function(r, o, i) {
        var s = o[2];
        return r[i] = i,
        s.forEach(function(l) {
            r[l] = i
        }),
        r
    });
    var n = "far"in Xo || et.autoFetchSvg
      , a = Qc(Mx, function(r, o) {
        var i = o[0]
          , s = o[1]
          , l = o[2];
        return s === "far" && !n && (s = "fas"),
        typeof i == "string" && (r.names[i] = {
            prefix: s,
            iconName: l
        }),
        typeof i == "number" && (r.unicodes[i.toString(16)] = {
            prefix: s,
            iconName: l
        }),
        r
    }, {
        names: {},
        unicodes: {}
    });
    q6 = a.names,
    W6 = a.unicodes,
    Hf = lc(et.styleDefault, {
        family: et.familyDefault
    })
};
gx(function(e) {
    Hf = lc(e.styleDefault, {
        family: et.familyDefault
    })
});
G6();
function Vf(e, t) {
    return (j6[e] || {})[t]
}
function Lx(e, t) {
    return (U6[e] || {})[t]
}
function oo(e, t) {
    return (Y6[e] || {})[t]
}
function X6(e) {
    return q6[e] || {
        prefix: null,
        iconName: null
    }
}
function Ix(e) {
    var t = W6[e]
      , n = Vf("fas", e);
    return t || (n ? {
        prefix: "fas",
        iconName: n
    } : null) || {
        prefix: null,
        iconName: null
    }
}
function Br() {
    return Hf
}
var Ff = function() {
    return {
        prefix: null,
        iconName: null,
        rest: []
    }
};
function lc(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
      , n = t.family
      , a = n === void 0 ? zt : n
      , r = Es[a][e]
      , o = xs[a][e] || xs[a][r]
      , i = e in va.styles ? e : null;
    return o || i || null
}
var Y3 = (Pl = {},
rn(Pl, zt, Object.keys(Ts[zt])),
rn(Pl, Nt, Object.keys(Ts[Nt])),
Pl);
function cc(e) {
    var t, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, a = n.skipLookups, r = a === void 0 ? !1 : a, o = (t = {},
    rn(t, zt, "".concat(et.cssPrefix, "-").concat(zt)),
    rn(t, Nt, "".concat(et.cssPrefix, "-").concat(Nt)),
    t), i = null, s = zt;
    (e.includes(o[zt]) || e.some(function(c) {
        return Y3[zt].includes(c)
    })) && (s = zt),
    (e.includes(o[Nt]) || e.some(function(c) {
        return Y3[Nt].includes(c)
    })) && (s = Nt);
    var l = e.reduce(function(c, u) {
        var f = Px(et.cssPrefix, u);
        if (Xo[u] ? (u = zx[s].includes(u) ? ix[s][u] : u,
        i = u,
        c.prefix = u) : Ax[s].indexOf(u) > -1 ? (i = u,
        c.prefix = lc(u, {
            family: s
        })) : f ? c.iconName = f : u !== et.replacementClass && u !== o[zt] && u !== o[Nt] && c.rest.push(u),
        !r && c.prefix && c.iconName) {
            var d = i === "fa" ? X6(c.iconName) : {}
              , p = oo(c.prefix, c.iconName);
            d.prefix && (i = null),
            c.iconName = d.iconName || p || c.iconName,
            c.prefix = d.prefix || c.prefix,
            c.prefix === "far" && !Xo.far && Xo.fas && !et.autoFetchSvg && (c.prefix = "fas")
        }
        return c
    }, Ff());
    return (e.includes("fa-brands") || e.includes("fab")) && (l.prefix = "fab"),
    (e.includes("fa-duotone") || e.includes("fad")) && (l.prefix = "fad"),
    !l.prefix && s === Nt && (Xo.fass || et.autoFetchSvg) && (l.prefix = "fass",
    l.iconName = oo(l.prefix, l.iconName) || l.iconName),
    (l.prefix === "fa" || i === "fa") && (l.prefix = Br() || "fas"),
    l
}
var Bx = function() {
    function e() {
        GE(this, e),
        this.definitions = {}
    }
    return XE(e, [{
        key: "add",
        value: function() {
            for (var n = this, a = arguments.length, r = new Array(a), o = 0; o < a; o++)
                r[o] = arguments[o];
            var i = r.reduce(this._pullDefinitions, {});
            Object.keys(i).forEach(function(s) {
                n.definitions[s] = Ke(Ke({}, n.definitions[s] || {}), i[s]),
                au(s, i[s]);
                var l = Ts[zt][s];
                l && au(l, i[s]),
                G6()
            })
        }
    }, {
        key: "reset",
        value: function() {
            this.definitions = {}
        }
    }, {
        key: "_pullDefinitions",
        value: function(n, a) {
            var r = a.prefix && a.iconName && a.icon ? {
                0: a
            } : a;
            return Object.keys(r).map(function(o) {
                var i = r[o]
                  , s = i.prefix
                  , l = i.iconName
                  , c = i.icon
                  , u = c[2];
                n[s] || (n[s] = {}),
                u.length > 0 && u.forEach(function(f) {
                    typeof f == "string" && (n[s][f] = c)
                }),
                n[s][l] = c
            }),
            n
        }
    }]),
    e
}()
  , G3 = []
  , Ko = {}
  , oi = {}
  , Rx = Object.keys(oi);
function Dx(e, t) {
    var n = t.mixoutsTo;
    return G3 = e,
    Ko = {},
    Object.keys(oi).forEach(function(a) {
        Rx.indexOf(a) === -1 && delete oi[a]
    }),
    G3.forEach(function(a) {
        var r = a.mixout ? a.mixout() : {};
        if (Object.keys(r).forEach(function(i) {
            typeof r[i] == "function" && (n[i] = r[i]),
            S1(r[i]) === "object" && Object.keys(r[i]).forEach(function(s) {
                n[i] || (n[i] = {}),
                n[i][s] = r[i][s]
            })
        }),
        a.hooks) {
            var o = a.hooks();
            Object.keys(o).forEach(function(i) {
                Ko[i] || (Ko[i] = []),
                Ko[i].push(o[i])
            })
        }
        a.provides && a.provides(oi)
    }),
    n
}
function ru(e, t) {
    for (var n = arguments.length, a = new Array(n > 2 ? n - 2 : 0), r = 2; r < n; r++)
        a[r - 2] = arguments[r];
    var o = Ko[e] || [];
    return o.forEach(function(i) {
        t = i.apply(null, [t].concat(a))
    }),
    t
}
function So(e) {
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), a = 1; a < t; a++)
        n[a - 1] = arguments[a];
    var r = Ko[e] || [];
    r.forEach(function(o) {
        o.apply(null, n)
    })
}
function ir() {
    var e = arguments[0]
      , t = Array.prototype.slice.call(arguments, 1);
    return oi[e] ? oi[e].apply(null, t) : void 0
}
function ou(e) {
    e.prefix === "fa" && (e.prefix = "fas");
    var t = e.iconName
      , n = e.prefix || Br();
    if (t)
        return t = oo(n, t) || t,
        q3(K6.definitions, n, t) || q3(va.styles, n, t)
}
var K6 = new Bx
  , Nx = function() {
    et.autoReplaceSvg = !1,
    et.observeMutations = !1,
    So("noAuto")
}
  , Hx = {
    i2svg: function() {
        var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return ur ? (So("beforeI2svg", t),
        ir("pseudoElements2svg", t),
        ir("i2svg", t)) : Promise.reject("Operation requires a DOM of some kind.")
    },
    watch: function() {
        var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
          , n = t.autoReplaceSvgRoot;
        et.autoReplaceSvg === !1 && (et.autoReplaceSvg = !0),
        et.observeMutations = !0,
        $x(function() {
            Fx({
                autoReplaceSvgRoot: n
            }),
            So("watch", t)
        })
    }
}
  , Vx = {
    icon: function(t) {
        if (t === null)
            return null;
        if (S1(t) === "object" && t.prefix && t.iconName)
            return {
                prefix: t.prefix,
                iconName: oo(t.prefix, t.iconName) || t.iconName
            };
        if (Array.isArray(t) && t.length === 2) {
            var n = t[1].indexOf("fa-") === 0 ? t[1].slice(3) : t[1]
              , a = lc(t[0]);
            return {
                prefix: a,
                iconName: oo(a, n) || n
            }
        }
        if (typeof t == "string" && (t.indexOf("".concat(et.cssPrefix, "-")) > -1 || t.match(sx))) {
            var r = cc(t.split(" "), {
                skipLookups: !0
            });
            return {
                prefix: r.prefix || Br(),
                iconName: oo(r.prefix, r.iconName) || r.iconName
            }
        }
        if (typeof t == "string") {
            var o = Br();
            return {
                prefix: o,
                iconName: oo(o, t) || t
            }
        }
    }
}
  , qn = {
    noAuto: Nx,
    config: et,
    dom: Hx,
    parse: Vx,
    library: K6,
    findIconDefinition: ou,
    toHtml: el
}
  , Fx = function() {
    var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
      , n = t.autoReplaceSvgRoot
      , a = n === void 0 ? At : n;
    (Object.keys(va.styles).length > 0 || et.autoFetchSvg) && ur && et.autoReplaceSvg && qn.dom.i2svg({
        node: a
    })
};
function uc(e, t) {
    return Object.defineProperty(e, "abstract", {
        get: t
    }),
    Object.defineProperty(e, "html", {
        get: function() {
            return e.abstract.map(function(a) {
                return el(a)
            })
        }
    }),
    Object.defineProperty(e, "node", {
        get: function() {
            if (ur) {
                var a = At.createElement("div");
                return a.innerHTML = e.html,
                a.children
            }
        }
    }),
    e
}
function jx(e) {
    var t = e.children
      , n = e.main
      , a = e.mask
      , r = e.attributes
      , o = e.styles
      , i = e.transform;
    if (Nf(i) && n.found && !a.found) {
        var s = n.width
          , l = n.height
          , c = {
            x: s / l / 2,
            y: .5
        };
        r.style = sc(Ke(Ke({}, o), {}, {
            "transform-origin": "".concat(c.x + i.x / 16, "em ").concat(c.y + i.y / 16, "em")
        }))
    }
    return [{
        tag: "svg",
        attributes: r,
        children: t
    }]
}
function Ux(e) {
    var t = e.prefix
      , n = e.iconName
      , a = e.children
      , r = e.attributes
      , o = e.symbol
      , i = o === !0 ? "".concat(t, "-").concat(et.cssPrefix, "-").concat(n) : o;
    return [{
        tag: "svg",
        attributes: {
            style: "display: none;"
        },
        children: [{
            tag: "symbol",
            attributes: Ke(Ke({}, r), {}, {
                id: i
            }),
            children: a
        }]
    }]
}
function jf(e) {
    var t = e.icons
      , n = t.main
      , a = t.mask
      , r = e.prefix
      , o = e.iconName
      , i = e.transform
      , s = e.symbol
      , l = e.title
      , c = e.maskId
      , u = e.titleId
      , f = e.extra
      , d = e.watchable
      , p = d === void 0 ? !1 : d
      , h = a.found ? a : n
      , m = h.width
      , g = h.height
      , b = r === "fak"
      , v = [et.replacementClass, o ? "".concat(et.cssPrefix, "-").concat(o) : ""].filter(function(T) {
        return f.classes.indexOf(T) === -1
    }).filter(function(T) {
        return T !== "" || !!T
    }).concat(f.classes).join(" ")
      , y = {
        children: [],
        attributes: Ke(Ke({}, f.attributes), {}, {
            "data-prefix": r,
            "data-icon": o,
            class: v,
            role: f.attributes.role || "img",
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 ".concat(m, " ").concat(g)
        })
    }
      , w = b && !~f.classes.indexOf("fa-fw") ? {
        width: "".concat(m / g * 16 * .0625, "em")
    } : {};
    p && (y.attributes[ko] = ""),
    l && (y.children.push({
        tag: "title",
        attributes: {
            id: y.attributes["aria-labelledby"] || "title-".concat(u || zs())
        },
        children: [l]
    }),
    delete y.attributes.title);
    var C = Ke(Ke({}, y), {}, {
        prefix: r,
        iconName: o,
        main: n,
        mask: a,
        maskId: c,
        transform: i,
        symbol: s,
        styles: Ke(Ke({}, w), f.styles)
    })
      , _ = a.found && n.found ? ir("generateAbstractMask", C) || {
        children: [],
        attributes: {}
    } : ir("generateAbstractIcon", C) || {
        children: [],
        attributes: {}
    }
      , E = _.children
      , z = _.attributes;
    return C.children = E,
    C.attributes = z,
    s ? Ux(C) : jx(C)
}
function X3(e) {
    var t = e.content
      , n = e.width
      , a = e.height
      , r = e.transform
      , o = e.title
      , i = e.extra
      , s = e.watchable
      , l = s === void 0 ? !1 : s
      , c = Ke(Ke(Ke({}, i.attributes), o ? {
        title: o
    } : {}), {}, {
        class: i.classes.join(" ")
    });
    l && (c[ko] = "");
    var u = Ke({}, i.styles);
    Nf(r) && (u.transform = wx({
        transform: r,
        startCentered: !0,
        width: n,
        height: a
    }),
    u["-webkit-transform"] = u.transform);
    var f = sc(u);
    f.length > 0 && (c.style = f);
    var d = [];
    return d.push({
        tag: "span",
        attributes: c,
        children: [t]
    }),
    o && d.push({
        tag: "span",
        attributes: {
            class: "sr-only"
        },
        children: [o]
    }),
    d
}
function qx(e) {
    var t = e.content
      , n = e.title
      , a = e.extra
      , r = Ke(Ke(Ke({}, a.attributes), n ? {
        title: n
    } : {}), {}, {
        class: a.classes.join(" ")
    })
      , o = sc(a.styles);
    o.length > 0 && (r.style = o);
    var i = [];
    return i.push({
        tag: "span",
        attributes: r,
        children: [t]
    }),
    n && i.push({
        tag: "span",
        attributes: {
            class: "sr-only"
        },
        children: [n]
    }),
    i
}
var e2 = va.styles;
function iu(e) {
    var t = e[0]
      , n = e[1]
      , a = e.slice(4)
      , r = Pf(a, 1)
      , o = r[0]
      , i = null;
    return Array.isArray(o) ? i = {
        tag: "g",
        attributes: {
            class: "".concat(et.cssPrefix, "-").concat(ro.GROUP)
        },
        children: [{
            tag: "path",
            attributes: {
                class: "".concat(et.cssPrefix, "-").concat(ro.SECONDARY),
                fill: "currentColor",
                d: o[0]
            }
        }, {
            tag: "path",
            attributes: {
                class: "".concat(et.cssPrefix, "-").concat(ro.PRIMARY),
                fill: "currentColor",
                d: o[1]
            }
        }]
    } : i = {
        tag: "path",
        attributes: {
            fill: "currentColor",
            d: o
        }
    },
    {
        found: !0,
        width: t,
        height: n,
        icon: i
    }
}
var Wx = {
    found: !1,
    width: 512,
    height: 512
};
function Yx(e, t) {
    !B6 && !et.showMissingIcons && e && console.error('Icon with name "'.concat(e, '" and prefix "').concat(t, '" is missing.'))
}
function su(e, t) {
    var n = t;
    return t === "fa" && et.styleDefault !== null && (t = Br()),
    new Promise(function(a, r) {
        var o = {
            found: !1,
            width: 512,
            height: 512,
            icon: ir("missingIconAbstract") || {}
        };
        if (n === "fa") {
            var i = X6(e) || {};
            e = i.iconName || e,
            t = i.prefix || t
        }
        if (e && t && e2[t] && e2[t][e]) {
            var s = e2[t][e];
            return a(iu(s))
        }
        Yx(e, t),
        a(Ke(Ke({}, Wx), {}, {
            icon: et.showMissingIcons && e ? ir("missingIconAbstract") || {} : {}
        }))
    }
    )
}
var K3 = function() {}
  , lu = et.measurePerformance && $l && $l.mark && $l.measure ? $l : {
    mark: K3,
    measure: K3
}
  , Qi = 'FA "6.3.0"'
  , Gx = function(t) {
    return lu.mark("".concat(Qi, " ").concat(t, " begins")),
    function() {
        return Z6(t)
    }
}
  , Z6 = function(t) {
    lu.mark("".concat(Qi, " ").concat(t, " ends")),
    lu.measure("".concat(Qi, " ").concat(t), "".concat(Qi, " ").concat(t, " begins"), "".concat(Qi, " ").concat(t, " ends"))
}
  , Uf = {
    begin: Gx,
    end: Z6
}
  , Yl = function() {};
function Z3(e) {
    var t = e.getAttribute ? e.getAttribute(ko) : null;
    return typeof t == "string"
}
function Xx(e) {
    var t = e.getAttribute ? e.getAttribute(If) : null
      , n = e.getAttribute ? e.getAttribute(Bf) : null;
    return t && n
}
function Kx(e) {
    return e && e.classList && e.classList.contains && e.classList.contains(et.replacementClass)
}
function Zx() {
    if (et.autoReplaceSvg === !0)
        return Gl.replace;
    var e = Gl[et.autoReplaceSvg];
    return e || Gl.replace
}
function Jx(e) {
    return At.createElementNS("http://www.w3.org/2000/svg", e)
}
function Qx(e) {
    return At.createElement(e)
}
function J6(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
      , n = t.ceFn
      , a = n === void 0 ? e.tag === "svg" ? Jx : Qx : n;
    if (typeof e == "string")
        return At.createTextNode(e);
    var r = a(e.tag);
    Object.keys(e.attributes || []).forEach(function(i) {
        r.setAttribute(i, e.attributes[i])
    });
    var o = e.children || [];
    return o.forEach(function(i) {
        r.appendChild(J6(i, {
            ceFn: a
        }))
    }),
    r
}
function eT(e) {
    var t = " ".concat(e.outerHTML, " ");
    return t = "".concat(t, "Font Awesome fontawesome.com "),
    t
}
var Gl = {
    replace: function(t) {
        var n = t[0];
        if (n.parentNode)
            if (t[1].forEach(function(r) {
                n.parentNode.insertBefore(J6(r), n)
            }),
            n.getAttribute(ko) === null && et.keepOriginalSource) {
                var a = At.createComment(eT(n));
                n.parentNode.replaceChild(a, n)
            } else
                n.remove()
    },
    nest: function(t) {
        var n = t[0]
          , a = t[1];
        if (~Df(n).indexOf(et.replacementClass))
            return Gl.replace(t);
        var r = new RegExp("".concat(et.cssPrefix, "-.*"));
        if (delete a[0].attributes.id,
        a[0].attributes.class) {
            var o = a[0].attributes.class.split(" ").reduce(function(s, l) {
                return l === et.replacementClass || l.match(r) ? s.toSvg.push(l) : s.toNode.push(l),
                s
            }, {
                toNode: [],
                toSvg: []
            });
            a[0].attributes.class = o.toSvg.join(" "),
            o.toNode.length === 0 ? n.removeAttribute("class") : n.setAttribute("class", o.toNode.join(" "))
        }
        var i = a.map(function(s) {
            return el(s)
        }).join(`
`);
        n.setAttribute(ko, ""),
        n.innerHTML = i
    }
};
function J3(e) {
    e()
}
function Q6(e, t) {
    var n = typeof t == "function" ? t : Yl;
    if (e.length === 0)
        n();
    else {
        var a = J3;
        et.mutateApproach === rx && (a = Ir.requestAnimationFrame || J3),
        a(function() {
            var r = Zx()
              , o = Uf.begin("mutate");
            e.map(r),
            o(),
            n()
        })
    }
}
var qf = !1;
function e8() {
    qf = !0
}
function cu() {
    qf = !1
}
var E1 = null;
function Q3(e) {
    if (F3 && et.observeMutations) {
        var t = e.treeCallback
          , n = t === void 0 ? Yl : t
          , a = e.nodeCallback
          , r = a === void 0 ? Yl : a
          , o = e.pseudoElementsCallback
          , i = o === void 0 ? Yl : o
          , s = e.observeMutationsRoot
          , l = s === void 0 ? At : s;
        E1 = new F3(function(c) {
            if (!qf) {
                var u = Br();
                ki(c).forEach(function(f) {
                    if (f.type === "childList" && f.addedNodes.length > 0 && !Z3(f.addedNodes[0]) && (et.searchPseudoElements && i(f.target),
                    n(f.target)),
                    f.type === "attributes" && f.target.parentNode && et.searchPseudoElements && i(f.target.parentNode),
                    f.type === "attributes" && Z3(f.target) && ~fx.indexOf(f.attributeName))
                        if (f.attributeName === "class" && Xx(f.target)) {
                            var d = cc(Df(f.target))
                              , p = d.prefix
                              , h = d.iconName;
                            f.target.setAttribute(If, p || u),
                            h && f.target.setAttribute(Bf, h)
                        } else
                            Kx(f.target) && r(f.target)
                })
            }
        }
        ),
        ur && E1.observe(l, {
            childList: !0,
            attributes: !0,
            characterData: !0,
            subtree: !0
        })
    }
}
function tT() {
    E1 && E1.disconnect()
}
function nT(e) {
    var t = e.getAttribute("style")
      , n = [];
    return t && (n = t.split(";").reduce(function(a, r) {
        var o = r.split(":")
          , i = o[0]
          , s = o.slice(1);
        return i && s.length > 0 && (a[i] = s.join(":").trim()),
        a
    }, {})),
    n
}
function aT(e) {
    var t = e.getAttribute("data-prefix")
      , n = e.getAttribute("data-icon")
      , a = e.innerText !== void 0 ? e.innerText.trim() : ""
      , r = cc(Df(e));
    return r.prefix || (r.prefix = Br()),
    t && n && (r.prefix = t,
    r.iconName = n),
    r.iconName && r.prefix || (r.prefix && a.length > 0 && (r.iconName = Lx(r.prefix, e.innerText) || Vf(r.prefix, nu(e.innerText))),
    !r.iconName && et.autoFetchSvg && e.firstChild && e.firstChild.nodeType === Node.TEXT_NODE && (r.iconName = e.firstChild.data)),
    r
}
function rT(e) {
    var t = ki(e.attributes).reduce(function(r, o) {
        return r.name !== "class" && r.name !== "style" && (r[o.name] = o.value),
        r
    }, {})
      , n = e.getAttribute("title")
      , a = e.getAttribute("data-fa-title-id");
    return et.autoA11y && (n ? t["aria-labelledby"] = "".concat(et.replacementClass, "-title-").concat(a || zs()) : (t["aria-hidden"] = "true",
    t.focusable = "false")),
    t
}
function oT() {
    return {
        iconName: null,
        title: null,
        titleId: null,
        prefix: null,
        transform: Oa,
        symbol: !1,
        mask: {
            iconName: null,
            prefix: null,
            rest: []
        },
        maskId: null,
        extra: {
            classes: [],
            styles: {},
            attributes: {}
        }
    }
}
function e4(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        styleParser: !0
    }
      , n = aT(e)
      , a = n.iconName
      , r = n.prefix
      , o = n.rest
      , i = rT(e)
      , s = ru("parseNodeAttributes", {}, e)
      , l = t.styleParser ? nT(e) : [];
    return Ke({
        iconName: a,
        title: e.getAttribute("title"),
        titleId: e.getAttribute("data-fa-title-id"),
        prefix: r,
        transform: Oa,
        mask: {
            iconName: null,
            prefix: null,
            rest: []
        },
        maskId: null,
        symbol: !1,
        extra: {
            classes: o,
            styles: l,
            attributes: i
        }
    }, s)
}
var iT = va.styles;
function t8(e) {
    var t = et.autoReplaceSvg === "nest" ? e4(e, {
        styleParser: !1
    }) : e4(e);
    return ~t.extra.classes.indexOf(R6) ? ir("generateLayersText", e, t) : ir("generateSvgReplacementMutation", e, t)
}
var Rr = new Set;
Rf.map(function(e) {
    Rr.add("fa-".concat(e))
});
Object.keys(Es[zt]).map(Rr.add.bind(Rr));
Object.keys(Es[Nt]).map(Rr.add.bind(Rr));
Rr = Js(Rr);
function t4(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (!ur)
        return Promise.resolve();
    var n = At.documentElement.classList
      , a = function(f) {
        return n.add("".concat(j3, "-").concat(f))
    }
      , r = function(f) {
        return n.remove("".concat(j3, "-").concat(f))
    }
      , o = et.autoFetchSvg ? Rr : Rf.map(function(u) {
        return "fa-".concat(u)
    }).concat(Object.keys(iT));
    o.includes("fa") || o.push("fa");
    var i = [".".concat(R6, ":not([").concat(ko, "])")].concat(o.map(function(u) {
        return ".".concat(u, ":not([").concat(ko, "])")
    })).join(", ");
    if (i.length === 0)
        return Promise.resolve();
    var s = [];
    try {
        s = ki(e.querySelectorAll(i))
    } catch {}
    if (s.length > 0)
        a("pending"),
        r("complete");
    else
        return Promise.resolve();
    var l = Uf.begin("onTree")
      , c = s.reduce(function(u, f) {
        try {
            var d = t8(f);
            d && u.push(d)
        } catch (p) {
            B6 || p.name === "MissingIcon" && console.error(p)
        }
        return u
    }, []);
    return new Promise(function(u, f) {
        Promise.all(c).then(function(d) {
            Q6(d, function() {
                a("active"),
                a("complete"),
                r("pending"),
                typeof t == "function" && t(),
                l(),
                u()
            })
        }).catch(function(d) {
            l(),
            f(d)
        })
    }
    )
}
function sT(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    t8(e).then(function(n) {
        n && Q6([n], t)
    })
}
function lT(e) {
    return function(t) {
        var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
          , a = (t || {}).icon ? t : ou(t || {})
          , r = n.mask;
        return r && (r = (r || {}).icon ? r : ou(r || {})),
        e(a, Ke(Ke({}, n), {}, {
            mask: r
        }))
    }
}
var cT = function(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
      , a = n.transform
      , r = a === void 0 ? Oa : a
      , o = n.symbol
      , i = o === void 0 ? !1 : o
      , s = n.mask
      , l = s === void 0 ? null : s
      , c = n.maskId
      , u = c === void 0 ? null : c
      , f = n.title
      , d = f === void 0 ? null : f
      , p = n.titleId
      , h = p === void 0 ? null : p
      , m = n.classes
      , g = m === void 0 ? [] : m
      , b = n.attributes
      , v = b === void 0 ? {} : b
      , y = n.styles
      , w = y === void 0 ? {} : y;
    if (t) {
        var C = t.prefix
          , _ = t.iconName
          , E = t.icon;
        return uc(Ke({
            type: "icon"
        }, t), function() {
            return So("beforeDOMElementCreation", {
                iconDefinition: t,
                params: n
            }),
            et.autoA11y && (d ? v["aria-labelledby"] = "".concat(et.replacementClass, "-title-").concat(h || zs()) : (v["aria-hidden"] = "true",
            v.focusable = "false")),
            jf({
                icons: {
                    main: iu(E),
                    mask: l ? iu(l.icon) : {
                        found: !1,
                        width: null,
                        height: null,
                        icon: {}
                    }
                },
                prefix: C,
                iconName: _,
                transform: Ke(Ke({}, Oa), r),
                symbol: i,
                title: d,
                maskId: u,
                titleId: h,
                extra: {
                    attributes: v,
                    styles: w,
                    classes: g
                }
            })
        })
    }
}
  , uT = {
    mixout: function() {
        return {
            icon: lT(cT)
        }
    },
    hooks: function() {
        return {
            mutationObserverCallbacks: function(n) {
                return n.treeCallback = t4,
                n.nodeCallback = sT,
                n
            }
        }
    },
    provides: function(t) {
        t.i2svg = function(n) {
            var a = n.node
              , r = a === void 0 ? At : a
              , o = n.callback
              , i = o === void 0 ? function() {}
            : o;
            return t4(r, i)
        }
        ,
        t.generateSvgReplacementMutation = function(n, a) {
            var r = a.iconName
              , o = a.title
              , i = a.titleId
              , s = a.prefix
              , l = a.transform
              , c = a.symbol
              , u = a.mask
              , f = a.maskId
              , d = a.extra;
            return new Promise(function(p, h) {
                Promise.all([su(r, s), u.iconName ? su(u.iconName, u.prefix) : Promise.resolve({
                    found: !1,
                    width: 512,
                    height: 512,
                    icon: {}
                })]).then(function(m) {
                    var g = Pf(m, 2)
                      , b = g[0]
                      , v = g[1];
                    p([n, jf({
                        icons: {
                            main: b,
                            mask: v
                        },
                        prefix: s,
                        iconName: r,
                        transform: l,
                        symbol: c,
                        maskId: f,
                        title: o,
                        titleId: i,
                        extra: d,
                        watchable: !0
                    })])
                }).catch(h)
            }
            )
        }
        ,
        t.generateAbstractIcon = function(n) {
            var a = n.children
              , r = n.attributes
              , o = n.main
              , i = n.transform
              , s = n.styles
              , l = sc(s);
            l.length > 0 && (r.style = l);
            var c;
            return Nf(i) && (c = ir("generateAbstractTransformGrouping", {
                main: o,
                transform: i,
                containerWidth: o.width,
                iconWidth: o.width
            })),
            a.push(c || o.icon),
            {
                children: a,
                attributes: r
            }
        }
    }
}
  , fT = {
    mixout: function() {
        return {
            layer: function(n) {
                var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
                  , r = a.classes
                  , o = r === void 0 ? [] : r;
                return uc({
                    type: "layer"
                }, function() {
                    So("beforeDOMElementCreation", {
                        assembler: n,
                        params: a
                    });
                    var i = [];
                    return n(function(s) {
                        Array.isArray(s) ? s.map(function(l) {
                            i = i.concat(l.abstract)
                        }) : i = i.concat(s.abstract)
                    }),
                    [{
                        tag: "span",
                        attributes: {
                            class: ["".concat(et.cssPrefix, "-layers")].concat(Js(o)).join(" ")
                        },
                        children: i
                    }]
                })
            }
        }
    }
}
  , dT = {
    mixout: function() {
        return {
            counter: function(n) {
                var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
                  , r = a.title
                  , o = r === void 0 ? null : r
                  , i = a.classes
                  , s = i === void 0 ? [] : i
                  , l = a.attributes
                  , c = l === void 0 ? {} : l
                  , u = a.styles
                  , f = u === void 0 ? {} : u;
                return uc({
                    type: "counter",
                    content: n
                }, function() {
                    return So("beforeDOMElementCreation", {
                        content: n,
                        params: a
                    }),
                    qx({
                        content: n.toString(),
                        title: o,
                        extra: {
                            attributes: c,
                            styles: f,
                            classes: ["".concat(et.cssPrefix, "-layers-counter")].concat(Js(s))
                        }
                    })
                })
            }
        }
    }
}
  , pT = {
    mixout: function() {
        return {
            text: function(n) {
                var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
                  , r = a.transform
                  , o = r === void 0 ? Oa : r
                  , i = a.title
                  , s = i === void 0 ? null : i
                  , l = a.classes
                  , c = l === void 0 ? [] : l
                  , u = a.attributes
                  , f = u === void 0 ? {} : u
                  , d = a.styles
                  , p = d === void 0 ? {} : d;
                return uc({
                    type: "text",
                    content: n
                }, function() {
                    return So("beforeDOMElementCreation", {
                        content: n,
                        params: a
                    }),
                    X3({
                        content: n,
                        transform: Ke(Ke({}, Oa), o),
                        title: s,
                        extra: {
                            attributes: f,
                            styles: p,
                            classes: ["".concat(et.cssPrefix, "-layers-text")].concat(Js(c))
                        }
                    })
                })
            }
        }
    },
    provides: function(t) {
        t.generateLayersText = function(n, a) {
            var r = a.title
              , o = a.transform
              , i = a.extra
              , s = null
              , l = null;
            if (P6) {
                var c = parseInt(getComputedStyle(n).fontSize, 10)
                  , u = n.getBoundingClientRect();
                s = u.width / c,
                l = u.height / c
            }
            return et.autoA11y && !r && (i.attributes["aria-hidden"] = "true"),
            Promise.resolve([n, X3({
                content: n.innerHTML,
                width: s,
                height: l,
                transform: o,
                title: r,
                extra: i,
                watchable: !0
            })])
        }
    }
}
  , hT = new RegExp('"',"ug")
  , n4 = [1105920, 1112319];
function mT(e) {
    var t = e.replace(hT, "")
      , n = Tx(t, 0)
      , a = n >= n4[0] && n <= n4[1]
      , r = t.length === 2 ? t[0] === t[1] : !1;
    return {
        value: nu(r ? t[0] : t),
        isSecondary: a || r
    }
}
function a4(e, t) {
    var n = "".concat(ax).concat(t.replace(":", "-"));
    return new Promise(function(a, r) {
        if (e.getAttribute(n) !== null)
            return a();
        var o = ki(e.children)
          , i = o.filter(function(E) {
            return E.getAttribute(tu) === t
        })[0]
          , s = Ir.getComputedStyle(e, t)
          , l = s.getPropertyValue("font-family").match(lx)
          , c = s.getPropertyValue("font-weight")
          , u = s.getPropertyValue("content");
        if (i && !l)
            return e.removeChild(i),
            a();
        if (l && u !== "none" && u !== "") {
            var f = s.getPropertyValue("content")
              , d = ~["Sharp"].indexOf(l[2]) ? Nt : zt
              , p = ~["Solid", "Regular", "Light", "Thin", "Duotone", "Brands", "Kit"].indexOf(l[2]) ? xs[d][l[2].toLowerCase()] : cx[d][c]
              , h = mT(f)
              , m = h.value
              , g = h.isSecondary
              , b = l[0].startsWith("FontAwesome")
              , v = Vf(p, m)
              , y = v;
            if (b) {
                var w = Ix(m);
                w.iconName && w.prefix && (v = w.iconName,
                p = w.prefix)
            }
            if (v && !g && (!i || i.getAttribute(If) !== p || i.getAttribute(Bf) !== y)) {
                e.setAttribute(n, y),
                i && e.removeChild(i);
                var C = oT()
                  , _ = C.extra;
                _.attributes[tu] = t,
                su(v, p).then(function(E) {
                    var z = jf(Ke(Ke({}, C), {}, {
                        icons: {
                            main: E,
                            mask: Ff()
                        },
                        prefix: p,
                        iconName: y,
                        extra: _,
                        watchable: !0
                    }))
                      , T = At.createElement("svg");
                    t === "::before" ? e.insertBefore(T, e.firstChild) : e.appendChild(T),
                    T.outerHTML = z.map(function(A) {
                        return el(A)
                    }).join(`
`),
                    e.removeAttribute(n),
                    a()
                }).catch(r)
            } else
                a()
        } else
            a()
    }
    )
}
function gT(e) {
    return Promise.all([a4(e, "::before"), a4(e, "::after")])
}
function vT(e) {
    return e.parentNode !== document.head && !~ox.indexOf(e.tagName.toUpperCase()) && !e.getAttribute(tu) && (!e.parentNode || e.parentNode.tagName !== "svg")
}
function r4(e) {
    if (ur)
        return new Promise(function(t, n) {
            var a = ki(e.querySelectorAll("*")).filter(vT).map(gT)
              , r = Uf.begin("searchPseudoElements");
            e8(),
            Promise.all(a).then(function() {
                r(),
                cu(),
                t()
            }).catch(function() {
                r(),
                cu(),
                n()
            })
        }
        )
}
var bT = {
    hooks: function() {
        return {
            mutationObserverCallbacks: function(n) {
                return n.pseudoElementsCallback = r4,
                n
            }
        }
    },
    provides: function(t) {
        t.pseudoElements2svg = function(n) {
            var a = n.node
              , r = a === void 0 ? At : a;
            et.searchPseudoElements && r4(r)
        }
    }
}
  , o4 = !1
  , yT = {
    mixout: function() {
        return {
            dom: {
                unwatch: function() {
                    e8(),
                    o4 = !0
                }
            }
        }
    },
    hooks: function() {
        return {
            bootstrap: function() {
                Q3(ru("mutationObserverCallbacks", {}))
            },
            noAuto: function() {
                tT()
            },
            watch: function(n) {
                var a = n.observeMutationsRoot;
                o4 ? cu() : Q3(ru("mutationObserverCallbacks", {
                    observeMutationsRoot: a
                }))
            }
        }
    }
}
  , i4 = function(t) {
    var n = {
        size: 16,
        x: 0,
        y: 0,
        flipX: !1,
        flipY: !1,
        rotate: 0
    };
    return t.toLowerCase().split(" ").reduce(function(a, r) {
        var o = r.toLowerCase().split("-")
          , i = o[0]
          , s = o.slice(1).join("-");
        if (i && s === "h")
            return a.flipX = !0,
            a;
        if (i && s === "v")
            return a.flipY = !0,
            a;
        if (s = parseFloat(s),
        isNaN(s))
            return a;
        switch (i) {
        case "grow":
            a.size = a.size + s;
            break;
        case "shrink":
            a.size = a.size - s;
            break;
        case "left":
            a.x = a.x - s;
            break;
        case "right":
            a.x = a.x + s;
            break;
        case "up":
            a.y = a.y - s;
            break;
        case "down":
            a.y = a.y + s;
            break;
        case "rotate":
            a.rotate = a.rotate + s;
            break
        }
        return a
    }, n)
}
  , CT = {
    mixout: function() {
        return {
            parse: {
                transform: function(n) {
                    return i4(n)
                }
            }
        }
    },
    hooks: function() {
        return {
            parseNodeAttributes: function(n, a) {
                var r = a.getAttribute("data-fa-transform");
                return r && (n.transform = i4(r)),
                n
            }
        }
    },
    provides: function(t) {
        t.generateAbstractTransformGrouping = function(n) {
            var a = n.main
              , r = n.transform
              , o = n.containerWidth
              , i = n.iconWidth
              , s = {
                transform: "translate(".concat(o / 2, " 256)")
            }
              , l = "translate(".concat(r.x * 32, ", ").concat(r.y * 32, ") ")
              , c = "scale(".concat(r.size / 16 * (r.flipX ? -1 : 1), ", ").concat(r.size / 16 * (r.flipY ? -1 : 1), ") ")
              , u = "rotate(".concat(r.rotate, " 0 0)")
              , f = {
                transform: "".concat(l, " ").concat(c, " ").concat(u)
            }
              , d = {
                transform: "translate(".concat(i / 2 * -1, " -256)")
            }
              , p = {
                outer: s,
                inner: f,
                path: d
            };
            return {
                tag: "g",
                attributes: Ke({}, p.outer),
                children: [{
                    tag: "g",
                    attributes: Ke({}, p.inner),
                    children: [{
                        tag: a.icon.tag,
                        children: a.icon.children,
                        attributes: Ke(Ke({}, a.icon.attributes), p.path)
                    }]
                }]
            }
        }
    }
}
  , t2 = {
    x: 0,
    y: 0,
    width: "100%",
    height: "100%"
};
function s4(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    return e.attributes && (e.attributes.fill || t) && (e.attributes.fill = "black"),
    e
}
function wT(e) {
    return e.tag === "g" ? e.children : [e]
}
var _T = {
    hooks: function() {
        return {
            parseNodeAttributes: function(n, a) {
                var r = a.getAttribute("data-fa-mask")
                  , o = r ? cc(r.split(" ").map(function(i) {
                    return i.trim()
                })) : Ff();
                return o.prefix || (o.prefix = Br()),
                n.mask = o,
                n.maskId = a.getAttribute("data-fa-mask-id"),
                n
            }
        }
    },
    provides: function(t) {
        t.generateAbstractMask = function(n) {
            var a = n.children
              , r = n.attributes
              , o = n.main
              , i = n.mask
              , s = n.maskId
              , l = n.transform
              , c = o.width
              , u = o.icon
              , f = i.width
              , d = i.icon
              , p = Cx({
                transform: l,
                containerWidth: f,
                iconWidth: c
            })
              , h = {
                tag: "rect",
                attributes: Ke(Ke({}, t2), {}, {
                    fill: "white"
                })
            }
              , m = u.children ? {
                children: u.children.map(s4)
            } : {}
              , g = {
                tag: "g",
                attributes: Ke({}, p.inner),
                children: [s4(Ke({
                    tag: u.tag,
                    attributes: Ke(Ke({}, u.attributes), p.path)
                }, m))]
            }
              , b = {
                tag: "g",
                attributes: Ke({}, p.outer),
                children: [g]
            }
              , v = "mask-".concat(s || zs())
              , y = "clip-".concat(s || zs())
              , w = {
                tag: "mask",
                attributes: Ke(Ke({}, t2), {}, {
                    id: v,
                    maskUnits: "userSpaceOnUse",
                    maskContentUnits: "userSpaceOnUse"
                }),
                children: [h, b]
            }
              , C = {
                tag: "defs",
                children: [{
                    tag: "clipPath",
                    attributes: {
                        id: y
                    },
                    children: wT(d)
                }, w]
            };
            return a.push(C, {
                tag: "rect",
                attributes: Ke({
                    fill: "currentColor",
                    "clip-path": "url(#".concat(y, ")"),
                    mask: "url(#".concat(v, ")")
                }, t2)
            }),
            {
                children: a,
                attributes: r
            }
        }
    }
}
  , kT = {
    provides: function(t) {
        var n = !1;
        Ir.matchMedia && (n = Ir.matchMedia("(prefers-reduced-motion: reduce)").matches),
        t.missingIconAbstract = function() {
            var a = []
              , r = {
                fill: "currentColor"
            }
              , o = {
                attributeType: "XML",
                repeatCount: "indefinite",
                dur: "2s"
            };
            a.push({
                tag: "path",
                attributes: Ke(Ke({}, r), {}, {
                    d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z"
                })
            });
            var i = Ke(Ke({}, o), {}, {
                attributeName: "opacity"
            })
              , s = {
                tag: "circle",
                attributes: Ke(Ke({}, r), {}, {
                    cx: "256",
                    cy: "364",
                    r: "28"
                }),
                children: []
            };
            return n || s.children.push({
                tag: "animate",
                attributes: Ke(Ke({}, o), {}, {
                    attributeName: "r",
                    values: "28;14;28;28;14;28;"
                })
            }, {
                tag: "animate",
                attributes: Ke(Ke({}, i), {}, {
                    values: "1;0;1;1;0;1;"
                })
            }),
            a.push(s),
            a.push({
                tag: "path",
                attributes: Ke(Ke({}, r), {}, {
                    opacity: "1",
                    d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z"
                }),
                children: n ? [] : [{
                    tag: "animate",
                    attributes: Ke(Ke({}, i), {}, {
                        values: "1;0;0;0;0;1;"
                    })
                }]
            }),
            n || a.push({
                tag: "path",
                attributes: Ke(Ke({}, r), {}, {
                    opacity: "0",
                    d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z"
                }),
                children: [{
                    tag: "animate",
                    attributes: Ke(Ke({}, i), {}, {
                        values: "0;0;1;1;0;0;"
                    })
                }]
            }),
            {
                tag: "g",
                attributes: {
                    class: "missing"
                },
                children: a
            }
        }
    }
}
  , ST = {
    hooks: function() {
        return {
            parseNodeAttributes: function(n, a) {
                var r = a.getAttribute("data-fa-symbol")
                  , o = r === null ? !1 : r === "" ? !0 : r;
                return n.symbol = o,
                n
            }
        }
    }
}
  , $T = [kx, uT, fT, dT, pT, bT, yT, CT, _T, kT, ST];
Dx($T, {
    mixoutsTo: qn
});
var iU = qn.noAuto
  , n8 = qn.config
  , ET = qn.library
  , sU = qn.dom
  , x1 = qn.parse
  , lU = qn.findIconDefinition
  , cU = qn.toHtml
  , xT = qn.icon
  , uU = qn.layer
  , TT = qn.text
  , fU = qn.counter;
function l4(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var a = Object.getOwnPropertySymbols(e);
        t && (a = a.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable
        })),
        n.push.apply(n, a)
    }
    return n
}
function ma(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? l4(Object(n), !0).forEach(function(a) {
            Sn(e, a, n[a])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : l4(Object(n)).forEach(function(a) {
            Object.defineProperty(e, a, Object.getOwnPropertyDescriptor(n, a))
        })
    }
    return e
}
function T1(e) {
    return T1 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    }
    : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }
    ,
    T1(e)
}
function Sn(e, t, n) {
    return t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n,
    e
}
function MT(e, t) {
    if (e == null)
        return {};
    var n = {}, a = Object.keys(e), r, o;
    for (o = 0; o < a.length; o++)
        r = a[o],
        !(t.indexOf(r) >= 0) && (n[r] = e[r]);
    return n
}
function zT(e, t) {
    if (e == null)
        return {};
    var n = MT(e, t), a, r;
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        for (r = 0; r < o.length; r++)
            a = o[r],
            !(t.indexOf(a) >= 0) && Object.prototype.propertyIsEnumerable.call(e, a) && (n[a] = e[a])
    }
    return n
}
function uu(e) {
    return AT(e) || OT(e) || PT(e) || LT()
}
function AT(e) {
    if (Array.isArray(e))
        return fu(e)
}
function OT(e) {
    if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null)
        return Array.from(e)
}
function PT(e, t) {
    if (e) {
        if (typeof e == "string")
            return fu(e, t);
        var n = Object.prototype.toString.call(e).slice(8, -1);
        if (n === "Object" && e.constructor && (n = e.constructor.name),
        n === "Map" || n === "Set")
            return Array.from(e);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return fu(e, t)
    }
}
function fu(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var n = 0, a = new Array(t); n < t; n++)
        a[n] = e[n];
    return a
}
function LT() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
var IT = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}
  , a8 = {
    exports: {}
};
(function(e) {
    (function(t) {
        var n = function(b, v, y) {
            if (!c(v) || f(v) || d(v) || p(v) || l(v))
                return v;
            var w, C = 0, _ = 0;
            if (u(v))
                for (w = [],
                _ = v.length; C < _; C++)
                    w.push(n(b, v[C], y));
            else {
                w = {};
                for (var E in v)
                    Object.prototype.hasOwnProperty.call(v, E) && (w[b(E, y)] = n(b, v[E], y))
            }
            return w
        }
          , a = function(b, v) {
            v = v || {};
            var y = v.separator || "_"
              , w = v.split || /(?=[A-Z])/;
            return b.split(w).join(y)
        }
          , r = function(b) {
            return h(b) ? b : (b = b.replace(/[\-_\s]+(.)?/g, function(v, y) {
                return y ? y.toUpperCase() : ""
            }),
            b.substr(0, 1).toLowerCase() + b.substr(1))
        }
          , o = function(b) {
            var v = r(b);
            return v.substr(0, 1).toUpperCase() + v.substr(1)
        }
          , i = function(b, v) {
            return a(b, v).toLowerCase()
        }
          , s = Object.prototype.toString
          , l = function(b) {
            return typeof b == "function"
        }
          , c = function(b) {
            return b === Object(b)
        }
          , u = function(b) {
            return s.call(b) == "[object Array]"
        }
          , f = function(b) {
            return s.call(b) == "[object Date]"
        }
          , d = function(b) {
            return s.call(b) == "[object RegExp]"
        }
          , p = function(b) {
            return s.call(b) == "[object Boolean]"
        }
          , h = function(b) {
            return b = b - 0,
            b === b
        }
          , m = function(b, v) {
            var y = v && "process"in v ? v.process : v;
            return typeof y != "function" ? b : function(w, C) {
                return y(w, b, C)
            }
        }
          , g = {
            camelize: r,
            decamelize: i,
            pascalize: o,
            depascalize: i,
            camelizeKeys: function(b, v) {
                return n(m(r, v), b)
            },
            decamelizeKeys: function(b, v) {
                return n(m(i, v), b, v)
            },
            pascalizeKeys: function(b, v) {
                return n(m(o, v), b)
            },
            depascalizeKeys: function() {
                return this.decamelizeKeys.apply(this, arguments)
            }
        };
        e.exports ? e.exports = g : t.humps = g
    }
    )(IT)
}
)(a8);
var BT = a8.exports
  , RT = ["class", "style"];
function DT(e) {
    return e.split(";").map(function(t) {
        return t.trim()
    }).filter(function(t) {
        return t
    }).reduce(function(t, n) {
        var a = n.indexOf(":")
          , r = BT.camelize(n.slice(0, a))
          , o = n.slice(a + 1).trim();
        return t[r] = o,
        t
    }, {})
}
function NT(e) {
    return e.split(/\s+/).reduce(function(t, n) {
        return t[n] = !0,
        t
    }, {})
}
function Wf(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
      , n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (typeof e == "string")
        return e;
    var a = (e.children || []).map(function(l) {
        return Wf(l)
    })
      , r = Object.keys(e.attributes || {}).reduce(function(l, c) {
        var u = e.attributes[c];
        switch (c) {
        case "class":
            l.class = NT(u);
            break;
        case "style":
            l.style = DT(u);
            break;
        default:
            l.attrs[c] = u
        }
        return l
    }, {
        attrs: {},
        class: {},
        style: {}
    });
    n.class;
    var o = n.style
      , i = o === void 0 ? {} : o
      , s = zT(n, RT);
    return Pe(e.tag, ma(ma(ma({}, t), {}, {
        class: r.class,
        style: ma(ma({}, r.style), i)
    }, r.attrs), s), a)
}
var r8 = !1;
try {
    r8 = !0
} catch {}
function HT() {
    if (!r8 && console && typeof console.error == "function") {
        var e;
        (e = console).error.apply(e, arguments)
    }
}
function hs(e, t) {
    return Array.isArray(t) && t.length > 0 || !Array.isArray(t) && t ? Sn({}, e, t) : {}
}
function VT(e) {
    var t, n = (t = {
        "fa-spin": e.spin,
        "fa-pulse": e.pulse,
        "fa-fw": e.fixedWidth,
        "fa-border": e.border,
        "fa-li": e.listItem,
        "fa-inverse": e.inverse,
        "fa-flip": e.flip === !0,
        "fa-flip-horizontal": e.flip === "horizontal" || e.flip === "both",
        "fa-flip-vertical": e.flip === "vertical" || e.flip === "both"
    },
    Sn(t, "fa-".concat(e.size), e.size !== null),
    Sn(t, "fa-rotate-".concat(e.rotation), e.rotation !== null),
    Sn(t, "fa-pull-".concat(e.pull), e.pull !== null),
    Sn(t, "fa-swap-opacity", e.swapOpacity),
    Sn(t, "fa-bounce", e.bounce),
    Sn(t, "fa-shake", e.shake),
    Sn(t, "fa-beat", e.beat),
    Sn(t, "fa-fade", e.fade),
    Sn(t, "fa-beat-fade", e.beatFade),
    Sn(t, "fa-flash", e.flash),
    Sn(t, "fa-spin-pulse", e.spinPulse),
    Sn(t, "fa-spin-reverse", e.spinReverse),
    t);
    return Object.keys(n).map(function(a) {
        return n[a] ? a : null
    }).filter(function(a) {
        return a
    })
}
function c4(e) {
    if (e && T1(e) === "object" && e.prefix && e.iconName && e.icon)
        return e;
    if (x1.icon)
        return x1.icon(e);
    if (e === null)
        return null;
    if (T1(e) === "object" && e.prefix && e.iconName)
        return e;
    if (Array.isArray(e) && e.length === 2)
        return {
            prefix: e[0],
            iconName: e[1]
        };
    if (typeof e == "string")
        return {
            prefix: "fas",
            iconName: e
        }
}
var FT = jr({
    name: "FontAwesomeIcon",
    props: {
        border: {
            type: Boolean,
            default: !1
        },
        fixedWidth: {
            type: Boolean,
            default: !1
        },
        flip: {
            type: [Boolean, String],
            default: !1,
            validator: function(t) {
                return [!0, !1, "horizontal", "vertical", "both"].indexOf(t) > -1
            }
        },
        icon: {
            type: [Object, Array, String],
            required: !0
        },
        mask: {
            type: [Object, Array, String],
            default: null
        },
        listItem: {
            type: Boolean,
            default: !1
        },
        pull: {
            type: String,
            default: null,
            validator: function(t) {
                return ["right", "left"].indexOf(t) > -1
            }
        },
        pulse: {
            type: Boolean,
            default: !1
        },
        rotation: {
            type: [String, Number],
            default: null,
            validator: function(t) {
                return [90, 180, 270].indexOf(Number.parseInt(t, 10)) > -1
            }
        },
        swapOpacity: {
            type: Boolean,
            default: !1
        },
        size: {
            type: String,
            default: null,
            validator: function(t) {
                return ["2xs", "xs", "sm", "lg", "xl", "2xl", "1x", "2x", "3x", "4x", "5x", "6x", "7x", "8x", "9x", "10x"].indexOf(t) > -1
            }
        },
        spin: {
            type: Boolean,
            default: !1
        },
        transform: {
            type: [String, Object],
            default: null
        },
        symbol: {
            type: [Boolean, String],
            default: !1
        },
        title: {
            type: String,
            default: null
        },
        inverse: {
            type: Boolean,
            default: !1
        },
        bounce: {
            type: Boolean,
            default: !1
        },
        shake: {
            type: Boolean,
            default: !1
        },
        beat: {
            type: Boolean,
            default: !1
        },
        fade: {
            type: Boolean,
            default: !1
        },
        beatFade: {
            type: Boolean,
            default: !1
        },
        flash: {
            type: Boolean,
            default: !1
        },
        spinPulse: {
            type: Boolean,
            default: !1
        },
        spinReverse: {
            type: Boolean,
            default: !1
        }
    },
    setup: function(t, n) {
        var a = n.attrs
          , r = ae(function() {
            return c4(t.icon)
        })
          , o = ae(function() {
            return hs("classes", VT(t))
        })
          , i = ae(function() {
            return hs("transform", typeof t.transform == "string" ? x1.transform(t.transform) : t.transform)
        })
          , s = ae(function() {
            return hs("mask", c4(t.mask))
        })
          , l = ae(function() {
            return xT(r.value, ma(ma(ma(ma({}, o.value), i.value), s.value), {}, {
                symbol: t.symbol,
                title: t.title
            }))
        });
        st(l, function(u) {
            if (!u)
                return HT("Could not find one or more icon(s)", r.value, s.value)
        }, {
            immediate: !0
        });
        var c = ae(function() {
            return l.value ? Wf(l.value.abstract[0], {}, a) : null
        });
        return function() {
            return c.value
        }
    }
})
  , dU = jr({
    name: "FontAwesomeLayers",
    props: {
        fixedWidth: {
            type: Boolean,
            default: !1
        }
    },
    setup: function(t, n) {
        var a = n.slots
          , r = n8.familyPrefix
          , o = ae(function() {
            return ["".concat(r, "-layers")].concat(uu(t.fixedWidth ? ["".concat(r, "-fw")] : []))
        });
        return function() {
            return Pe("div", {
                class: o.value
            }, a.default ? a.default() : [])
        }
    }
})
  , pU = jr({
    name: "FontAwesomeLayersText",
    props: {
        value: {
            type: [String, Number],
            default: ""
        },
        transform: {
            type: [String, Object],
            default: null
        },
        counter: {
            type: Boolean,
            default: !1
        },
        position: {
            type: String,
            default: null,
            validator: function(t) {
                return ["bottom-left", "bottom-right", "top-left", "top-right"].indexOf(t) > -1
            }
        }
    },
    setup: function(t, n) {
        var a = n.attrs
          , r = n8.familyPrefix
          , o = ae(function() {
            return hs("classes", [].concat(uu(t.counter ? ["".concat(r, "-layers-counter")] : []), uu(t.position ? ["".concat(r, "-layers-").concat(t.position)] : [])))
        })
          , i = ae(function() {
            return hs("transform", typeof t.transform == "string" ? x1.transform(t.transform) : t.transform)
        })
          , s = ae(function() {
            var c = TT(t.value.toString(), ma(ma({}, i.value), o.value))
              , u = c.abstract;
            return t.counter && (u[0].attributes.class = u[0].attributes.class.replace("fa-layers-text", "")),
            u[0]
        })
          , l = ae(function() {
            return Wf(s.value, {}, a)
        });
        return function() {
            return l.value
        }
    }
});
var jT = {
    prefix: "fab",
    iconName: "discord",
    icon: [640, 512, [], "f392", "M524.531,69.836a1.5,1.5,0,0,0-.764-.7A485.065,485.065,0,0,0,404.081,32.03a1.816,1.816,0,0,0-1.923.91,337.461,337.461,0,0,0-14.9,30.6,447.848,447.848,0,0,0-134.426,0,309.541,309.541,0,0,0-15.135-30.6,1.89,1.89,0,0,0-1.924-.91A483.689,483.689,0,0,0,116.085,69.137a1.712,1.712,0,0,0-.788.676C39.068,183.651,18.186,294.69,28.43,404.354a2.016,2.016,0,0,0,.765,1.375A487.666,487.666,0,0,0,176.02,479.918a1.9,1.9,0,0,0,2.063-.676A348.2,348.2,0,0,0,208.12,430.4a1.86,1.86,0,0,0-1.019-2.588,321.173,321.173,0,0,1-45.868-21.853,1.885,1.885,0,0,1-.185-3.126c3.082-2.309,6.166-4.711,9.109-7.137a1.819,1.819,0,0,1,1.9-.256c96.229,43.917,200.41,43.917,295.5,0a1.812,1.812,0,0,1,1.924.233c2.944,2.426,6.027,4.851,9.132,7.16a1.884,1.884,0,0,1-.162,3.126,301.407,301.407,0,0,1-45.89,21.83,1.875,1.875,0,0,0-1,2.611,391.055,391.055,0,0,0,30.014,48.815,1.864,1.864,0,0,0,2.063.7A486.048,486.048,0,0,0,610.7,405.729a1.882,1.882,0,0,0,.765-1.352C623.729,277.594,590.933,167.465,524.531,69.836ZM222.491,337.58c-28.972,0-52.844-26.587-52.844-59.239S193.056,219.1,222.491,219.1c29.665,0,53.306,26.82,52.843,59.239C275.334,310.993,251.924,337.58,222.491,337.58Zm195.38,0c-28.971,0-52.843-26.587-52.843-59.239S388.437,219.1,417.871,219.1c29.667,0,53.307,26.82,52.844,59.239C470.715,310.993,447.538,337.58,417.871,337.58Z"]
};
function UT() {
    var e = window.navigator.userAgent
      , t = e.indexOf("MSIE ");
    if (t > 0)
        return parseInt(e.substring(t + 5, e.indexOf(".", t)), 10);
    var n = e.indexOf("Trident/");
    if (n > 0) {
        var a = e.indexOf("rv:");
        return parseInt(e.substring(a + 3, e.indexOf(".", a)), 10)
    }
    var r = e.indexOf("Edge/");
    return r > 0 ? parseInt(e.substring(r + 5, e.indexOf(".", r)), 10) : -1
}
let Xl;
function du() {
    du.init || (du.init = !0,
    Xl = UT() !== -1)
}
var fc = {
    name: "ResizeObserver",
    props: {
        emitOnMount: {
            type: Boolean,
            default: !1
        },
        ignoreWidth: {
            type: Boolean,
            default: !1
        },
        ignoreHeight: {
            type: Boolean,
            default: !1
        }
    },
    emits: ["notify"],
    mounted() {
        du(),
        Zn( () => {
            this._w = this.$el.offsetWidth,
            this._h = this.$el.offsetHeight,
            this.emitOnMount && this.emitSize()
        }
        );
        const e = document.createElement("object");
        this._resizeObject = e,
        e.setAttribute("aria-hidden", "true"),
        e.setAttribute("tabindex", -1),
        e.onload = this.addResizeHandlers,
        e.type = "text/html",
        Xl && this.$el.appendChild(e),
        e.data = "about:blank",
        Xl || this.$el.appendChild(e)
    },
    beforeUnmount() {
        this.removeResizeHandlers()
    },
    methods: {
        compareAndNotify() {
            (!this.ignoreWidth && this._w !== this.$el.offsetWidth || !this.ignoreHeight && this._h !== this.$el.offsetHeight) && (this._w = this.$el.offsetWidth,
            this._h = this.$el.offsetHeight,
            this.emitSize())
        },
        emitSize() {
            this.$emit("notify", {
                width: this._w,
                height: this._h
            })
        },
        addResizeHandlers() {
            this._resizeObject.contentDocument.defaultView.addEventListener("resize", this.compareAndNotify),
            this.compareAndNotify()
        },
        removeResizeHandlers() {
            this._resizeObject && this._resizeObject.onload && (!Xl && this._resizeObject.contentDocument && this._resizeObject.contentDocument.defaultView.removeEventListener("resize", this.compareAndNotify),
            this.$el.removeChild(this._resizeObject),
            this._resizeObject.onload = null,
            this._resizeObject = null)
        }
    }
};
const qT = O0("data-v-b329ee4c");
qt("data-v-b329ee4c");
const WT = {
    class: "resize-observer",
    tabindex: "-1"
};
Wt();
const YT = qT( (e, t, n, a, r, o) => (O(),
K("div", WT)));
fc.render = YT;
fc.__scopeId = "data-v-b329ee4c";
fc.__file = "src/components/ResizeObserver.vue";
function Kl(e) {
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Kl = function(t) {
        return typeof t
    }
    : Kl = function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }
    ,
    Kl(e)
}
function GT(e, t) {
    if (!(e instanceof t))
        throw new TypeError("Cannot call a class as a function")
}
function u4(e, t) {
    for (var n = 0; n < t.length; n++) {
        var a = t[n];
        a.enumerable = a.enumerable || !1,
        a.configurable = !0,
        "value"in a && (a.writable = !0),
        Object.defineProperty(e, a.key, a)
    }
}
function XT(e, t, n) {
    return t && u4(e.prototype, t),
    n && u4(e, n),
    e
}
function f4(e) {
    return KT(e) || ZT(e) || JT(e) || QT()
}
function KT(e) {
    if (Array.isArray(e))
        return pu(e)
}
function ZT(e) {
    if (typeof Symbol < "u" && Symbol.iterator in Object(e))
        return Array.from(e)
}
function JT(e, t) {
    if (e) {
        if (typeof e == "string")
            return pu(e, t);
        var n = Object.prototype.toString.call(e).slice(8, -1);
        if (n === "Object" && e.constructor && (n = e.constructor.name),
        n === "Map" || n === "Set")
            return Array.from(e);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return pu(e, t)
    }
}
function pu(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var n = 0, a = new Array(t); n < t; n++)
        a[n] = e[n];
    return a
}
function QT() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function eM(e) {
    var t;
    return typeof e == "function" ? t = {
        callback: e
    } : t = e,
    t
}
function tM(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, a, r, o, i = function(l) {
        for (var c = arguments.length, u = new Array(c > 1 ? c - 1 : 0), f = 1; f < c; f++)
            u[f - 1] = arguments[f];
        if (o = u,
        !(a && l === r)) {
            var d = n.leading;
            typeof d == "function" && (d = d(l, r)),
            (!a || l !== r) && d && e.apply(void 0, [l].concat(f4(o))),
            r = l,
            clearTimeout(a),
            a = setTimeout(function() {
                e.apply(void 0, [l].concat(f4(o))),
                a = 0
            }, t)
        }
    };
    return i._clear = function() {
        clearTimeout(a),
        a = null
    }
    ,
    i
}
function o8(e, t) {
    if (e === t)
        return !0;
    if (Kl(e) === "object") {
        for (var n in e)
            if (!o8(e[n], t[n]))
                return !1;
        return !0
    }
    return !1
}
var nM = function() {
    function e(t, n, a) {
        GT(this, e),
        this.el = t,
        this.observer = null,
        this.frozen = !1,
        this.createObserver(n, a)
    }
    return XT(e, [{
        key: "createObserver",
        value: function(n, a) {
            var r = this;
            if (this.observer && this.destroyObserver(),
            !this.frozen) {
                if (this.options = eM(n),
                this.callback = function(s, l) {
                    r.options.callback(s, l),
                    s && r.options.once && (r.frozen = !0,
                    r.destroyObserver())
                }
                ,
                this.callback && this.options.throttle) {
                    var o = this.options.throttleOptions || {}
                      , i = o.leading;
                    this.callback = tM(this.callback, this.options.throttle, {
                        leading: function(l) {
                            return i === "both" || i === "visible" && l || i === "hidden" && !l
                        }
                    })
                }
                this.oldResult = void 0,
                this.observer = new IntersectionObserver(function(s) {
                    var l = s[0];
                    if (s.length > 1) {
                        var c = s.find(function(f) {
                            return f.isIntersecting
                        });
                        c && (l = c)
                    }
                    if (r.callback) {
                        var u = l.isIntersecting && l.intersectionRatio >= r.threshold;
                        if (u === r.oldResult)
                            return;
                        r.oldResult = u,
                        r.callback(u, l)
                    }
                }
                ,this.options.intersection),
                Zn(function() {
                    r.observer && r.observer.observe(r.el)
                })
            }
        }
    }, {
        key: "destroyObserver",
        value: function() {
            this.observer && (this.observer.disconnect(),
            this.observer = null),
            this.callback && this.callback._clear && (this.callback._clear(),
            this.callback = null)
        }
    }, {
        key: "threshold",
        get: function() {
            return this.options.intersection && typeof this.options.intersection.threshold == "number" ? this.options.intersection.threshold : 0
        }
    }]),
    e
}();
function i8(e, t, n) {
    var a = t.value;
    if (a)
        if (typeof IntersectionObserver > "u")
            console.warn("[vue-observe-visibility] IntersectionObserver API is not available in your browser. Please install this polyfill: https://github.com/w3c/IntersectionObserver/tree/master/polyfill");
        else {
            var r = new nM(e,a,n);
            e._vue_visibilityState = r
        }
}
function aM(e, t, n) {
    var a = t.value
      , r = t.oldValue;
    if (!o8(a, r)) {
        var o = e._vue_visibilityState;
        if (!a) {
            s8(e);
            return
        }
        o ? o.createObserver(a, n) : i8(e, {
            value: a
        }, n)
    }
}
function s8(e) {
    var t = e._vue_visibilityState;
    t && (t.destroyObserver(),
    delete e._vue_visibilityState)
}
var rM = {
    beforeMount: i8,
    updated: aM,
    unmounted: s8
};
function oM(e) {
    return {
        all: e = e || new Map,
        on: function(t, n) {
            var a = e.get(t);
            a && a.push(n) || e.set(t, [n])
        },
        off: function(t, n) {
            var a = e.get(t);
            a && a.splice(a.indexOf(n) >>> 0, 1)
        },
        emit: function(t, n) {
            (e.get(t) || []).slice().map(function(a) {
                a(n)
            }),
            (e.get("*") || []).slice().map(function(a) {
                a(t, n)
            })
        }
    }
}
var iM = {
    itemsLimit: 1e3
}
  , sM = /(auto|scroll)/;
function l8(e, t) {
    return e.parentNode === null ? t : l8(e.parentNode, t.concat([e]))
}
var n2 = function(t, n) {
    return getComputedStyle(t, null).getPropertyValue(n)
}
  , lM = function(t) {
    return n2(t, "overflow") + n2(t, "overflow-y") + n2(t, "overflow-x")
}
  , cM = function(t) {
    return sM.test(lM(t))
};
function d4(e) {
    if (e instanceof HTMLElement || e instanceof SVGElement) {
        for (var t = l8(e.parentNode, []), n = 0; n < t.length; n += 1)
            if (cM(t[n]))
                return t[n];
        return document.scrollingElement || document.documentElement
    }
}
function hu(e) {
    return hu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    }
    : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }
    ,
    hu(e)
}
var c8 = {
    items: {
        type: Array,
        required: !0
    },
    keyField: {
        type: String,
        default: "id"
    },
    direction: {
        type: String,
        default: "vertical",
        validator: function(t) {
            return ["vertical", "horizontal"].includes(t)
        }
    },
    listTag: {
        type: String,
        default: "div"
    },
    itemTag: {
        type: String,
        default: "div"
    }
};
function u8() {
    return this.items.length && hu(this.items[0]) !== "object"
}
var mu = !1;
if (typeof window < "u") {
    mu = !1;
    try {
        var uM = Object.defineProperty({}, "passive", {
            get: function() {
                mu = !0
            }
        });
        window.addEventListener("test", null, uM)
    } catch {}
}
let fM = 0;
var dc = {
    name: "RecycleScroller",
    components: {
        ResizeObserver: fc
    },
    directives: {
        ObserveVisibility: rM
    },
    props: {
        ...c8,
        itemSize: {
            type: Number,
            default: null
        },
        gridItems: {
            type: Number,
            default: void 0
        },
        itemSecondarySize: {
            type: Number,
            default: void 0
        },
        minItemSize: {
            type: [Number, String],
            default: null
        },
        sizeField: {
            type: String,
            default: "size"
        },
        typeField: {
            type: String,
            default: "type"
        },
        buffer: {
            type: Number,
            default: 200
        },
        pageMode: {
            type: Boolean,
            default: !1
        },
        prerender: {
            type: Number,
            default: 0
        },
        emitUpdate: {
            type: Boolean,
            default: !1
        },
        updateInterval: {
            type: Number,
            default: 0
        },
        skipHover: {
            type: Boolean,
            default: !1
        },
        listTag: {
            type: String,
            default: "div"
        },
        itemTag: {
            type: String,
            default: "div"
        },
        listClass: {
            type: [String, Object, Array],
            default: ""
        },
        itemClass: {
            type: [String, Object, Array],
            default: ""
        }
    },
    emits: ["resize", "visible", "hidden", "update", "scroll-start", "scroll-end"],
    data() {
        return {
            pool: [],
            totalSize: 0,
            ready: !1,
            hoverKey: null
        }
    },
    computed: {
        sizes() {
            if (this.itemSize === null) {
                const e = {
                    "-1": {
                        accumulator: 0
                    }
                }
                  , t = this.items
                  , n = this.sizeField
                  , a = this.minItemSize;
                let r = 1e4, o = 0, i;
                for (let s = 0, l = t.length; s < l; s++)
                    i = t[s][n] || a,
                    i < r && (r = i),
                    o += i,
                    e[s] = {
                        accumulator: o,
                        size: i
                    };
                return this.$_computedMinItemSize = r,
                e
            }
            return []
        },
        simpleArray: u8,
        itemIndexByKey() {
            const {keyField: e, items: t} = this
              , n = {};
            for (let a = 0, r = t.length; a < r; a++)
                n[t[a][e]] = a;
            return n
        }
    },
    watch: {
        items() {
            this.updateVisibleItems(!0)
        },
        pageMode() {
            this.applyPageMode(),
            this.updateVisibleItems(!1)
        },
        sizes: {
            handler() {
                this.updateVisibleItems(!1)
            },
            deep: !0
        },
        gridItems() {
            this.updateVisibleItems(!0)
        },
        itemSecondarySize() {
            this.updateVisibleItems(!0)
        }
    },
    created() {
        this.$_startIndex = 0,
        this.$_endIndex = 0,
        this.$_views = new Map,
        this.$_unusedViews = new Map,
        this.$_scrollDirty = !1,
        this.$_lastUpdateScrollPosition = 0,
        this.prerender && (this.$_prerender = !0,
        this.updateVisibleItems(!1)),
        this.gridItems && !this.itemSize && console.error("[vue-recycle-scroller] You must provide an itemSize when using gridItems")
    },
    mounted() {
        this.applyPageMode(),
        this.$nextTick( () => {
            this.$_prerender = !1,
            this.updateVisibleItems(!0),
            this.ready = !0
        }
        )
    },
    activated() {
        const e = this.$_lastUpdateScrollPosition;
        typeof e == "number" && this.$nextTick( () => {
            this.scrollToPosition(e)
        }
        )
    },
    beforeUnmount() {
        this.removeListeners()
    },
    methods: {
        addView(e, t, n, a, r) {
            const o = ga({
                id: fM++,
                index: t,
                used: !0,
                key: a,
                type: r
            })
              , i = ef({
                item: n,
                position: 0,
                nr: o
            });
            return e.push(i),
            i
        },
        unuseView(e, t=!1) {
            const n = this.$_unusedViews
              , a = e.nr.type;
            let r = n.get(a);
            r || (r = [],
            n.set(a, r)),
            r.push(e),
            t || (e.nr.used = !1,
            e.position = -9999)
        },
        handleResize() {
            this.$emit("resize"),
            this.ready && this.updateVisibleItems(!1)
        },
        handleScroll(e) {
            if (!this.$_scrollDirty) {
                if (this.$_scrollDirty = !0,
                this.$_updateTimeout)
                    return;
                const t = () => requestAnimationFrame( () => {
                    this.$_scrollDirty = !1;
                    const {continuous: n} = this.updateVisibleItems(!1, !0);
                    n || (clearTimeout(this.$_refreshTimout),
                    this.$_refreshTimout = setTimeout(this.handleScroll, this.updateInterval + 100))
                }
                );
                t(),
                this.updateInterval && (this.$_updateTimeout = setTimeout( () => {
                    this.$_updateTimeout = 0,
                    this.$_scrollDirty && t()
                }
                , this.updateInterval))
            }
        },
        handleVisibilityChange(e, t) {
            this.ready && (e || t.boundingClientRect.width !== 0 || t.boundingClientRect.height !== 0 ? (this.$emit("visible"),
            requestAnimationFrame( () => {
                this.updateVisibleItems(!1)
            }
            )) : this.$emit("hidden"))
        },
        updateVisibleItems(e, t=!1) {
            const n = this.itemSize
              , a = this.gridItems || 1
              , r = this.itemSecondarySize || n
              , o = this.$_computedMinItemSize
              , i = this.typeField
              , s = this.simpleArray ? null : this.keyField
              , l = this.items
              , c = l.length
              , u = this.sizes
              , f = this.$_views
              , d = this.$_unusedViews
              , p = this.pool
              , h = this.itemIndexByKey;
            let m, g, b, v, y;
            if (!c)
                m = g = v = y = b = 0;
            else if (this.$_prerender)
                m = v = 0,
                g = y = Math.min(this.prerender, l.length),
                b = null;
            else {
                const A = this.getScroll();
                if (t) {
                    let L = A.start - this.$_lastUpdateScrollPosition;
                    if (L < 0 && (L = -L),
                    n === null && L < o || L < n)
                        return {
                            continuous: !0
                        }
                }
                this.$_lastUpdateScrollPosition = A.start;
                const x = this.buffer;
                A.start -= x,
                A.end += x;
                let M = 0;
                if (this.$refs.before && (M = this.$refs.before.scrollHeight,
                A.start -= M),
                this.$refs.after) {
                    const L = this.$refs.after.scrollHeight;
                    A.end += L
                }
                if (n === null) {
                    let L, U = 0, Y = c - 1, H = ~~(c / 2), W;
                    do
                        W = H,
                        L = u[H].accumulator,
                        L < A.start ? U = H : H < c - 1 && u[H + 1].accumulator > A.start && (Y = H),
                        H = ~~((U + Y) / 2);
                    while (H !== W);
                    for (H < 0 && (H = 0),
                    m = H,
                    b = u[c - 1].accumulator,
                    g = H; g < c && u[g].accumulator < A.end; g++)
                        ;
                    for (g === -1 ? g = l.length - 1 : (g++,
                    g > c && (g = c)),
                    v = m; v < c && M + u[v].accumulator < A.start; v++)
                        ;
                    for (y = v; y < c && M + u[y].accumulator < A.end; y++)
                        ;
                } else {
                    m = ~~(A.start / n * a);
                    const L = m % a;
                    m -= L,
                    g = Math.ceil(A.end / n * a),
                    v = Math.max(0, Math.floor((A.start - M) / n * a)),
                    y = Math.floor((A.end - M) / n * a),
                    m < 0 && (m = 0),
                    g > c && (g = c),
                    v < 0 && (v = 0),
                    y > c && (y = c),
                    b = Math.ceil(c / a) * n
                }
            }
            g - m > iM.itemsLimit && this.itemsLimitError(),
            this.totalSize = b;
            let w;
            const C = m <= this.$_endIndex && g >= this.$_startIndex;
            if (C)
                for (let A = 0, x = p.length; A < x; A++)
                    w = p[A],
                    w.nr.used && (e && (w.nr.index = h[w.item[s]]),
                    (w.nr.index == null || w.nr.index < m || w.nr.index >= g) && this.unuseView(w));
            const _ = C ? null : new Map;
            let E, z, T;
            for (let A = m; A < g; A++) {
                E = l[A];
                const x = s ? E[s] : E;
                if (x == null)
                    throw new Error(`Key is ${x} on item (keyField is '${s}')`);
                if (w = f.get(x),
                !n && !u[A].size) {
                    w && this.unuseView(w);
                    continue
                }
                z = E[i];
                let M = d.get(z)
                  , L = !1;
                if (!w)
                    C ? M && M.length ? w = M.pop() : w = this.addView(p, A, E, x, z) : (T = _.get(z) || 0,
                    (!M || T >= M.length) && (w = this.addView(p, A, E, x, z),
                    this.unuseView(w, !0),
                    M = d.get(z)),
                    w = M[T],
                    _.set(z, T + 1)),
                    f.delete(w.nr.key),
                    w.nr.used = !0,
                    w.nr.index = A,
                    w.nr.key = x,
                    w.nr.type = z,
                    f.set(x, w),
                    L = !0;
                else if (!w.nr.used && (w.nr.used = !0,
                L = !0,
                M)) {
                    const U = M.indexOf(w);
                    U !== -1 && M.splice(U, 1)
                }
                w.item = E,
                L && (A === l.length - 1 && this.$emit("scroll-end"),
                A === 0 && this.$emit("scroll-start")),
                n === null ? (w.position = u[A - 1].accumulator,
                w.offset = 0) : (w.position = Math.floor(A / a) * n,
                w.offset = A % a * r)
            }
            return this.$_startIndex = m,
            this.$_endIndex = g,
            this.emitUpdate && this.$emit("update", m, g, v, y),
            clearTimeout(this.$_sortTimer),
            this.$_sortTimer = setTimeout(this.sortViews, this.updateInterval + 300),
            {
                continuous: C
            }
        },
        getListenerTarget() {
            let e = d4(this.$el);
            return window.document && (e === window.document.documentElement || e === window.document.body) && (e = window),
            e
        },
        getScroll() {
            const {$el: e, direction: t} = this
              , n = t === "vertical";
            let a;
            if (this.pageMode) {
                const r = e.getBoundingClientRect()
                  , o = n ? r.height : r.width;
                let i = -(n ? r.top : r.left)
                  , s = n ? window.innerHeight : window.innerWidth;
                i < 0 && (s += i,
                i = 0),
                i + s > o && (s = o - i),
                a = {
                    start: i,
                    end: i + s
                }
            } else
                n ? a = {
                    start: e.scrollTop,
                    end: e.scrollTop + e.clientHeight
                } : a = {
                    start: e.scrollLeft,
                    end: e.scrollLeft + e.clientWidth
                };
            return a
        },
        applyPageMode() {
            this.pageMode ? this.addListeners() : this.removeListeners()
        },
        addListeners() {
            this.listenerTarget = this.getListenerTarget(),
            this.listenerTarget.addEventListener("scroll", this.handleScroll, mu ? {
                passive: !0
            } : !1),
            this.listenerTarget.addEventListener("resize", this.handleResize)
        },
        removeListeners() {
            this.listenerTarget && (this.listenerTarget.removeEventListener("scroll", this.handleScroll),
            this.listenerTarget.removeEventListener("resize", this.handleResize),
            this.listenerTarget = null)
        },
        scrollToItem(e) {
            let t;
            const n = this.gridItems || 1;
            this.itemSize === null ? t = e > 0 ? this.sizes[e - 1].accumulator : 0 : t = Math.floor(e / n) * this.itemSize,
            this.scrollToPosition(t)
        },
        scrollToPosition(e) {
            const t = this.direction === "vertical" ? {
                scroll: "scrollTop",
                start: "top"
            } : {
                scroll: "scrollLeft",
                start: "left"
            };
            let n, a, r;
            if (this.pageMode) {
                const o = d4(this.$el)
                  , i = o.tagName === "HTML" ? 0 : o[t.scroll]
                  , s = o.getBoundingClientRect()
                  , c = this.$el.getBoundingClientRect()[t.start] - s[t.start];
                n = o,
                a = t.scroll,
                r = e + i + c
            } else
                n = this.$el,
                a = t.scroll,
                r = e;
            n[a] = r
        },
        itemsLimitError() {
            throw setTimeout( () => {
                console.log("It seems the scroller element isn't scrolling, so it tries to render all the items at once.", "Scroller:", this.$el),
                console.log("Make sure the scroller has a fixed height (or width) and 'overflow-y' (or 'overflow-x') set to 'auto' so it can scroll correctly and only render the items visible in the scroll viewport.")
            }
            ),
            new Error("Rendered items limit reached")
        },
        sortViews() {
            this.pool.sort( (e, t) => e.nr.index - t.nr.index)
        }
    }
};
const dM = {
    key: 0,
    ref: "before",
    class: "vue-recycle-scroller__slot"
}
  , pM = {
    key: 1,
    ref: "after",
    class: "vue-recycle-scroller__slot"
};
function hM(e, t, n, a, r, o) {
    const i = P("ResizeObserver")
      , s = Hs("observe-visibility");
    return Fs((O(),
    G("div", {
        class: Ae(["vue-recycle-scroller", {
            ready: r.ready,
            "page-mode": n.pageMode,
            [`direction-${e.direction}`]: !0
        }]),
        onScrollPassive: t[0] || (t[0] = (...l) => o.handleScroll && o.handleScroll(...l))
    }, [e.$slots.before ? (O(),
    G("div", dM, [ce(e.$slots, "before")], 512)) : pe("v-if", !0), (O(),
    K(jn(n.listTag), {
        ref: "wrapper",
        style: Rt({
            [e.direction === "vertical" ? "minHeight" : "minWidth"]: r.totalSize + "px"
        }),
        class: Ae(["vue-recycle-scroller__item-wrapper", n.listClass])
    }, {
        default: k( () => [(O(!0),
        G(Be, null, vt(r.pool, l => (O(),
        K(jn(n.itemTag), Un({
            key: l.nr.id,
            style: r.ready ? {
                transform: `translate${e.direction === "vertical" ? "Y" : "X"}(${l.position}px) translate${e.direction === "vertical" ? "X" : "Y"}(${l.offset}px)`,
                width: n.gridItems ? `${e.direction === "vertical" && n.itemSecondarySize || n.itemSize}px` : void 0,
                height: n.gridItems ? `${e.direction === "horizontal" && n.itemSecondarySize || n.itemSize}px` : void 0
            } : null,
            class: ["vue-recycle-scroller__item-view", [n.itemClass, {
                hover: !n.skipHover && r.hoverKey === l.nr.key
            }]]
        }, J0(n.skipHover ? {} : {
            mouseenter: () => {
                r.hoverKey = l.nr.key
            }
            ,
            mouseleave: () => {
                r.hoverKey = null
            }
        })), {
            default: k( () => [ce(e.$slots, "default", {
                item: l.item,
                index: l.nr.index,
                active: l.nr.used
            })]),
            _: 2
        }, 1040, ["style", "class"]))), 128)), ce(e.$slots, "empty")]),
        _: 3
    }, 8, ["style", "class"])), e.$slots.after ? (O(),
    G("div", pM, [ce(e.$slots, "after")], 512)) : pe("v-if", !0), S(i, {
        onNotify: o.handleResize
    }, null, 8, ["onNotify"])], 34)), [[s, o.handleVisibilityChange]])
}
dc.render = hM;
dc.__file = "src/components/RecycleScroller.vue";
var f8 = {
    name: "DynamicScroller",
    components: {
        RecycleScroller: dc
    },
    provide() {
        return typeof ResizeObserver < "u" && (this.$_resizeObserver = new ResizeObserver(e => {
            requestAnimationFrame( () => {
                if (Array.isArray(e)) {
                    for (const t of e)
                        if (t.target && t.target.$_vs_onResize) {
                            let n, a;
                            if (t.borderBoxSize) {
                                const r = t.borderBoxSize[0];
                                n = r.inlineSize,
                                a = r.blockSize
                            } else
                                n = t.contentRect.width,
                                a = t.contentRect.height;
                            t.target.$_vs_onResize(t.target.$_vs_id, n, a)
                        }
                }
            }
            )
        }
        )),
        {
            vscrollData: this.vscrollData,
            vscrollParent: this,
            vscrollResizeObserver: this.$_resizeObserver
        }
    },
    inheritAttrs: !1,
    props: {
        ...c8,
        minItemSize: {
            type: [Number, String],
            required: !0
        }
    },
    emits: ["resize", "visible"],
    data() {
        return {
            vscrollData: {
                active: !0,
                sizes: {},
                keyField: this.keyField,
                simpleArray: !1
            }
        }
    },
    computed: {
        simpleArray: u8,
        itemsWithSize() {
            const e = []
              , {items: t, keyField: n, simpleArray: a} = this
              , r = this.vscrollData.sizes
              , o = t.length;
            for (let i = 0; i < o; i++) {
                const s = t[i]
                  , l = a ? i : s[n];
                let c = r[l];
                typeof c > "u" && !this.$_undefinedMap[l] && (c = 0),
                e.push({
                    item: s,
                    id: l,
                    size: c
                })
            }
            return e
        }
    },
    watch: {
        items() {
            this.forceUpdate()
        },
        simpleArray: {
            handler(e) {
                this.vscrollData.simpleArray = e
            },
            immediate: !0
        },
        direction(e) {
            this.forceUpdate(!0)
        },
        itemsWithSize(e, t) {
            const n = this.$el.scrollTop;
            let a = 0
              , r = 0;
            const o = Math.min(e.length, t.length);
            for (let s = 0; s < o && !(a >= n); s++)
                a += t[s].size || this.minItemSize,
                r += e[s].size || this.minItemSize;
            const i = r - a;
            i !== 0 && (this.$el.scrollTop += i)
        }
    },
    beforeCreate() {
        this.$_updates = [],
        this.$_undefinedSizes = 0,
        this.$_undefinedMap = {},
        this.$_events = oM()
    },
    activated() {
        this.vscrollData.active = !0
    },
    deactivated() {
        this.vscrollData.active = !1
    },
    unmounted() {
        this.$_events.all.clear()
    },
    methods: {
        onScrollerResize() {
            this.$refs.scroller && this.forceUpdate(),
            this.$emit("resize")
        },
        onScrollerVisible() {
            this.$_events.emit("vscroll:update", {
                force: !1
            }),
            this.$emit("visible")
        },
        forceUpdate(e=!1) {
            (e || this.simpleArray) && (this.vscrollData.sizes = {}),
            this.$_events.emit("vscroll:update", {
                force: !0
            })
        },
        scrollToItem(e) {
            const t = this.$refs.scroller;
            t && t.scrollToItem(e)
        },
        getItemSize(e, t=void 0) {
            const n = this.simpleArray ? t ?? this.items.indexOf(e) : e[this.keyField];
            return this.vscrollData.sizes[n] || 0
        },
        scrollToBottom() {
            if (this.$_scrollingToBottom)
                return;
            this.$_scrollingToBottom = !0;
            const e = this.$el;
            this.$nextTick( () => {
                e.scrollTop = e.scrollHeight + 5e3;
                const t = () => {
                    e.scrollTop = e.scrollHeight + 5e3,
                    requestAnimationFrame( () => {
                        e.scrollTop = e.scrollHeight + 5e3,
                        this.$_undefinedSizes === 0 ? this.$_scrollingToBottom = !1 : requestAnimationFrame(t)
                    }
                    )
                }
                ;
                requestAnimationFrame(t)
            }
            )
        }
    }
};
function mM(e, t, n, a, r, o) {
    const i = P("RecycleScroller");
    return O(),
    K(i, Un({
        ref: "scroller",
        items: o.itemsWithSize,
        "min-item-size": n.minItemSize,
        direction: e.direction,
        "key-field": "id",
        "list-tag": e.listTag,
        "item-tag": e.itemTag
    }, e.$attrs, {
        onResize: o.onScrollerResize,
        onVisible: o.onScrollerVisible
    }), {
        default: k( ({item: s, index: l, active: c}) => [ce(e.$slots, "default", c1(Q1({
            item: s.item,
            index: l,
            active: c,
            itemWithSize: s
        })))]),
        before: k( () => [ce(e.$slots, "before")]),
        after: k( () => [ce(e.$slots, "after")]),
        empty: k( () => [ce(e.$slots, "empty")]),
        _: 3
    }, 16, ["items", "min-item-size", "direction", "list-tag", "item-tag", "onResize", "onVisible"])
}
f8.render = mM;
f8.__file = "src/components/DynamicScroller.vue";
var gM = {
    name: "DynamicScrollerItem",
    inject: ["vscrollData", "vscrollParent", "vscrollResizeObserver"],
    props: {
        item: {
            required: !0
        },
        watchData: {
            type: Boolean,
            default: !1
        },
        active: {
            type: Boolean,
            required: !0
        },
        index: {
            type: Number,
            default: void 0
        },
        sizeDependencies: {
            type: [Array, Object],
            default: null
        },
        emitResize: {
            type: Boolean,
            default: !1
        },
        tag: {
            type: String,
            default: "div"
        }
    },
    emits: ["resize"],
    computed: {
        id() {
            if (this.vscrollData.simpleArray)
                return this.index;
            if (this.vscrollData.keyField in this.item)
                return this.item[this.vscrollData.keyField];
            throw new Error(`keyField '${this.vscrollData.keyField}' not found in your item. You should set a valid keyField prop on your Scroller`)
        },
        size() {
            return this.vscrollData.sizes[this.id] || 0
        },
        finalActive() {
            return this.active && this.vscrollData.active
        }
    },
    watch: {
        watchData: "updateWatchData",
        id(e, t) {
            if (this.$el.$_vs_id = this.id,
            this.size || this.onDataUpdate(),
            this.$_sizeObserved) {
                const n = this.vscrollData.sizes[t]
                  , a = this.vscrollData.sizes[e];
                n != null && n !== a && this.applySize(n)
            }
        },
        finalActive(e) {
            this.size || (e ? this.vscrollParent.$_undefinedMap[this.id] || (this.vscrollParent.$_undefinedSizes++,
            this.vscrollParent.$_undefinedMap[this.id] = !0) : this.vscrollParent.$_undefinedMap[this.id] && (this.vscrollParent.$_undefinedSizes--,
            this.vscrollParent.$_undefinedMap[this.id] = !1)),
            this.vscrollResizeObserver ? e ? this.observeSize() : this.unobserveSize() : e && this.$_pendingVScrollUpdate === this.id && this.updateSize()
        }
    },
    created() {
        if (!this.$isServer && (this.$_forceNextVScrollUpdate = null,
        this.updateWatchData(),
        !this.vscrollResizeObserver)) {
            for (const e in this.sizeDependencies)
                this.$watch( () => this.sizeDependencies[e], this.onDataUpdate);
            this.vscrollParent.$_events.on("vscroll:update", this.onVscrollUpdate)
        }
    },
    mounted() {
        this.finalActive && (this.updateSize(),
        this.observeSize())
    },
    beforeUnmount() {
        this.vscrollParent.$_events.off("vscroll:update", this.onVscrollUpdate),
        this.unobserveSize()
    },
    methods: {
        updateSize() {
            this.finalActive ? this.$_pendingSizeUpdate !== this.id && (this.$_pendingSizeUpdate = this.id,
            this.$_forceNextVScrollUpdate = null,
            this.$_pendingVScrollUpdate = null,
            this.computeSize(this.id)) : this.$_forceNextVScrollUpdate = this.id
        },
        updateWatchData() {
            this.watchData && !this.vscrollResizeObserver ? this.$_watchData = this.$watch("item", () => {
                this.onDataUpdate()
            }
            , {
                deep: !0
            }) : this.$_watchData && (this.$_watchData(),
            this.$_watchData = null)
        },
        onVscrollUpdate({force: e}) {
            !this.finalActive && e && (this.$_pendingVScrollUpdate = this.id),
            (this.$_forceNextVScrollUpdate === this.id || e || !this.size) && this.updateSize()
        },
        onDataUpdate() {
            this.updateSize()
        },
        computeSize(e) {
            this.$nextTick( () => {
                if (this.id === e) {
                    const t = this.$el.offsetWidth
                      , n = this.$el.offsetHeight;
                    this.applyWidthHeight(t, n)
                }
                this.$_pendingSizeUpdate = null
            }
            )
        },
        applyWidthHeight(e, t) {
            const n = ~~(this.vscrollParent.direction === "vertical" ? t : e);
            n && this.size !== n && this.applySize(n)
        },
        applySize(e) {
            this.vscrollParent.$_undefinedMap[this.id] && (this.vscrollParent.$_undefinedSizes--,
            this.vscrollParent.$_undefinedMap[this.id] = void 0),
            this.vscrollData.sizes[this.id] = e,
            this.emitResize && this.$emit("resize", this.id)
        },
        observeSize() {
            this.vscrollResizeObserver && (this.$_sizeObserved || (this.vscrollResizeObserver.observe(this.$el),
            this.$el.$_vs_id = this.id,
            this.$el.$_vs_onResize = this.onResize,
            this.$_sizeObserved = !0))
        },
        unobserveSize() {
            this.vscrollResizeObserver && this.$_sizeObserved && (this.vscrollResizeObserver.unobserve(this.$el),
            this.$el.$_vs_onResize = void 0,
            this.$_sizeObserved = !1)
        },
        onResize(e, t, n) {
            this.id === e && this.applyWidthHeight(t, n)
        }
    },
    render() {
        return Pe(this.tag, this.$slots.default())
    }
};
gM.__file = "src/components/DynamicScrollerItem.vue";
/*!
 * Vue-Lazyload.js v3.0.0
 * (c) 2023 Awe <hilongjw@gmail.com>
 * Released under the MIT License.
 */
function d8(e, t) {
    return t = {
        exports: {}
    },
    e(t, t.exports),
    t.exports
}
var gu = d8(function(e) {
    const t = Object.prototype.toString
      , n = Object.prototype.propertyIsEnumerable
      , a = Object.getOwnPropertySymbols;
    e.exports = (o, ...i) => {
        if (!r(o))
            throw new TypeError("expected the first argument to be an object");
        if (i.length === 0 || typeof Symbol != "function" || typeof a != "function")
            return o;
        for (let s of i) {
            let l = a(s);
            for (let c of l)
                n.call(s, c) && (o[c] = s[c])
        }
        return o
    }
    ;
    function r(o) {
        return typeof o == "function" || t.call(o) === "[object Object]" || Array.isArray(o)
    }
})
  , p4 = Object.freeze({
    __proto__: null,
    default: gu,
    __moduleExports: gu
})
  , vM = p4 && gu || p4
  , h4 = d8(function(e) {
    const t = Object.prototype.toString
      , n = i => i !== "__proto__" && i !== "constructor" && i !== "prototype"
      , a = e.exports = (i, ...s) => {
        let l = 0;
        for (o(i) && (i = s[l++]),
        i || (i = {}); l < s.length; l++)
            if (r(s[l])) {
                for (const c of Object.keys(s[l]))
                    n(c) && (r(i[c]) && r(s[l][c]) ? a(i[c], s[l][c]) : i[c] = s[l][c]);
                vM(i, s[l])
            }
        return i
    }
    ;
    function r(i) {
        return typeof i == "function" || t.call(i) === "[object Object]"
    }
    function o(i) {
        return typeof i == "object" ? i === null : typeof i != "function"
    }
});
const Dr = typeof window < "u" && window !== null
  , m4 = bM();
function bM() {
    return Dr && "IntersectionObserver"in window && "IntersectionObserverEntry"in window && "intersectionRatio"in window.IntersectionObserverEntry.prototype ? ("isIntersecting"in window.IntersectionObserverEntry.prototype || Object.defineProperty(window.IntersectionObserverEntry.prototype, "isIntersecting", {
        get: function() {
            return this.intersectionRatio > 0
        }
    }),
    !0) : !1
}
const Zr = {
    event: "event",
    observer: "observer"
};
function es(e, t) {
    if (!e.length)
        return;
    const n = e.indexOf(t);
    if (n > -1)
        return e.splice(n, 1)
}
function g4(e, t) {
    if (e.tagName !== "IMG" || !e.getAttribute("data-srcset"))
        return "";
    let n = e.getAttribute("data-srcset").trim().split(",");
    const a = []
      , o = e.parentNode.offsetWidth * t;
    let i, s, l;
    n.forEach(f => {
        f = f.trim(),
        i = f.lastIndexOf(" "),
        i === -1 ? (s = f,
        l = 99999) : (s = f.substr(0, i),
        l = parseInt(f.substr(i + 1, f.length - i - 2), 10)),
        a.push([l, s])
    }
    ),
    a.sort( (f, d) => {
        if (f[0] < d[0])
            return 1;
        if (f[0] > d[0])
            return -1;
        if (f[0] === d[0]) {
            if (d[1].indexOf(".webp", d[1].length - 5) !== -1)
                return 1;
            if (f[1].indexOf(".webp", f[1].length - 5) !== -1)
                return -1
        }
        return 0
    }
    );
    let c = "", u;
    for (let f = 0; f < a.length; f++) {
        u = a[f],
        c = u[1];
        const d = a[f + 1];
        if (d && d[0] < o) {
            c = u[1];
            break
        } else if (!d) {
            c = u[1];
            break
        }
    }
    return c
}
const yM = (e=1) => Dr && window.devicePixelRatio || e;
function CM() {
    if (!Dr)
        return !1;
    let e = !0;
    function t(n, a) {
        const r = {
            lossy: "UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",
            lossless: "UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==",
            alpha: "UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==",
            animation: "UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA"
        }
          , o = new Image;
        o.onload = function() {
            const i = o.width > 0 && o.height > 0;
            a(i)
        }
        ,
        o.onerror = function() {
            a(!1)
        }
        ,
        o.src = "data:image/webp;base64," + r[n]
    }
    return t("lossy", n => {
        e = n
    }
    ),
    t("lossless", n => {
        e = n
    }
    ),
    t("alpha", n => {
        e = n
    }
    ),
    t("animation", n => {
        e = n
    }
    ),
    e
}
function wM(e, t) {
    let n = null
      , a = 0;
    return function() {
        if (n)
            return;
        const r = Date.now() - a
          , o = this
          , i = arguments
          , s = function() {
            a = Date.now(),
            n = !1,
            e.apply(o, i)
        };
        r >= t ? s() : n = setTimeout(s, t)
    }
}
function _M() {
    if (!Dr)
        return !1;
    let e = !1;
    try {
        const t = Object.defineProperty({}, "passive", {
            get: function() {
                e = !0
            }
        });
        window.addEventListener("test", Yf, t)
    } catch {}
    return e
}
const kM = _M()
  , SM = {
    on(e, t, n, a=!1) {
        kM ? e.addEventListener(t, n, {
            capture: a,
            passive: !0
        }) : e.addEventListener(t, n, a)
    },
    off(e, t, n, a=!1) {
        e.removeEventListener(t, n, a)
    }
}
  , vu = (e, t, n) => {
    let a = new Image;
    if (!e || !e.src) {
        const r = new Error("image src is required");
        return n(r)
    }
    e.cors && (a.crossOrigin = e.cors),
    a.src = e.src,
    a.onload = function() {
        t({
            naturalHeight: a.naturalHeight,
            naturalWidth: a.naturalWidth,
            src: a.src
        }),
        a = null
    }
    ,
    a.onerror = function(r) {
        n(r)
    }
}
  , a2 = (e, t) => typeof getComputedStyle < "u" ? getComputedStyle(e, null).getPropertyValue(t) : e.style[t]
  , $M = e => a2(e, "overflow") + a2(e, "overflowY") + a2(e, "overflowX")
  , EM = e => {
    if (!Dr)
        return;
    if (!(e instanceof Element))
        return window;
    let t = e;
    for (; t && !(t === document.body || t === document.documentElement || !t.parentNode); ) {
        if (/(scroll|auto)/.test($M(t)))
            return t;
        t = t.parentNode
    }
    return window
}
;
function xM(e) {
    return e !== null && typeof e == "object"
}
function Yf() {}
class TM {
    constructor(t) {
        this.max = t || 100,
        this._caches = []
    }
    has(t) {
        return this._caches.indexOf(t) > -1
    }
    add(t) {
        this.has(t) || (this._caches.push(t),
        this._caches.length > this.max && this.free())
    }
    free() {
        this._caches.shift()
    }
}
class MM {
    constructor(t, n, a, r, o, i, s, l, c, u) {
        this.el = t,
        this.src = n,
        this.error = a,
        this.loading = r,
        this.bindType = o,
        this.attempt = 0,
        this.cors = l,
        this.naturalHeight = 0,
        this.naturalWidth = 0,
        this.options = s,
        this.rect = {},
        this.$parent = i,
        this.elRenderer = c,
        this._imageCache = u,
        this.performanceData = {
            init: Date.now(),
            loadStart: 0,
            loadEnd: 0
        },
        this.filter(),
        this.initState(),
        this.render("loading", !1)
    }
    initState() {
        "dataset"in this.el ? this.el.dataset.src = this.src : this.el.setAttribute("data-src", this.src),
        this.state = {
            loading: !1,
            error: !1,
            loaded: !1,
            rendered: !1
        }
    }
    record(t) {
        this.performanceData[t] = Date.now()
    }
    update(t) {
        const n = this.src;
        this.src = t.src,
        this.loading = t.loading,
        this.error = t.error,
        this.filter(),
        n !== this.src && (this.attempt = 0,
        this.initState())
    }
    getRect() {
        this.rect = this.el.getBoundingClientRect()
    }
    checkInView() {
        return this.getRect(),
        this.rect.top < window.innerHeight * this.options.preLoad && this.rect.bottom > this.options.preLoadTop && this.rect.left < window.innerWidth * this.options.preLoad && this.rect.right > 0
    }
    filter() {
        for (const t in this.options.filter)
            this.options.filter[t](this, this.options)
    }
    renderLoading(t) {
        this.state.loading = !0,
        vu({
            src: this.loading,
            cors: this.cors
        }, () => {
            this.render("loading", !1),
            this.state.loading = !1,
            t()
        }
        , () => {
            t(),
            this.state.loading = !1,
            this.options.silent || console.warn(`VueLazyload log: load failed with loading image(${this.loading})`)
        }
        )
    }
    load(t=Yf) {
        if (this.attempt > this.options.attempt - 1 && this.state.error) {
            this.options.silent || console.log(`VueLazyload log: ${this.src} tried too more than ${this.options.attempt} times`),
            t();
            return
        }
        if (!(this.state.rendered && this.state.loaded)) {
            if (this._imageCache.has(this.src))
                return this.state.loaded = !0,
                this.render("loaded", !0),
                this.state.rendered = !0,
                t();
            this.renderLoading( () => {
                this.attempt++,
                this.options.adapter.beforeLoad && this.options.adapter.beforeLoad(this, this.options),
                this.record("loadStart"),
                vu({
                    src: this.src,
                    cors: this.cors
                }, n => {
                    this.naturalHeight = n.naturalHeight,
                    this.naturalWidth = n.naturalWidth,
                    this.state.loaded = !0,
                    this.state.error = !1,
                    this.record("loadEnd"),
                    this.render("loaded", !1),
                    this.state.rendered = !0,
                    this._imageCache.add(this.src),
                    t()
                }
                , n => {
                    !this.options.silent && console.error(n),
                    this.state.error = !0,
                    this.state.loaded = !1,
                    this.render("error", !1)
                }
                )
            }
            )
        }
    }
    render(t, n) {
        this.elRenderer(this, t, n)
    }
    performance() {
        let t = "loading"
          , n = 0;
        return this.state.loaded && (t = "loaded",
        n = (this.performanceData.loadEnd - this.performanceData.loadStart) / 1e3),
        this.state.error && (t = "error"),
        {
            src: this.src,
            state: t,
            time: n
        }
    }
    $destroy() {
        this.el = null,
        this.src = "",
        this.error = null,
        this.loading = "",
        this.bindType = null,
        this.attempt = 0
    }
}
const v4 = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"
  , zM = ["scroll", "wheel", "mousewheel", "resize", "animationend", "transitionend", "touchmove"]
  , AM = {
    rootMargin: "0px",
    threshold: 0
};
let OM = class {
    constructor({preLoad: t, error: n, throttleWait: a, preLoadTop: r, dispatchEvent: o, loading: i, attempt: s, silent: l=!0, scale: c, listenEvents: u, filter: f, adapter: d, observer: p, observerOptions: h}) {
        this.version = '"3.0.0"',
        this.lazyContainerMananger = null,
        this.mode = Zr.event,
        this.ListenerQueue = [],
        this.TargetIndex = 0,
        this.TargetQueue = [],
        this.options = {
            silent: l,
            dispatchEvent: !!o,
            throttleWait: a || 200,
            preLoad: t || 1.3,
            preLoadTop: r || 0,
            error: n || v4,
            loading: i || v4,
            attempt: s || 3,
            scale: c || yM(c),
            listenEvents: u || zM,
            supportWebp: CM(),
            filter: f || {},
            adapter: d || {},
            observer: !!p,
            observerOptions: h || AM
        },
        this._initEvent(),
        this._imageCache = new TM(200),
        this.lazyLoadHandler = wM(this._lazyLoadHandler.bind(this), this.options.throttleWait),
        this.setMode(this.options.observer ? Zr.observer : Zr.event)
    }
    performance() {
        const t = [];
        return this.ListenerQueue.map(n => t.push(n.performance())),
        t
    }
    addLazyBox(t) {
        this.ListenerQueue.push(t),
        Dr && (this._addListenerTarget(window),
        this._observer && this._observer.observe(t.el),
        t.$el && t.$el.parentNode && this._addListenerTarget(t.$el.parentNode))
    }
    add(t, n, a) {
        if (this.ListenerQueue.some(l => l.el === t))
            return this.update(t, n),
            Zn(this.lazyLoadHandler);
        let {src: r, loading: o, error: i, cors: s} = this._valueFormatter(n.value);
        Zn( () => {
            r = g4(t, this.options.scale) || r,
            this._observer && this._observer.observe(t);
            const l = Object.keys(n.modifiers)[0];
            let c;
            l && (c = n.instance.$refs[l],
            c = c ? c.el || c : document.getElementById(l)),
            c || (c = EM(t));
            const u = new MM(t,r,i,o,n.arg,c,this.options,s,this._elRenderer.bind(this),this._imageCache);
            this.ListenerQueue.push(u),
            Dr && (this._addListenerTarget(window),
            this._addListenerTarget(c)),
            Zn(this.lazyLoadHandler)
        }
        )
    }
    update(t, n, a) {
        let {src: r, loading: o, error: i} = this._valueFormatter(n.value);
        r = g4(t, this.options.scale) || r;
        const s = this.ListenerQueue.find(l => l.el === t);
        s ? s.update({
            src: r,
            loading: o,
            error: i
        }) : (t.getAttribute("lazy") !== "loaded" || t.dataset.src !== r) && this.add(t, n, a),
        this._observer && (this._observer.unobserve(t),
        this._observer.observe(t)),
        Zn(this.lazyLoadHandler)
    }
    remove(t) {
        if (!t)
            return;
        this._observer && this._observer.unobserve(t);
        const n = this.ListenerQueue.find(a => a.el === t);
        n && (this._removeListenerTarget(n.$parent),
        this._removeListenerTarget(window),
        es(this.ListenerQueue, n),
        n.$destroy && n.$destroy())
    }
    removeComponent(t) {
        t && (es(this.ListenerQueue, t),
        this._observer && this._observer.unobserve(t.el),
        t.$parent && t.$el.parentNode && this._removeListenerTarget(t.$el.parentNode),
        this._removeListenerTarget(window))
    }
    setMode(t) {
        !m4 && t === Zr.observer && (t = Zr.event),
        this.mode = t,
        t === Zr.event ? (this._observer && (this.ListenerQueue.forEach(n => {
            this._observer.unobserve(n.el)
        }
        ),
        this._observer = null),
        this.TargetQueue.forEach(n => {
            this._initListen(n.el, !0)
        }
        )) : (this.TargetQueue.forEach(n => {
            this._initListen(n.el, !1)
        }
        ),
        this._initIntersectionObserver())
    }
    _addListenerTarget(t) {
        if (!t)
            return;
        let n = this.TargetQueue.find(a => a.el === t);
        return n ? n.childrenCount++ : (n = {
            el: t,
            id: ++this.TargetIndex,
            childrenCount: 1,
            listened: !0
        },
        this.mode === Zr.event && this._initListen(n.el, !0),
        this.TargetQueue.push(n)),
        this.TargetIndex
    }
    _removeListenerTarget(t) {
        this.TargetQueue.forEach( (n, a) => {
            n.el === t && (n.childrenCount--,
            n.childrenCount || (this._initListen(n.el, !1),
            this.TargetQueue.splice(a, 1),
            n = null))
        }
        )
    }
    _initListen(t, n) {
        this.options.listenEvents.forEach(a => SM[n ? "on" : "off"](t, a, this.lazyLoadHandler))
    }
    _initEvent() {
        this.Event = {
            listeners: {
                loading: [],
                loaded: [],
                error: []
            }
        },
        this.$on = (t, n) => {
            this.Event.listeners[t] || (this.Event.listeners[t] = []),
            this.Event.listeners[t].push(n)
        }
        ,
        this.$once = (t, n) => {
            const a = this;
            function r() {
                a.$off(t, r),
                n.apply(a, arguments)
            }
            this.$on(t, r)
        }
        ,
        this.$off = (t, n) => {
            if (!n) {
                if (!this.Event.listeners[t])
                    return;
                this.Event.listeners[t].length = 0;
                return
            }
            es(this.Event.listeners[t], n)
        }
        ,
        this.$emit = (t, n, a) => {
            this.Event.listeners[t] && this.Event.listeners[t].forEach(r => r(n, a))
        }
    }
    _lazyLoadHandler() {
        const t = [];
        this.ListenerQueue.forEach( (n, a) => {
            (!n.el || !n.el.parentNode || n.state.loaded) && t.push(n),
            n.checkInView() && (n.state.loaded || n.load())
        }
        ),
        t.forEach(n => {
            es(this.ListenerQueue, n),
            n.$destroy && n.$destroy()
        }
        )
    }
    _initIntersectionObserver() {
        m4 && (this._observer = new IntersectionObserver(this._observerHandler.bind(this),this.options.observerOptions),
        this.ListenerQueue.length && this.ListenerQueue.forEach(t => {
            this._observer.observe(t.el)
        }
        ))
    }
    _observerHandler(t) {
        t.forEach(n => {
            n.isIntersecting && this.ListenerQueue.forEach(a => {
                if (a.el === n.target) {
                    if (a.state.loaded)
                        return this._observer.unobserve(a.el);
                    a.load()
                }
            }
            )
        }
        )
    }
    _elRenderer(t, n, a) {
        if (!t.el)
            return;
        const {el: r, bindType: o} = t;
        let i;
        switch (n) {
        case "loading":
            i = t.loading;
            break;
        case "error":
            i = t.error;
            break;
        default:
            i = t.src;
            break
        }
        if (o ? r.style[o] = 'url("' + i + '")' : r.getAttribute("src") !== i && r.setAttribute("src", i),
        r.setAttribute("lazy", n),
        this.$emit(n, t, a),
        this.options.adapter[n] && this.options.adapter[n](t, this.options),
        this.options.dispatchEvent) {
            const s = new CustomEvent(n,{
                detail: t
            });
            r.dispatchEvent(s)
        }
    }
    _valueFormatter(t) {
        return xM(t) ? (!t.src && !this.options.silent && console.error("Vue Lazyload warning: miss src with " + t),
        {
            src: t.src,
            loading: t.loading || this.options.loading,
            error: t.error || this.options.error,
            cors: this.options.cors
        }) : {
            src: t,
            loading: this.options.loading,
            error: this.options.error,
            cors: this.options.cors
        }
    }
}
;
const p8 = (e, t) => {
    let n = Jn({});
    const a = () => {
        n = e.value.getBoundingClientRect()
    }
    ;
    return {
        rect: n,
        checkInView: () => (a(),
        Dr && n.top < window.innerHeight * t && n.bottom > 0 && n.left < window.innerWidth * t && n.right > 0)
    }
}
;
var PM = e => jr({
    props: {
        tag: {
            type: String,
            default: "div"
        }
    },
    emits: ["show"],
    setup(t, {emit: n, slots: a}) {
        const r = oe()
          , o = Jn({
            loaded: !1,
            error: !1,
            attempt: 0
        })
          , i = oe(!1)
          , {rect: s, checkInView: l} = p8(r, e.options.preLoad)
          , c = () => {
            i.value = !0,
            o.loaded = !0,
            n("show", i.value)
        }
          , u = ae( () => ({
            el: r.value,
            rect: s,
            checkInView: l,
            load: c,
            state: o
        }));
        return Xe( () => {
            e.addLazyBox(u.value),
            e.lazyLoadHandler()
        }
        ),
        Ca( () => {
            e.removeComponent(u.value)
        }
        ),
        () => {
            var f;
            return S(t.tag, {
                ref: r
            }, [i.value && ((f = a.default) === null || f === void 0 ? void 0 : f.call(a))])
        }
    }
});
class LM {
    constructor(t) {
        this.lazy = t,
        t.lazyContainerMananger = this,
        this._queue = []
    }
    bind(t, n, a) {
        const r = new BM(t,n,a,this.lazy);
        this._queue.push(r)
    }
    update(t, n, a) {
        const r = this._queue.find(o => o.el === t);
        r && r.update(t, n)
    }
    unbind(t, n, a) {
        const r = this._queue.find(o => o.el === t);
        r && (r.clear(),
        es(this._queue, r))
    }
}
const IM = {
    selector: "img",
    error: "",
    loading: ""
};
class BM {
    constructor(t, n, a, r) {
        this.el = t,
        this.vnode = a,
        this.binding = n,
        this.options = {},
        this.lazy = r,
        this._queue = [],
        this.update(t, n)
    }
    update(t, n) {
        this.el = t,
        this.options = h4({}, IM, n.value),
        this.getImgs().forEach(r => {
            this.lazy.add(r, h4({}, this.binding, {
                value: {
                    src: r.getAttribute("data-src") || r.dataset.src,
                    error: r.getAttribute("data-error") || r.dataset.error || this.options.error,
                    loading: r.getAttribute("data-loading") || r.dataset.loading || this.options.loading
                }
            }), this.vnode)
        }
        )
    }
    getImgs() {
        return Array.from(this.el.querySelectorAll(this.options.selector))
    }
    clear() {
        this.getImgs().forEach(n => this.lazy.remove(n)),
        this.vnode = null,
        this.binding = null,
        this.lazy = null
    }
}
var RM = e => jr({
    setup(t, {slots: n}) {
        const a = oe()
          , r = Jn({
            src: "",
            error: "",
            loading: "",
            attempt: e.options.attempt
        })
          , o = Jn({
            loaded: !1,
            error: !1,
            attempt: 0
        })
          , {rect: i, checkInView: s} = p8(a, e.options.preLoad)
          , l = oe("")
          , c = (d=Yf) => {
            if (o.attempt > r.attempt - 1 && o.error)
                return e.options.silent || console.log(`VueLazyload log: ${r.src} tried too more than ${r.attempt} times`),
                d();
            const p = r.src;
            vu({
                src: p
            }, ({src: h}) => {
                l.value = h,
                o.loaded = !0
            }
            , () => {
                o.attempt++,
                l.value = r.error,
                o.error = !0
            }
            )
        }
          , u = ae( () => ({
            el: a.value,
            rect: i,
            checkInView: s,
            load: c,
            state: o
        }));
        Xe( () => {
            e.addLazyBox(u.value),
            e.lazyLoadHandler()
        }
        ),
        Ca( () => {
            e.removeComponent(u.value)
        }
        );
        const f = () => {
            const {src: d, loading: p, error: h} = e._valueFormatter(t.src);
            o.loaded = !1,
            r.src = d,
            r.error = h,
            r.loading = p,
            l.value = r.loading
        }
        ;
        return st( () => t.src, () => {
            f(),
            e.addLazyBox(u.value),
            e.lazyLoadHandler()
        }
        , {
            immediate: !0
        }),
        () => {
            var d;
            return S(t.tag || "img", {
                src: l.value,
                ref: a
            }, [(d = n.default) === null || d === void 0 ? void 0 : d.call(n)])
        }
    }
})
  , DM = {
    install(e, t={}) {
        const n = new OM(t)
          , a = new LM(n);
        if (Number(e.version.split(".")[0]) < 3)
            return new Error("Vue version at least 3.0");
        e.config.globalProperties.$Lazyload = n,
        e.provide("Lazyload", n),
        t.lazyComponent && e.component("lazy-component", PM(n)),
        t.lazyImage && e.component("lazy-image", RM(n)),
        e.directive("lazy", {
            beforeMount: n.add.bind(n),
            beforeUpdate: n.update.bind(n),
            updated: n.lazyLoadHandler.bind(n),
            unmounted: n.remove.bind(n)
        }),
        e.directive("lazy-container", {
            beforeMount: a.bind.bind(a),
            updated: a.update.bind(a),
            unmounted: a.unbind.bind(a)
        })
    }
};
function NM(e) {
    const [t,n="ms"] = String(e).split(/(ms|s)/i)
      , a = {
        ms: 1,
        s: 1e3
    };
    return Number(t) * a[n]
}
function HM(e, t) {
    let n = null;
    const a = typeof t == "number" ? t : NM(t)
      , r = function(...o) {
        const i = () => {
            n = null,
            e.apply(this, o)
        }
        ;
        clearTimeout(n),
        n = setTimeout(i, a),
        n || e.apply(this, o)
    };
    return r.cancel = () => {
        clearTimeout(n),
        n = null
    }
    ,
    r
}
function r2(e) {
    return e.map(t => t.toLowerCase())
}
function VM(e) {
    return Array.isArray(e) ? e : e == null ? [] : [e]
}
function FM(e, t) {
    const n = e ? e["debounce-events"] : [];
    return n && n.length > 0 ? Array.isArray(n) ? r2(n) : r2(n.split(",")) : r2(VM(t))
}
function h8(e) {
    return e === ""
}
function jM(e, t) {
    return e === "Enter" && (!t.lock || t.unlock)
}
function UM(e, t, n) {
    return h8(e) && n.fireonempty && (t === "Enter" || t === " ")
}
function qM({lock: e=!1, listenTo: t="keyup", defaultTime: n="300ms", fireOnEmpty: a=!1, cancelOnEmpty: r=!1, trim: o=!1}={}) {
    return {
        created(i, {value: s, arg: l=n, modifiers: c}, u) {
            const f = Object.assign({
                lock: e,
                trim: o,
                fireonempty: a,
                cancelonempty: r
            }, c)
              , d = FM(u.props, t)
              , p = HM(m => {
                s(m.target.value, m)
            }
            , l);
            function h(m) {
                const g = f.trim ? m.target.value.trim() : m.target.value;
                h8(g) && f.cancelonempty ? p.cancel() : jM(m.key, f) || UM(g, m.key, f) ? (p.cancel(),
                s(m.target.value, m)) : p(m)
            }
            d.forEach(m => {
                i.addEventListener(m, h)
            }
            )
        }
    }
}
const b4 = [{
    id: "view-apps",
    name: "apps",
    icon: "f7:layers_alt_fill",
    label: "Apps",
    url: "/"
}, {
    id: "view-sources",
    name: "sources",
    icon: "material:public",
    label: "Sources",
    url: "/source/"
}, {
    id: "view-device",
    name: "device",
    icon: "f7:device_phone_portrait",
    label: "Device",
    url: "/device/"
}, {
    id: "view-signer",
    name: "signer",
    icon: "f7:pencil_outline",
    label: "Signer",
    url: "/signer/"
}, {
    id: "view-settings",
    name: "settings",
    icon: "f7:gear_alt_fill",
    label: "Settings",
    url: "/settings/"
}]
  , Fa = oa("navigation", {
    state: () => ({
        viewTabs: b4,
        activeTab: b4[0].id
    }),
    getters: {},
    actions: {
        setActiveTab(e) {
            this.activeTab = e
        }
    }
})
  , WM = {
    __name: "ui",
    setup(e) {
        const t = Fa();
        return (n, a) => {
            const r = P("f7-view");
            return O(!0),
            G(Be, null, vt(B(t).viewTabs, o => (O(),
            K(r, {
                id: o.id,
                key: o.id,
                main: o.url === "/",
                tab: "",
                "tab-active": B(t).activeTab === o.id,
                url: o.url
            }, null, 8, ["id", "main", "tab-active", "url"]))), 128)
        }
    }
};
const YM = {
    class: "tabbar-label"
}
  , GM = V("div", {
    class: "toolbar-layout-wrapper toolbar-menu"
}, [V("div", {
    class: "toolbar-views__toolbar-sticky__bg"
}), V("div", {
    class: "toolbar-views__toolbar-sticky__gradient-bg"
})], -1)
  , XM = {
    __name: "ui",
    setup(e) {
        const t = Fa();
        return (n, a) => {
            const r = P("f7-icon")
              , o = P("f7-button")
              , i = P("f7-segmented");
            return O(),
            G(Be, null, [S(i, {
                class: "toolbar-views-ui__segmented-toolbar toolbar-menu",
                strong: "",
                tag: "div"
            }, {
                default: k( () => [(O(!0),
                G(Be, null, vt(B(t).viewTabs, s => (O(),
                K(o, {
                    key: s.id,
                    "tab-link": `#${s.id}`,
                    "tab-link-active": B(t).activeTab === s.id,
                    onClick: l => B(t).setActiveTab(s.id)
                }, {
                    default: k( () => [S(r, {
                        ios: s.icon
                    }, null, 8, ["ios"]), V("span", YM, Me(s.label), 1)]),
                    _: 2
                }, 1032, ["tab-link", "tab-link-active", "onClick"]))), 128))]),
                _: 1
            }), GM], 64)
        }
    }
};
const it = (e, t) => {
    const n = e.__vccOpts || e;
    for (const [a,r] of t)
        n[a] = r;
    return n
}
  , KM = {
    __name: "ui",
    setup(e) {
        const t = Fa();
        return (n, a) => {
            const r = P("f7-icon")
              , o = P("f7-list-item")
              , i = P("f7-list");
            return O(),
            K(i, {
                "menu-list": "",
                "no-hairlines": ""
            }, {
                default: k( () => [(O(!0),
                G(Be, null, vt(B(t).viewTabs, s => (O(),
                K(o, {
                    key: s.id,
                    link: "",
                    selected: B(t).activeTab === s.id,
                    "tab-link": `#${s.id}`,
                    title: s.label,
                    onClick: l => B(t).setActiveTab(s.id)
                }, {
                    media: k( () => [S(r, {
                        class: "left-panel__menu-icon",
                        ios: s.icon
                    }, null, 8, ["ios"])]),
                    _: 2
                }, 1032, ["selected", "tab-link", "title", "onClick"]))), 128))]),
                _: 1
            })
        }
    }
}
  , ZM = it(KM, [["__scopeId", "data-v-0dae4469"]])
  , JM = {};
function QM(e, t) {
    const n = P("f7-icon")
      , a = P("f7-list-item")
      , r = P("f7-list");
    return O(),
    K(r, {
        class: "rounded-items",
        inset: ""
    }, {
        default: k( () => [S(a, {
            link: "/docs/3/",
            title: "Terms of services"
        }, {
            media: k( () => [S(n, {
                f7: "info_circle_fill"
            })]),
            _: 1
        }), S(a, {
            link: "/docs/",
            title: "Help Center"
        }, {
            media: k( () => [S(n, {
                f7: "question_diamond_fill"
            })]),
            _: 1
        }), S(a, {
            link: "/docs/4/",
            title: "Privacy policy"
        }, {
            media: k( () => [S(n, {
                f7: "hand_raised_fill"
            })]),
            _: 1
        })]),
        _: 1
    })
}
const ez = it(JM, [["render", QM]])
  , tz = V("path", {
    d: "M403.229 0h78.506L310.219 196.04 512 462.799H354.002L230.261 301.007 88.669 462.799h-78.56l183.455-209.683L0 0h161.999l111.856 147.88L403.229 0zm-27.556 415.805h43.505L138.363 44.527h-46.68l283.99 371.278z",
    "fill-rule": "nonzero"
}, null, -1)
  , nz = [tz]
  , m8 = {
    __name: "XIcons",
    props: {
        size: {
            type: String,
            default: "28"
        }
    },
    setup(e) {
        const t = e;
        return (n, a) => (O(),
        G("svg", {
            "aria-label": "X",
            style: Rt({
                width: `${t.size}px`,
                fill: "var(--f7-theme-color)"
            }),
            viewBox: "0 0 512 462.799",
            xmlns: "http://www.w3.org/2000/svg"
        }, nz, 4))
    }
}
  , az = V("g", {
    style: {
        stroke: "none",
        "stroke-width": "0",
        "stroke-dasharray": "none",
        "stroke-linecap": "butt",
        "stroke-linejoin": "miter",
        "stroke-miterlimit": "10",
        "fill-rule": "nonzero"
    },
    transform: "translate(1.4065934065934016 1.4065934065934016) scale(2.81 2.81)"
}, [V("path", {
    d: "M 88.119 23.338 c -1.035 -3.872 -4.085 -6.922 -7.957 -7.957 C 73.144 13.5 45 13.5 45 13.5 s -28.144 0 -35.162 1.881 c -3.872 1.035 -6.922 4.085 -7.957 7.957 C 0 30.356 0 45 0 45 s 0 14.644 1.881 21.662 c 1.035 3.872 4.085 6.922 7.957 7.957 C 16.856 76.5 45 76.5 45 76.5 s 28.144 0 35.162 -1.881 c 3.872 -1.035 6.922 -4.085 7.957 -7.957 C 90 59.644 90 45 90 45 S 90 30.356 88.119 23.338 z M 36 58.5 v -27 L 59.382 45 L 36 58.5 z",
    "stroke-linecap": "round",
    style: {
        stroke: "none",
        "stroke-width": "1",
        "stroke-dasharray": "none",
        "stroke-linecap": "butt",
        "stroke-linejoin": "miter",
        "stroke-miterlimit": "10",
        "fill-rule": "nonzero",
        opacity: "1"
    },
    transform: " matrix(1 0 0 1 0 0) "
})], -1)
  , rz = [az]
  , oz = {
    __name: "YouTubeIcon",
    props: {
        size: {
            type: String,
            default: "28"
        }
    },
    setup(e) {
        const t = e;
        return (n, a) => (O(),
        G("svg", {
            "aria-label": "YouTube",
            style: Rt({
                width: `${t.size}px`,
                fill: "var(--f7-theme-color)"
            }),
            viewBox: "0 0 256 256",
            xmlns: "http://www.w3.org/2000/svg"
        }, rz, 4))
    }
}
  , iz = {
    __name: "ui",
    setup(e) {
        return (t, n) => {
            const a = P("f7-list-item")
              , r = P("f7-icon")
              , o = P("f7-list");
            return O(),
            K(o, {
                class: "rounded-items",
                inset: ""
            }, {
                default: k( () => [S(a, {
                    external: "",
                    link: "https://x.com/flekstore_com",
                    title: "X.com"
                }, {
                    media: k( () => [S(m8, {
                        size: "26"
                    })]),
                    _: 1
                }), S(a, {
                    external: "",
                    link: "https://www.youtube.com/channel/UCOqUkxEN8CMnp1_h1C_G_8Q",
                    title: "YouTube"
                }, {
                    media: k( () => [S(oz, {
                        size: "28"
                    })]),
                    _: 1
                }), S(a, {
                    external: "",
                    link: "https://t.me/flekstorecom",
                    title: "Telegram"
                }, {
                    media: k( () => [S(r, {
                        f7: "paperplane_fill"
                    })]),
                    _: 1
                })]),
                _: 1
            })
        }
    }
}
  , pc = "Notification"in window && "serviceWorker"in navigator && "PushManager"in window
  , y4 = localStorage.getItem("notificationsEnabled")
  , ms = oe(y4 !== null ? y4 === "true" : !1);
function Zo(e) {
    ms.value = e,
    localStorage.setItem("notificationsEnabled", e)
}
function sz(e) {
    const t = "=".repeat((4 - e.length % 4) % 4)
      , n = (e + t).replace(/-/g, "+").replace(/_/g, "/")
      , a = window.atob(n)
      , r = new Uint8Array(a.length);
    for (let o = 0; o < a.length; ++o)
        r[o] = a.charCodeAt(o);
    return r
}
async function g8() {
    if (!pc)
        return console.error("    ."),
        Zo(!1),
        null;
    if (Notification.permission === "denied")
        return console.warn("  ."),
        Zo(!1),
        null;
    if (Notification.permission !== "granted" && await Notification.requestPermission() !== "granted")
        return console.warn("     ."),
        null;
    try {
        const e = await navigator.serviceWorker.ready;
        let t = await e.pushManager.getSubscription();
        if (t)
            console.log("  :", t);
        else {
            t = await e.pushManager.subscribe({
                userVisibleOnly: !0,
                applicationServerKey: sz("BLMngsEvMPdjBjHHfXki6D4FHmN-uwjwxNcFqGwN9NJP0vZ7xyart2bDJkqU_JYM03FURzzEonQwmE_0KvKTNnM")
            }),
            console.log("  :", t);
            const n = JSON.parse(JSON.stringify(t))
              , a = {
                uuid: localStorage.fsAppUUID,
                device_id: parseInt(localStorage.device_id, 10),
                endpoint: n.endpoint,
                auth: n.keys.auth,
                p256dh: n.keys.p256dh
            };
            await fetch("https://nestapi.flekstore.com/push", {
                method: "post",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(a)
            })
        }
        return Zo(!0),
        t
    } catch (e) {
        return console.error("    :", e),
        Zo(!1),
        null
    }
}
async function v8() {
    if (!pc)
        return console.error("    ."),
        !1;
    try {
        const t = await (await navigator.serviceWorker.ready).pushManager.getSubscription();
        return t ? (await fetch(`https://nestapi.flekstore.com/push/${localStorage.fsAppUUID}`, {
            method: "delete",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify({})
        }),
        await t.unsubscribe() ? (console.log("    ."),
        Zo(!1),
        !0) : (console.error("   ."),
        !1)) : (console.warn("      ."),
        Zo(!1),
        !0)
    } catch (e) {
        return console.error("    :", e),
        !1
    }
}
const lz = {
    key: 0
}
  , cz = {
    key: 1
}
  , uz = {
    __name: "ui",
    setup(e) {
        const t = oe(pc)
          , n = oe(ms.value);
        st(ms, r => {
            n.value = r
        }
        );
        const a = async () => {
            if (n.value)
                await v8() && (n.value = !1);
            else {
                const r = await g8();
                r ? n.value = !0 : r === null && D.dialog.alert(`<ol style="text-align: left">
                <li>Go to the "Settings" app</li>
                <li>Click "Notifications"</li>
                <li>Find the "FlekSt0re" app in the list</li>
                <li>Allow notifications to be sent</li>
              </ol>`, "Allow access to notifications")
            }
        }
        ;
        return Xe( () => {
            window.addEventListener("focus", () => {
                n.value = ms.value
            }
            )
        }
        ),
        (r, o) => {
            const i = P("f7-icon")
              , s = P("f7-list-item")
              , l = P("f7-list");
            return O(),
            K(l, {
                class: "rounded-items",
                inset: ""
            }, {
                default: k( () => [t.value ? (O(),
                K(s, {
                    key: 0,
                    link: "",
                    title: "Notifications",
                    onClick: a
                }, {
                    media: k( () => [S(i, {
                        f7: "bell_fill"
                    })]),
                    after: k( () => [n.value ? (O(),
                    G("div", lz, " Subscribed ")) : (O(),
                    G("div", cz, " Unsubscribed "))]),
                    _: 1
                })) : pe("", !0), S(s, {
                    link: "/settings/privacy-and-security/",
                    title: "Privacy and Security"
                }, {
                    media: k( () => [S(i, {
                        f7: "lock_fill"
                    })]),
                    _: 1
                })]),
                _: 1
            })
        }
    }
}
  , b8 = e => {
    const t = e.targetEl.getBoundingClientRect()
      , n = e.el.offsetWidth
      , a = window.innerWidth
      , r = t.left + t.width / 2
      , o = a - r
      , i = a - n;
    let s;
    r > o ? s = i > r ? n / 2 : r - i : s = i < o ? n - (o - i) : n / 2,
    e.el.style.transformOrigin = `${s}px top`
}
  , hc = e => {
    D.toast.create({
        text: e,
        closeTimeout: 5e3,
        closeButton: !0,
        destroyOnClose: !0,
        position: "top",
        horizontalPosition: "center"
    }).open()
}
  , fz = e => {
    const t = e.startsWith("#") ? e.slice(1) : e
      , n = parseInt(t.slice(0, 2), 16)
      , a = parseInt(t.slice(2, 4), 16)
      , r = parseInt(t.slice(4, 6), 16)
      , o = `#${Math.floor(n * .8).toString(16)}${Math.floor(a * .8).toString(16)}${Math.floor(r * .8).toString(16)}`
      , i = `#${Math.floor(n * 1.2).toString(16)}${Math.floor(a * 1.2).toString(16)}${Math.floor(r * 1.2).toString(16)}`;
    return {
        "--f7-theme-color": `#${t}`,
        "--f7-theme-color-rgb": `${n}, ${a}, ${r}`,
        "--f7-theme-color-shade": o,
        "--f7-theme-color-tint": i
    }
}
  , dz = e => `:root {
${Object.entries(e).map( ([n,a]) => `${n}: ${a};`).join(`
`)}
}`
  , pz = () => {
    if (!document.getElementById("colors")) {
        const t = document.createElement("style");
        t.rel = "stylesheet",
        t.id = "colors",
        document.head.appendChild(t)
    }
}
  , hz = e => {
    const t = document.getElementById("colors");
    if (!t)
        throw new Error("  style  ");
    t.textContent = dz(fz(e))
}
  , Gf = e => {
    let t = "";
    const n = "0123456789abcdefghijklmnopqrstuvwxyz"
      , a = Math.ceil(e.length / 2)
      , r = new Uint8Array(a);
    if (typeof crypto < "u" && crypto.getRandomValues)
        crypto.getRandomValues(r);
    else
        for (let s = 0; s < a; s++)
            r[s] = Math.floor(Math.random() * 256);
    let o = 0
      , i = 0;
    for (; i < e.length && o < a; )
        if (e[i] === "-")
            t += "-",
            i++;
        else {
            const s = r[o] >> 4
              , l = r[o] & 15;
            t += e[i] === "x" ? n[s] : n[l],
            i++,
            i < e.length && e[i] === "x" && (t += n[l],
            i++),
            o++
        }
    return t
}
  , tl = e => {
    const t = document.createElement("textarea");
    t.value = e,
    document.body.appendChild(t),
    t.select(),
    document.execCommand("copy"),
    document.body.removeChild(t)
}
  , Si = Intl.DateTimeFormat(void 0, {
    day: "numeric",
    month: "short",
    year: "numeric"
})
  , mz = e => {
    const t = new Date(e);
    return Si.format(t)
}
  , mc = (e, t=!1, n=1) => {
    const a = t ? 1e3 : 1024;
    if (Math.abs(e) < a)
        return `${e} B`;
    const r = t ? ["kB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"] : ["KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"];
    let o = -1;
    const i = 10 ** n;
    do
        e /= a,
        ++o;
    while (Math.round(Math.abs(e) * i) / i >= a && o < r.length - 1);
    return `${e.toFixed(n)} ${r[o]}`
}
  , gz = () => {
    const {userAgent: e} = window.navigator
      , t = e.match(/(iPhone|iPad|iPod).*OS\s([\d_]+)/);
    return t && t.length >= 3 ? t[2].replace(/_/g, ".") : "Unknown iOS version"
}
  , vz = async () => {
    const t = await (await fetch("https://api.ipsw.me/v4/device/iPhone16,2?type=beta")).json();
    return t.firmwares && t.firmwares.length > 0 ? t.firmwares[0].version : null
}
  , bz = (e, t) => {
    const n = e.split(".").map(Number)
      , a = t.split(".").map(Number);
    for (let r = 0; r < Math.max(n.length, a.length); r++) {
        const o = n[r] || 0
          , i = a[r] || 0;
        if (o > i)
            return 1;
        if (o < i)
            return -1
    }
    return 0
}
  , yz = e => new URLSearchParams(window.location.search).get(e);
const Cz = () => {
    const t = "abcdefghijklmnopqrstuvwxyz0123456789";
    let n = "";
    for (let a = 0; a < 10; a++)
        n += t.charAt(Math.floor(Math.random() * t.length));
    return `${n}`
}
  , wz = () => (navigator.language || navigator.userLanguage).split("-")[0]
  , _z = e => {
    const t = new Date(e)
      , n = new Date;
    return t < n
}
  , kz = [{
    name: "Nabzclan - IPA Library",
    subtitle: "Welcome to Nabzclan - IPA Library Repo!",
    iconURL: "https://pbs.twimg.com/profile_images/1607513868359565312/z9Dzmkaw_400x400.jpg",
    sourceURL: "https://apps.nabzclan.vip/repos/altstore.php",
    count: 179
}, {
    name: "AppTesters IPA Repo",
    subtitle: "Biggest Updated Modified IPA Library for Sideloading - AppTesters.org",
    iconURL: "https://apptesters.org/wp-content/uploads/2024/04/AppTesters-Logo-Site-Icon.webp",
    sourceURL: "https://repository.apptesters.org",
    count: 836
}, {
    name: "Quantum Source",
    subtitle: "Contains all of your favorite emulators, games, jailbreaks, utilities, and more.",
    iconURL: "https://quarksources.github.io/assets/ElementQ-Circled.png",
    sourceURL: "https://quarksources.github.io/dist/quantumsource.min.json",
    count: 38
}]
  , Sz = !0
  , Zl = "#ffffff"
  , $z = !1
  , Ez = !1
  , xz = localStorage.fsDarkMode ? JSON.parse(localStorage.fsDarkMode) : Sz
  , C4 = localStorage.fsThemeColorHex ? localStorage.fsThemeColorHex : Zl
  , Tz = localStorage.dev_mode ? !0 : $z
  , Mz = localStorage.isAdultUser ? JSON.parse(localStorage.isAdultUser) : Ez
  , nl = oa("app", {
    state: () => ({
        devMode: Tz,
        darkMode: xz,
        themeColorHex: C4,
        resetThemeColorExecuted: 0,
        isAdultUser: Mz
    }),
    getters: {},
    actions: {
        switchDarkMode() {
            this.darkMode = !this.darkMode,
            localStorage.fsDarkMode = this.darkMode,
            (this.themeColorHex === Zl || this.themeColorHex === "#000000") && this.resetThemeColor()
        },
        setAccessToAdultContent(e) {
            this.isAdultUser = e,
            localStorage.isAdultUser = e
        },
        init() {
            this.updateBodyDarkThemeClass(),
            pz(),
            this.setThemeColor(C4),
            localStorage.fsAppUUID = localStorage.fsAppUUID ?? Gf("xxxxxxxxxxxxxx"),
            localStorage.sources = localStorage.sources ?? JSON.stringify(kz)
        },
        updateBodyDarkThemeClass() {
            this.darkMode ? document.body.classList.add("dark") : document.body.classList.remove("dark")
        },
        setThemeColor(e) {
            if (!/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(e))
                throw new Error(`  : ${e}`);
            hz(e),
            this.setDefaultColorClass(e),
            localStorage.fsThemeColorHex = e,
            this.themeColorHex = e
        },
        setDefaultColorClass(e) {
            const t = document.getElementById("app");
            if (!t)
                throw new Error("    ");
            e === Zl || e === "#000000" ? t.classList.add("default-colors") : t.classList.remove("default-colors")
        },
        resetThemeColor() {
            this.darkMode ? this.setThemeColor(Zl) : this.setThemeColor("#000000"),
            this.resetThemeColorExecuted++
        }
    }
});
const zz = {
    __name: "ui",
    setup(e) {
        const t = nl();
        let n;
        return df( () => {
            t.resetThemeColorExecuted && n.setValue({
                hex: t.themeColorHex
            })
        }
        ),
        Xe( () => {
            ut( () => {
                n = D.colorPicker.create({
                    inputEl: "#demo-color-picker-wheel",
                    targetEl: "#demo-color-picker-wheel-value",
                    targetElSetBackgroundColor: !0,
                    modules: ["wheel"],
                    openIn: "popover",
                    value: {
                        hex: t.themeColorHex
                    },
                    on: {
                        open: a => {
                            b8(a.modal),
                            window.dispatchEvent(new Event("resize"))
                        }
                        ,
                        change: a => {
                            t.setThemeColor(a.value.hex)
                        }
                    }
                })
            }
            )
        }
        ),
        (a, r) => (O(),
        G("i", {
            id: "demo-color-picker-wheel-value",
            class: "icon demo-list-icon",
            style: Rt({
                backgroundColor: B(t).themeColorHex
            })
        }, null, 4))
    }
}
  , Az = {
    __name: "ui",
    setup(e) {
        const t = nl();
        return (n, a) => {
            const r = P("f7-icon")
              , o = P("f7-toggle")
              , i = P("f7-list-item")
              , s = P("f7-list");
            return O(),
            K(s, {
                class: "rounded-items",
                inset: ""
            }, {
                default: k( () => [S(i, {
                    title: "Dark mode"
                }, {
                    media: k( () => [S(r, {
                        f7: "moon_fill"
                    })]),
                    after: k( () => [S(o, {
                        checked: B(t).darkMode,
                        onChange: a[0] || (a[0] = l => B(t).switchDarkMode())
                    }, null, 8, ["checked"])]),
                    _: 1
                }), S(i, {
                    title: "Color theme"
                }, {
                    media: k( () => [S(r, {
                        f7: "paintbrush_fill"
                    })]),
                    after: k( () => [S(B(zz))]),
                    _: 1
                }), S(i, {
                    link: "#",
                    "no-chevron": "",
                    title: "Restore color",
                    onClick: B(t).resetThemeColor
                }, {
                    media: k( () => [S(r, {
                        f7: "arrow_clockwise"
                    })]),
                    _: 1
                }, 8, ["onClick"])]),
                _: 1
            })
        }
    }
};
function y8(e, t) {
    return function() {
        return e.apply(t, arguments)
    }
}
const {toString: C8} = Object.prototype
  , {getPrototypeOf: Xf} = Object
  , Kf = (e => t => {
    const n = C8.call(t);
    return e[n] || (e[n] = n.slice(8, -1).toLowerCase())
}
)(Object.create(null))
  , fr = e => (e = e.toLowerCase(),
t => Kf(t) === e)
  , gc = e => t => typeof t === e
  , {isArray: $i} = Array
  , As = gc("undefined");
function Oz(e) {
    return e !== null && !As(e) && e.constructor !== null && !As(e.constructor) && Nr(e.constructor.isBuffer) && e.constructor.isBuffer(e)
}
const w8 = fr("ArrayBuffer");
function Pz(e) {
    let t;
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && w8(e.buffer),
    t
}
const Lz = gc("string")
  , Nr = gc("function")
  , _8 = gc("number")
  , Zf = e => e !== null && typeof e == "object"
  , Iz = e => e === !0 || e === !1
  , Jl = e => {
    if (Kf(e) !== "object")
        return !1;
    const t = Xf(e);
    return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e)
}
  , Bz = fr("Date")
  , Rz = fr("File")
  , Dz = fr("Blob")
  , Nz = fr("FileList")
  , Hz = e => Zf(e) && Nr(e.pipe)
  , Vz = e => {
    const t = "[object FormData]";
    return e && (typeof FormData == "function" && e instanceof FormData || C8.call(e) === t || Nr(e.toString) && e.toString() === t)
}
  , Fz = fr("URLSearchParams")
  , jz = e => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function al(e, t, {allOwnKeys: n=!1}={}) {
    if (e === null || typeof e > "u")
        return;
    let a, r;
    if (typeof e != "object" && (e = [e]),
    $i(e))
        for (a = 0,
        r = e.length; a < r; a++)
            t.call(null, e[a], a, e);
    else {
        const o = n ? Object.getOwnPropertyNames(e) : Object.keys(e)
          , i = o.length;
        let s;
        for (a = 0; a < i; a++)
            s = o[a],
            t.call(null, e[s], s, e)
    }
}
function k8(e, t) {
    t = t.toLowerCase();
    const n = Object.keys(e);
    let a = n.length, r;
    for (; a-- > 0; )
        if (r = n[a],
        t === r.toLowerCase())
            return r;
    return null
}
const S8 = ( () => typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global)()
  , $8 = e => !As(e) && e !== S8;
function bu() {
    const {caseless: e} = $8(this) && this || {}
      , t = {}
      , n = (a, r) => {
        const o = e && k8(t, r) || r;
        Jl(t[o]) && Jl(a) ? t[o] = bu(t[o], a) : Jl(a) ? t[o] = bu({}, a) : $i(a) ? t[o] = a.slice() : t[o] = a
    }
    ;
    for (let a = 0, r = arguments.length; a < r; a++)
        arguments[a] && al(arguments[a], n);
    return t
}
const Uz = (e, t, n, {allOwnKeys: a}={}) => (al(t, (r, o) => {
    n && Nr(r) ? e[o] = y8(r, n) : e[o] = r
}
, {
    allOwnKeys: a
}),
e)
  , qz = e => (e.charCodeAt(0) === 65279 && (e = e.slice(1)),
e)
  , Wz = (e, t, n, a) => {
    e.prototype = Object.create(t.prototype, a),
    e.prototype.constructor = e,
    Object.defineProperty(e, "super", {
        value: t.prototype
    }),
    n && Object.assign(e.prototype, n)
}
  , Yz = (e, t, n, a) => {
    let r, o, i;
    const s = {};
    if (t = t || {},
    e == null)
        return t;
    do {
        for (r = Object.getOwnPropertyNames(e),
        o = r.length; o-- > 0; )
            i = r[o],
            (!a || a(i, e, t)) && !s[i] && (t[i] = e[i],
            s[i] = !0);
        e = n !== !1 && Xf(e)
    } while (e && (!n || n(e, t)) && e !== Object.prototype);
    return t
}
  , Gz = (e, t, n) => {
    e = String(e),
    (n === void 0 || n > e.length) && (n = e.length),
    n -= t.length;
    const a = e.indexOf(t, n);
    return a !== -1 && a === n
}
  , Xz = e => {
    if (!e)
        return null;
    if ($i(e))
        return e;
    let t = e.length;
    if (!_8(t))
        return null;
    const n = new Array(t);
    for (; t-- > 0; )
        n[t] = e[t];
    return n
}
  , Kz = (e => t => e && t instanceof e)(typeof Uint8Array < "u" && Xf(Uint8Array))
  , Zz = (e, t) => {
    const a = (e && e[Symbol.iterator]).call(e);
    let r;
    for (; (r = a.next()) && !r.done; ) {
        const o = r.value;
        t.call(e, o[0], o[1])
    }
}
  , Jz = (e, t) => {
    let n;
    const a = [];
    for (; (n = e.exec(t)) !== null; )
        a.push(n);
    return a
}
  , Qz = fr("HTMLFormElement")
  , eA = e => e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(n, a, r) {
    return a.toUpperCase() + r
})
  , w4 = ( ({hasOwnProperty: e}) => (t, n) => e.call(t, n))(Object.prototype)
  , tA = fr("RegExp")
  , E8 = (e, t) => {
    const n = Object.getOwnPropertyDescriptors(e)
      , a = {};
    al(n, (r, o) => {
        t(r, o, e) !== !1 && (a[o] = r)
    }
    ),
    Object.defineProperties(e, a)
}
  , nA = e => {
    E8(e, (t, n) => {
        if (Nr(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
            return !1;
        const a = e[n];
        if (Nr(a)) {
            if (t.enumerable = !1,
            "writable"in t) {
                t.writable = !1;
                return
            }
            t.set || (t.set = () => {
                throw Error("Can not rewrite read-only method '" + n + "'")
            }
            )
        }
    }
    )
}
  , aA = (e, t) => {
    const n = {}
      , a = r => {
        r.forEach(o => {
            n[o] = !0
        }
        )
    }
    ;
    return $i(e) ? a(e) : a(String(e).split(t)),
    n
}
  , rA = () => {}
  , oA = (e, t) => (e = +e,
Number.isFinite(e) ? e : t)
  , o2 = "abcdefghijklmnopqrstuvwxyz"
  , _4 = "0123456789"
  , x8 = {
    DIGIT: _4,
    ALPHA: o2,
    ALPHA_DIGIT: o2 + o2.toUpperCase() + _4
}
  , iA = (e=16, t=x8.ALPHA_DIGIT) => {
    let n = "";
    const {length: a} = t;
    for (; e--; )
        n += t[Math.random() * a | 0];
    return n
}
;
function sA(e) {
    return !!(e && Nr(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator])
}
const lA = e => {
    const t = new Array(10)
      , n = (a, r) => {
        if (Zf(a)) {
            if (t.indexOf(a) >= 0)
                return;
            if (!("toJSON"in a)) {
                t[r] = a;
                const o = $i(a) ? [] : {};
                return al(a, (i, s) => {
                    const l = n(i, r + 1);
                    !As(l) && (o[s] = l)
                }
                ),
                t[r] = void 0,
                o
            }
        }
        return a
    }
    ;
    return n(e, 0)
}
  , ke = {
    isArray: $i,
    isArrayBuffer: w8,
    isBuffer: Oz,
    isFormData: Vz,
    isArrayBufferView: Pz,
    isString: Lz,
    isNumber: _8,
    isBoolean: Iz,
    isObject: Zf,
    isPlainObject: Jl,
    isUndefined: As,
    isDate: Bz,
    isFile: Rz,
    isBlob: Dz,
    isRegExp: tA,
    isFunction: Nr,
    isStream: Hz,
    isURLSearchParams: Fz,
    isTypedArray: Kz,
    isFileList: Nz,
    forEach: al,
    merge: bu,
    extend: Uz,
    trim: jz,
    stripBOM: qz,
    inherits: Wz,
    toFlatObject: Yz,
    kindOf: Kf,
    kindOfTest: fr,
    endsWith: Gz,
    toArray: Xz,
    forEachEntry: Zz,
    matchAll: Jz,
    isHTMLForm: Qz,
    hasOwnProperty: w4,
    hasOwnProp: w4,
    reduceDescriptors: E8,
    freezeMethods: nA,
    toObjectSet: aA,
    toCamelCase: eA,
    noop: rA,
    toFiniteNumber: oA,
    findKey: k8,
    global: S8,
    isContextDefined: $8,
    ALPHABET: x8,
    generateString: iA,
    isSpecCompliantForm: sA,
    toJSONObject: lA
};
function wt(e, t, n, a, r) {
    Error.call(this),
    Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack,
    this.message = e,
    this.name = "AxiosError",
    t && (this.code = t),
    n && (this.config = n),
    a && (this.request = a),
    r && (this.response = r)
}
ke.inherits(wt, Error, {
    toJSON: function() {
        return {
            message: this.message,
            name: this.name,
            description: this.description,
            number: this.number,
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            config: ke.toJSONObject(this.config),
            code: this.code,
            status: this.response && this.response.status ? this.response.status : null
        }
    }
});
const T8 = wt.prototype
  , M8 = {};
["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(e => {
    M8[e] = {
        value: e
    }
}
);
Object.defineProperties(wt, M8);
Object.defineProperty(T8, "isAxiosError", {
    value: !0
});
wt.from = (e, t, n, a, r, o) => {
    const i = Object.create(T8);
    return ke.toFlatObject(e, i, function(l) {
        return l !== Error.prototype
    }, s => s !== "isAxiosError"),
    wt.call(i, e.message, t, n, a, r),
    i.cause = e,
    i.name = e.name,
    o && Object.assign(i, o),
    i
}
;
const z8 = null;
function yu(e) {
    return ke.isPlainObject(e) || ke.isArray(e)
}
function A8(e) {
    return ke.endsWith(e, "[]") ? e.slice(0, -2) : e
}
function k4(e, t, n) {
    return e ? e.concat(t).map(function(r, o) {
        return r = A8(r),
        !n && o ? "[" + r + "]" : r
    }).join(n ? "." : "") : t
}
function cA(e) {
    return ke.isArray(e) && !e.some(yu)
}
const uA = ke.toFlatObject(ke, {}, null, function(t) {
    return /^is[A-Z]/.test(t)
});
function vc(e, t, n) {
    if (!ke.isObject(e))
        throw new TypeError("target must be an object");
    t = t || new (z8 || FormData),
    n = ke.toFlatObject(n, {
        metaTokens: !0,
        dots: !1,
        indexes: !1
    }, !1, function(m, g) {
        return !ke.isUndefined(g[m])
    });
    const a = n.metaTokens
      , r = n.visitor || u
      , o = n.dots
      , i = n.indexes
      , l = (n.Blob || typeof Blob < "u" && Blob) && ke.isSpecCompliantForm(t);
    if (!ke.isFunction(r))
        throw new TypeError("visitor must be a function");
    function c(h) {
        if (h === null)
            return "";
        if (ke.isDate(h))
            return h.toISOString();
        if (!l && ke.isBlob(h))
            throw new wt("Blob is not supported. Use a Buffer instead.");
        return ke.isArrayBuffer(h) || ke.isTypedArray(h) ? l && typeof Blob == "function" ? new Blob([h]) : Buffer.from(h) : h
    }
    function u(h, m, g) {
        let b = h;
        if (h && !g && typeof h == "object") {
            if (ke.endsWith(m, "{}"))
                m = a ? m : m.slice(0, -2),
                h = JSON.stringify(h);
            else if (ke.isArray(h) && cA(h) || (ke.isFileList(h) || ke.endsWith(m, "[]")) && (b = ke.toArray(h)))
                return m = A8(m),
                b.forEach(function(y, w) {
                    !(ke.isUndefined(y) || y === null) && t.append(i === !0 ? k4([m], w, o) : i === null ? m : m + "[]", c(y))
                }),
                !1
        }
        return yu(h) ? !0 : (t.append(k4(g, m, o), c(h)),
        !1)
    }
    const f = []
      , d = Object.assign(uA, {
        defaultVisitor: u,
        convertValue: c,
        isVisitable: yu
    });
    function p(h, m) {
        if (!ke.isUndefined(h)) {
            if (f.indexOf(h) !== -1)
                throw Error("Circular reference detected in " + m.join("."));
            f.push(h),
            ke.forEach(h, function(b, v) {
                (!(ke.isUndefined(b) || b === null) && r.call(t, b, ke.isString(v) ? v.trim() : v, m, d)) === !0 && p(b, m ? m.concat(v) : [v])
            }),
            f.pop()
        }
    }
    if (!ke.isObject(e))
        throw new TypeError("data must be an object");
    return p(e),
    t
}
function S4(e) {
    const t = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
    };
    return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(a) {
        return t[a]
    })
}
function Jf(e, t) {
    this._pairs = [],
    e && vc(e, this, t)
}
const O8 = Jf.prototype;
O8.append = function(t, n) {
    this._pairs.push([t, n])
}
;
O8.toString = function(t) {
    const n = t ? function(a) {
        return t.call(this, a, S4)
    }
    : S4;
    return this._pairs.map(function(r) {
        return n(r[0]) + "=" + n(r[1])
    }, "").join("&")
}
;
function fA(e) {
    return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
}
function P8(e, t, n) {
    if (!t)
        return e;
    const a = n && n.encode || fA
      , r = n && n.serialize;
    let o;
    if (r ? o = r(t, n) : o = ke.isURLSearchParams(t) ? t.toString() : new Jf(t,n).toString(a),
    o) {
        const i = e.indexOf("#");
        i !== -1 && (e = e.slice(0, i)),
        e += (e.indexOf("?") === -1 ? "?" : "&") + o
    }
    return e
}
class $4 {
    constructor() {
        this.handlers = []
    }
    use(t, n, a) {
        return this.handlers.push({
            fulfilled: t,
            rejected: n,
            synchronous: a ? a.synchronous : !1,
            runWhen: a ? a.runWhen : null
        }),
        this.handlers.length - 1
    }
    eject(t) {
        this.handlers[t] && (this.handlers[t] = null)
    }
    clear() {
        this.handlers && (this.handlers = [])
    }
    forEach(t) {
        ke.forEach(this.handlers, function(a) {
            a !== null && t(a)
        })
    }
}
const L8 = {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1
}
  , dA = typeof URLSearchParams < "u" ? URLSearchParams : Jf
  , pA = typeof FormData < "u" ? FormData : null
  , hA = typeof Blob < "u" ? Blob : null
  , mA = ( () => {
    let e;
    return typeof navigator < "u" && ((e = navigator.product) === "ReactNative" || e === "NativeScript" || e === "NS") ? !1 : typeof window < "u" && typeof document < "u"
}
)()
  , gA = ( () => typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function")()
  , Pa = {
    isBrowser: !0,
    classes: {
        URLSearchParams: dA,
        FormData: pA,
        Blob: hA
    },
    isStandardBrowserEnv: mA,
    isStandardBrowserWebWorkerEnv: gA,
    protocols: ["http", "https", "file", "blob", "url", "data"]
};
function vA(e, t) {
    return vc(e, new Pa.classes.URLSearchParams, Object.assign({
        visitor: function(n, a, r, o) {
            return Pa.isNode && ke.isBuffer(n) ? (this.append(a, n.toString("base64")),
            !1) : o.defaultVisitor.apply(this, arguments)
        }
    }, t))
}
function bA(e) {
    return ke.matchAll(/\w+|\[(\w*)]/g, e).map(t => t[0] === "[]" ? "" : t[1] || t[0])
}
function yA(e) {
    const t = {}
      , n = Object.keys(e);
    let a;
    const r = n.length;
    let o;
    for (a = 0; a < r; a++)
        o = n[a],
        t[o] = e[o];
    return t
}
function I8(e) {
    function t(n, a, r, o) {
        let i = n[o++];
        const s = Number.isFinite(+i)
          , l = o >= n.length;
        return i = !i && ke.isArray(r) ? r.length : i,
        l ? (ke.hasOwnProp(r, i) ? r[i] = [r[i], a] : r[i] = a,
        !s) : ((!r[i] || !ke.isObject(r[i])) && (r[i] = []),
        t(n, a, r[i], o) && ke.isArray(r[i]) && (r[i] = yA(r[i])),
        !s)
    }
    if (ke.isFormData(e) && ke.isFunction(e.entries)) {
        const n = {};
        return ke.forEachEntry(e, (a, r) => {
            t(bA(a), r, n, 0)
        }
        ),
        n
    }
    return null
}
const CA = {
    "Content-Type": void 0
};
function wA(e, t, n) {
    if (ke.isString(e))
        try {
            return (t || JSON.parse)(e),
            ke.trim(e)
        } catch (a) {
            if (a.name !== "SyntaxError")
                throw a
        }
    return (n || JSON.stringify)(e)
}
const Ei = {
    transitional: L8,
    adapter: ["xhr", "http"],
    transformRequest: [function(t, n) {
        const a = n.getContentType() || ""
          , r = a.indexOf("application/json") > -1
          , o = ke.isObject(t);
        if (o && ke.isHTMLForm(t) && (t = new FormData(t)),
        ke.isFormData(t))
            return r && r ? JSON.stringify(I8(t)) : t;
        if (ke.isArrayBuffer(t) || ke.isBuffer(t) || ke.isStream(t) || ke.isFile(t) || ke.isBlob(t))
            return t;
        if (ke.isArrayBufferView(t))
            return t.buffer;
        if (ke.isURLSearchParams(t))
            return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1),
            t.toString();
        let s;
        if (o) {
            if (a.indexOf("application/x-www-form-urlencoded") > -1)
                return vA(t, this.formSerializer).toString();
            if ((s = ke.isFileList(t)) || a.indexOf("multipart/form-data") > -1) {
                const l = this.env && this.env.FormData;
                return vc(s ? {
                    "files[]": t
                } : t, l && new l, this.formSerializer)
            }
        }
        return o || r ? (n.setContentType("application/json", !1),
        wA(t)) : t
    }
    ],
    transformResponse: [function(t) {
        const n = this.transitional || Ei.transitional
          , a = n && n.forcedJSONParsing
          , r = this.responseType === "json";
        if (t && ke.isString(t) && (a && !this.responseType || r)) {
            const i = !(n && n.silentJSONParsing) && r;
            try {
                return JSON.parse(t)
            } catch (s) {
                if (i)
                    throw s.name === "SyntaxError" ? wt.from(s, wt.ERR_BAD_RESPONSE, this, null, this.response) : s
            }
        }
        return t
    }
    ],
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
        FormData: Pa.classes.FormData,
        Blob: Pa.classes.Blob
    },
    validateStatus: function(t) {
        return t >= 200 && t < 300
    },
    headers: {
        common: {
            Accept: "application/json, text/plain, */*"
        }
    }
};
ke.forEach(["delete", "get", "head"], function(t) {
    Ei.headers[t] = {}
});
ke.forEach(["post", "put", "patch"], function(t) {
    Ei.headers[t] = ke.merge(CA)
});
const _A = ke.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"])
  , kA = e => {
    const t = {};
    let n, a, r;
    return e && e.split(`
`).forEach(function(i) {
        r = i.indexOf(":"),
        n = i.substring(0, r).trim().toLowerCase(),
        a = i.substring(r + 1).trim(),
        !(!n || t[n] && _A[n]) && (n === "set-cookie" ? t[n] ? t[n].push(a) : t[n] = [a] : t[n] = t[n] ? t[n] + ", " + a : a)
    }),
    t
}
  , E4 = Symbol("internals");
function ji(e) {
    return e && String(e).trim().toLowerCase()
}
function Ql(e) {
    return e === !1 || e == null ? e : ke.isArray(e) ? e.map(Ql) : String(e)
}
function SA(e) {
    const t = Object.create(null)
      , n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let a;
    for (; a = n.exec(e); )
        t[a[1]] = a[2];
    return t
}
function $A(e) {
    return /^[-_a-zA-Z]+$/.test(e.trim())
}
function i2(e, t, n, a, r) {
    if (ke.isFunction(a))
        return a.call(this, t, n);
    if (r && (t = n),
    !!ke.isString(t)) {
        if (ke.isString(a))
            return t.indexOf(a) !== -1;
        if (ke.isRegExp(a))
            return a.test(t)
    }
}
function EA(e) {
    return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, n, a) => n.toUpperCase() + a)
}
function xA(e, t) {
    const n = ke.toCamelCase(" " + t);
    ["get", "set", "has"].forEach(a => {
        Object.defineProperty(e, a + n, {
            value: function(r, o, i) {
                return this[a].call(this, t, r, o, i)
            },
            configurable: !0
        })
    }
    )
}
let ta = class {
    constructor(t) {
        t && this.set(t)
    }
    set(t, n, a) {
        const r = this;
        function o(s, l, c) {
            const u = ji(l);
            if (!u)
                throw new Error("header name must be a non-empty string");
            const f = ke.findKey(r, u);
            (!f || r[f] === void 0 || c === !0 || c === void 0 && r[f] !== !1) && (r[f || l] = Ql(s))
        }
        const i = (s, l) => ke.forEach(s, (c, u) => o(c, u, l));
        return ke.isPlainObject(t) || t instanceof this.constructor ? i(t, n) : ke.isString(t) && (t = t.trim()) && !$A(t) ? i(kA(t), n) : t != null && o(n, t, a),
        this
    }
    get(t, n) {
        if (t = ji(t),
        t) {
            const a = ke.findKey(this, t);
            if (a) {
                const r = this[a];
                if (!n)
                    return r;
                if (n === !0)
                    return SA(r);
                if (ke.isFunction(n))
                    return n.call(this, r, a);
                if (ke.isRegExp(n))
                    return n.exec(r);
                throw new TypeError("parser must be boolean|regexp|function")
            }
        }
    }
    has(t, n) {
        if (t = ji(t),
        t) {
            const a = ke.findKey(this, t);
            return !!(a && this[a] !== void 0 && (!n || i2(this, this[a], a, n)))
        }
        return !1
    }
    delete(t, n) {
        const a = this;
        let r = !1;
        function o(i) {
            if (i = ji(i),
            i) {
                const s = ke.findKey(a, i);
                s && (!n || i2(a, a[s], s, n)) && (delete a[s],
                r = !0)
            }
        }
        return ke.isArray(t) ? t.forEach(o) : o(t),
        r
    }
    clear(t) {
        const n = Object.keys(this);
        let a = n.length
          , r = !1;
        for (; a--; ) {
            const o = n[a];
            (!t || i2(this, this[o], o, t, !0)) && (delete this[o],
            r = !0)
        }
        return r
    }
    normalize(t) {
        const n = this
          , a = {};
        return ke.forEach(this, (r, o) => {
            const i = ke.findKey(a, o);
            if (i) {
                n[i] = Ql(r),
                delete n[o];
                return
            }
            const s = t ? EA(o) : String(o).trim();
            s !== o && delete n[o],
            n[s] = Ql(r),
            a[s] = !0
        }
        ),
        this
    }
    concat(...t) {
        return this.constructor.concat(this, ...t)
    }
    toJSON(t) {
        const n = Object.create(null);
        return ke.forEach(this, (a, r) => {
            a != null && a !== !1 && (n[r] = t && ke.isArray(a) ? a.join(", ") : a)
        }
        ),
        n
    }
    [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]()
    }
    toString() {
        return Object.entries(this.toJSON()).map( ([t,n]) => t + ": " + n).join(`
`)
    }
    get[Symbol.toStringTag]() {
        return "AxiosHeaders"
    }
    static from(t) {
        return t instanceof this ? t : new this(t)
    }
    static concat(t, ...n) {
        const a = new this(t);
        return n.forEach(r => a.set(r)),
        a
    }
    static accessor(t) {
        const a = (this[E4] = this[E4] = {
            accessors: {}
        }).accessors
          , r = this.prototype;
        function o(i) {
            const s = ji(i);
            a[s] || (xA(r, i),
            a[s] = !0)
        }
        return ke.isArray(t) ? t.forEach(o) : o(t),
        this
    }
}
;
ta.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
ke.freezeMethods(ta.prototype);
ke.freezeMethods(ta);
function s2(e, t) {
    const n = this || Ei
      , a = t || n
      , r = ta.from(a.headers);
    let o = a.data;
    return ke.forEach(e, function(s) {
        o = s.call(n, o, r.normalize(), t ? t.status : void 0)
    }),
    r.normalize(),
    o
}
function B8(e) {
    return !!(e && e.__CANCEL__)
}
function rl(e, t, n) {
    wt.call(this, e ?? "canceled", wt.ERR_CANCELED, t, n),
    this.name = "CanceledError"
}
ke.inherits(rl, wt, {
    __CANCEL__: !0
});
function TA(e, t, n) {
    const a = n.config.validateStatus;
    !n.status || !a || a(n.status) ? e(n) : t(new wt("Request failed with status code " + n.status,[wt.ERR_BAD_REQUEST, wt.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],n.config,n.request,n))
}
const MA = Pa.isStandardBrowserEnv ? function() {
    return {
        write: function(n, a, r, o, i, s) {
            const l = [];
            l.push(n + "=" + encodeURIComponent(a)),
            ke.isNumber(r) && l.push("expires=" + new Date(r).toGMTString()),
            ke.isString(o) && l.push("path=" + o),
            ke.isString(i) && l.push("domain=" + i),
            s === !0 && l.push("secure"),
            document.cookie = l.join("; ")
        },
        read: function(n) {
            const a = document.cookie.match(new RegExp("(^|;\\s*)(" + n + ")=([^;]*)"));
            return a ? decodeURIComponent(a[3]) : null
        },
        remove: function(n) {
            this.write(n, "", Date.now() - 864e5)
        }
    }
}() : function() {
    return {
        write: function() {},
        read: function() {
            return null
        },
        remove: function() {}
    }
}();
function zA(e) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e)
}
function AA(e, t) {
    return t ? e.replace(/\/+$/, "") + "/" + t.replace(/^\/+/, "") : e
}
function R8(e, t) {
    return e && !zA(t) ? AA(e, t) : t
}
const OA = Pa.isStandardBrowserEnv ? function() {
    const t = /(msie|trident)/i.test(navigator.userAgent)
      , n = document.createElement("a");
    let a;
    function r(o) {
        let i = o;
        return t && (n.setAttribute("href", i),
        i = n.href),
        n.setAttribute("href", i),
        {
            href: n.href,
            protocol: n.protocol ? n.protocol.replace(/:$/, "") : "",
            host: n.host,
            search: n.search ? n.search.replace(/^\?/, "") : "",
            hash: n.hash ? n.hash.replace(/^#/, "") : "",
            hostname: n.hostname,
            port: n.port,
            pathname: n.pathname.charAt(0) === "/" ? n.pathname : "/" + n.pathname
        }
    }
    return a = r(window.location.href),
    function(i) {
        const s = ke.isString(i) ? r(i) : i;
        return s.protocol === a.protocol && s.host === a.host
    }
}() : function() {
    return function() {
        return !0
    }
}();
function PA(e) {
    const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
    return t && t[1] || ""
}
function LA(e, t) {
    e = e || 10;
    const n = new Array(e)
      , a = new Array(e);
    let r = 0, o = 0, i;
    return t = t !== void 0 ? t : 1e3,
    function(l) {
        const c = Date.now()
          , u = a[o];
        i || (i = c),
        n[r] = l,
        a[r] = c;
        let f = o
          , d = 0;
        for (; f !== r; )
            d += n[f++],
            f = f % e;
        if (r = (r + 1) % e,
        r === o && (o = (o + 1) % e),
        c - i < t)
            return;
        const p = u && c - u;
        return p ? Math.round(d * 1e3 / p) : void 0
    }
}
function x4(e, t) {
    let n = 0;
    const a = LA(50, 250);
    return r => {
        const o = r.loaded
          , i = r.lengthComputable ? r.total : void 0
          , s = o - n
          , l = a(s)
          , c = o <= i;
        n = o;
        const u = {
            loaded: o,
            total: i,
            progress: i ? o / i : void 0,
            bytes: s,
            rate: l || void 0,
            estimated: l && i && c ? (i - o) / l : void 0,
            event: r
        };
        u[t ? "download" : "upload"] = !0,
        e(u)
    }
}
const IA = typeof XMLHttpRequest < "u"
  , BA = IA && function(e) {
    return new Promise(function(n, a) {
        let r = e.data;
        const o = ta.from(e.headers).normalize()
          , i = e.responseType;
        let s;
        function l() {
            e.cancelToken && e.cancelToken.unsubscribe(s),
            e.signal && e.signal.removeEventListener("abort", s)
        }
        ke.isFormData(r) && (Pa.isStandardBrowserEnv || Pa.isStandardBrowserWebWorkerEnv) && o.setContentType(!1);
        let c = new XMLHttpRequest;
        if (e.auth) {
            const p = e.auth.username || ""
              , h = e.auth.password ? unescape(encodeURIComponent(e.auth.password)) : "";
            o.set("Authorization", "Basic " + btoa(p + ":" + h))
        }
        const u = R8(e.baseURL, e.url);
        c.open(e.method.toUpperCase(), P8(u, e.params, e.paramsSerializer), !0),
        c.timeout = e.timeout;
        function f() {
            if (!c)
                return;
            const p = ta.from("getAllResponseHeaders"in c && c.getAllResponseHeaders())
              , m = {
                data: !i || i === "text" || i === "json" ? c.responseText : c.response,
                status: c.status,
                statusText: c.statusText,
                headers: p,
                config: e,
                request: c
            };
            TA(function(b) {
                n(b),
                l()
            }, function(b) {
                a(b),
                l()
            }, m),
            c = null
        }
        if ("onloadend"in c ? c.onloadend = f : c.onreadystatechange = function() {
            !c || c.readyState !== 4 || c.status === 0 && !(c.responseURL && c.responseURL.indexOf("file:") === 0) || setTimeout(f)
        }
        ,
        c.onabort = function() {
            c && (a(new wt("Request aborted",wt.ECONNABORTED,e,c)),
            c = null)
        }
        ,
        c.onerror = function() {
            a(new wt("Network Error",wt.ERR_NETWORK,e,c)),
            c = null
        }
        ,
        c.ontimeout = function() {
            let h = e.timeout ? "timeout of " + e.timeout + "ms exceeded" : "timeout exceeded";
            const m = e.transitional || L8;
            e.timeoutErrorMessage && (h = e.timeoutErrorMessage),
            a(new wt(h,m.clarifyTimeoutError ? wt.ETIMEDOUT : wt.ECONNABORTED,e,c)),
            c = null
        }
        ,
        Pa.isStandardBrowserEnv) {
            const p = (e.withCredentials || OA(u)) && e.xsrfCookieName && MA.read(e.xsrfCookieName);
            p && o.set(e.xsrfHeaderName, p)
        }
        r === void 0 && o.setContentType(null),
        "setRequestHeader"in c && ke.forEach(o.toJSON(), function(h, m) {
            c.setRequestHeader(m, h)
        }),
        ke.isUndefined(e.withCredentials) || (c.withCredentials = !!e.withCredentials),
        i && i !== "json" && (c.responseType = e.responseType),
        typeof e.onDownloadProgress == "function" && c.addEventListener("progress", x4(e.onDownloadProgress, !0)),
        typeof e.onUploadProgress == "function" && c.upload && c.upload.addEventListener("progress", x4(e.onUploadProgress)),
        (e.cancelToken || e.signal) && (s = p => {
            c && (a(!p || p.type ? new rl(null,e,c) : p),
            c.abort(),
            c = null)
        }
        ,
        e.cancelToken && e.cancelToken.subscribe(s),
        e.signal && (e.signal.aborted ? s() : e.signal.addEventListener("abort", s)));
        const d = PA(u);
        if (d && Pa.protocols.indexOf(d) === -1) {
            a(new wt("Unsupported protocol " + d + ":",wt.ERR_BAD_REQUEST,e));
            return
        }
        c.send(r || null)
    }
    )
}
  , e1 = {
    http: z8,
    xhr: BA
};
ke.forEach(e1, (e, t) => {
    if (e) {
        try {
            Object.defineProperty(e, "name", {
                value: t
            })
        } catch {}
        Object.defineProperty(e, "adapterName", {
            value: t
        })
    }
}
);
const RA = {
    getAdapter: e => {
        e = ke.isArray(e) ? e : [e];
        const {length: t} = e;
        let n, a;
        for (let r = 0; r < t && (n = e[r],
        !(a = ke.isString(n) ? e1[n.toLowerCase()] : n)); r++)
            ;
        if (!a)
            throw a === !1 ? new wt(`Adapter ${n} is not supported by the environment`,"ERR_NOT_SUPPORT") : new Error(ke.hasOwnProp(e1, n) ? `Adapter '${n}' is not available in the build` : `Unknown adapter '${n}'`);
        if (!ke.isFunction(a))
            throw new TypeError("adapter is not a function");
        return a
    }
    ,
    adapters: e1
};
function l2(e) {
    if (e.cancelToken && e.cancelToken.throwIfRequested(),
    e.signal && e.signal.aborted)
        throw new rl(null,e)
}
function T4(e) {
    return l2(e),
    e.headers = ta.from(e.headers),
    e.data = s2.call(e, e.transformRequest),
    ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1),
    RA.getAdapter(e.adapter || Ei.adapter)(e).then(function(a) {
        return l2(e),
        a.data = s2.call(e, e.transformResponse, a),
        a.headers = ta.from(a.headers),
        a
    }, function(a) {
        return B8(a) || (l2(e),
        a && a.response && (a.response.data = s2.call(e, e.transformResponse, a.response),
        a.response.headers = ta.from(a.response.headers))),
        Promise.reject(a)
    })
}
const M4 = e => e instanceof ta ? e.toJSON() : e;
function vi(e, t) {
    t = t || {};
    const n = {};
    function a(c, u, f) {
        return ke.isPlainObject(c) && ke.isPlainObject(u) ? ke.merge.call({
            caseless: f
        }, c, u) : ke.isPlainObject(u) ? ke.merge({}, u) : ke.isArray(u) ? u.slice() : u
    }
    function r(c, u, f) {
        if (ke.isUndefined(u)) {
            if (!ke.isUndefined(c))
                return a(void 0, c, f)
        } else
            return a(c, u, f)
    }
    function o(c, u) {
        if (!ke.isUndefined(u))
            return a(void 0, u)
    }
    function i(c, u) {
        if (ke.isUndefined(u)) {
            if (!ke.isUndefined(c))
                return a(void 0, c)
        } else
            return a(void 0, u)
    }
    function s(c, u, f) {
        if (f in t)
            return a(c, u);
        if (f in e)
            return a(void 0, c)
    }
    const l = {
        url: o,
        method: o,
        data: o,
        baseURL: i,
        transformRequest: i,
        transformResponse: i,
        paramsSerializer: i,
        timeout: i,
        timeoutMessage: i,
        withCredentials: i,
        adapter: i,
        responseType: i,
        xsrfCookieName: i,
        xsrfHeaderName: i,
        onUploadProgress: i,
        onDownloadProgress: i,
        decompress: i,
        maxContentLength: i,
        maxBodyLength: i,
        beforeRedirect: i,
        transport: i,
        httpAgent: i,
        httpsAgent: i,
        cancelToken: i,
        socketPath: i,
        responseEncoding: i,
        validateStatus: s,
        headers: (c, u) => r(M4(c), M4(u), !0)
    };
    return ke.forEach(Object.keys(e).concat(Object.keys(t)), function(u) {
        const f = l[u] || r
          , d = f(e[u], t[u], u);
        ke.isUndefined(d) && f !== s || (n[u] = d)
    }),
    n
}
const D8 = "1.3.4"
  , Qf = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach( (e, t) => {
    Qf[e] = function(a) {
        return typeof a === e || "a" + (t < 1 ? "n " : " ") + e
    }
}
);
const z4 = {};
Qf.transitional = function(t, n, a) {
    function r(o, i) {
        return "[Axios v" + D8 + "] Transitional option '" + o + "'" + i + (a ? ". " + a : "")
    }
    return (o, i, s) => {
        if (t === !1)
            throw new wt(r(i, " has been removed" + (n ? " in " + n : "")),wt.ERR_DEPRECATED);
        return n && !z4[i] && (z4[i] = !0,
        console.warn(r(i, " has been deprecated since v" + n + " and will be removed in the near future"))),
        t ? t(o, i, s) : !0
    }
}
;
function DA(e, t, n) {
    if (typeof e != "object")
        throw new wt("options must be an object",wt.ERR_BAD_OPTION_VALUE);
    const a = Object.keys(e);
    let r = a.length;
    for (; r-- > 0; ) {
        const o = a[r]
          , i = t[o];
        if (i) {
            const s = e[o]
              , l = s === void 0 || i(s, o, e);
            if (l !== !0)
                throw new wt("option " + o + " must be " + l,wt.ERR_BAD_OPTION_VALUE);
            continue
        }
        if (n !== !0)
            throw new wt("Unknown option " + o,wt.ERR_BAD_OPTION)
    }
}
const Cu = {
    assertOptions: DA,
    validators: Qf
}
  , Cr = Cu.validators;
let go = class {
    constructor(t) {
        this.defaults = t,
        this.interceptors = {
            request: new $4,
            response: new $4
        }
    }
    request(t, n) {
        typeof t == "string" ? (n = n || {},
        n.url = t) : n = t || {},
        n = vi(this.defaults, n);
        const {transitional: a, paramsSerializer: r, headers: o} = n;
        a !== void 0 && Cu.assertOptions(a, {
            silentJSONParsing: Cr.transitional(Cr.boolean),
            forcedJSONParsing: Cr.transitional(Cr.boolean),
            clarifyTimeoutError: Cr.transitional(Cr.boolean)
        }, !1),
        r !== void 0 && Cu.assertOptions(r, {
            encode: Cr.function,
            serialize: Cr.function
        }, !0),
        n.method = (n.method || this.defaults.method || "get").toLowerCase();
        let i;
        i = o && ke.merge(o.common, o[n.method]),
        i && ke.forEach(["delete", "get", "head", "post", "put", "patch", "common"], h => {
            delete o[h]
        }
        ),
        n.headers = ta.concat(i, o);
        const s = [];
        let l = !0;
        this.interceptors.request.forEach(function(m) {
            typeof m.runWhen == "function" && m.runWhen(n) === !1 || (l = l && m.synchronous,
            s.unshift(m.fulfilled, m.rejected))
        });
        const c = [];
        this.interceptors.response.forEach(function(m) {
            c.push(m.fulfilled, m.rejected)
        });
        let u, f = 0, d;
        if (!l) {
            const h = [T4.bind(this), void 0];
            for (h.unshift.apply(h, s),
            h.push.apply(h, c),
            d = h.length,
            u = Promise.resolve(n); f < d; )
                u = u.then(h[f++], h[f++]);
            return u
        }
        d = s.length;
        let p = n;
        for (f = 0; f < d; ) {
            const h = s[f++]
              , m = s[f++];
            try {
                p = h(p)
            } catch (g) {
                m.call(this, g);
                break
            }
        }
        try {
            u = T4.call(this, p)
        } catch (h) {
            return Promise.reject(h)
        }
        for (f = 0,
        d = c.length; f < d; )
            u = u.then(c[f++], c[f++]);
        return u
    }
    getUri(t) {
        t = vi(this.defaults, t);
        const n = R8(t.baseURL, t.url);
        return P8(n, t.params, t.paramsSerializer)
    }
}
;
ke.forEach(["delete", "get", "head", "options"], function(t) {
    go.prototype[t] = function(n, a) {
        return this.request(vi(a || {}, {
            method: t,
            url: n,
            data: (a || {}).data
        }))
    }
});
ke.forEach(["post", "put", "patch"], function(t) {
    function n(a) {
        return function(o, i, s) {
            return this.request(vi(s || {}, {
                method: t,
                headers: a ? {
                    "Content-Type": "multipart/form-data"
                } : {},
                url: o,
                data: i
            }))
        }
    }
    go.prototype[t] = n(),
    go.prototype[t + "Form"] = n(!0)
});
let NA = class N8 {
    constructor(t) {
        if (typeof t != "function")
            throw new TypeError("executor must be a function.");
        let n;
        this.promise = new Promise(function(o) {
            n = o
        }
        );
        const a = this;
        this.promise.then(r => {
            if (!a._listeners)
                return;
            let o = a._listeners.length;
            for (; o-- > 0; )
                a._listeners[o](r);
            a._listeners = null
        }
        ),
        this.promise.then = r => {
            let o;
            const i = new Promise(s => {
                a.subscribe(s),
                o = s
            }
            ).then(r);
            return i.cancel = function() {
                a.unsubscribe(o)
            }
            ,
            i
        }
        ,
        t(function(o, i, s) {
            a.reason || (a.reason = new rl(o,i,s),
            n(a.reason))
        })
    }
    throwIfRequested() {
        if (this.reason)
            throw this.reason
    }
    subscribe(t) {
        if (this.reason) {
            t(this.reason);
            return
        }
        this._listeners ? this._listeners.push(t) : this._listeners = [t]
    }
    unsubscribe(t) {
        if (!this._listeners)
            return;
        const n = this._listeners.indexOf(t);
        n !== -1 && this._listeners.splice(n, 1)
    }
    static source() {
        let t;
        return {
            token: new N8(function(r) {
                t = r
            }
            ),
            cancel: t
        }
    }
}
;
function HA(e) {
    return function(n) {
        return e.apply(null, n)
    }
}
function VA(e) {
    return ke.isObject(e) && e.isAxiosError === !0
}
const wu = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
};
Object.entries(wu).forEach( ([e,t]) => {
    wu[t] = e
}
);
function H8(e) {
    const t = new go(e)
      , n = y8(go.prototype.request, t);
    return ke.extend(n, go.prototype, t, {
        allOwnKeys: !0
    }),
    ke.extend(n, t, null, {
        allOwnKeys: !0
    }),
    n.create = function(r) {
        return H8(vi(e, r))
    }
    ,
    n
}
const Ht = H8(Ei);
Ht.Axios = go;
Ht.CanceledError = rl;
Ht.CancelToken = NA;
Ht.isCancel = B8;
Ht.VERSION = D8;
Ht.toFormData = vc;
Ht.AxiosError = wt;
Ht.Cancel = Ht.CanceledError;
Ht.all = function(t) {
    return Promise.all(t)
}
;
Ht.spread = HA;
Ht.isAxiosError = VA;
Ht.mergeConfig = vi;
Ht.AxiosHeaders = ta;
Ht.formToJSON = e => I8(ke.isHTMLForm(e) ? new FormData(e) : e);
Ht.HttpStatusCode = wu;
Ht.default = Ht;
const {Axios: vU, AxiosError: bU, CanceledError: yU, isCancel: CU, CancelToken: wU, VERSION: _U, all: kU, Cancel: SU, isAxiosError: $U, spread: EU, toFormData: xU, AxiosHeaders: TU, HttpStatusCode: MU, formToJSON: zU, mergeConfig: AU} = Ht;
var io, B1, V8, si, t1;
class ed {
    constructor(t) {
        mn(this, B1);
        mn(this, si);
        mn(this, io, void 0);
        xd(this, io, Ht.create({
            baseURL: t
        }))
    }
    setAuthorizationToken(t) {
        pt(this, io).defaults.headers.common.Authorization = `Bearer ${t}`
    }
    get(t, n) {
        return Ii(this, B1, V8).call(this, "GET", t, n)
    }
    post(t, n) {
        return Ii(this, si, t1).call(this, "POST", t, n)
    }
    patch(t, n) {
        return Ii(this, si, t1).call(this, "PATCH", t, n)
    }
    delete(t, n) {
        return Ii(this, si, t1).call(this, "DELETE", t, n)
    }
}
io = new WeakMap,
B1 = new WeakSet,
V8 = function(t, n, a) {
    return pt(this, io).call(this, {
        method: t,
        url: n,
        params: a
    })
}
,
si = new WeakSet,
t1 = function(t, n, a) {
    return pt(this, io).call(this, {
        method: t,
        url: n,
        data: a
    })
}
;
class FA extends ed {
    constructor() {
        super("https://flekstore.com/rest")
    }
}
const td = new FA;
class jA extends ed {
    constructor() {
        super("https://nestapi.flekstore.com")
    }
}
const Ur = new jA
  , xa = "/device";
var Ta;
class UA {
    constructor() {
        mn(this, Ta, td)
    }
    getDevice(t) {
        return pt(this, Ta).get(`${xa}/getDevice`, t)
    }
    getDeviceIdByClientUid(t) {
        return pt(this, Ta).get(`${xa}/findDeviceByFp`, t)
    }
    getTariff(t) {
        return pt(this, Ta).get(`${xa}/getTariff`, t)
    }
    getOffers() {
        return pt(this, Ta).get(`${xa}/offer`, {})
    }
    getLastPayment(t) {
        return pt(this, Ta).get(`${xa}/getLastPayment`, t)
    }
    getDealId(t) {
        return pt(this, Ta).get(`${xa}/getDealId`, t)
    }
    checkActivation(t) {
        return pt(this, Ta).get(`${xa}/checkActivation`, t)
    }
}
Ta = new WeakMap;
var li;
class qA {
    constructor() {
        mn(this, li, Ur)
    }
    getDevice(t, n) {
        return pt(this, li).get(`${xa}/${t}`, n)
    }
    checkDeviceBanned(t) {
        return pt(this, li).get(`${xa}/check-ban/${t}`)
    }
    registerToStreamForFree(t, n) {
        return pt(this, li).patch(`${xa}/${t}/register-to-stream-for-free`, n)
    }
}
li = new WeakMap;
const Fo = new UA
  , c2 = new qA
  , WA = !!localStorage.device_id
  , YA = !!localStorage.triedToPurchase
  , ht = oa("device", {
    state: () => ({
        hasDeviceId: WA,
        triedToPurchase: YA,
        deviceIosVersion: gz(),
        oldSignerUI: !1,
        iosReleaseVersion: null,
        device: null,
        tariff: null,
        offers: null,
        isLoading: !1,
        loadingError: !1
    }),
    getters: {
        currentIosIsBeta(e) {
            return e.deviceIosVersion && e.iosReleaseVersion ? bz(e.deviceIosVersion, e.iosReleaseVersion) > 0 : !1
        },
        canContactSupport(e) {
            var t, n;
            return e.triedToPurchase || ((t = e == null ? void 0 : e.device) == null ? void 0 : t.service) || ((n = e == null ? void 0 : e.device) == null ? void 0 : n.stream)
        },
        getServiceByName: e => t => {
            var n;
            return Array.isArray((n = e == null ? void 0 : e.device) == null ? void 0 : n.service) ? e == null ? void 0 : e.device.service.find(a => a.name === t) : !1
        }
    },
    actions: {
        resetLoadingState() {
            this.isLoading = !0,
            this.loadingError = !1
        },
        saveDeviceId(e) {
            localStorage.device_id = e,
            this.hasDeviceId = !0
        },
        async getDevice() {
            if (this.resetLoadingState(),
            !!this.hasDeviceId)
                try {
                    const e = await c2.getDevice(localStorage.device_id);
                    e.data && (this.device = e.data,
                    this.device = this.defineStatuses(this.device))
                } catch {
                    this.loadingError = !0
                } finally {
                    this.isLoading = !1
                }
        },
        async checkBanned() {
            var e;
            try {
                const t = localStorage.getItem("device_id");
                if (!t)
                    throw new Error("Device ID not found in localStorage");
                const n = await c2.checkDeviceBanned(t);
                if (!n || !n.status)
                    throw new Error("Invalid response from server");
                (e = n.data) != null && e.isBanned && D.view.current.router.navigate("/bannedPopup/", {
                    props: {
                        banReason: n.data.banReason
                    }
                })
            } catch (t) {
                throw console.error("Error checking device status:", t.message),
                t
            }
        },
        defineStatuses(e) {
            const t = this;
            return e.hasActivation = e.queue ? null : !!e.stream && !e.stream.rip_date,
            e.hasPremium = !!(e.service && e.service.some(n => n.name === "premium")),
            Array.isArray(e.service) && e.service.length > 0 && e.service.forEach(n => {
                n.isExpired = _z(n.end_date)
            }
            ),
            e.isStreamOwner = e.stream && e.id === e.stream.owner_device_id,
            e.isUserStream = !!(e.stream && e.stream.owner_device_id),
            e.hasFreeRecovery = !1,
            e.streamRevoked = !!(e.stream && e.stream.date && e.stream.rip_date),
            t.oldSignerUI = !!(e != null && e.stream && (e.stream.id < 181313 || e.isStreamOwner)),
            this.getTariff().then( () => {}
            ),
            this.getOffers().then( () => {}
            ),
            e
        },
        async getAndSaveDeviceIdByClientUid() {
            this.resetLoadingState();
            try {
                const e = await Fo.getDeviceIdByClientUid({
                    fp_id: localStorage.fsAppUUID
                });
                e.data.data && this.saveDeviceId(e.data.data),
                await this.checkBanned(),
                await this.getDevice()
            } catch {} finally {
                this.isLoading = !1
            }
        },
        async getTariff(e= () => {}
        ) {
            if (this.resetLoadingState(),
            !!this.hasDeviceId)
                try {
                    const t = await Fo.getTariff({
                        id: localStorage.device_id
                    });
                    t.data.data && (this.tariff = JSON.parse(t.data.data))
                } catch {
                    this.loadingError = !0
                } finally {
                    e(),
                    this.isLoading = !1
                }
        },
        async getOffers(e= () => {}
        ) {
            if (this.resetLoadingState(),
            !!this.hasDeviceId)
                try {
                    const t = await Fo.getOffers();
                    t.data && (this.offers = t.data)
                } catch {
                    this.loadingError = !0
                } finally {
                    e(),
                    this.isLoading = !1
                }
        },
        async getLastPaymentAndDefineFreeRecovery() {
            if (this.resetLoadingState(),
            !!this.hasDeviceId)
                try {
                    const e = await Fo.getLastPayment({
                        id: localStorage.device_id
                    });
                    if (e.data.status !== "ok") {
                        this.device.hasFreeRecovery = !1;
                        return
                    }
                    const t = JSON.parse(e.data.data);
                    this.device.hasFreeRecovery = t && t.method && parseFloat(t.amount) > 10 && !["admin", "free", "gift"].includes(t.method) && !this.device.isUserStream
                } catch {
                    this.loadingError = !0
                } finally {
                    this.isLoading = !1
                }
        },
        async checkActivation(e= () => {}
        ) {
            if (this.resetLoadingState(),
            !!this.hasDeviceId)
                try {
                    const t = await Fo.checkActivation({
                        id: localStorage.device_id
                    });
                    t.data.data && `${t.data.data}` !== this.device.queue && await this.getDevice()
                } catch {
                    this.loadingError = !0
                } finally {
                    e(),
                    this.isLoading = !1
                }
        },
        async getDealId() {
            const e = yz("d");
            try {
                const t = await Fo.getDealId({
                    deal_code: e
                });
                localStorage.deal_id = t.data.data
            } catch {
                this.loadingError = !0
            } finally {
                this.isLoading = !1
            }
        },
        async restoreCertificateForFree() {
            D.dialog.preloader();
            try {
                await c2.registerToStreamForFree(this.device.id),
                D.dialog.alert("Free certificate recovery successfully initiated. <br/><br/>Thank you for staying with us ", "Done "),
                this.getDevice().then( () => {}
                )
            } catch {
                D.dialog.alert("Free recovery is not available for this device.", "Sorry")
            } finally {
                D.dialog.close(),
                this.isLoading = !1
            }
        }
    }
})
  , GA = {}
  , XA = V("div", {
    class: "skeleton-block",
    style: {
        width: "55px",
        height: "100px",
        "border-radius": "10px"
    }
}, null, -1);
function KA(e, t) {
    const n = P("f7-list-item")
      , a = P("f7-list")
      , r = P("f7-card-content");
    return O(),
    K(r, null, {
        default: k( () => [S(a, {
            class: "skeleton-text skeleton-effect-wave",
            "media-list": ""
        }, {
            default: k( () => [S(n, {
                after: "",
                "no-chevron": "",
                subtitle: "UDID:",
                text: "------------------------------",
                title: "-------------"
            }, {
                media: k( () => [XA]),
                _: 1
            })]),
            _: 1
        })]),
        _: 1
    })
}
const ZA = it(GA, [["render", KA]])
  , JA = {
    __name: "StatusChips",
    setup(e) {
        const t = ht()
          , n = ae( () => {
            var a;
            return Array.isArray((a = t.device) == null ? void 0 : a.service) ? t.device.service.some(r => r.name === "premium" && !r.isExpired) : !1
        }
        );
        return (a, r) => {
            const o = P("f7-icon")
              , i = P("f7-chip");
            return O(),
            G(Be, null, [B(t).device.hasActivation === !0 ? (O(),
            K(i, {
                key: 0,
                class: "chip-with-icon",
                outline: ""
            }, {
                text: k( () => [S(o, {
                    class: "chip-icon",
                    f7: "checkmark_alt",
                    "text-color": "green"
                }), J(" Certificate ")]),
                _: 1
            })) : pe("", !0), B(t).device.hasActivation === !1 ? (O(),
            K(i, {
                key: 1,
                class: "chip-with-icon",
                outline: ""
            }, {
                text: k( () => [S(o, {
                    class: "chip-icon",
                    f7: "xmark",
                    "text-color": "red"
                }), J(" Certificate ")]),
                _: 1
            })) : pe("", !0), B(t).device.hasActivation === null ? (O(),
            K(i, {
                key: 2,
                class: "chip-with-icon",
                outline: ""
            }, {
                text: k( () => [S(o, {
                    class: "chip-icon",
                    f7: "timer",
                    "text-color": "orange"
                }), J(" Certificate ")]),
                _: 1
            })) : pe("", !0), S(i, {
                class: "chip-with-icon",
                outline: ""
            }, {
                text: k( () => [n.value ? (O(),
                K(o, {
                    key: 1,
                    class: "chip-icon",
                    f7: "checkmark_alt",
                    "text-color": "green"
                })) : (O(),
                K(o, {
                    key: 0,
                    class: "chip-icon",
                    f7: "xmark",
                    "text-color": "red"
                })), J(" Premium ")]),
                _: 1
            })], 64)
        }
    }
};
const QA = {
    key: 0
}
  , eO = ["src"]
  , tO = {
    __name: "InfoCard",
    setup(e) {
        const t = ht()
          , n = a => {
            const r = a.substring(0, 6)
              , o = a.substring(a.length - 6);
            return `${r}${o}`
        }
        ;
        return (a, r) => {
            const o = P("f7-list-item")
              , i = P("f7-list")
              , s = P("f7-card-content")
              , l = P("f7-card");
            return O(),
            K(l, null, {
                default: k( () => [B(t).device ? (O(),
                G("div", QA, [S(s, null, {
                    default: k( () => [S(i, {
                        "media-list": ""
                    }, {
                        default: k( () => [S(o, {
                            after: "",
                            "no-chevron": "",
                            subtitle: "UDID:",
                            text: n(B(t).device.udid),
                            title: B(t).device.type
                        }, {
                            media: k( () => [V("img", {
                                alt: "Device picture",
                                height: "100",
                                src: `https://flekstore.com/client/img/device/devices/${B(t).device.type}${B(t).device.product}.png`
                            }, null, 8, eO)]),
                            inner: k( () => [S(JA)]),
                            _: 1
                        }, 8, ["text", "title"])]),
                        _: 1
                    })]),
                    _: 1
                }), ce(a.$slots, "default", {}, void 0, !0)])) : (O(),
                K(ZA, {
                    key: 1
                }))]),
                _: 3
            })
        }
    }
}
  , nO = it(tO, [["__scopeId", "data-v-16dd4ca4"]]);
const aO = {}
  , rO = {
    class: "page-col-medium"
};
function oO(e, t) {
    return O(),
    G("div", rO, [ce(e.$slots, "default")])
}
const An = it(aO, [["render", oO]])
  , iO = {
    style: {
        "text-align": "center"
    }
}
  , bc = {
    __name: "CardError",
    props: {
        iconName: {
            type: String,
            default: null
        },
        text: {
            type: String,
            required: !0
        }
    },
    setup(e) {
        const t = e;
        return (n, a) => {
            const r = P("f7-icon")
              , o = P("f7-card-content")
              , i = P("f7-card");
            return O(),
            K(i, null, {
                default: k( () => [S(o, null, {
                    default: k( () => [V("p", iO, [S(r, {
                        f7: t.iconName,
                        "text-color": "red"
                    }, null, 8, ["f7"]), J("  " + Me(t.text), 1)])]),
                    _: 1
                })]),
                _: 1
            })
        }
    }
}
  , sO = {}
  , lO = {
    class: "popup-push-navbar"
};
function cO(e, t) {
    const n = P("f7-icon")
      , a = P("f7-link");
    return O(),
    G("div", lO, [S(a, {
        "popup-close": ""
    }, {
        default: k( () => [S(n, {
            color: "gray",
            f7: "chevron_compact_down",
            size: "44px"
        })]),
        _: 1
    })])
}
const ia = it(sO, [["render", cO]])
  , F8 = {
    __name: "SwitchStateButton",
    props: {
        isActive: {
            type: Boolean,
            required: !0
        }
    },
    emits: ["switchMode"],
    setup(e) {
        const t = e;
        return (n, a) => {
            const r = P("f7-button");
            return t.isActive ? (O(),
            K(r, {
                key: 1,
                onClick: a[1] || (a[1] = o => n.$emit("switchMode"))
            }, {
                default: k( () => [ce(n.$slots, "active")]),
                _: 3
            })) : (O(),
            K(r, {
                key: 0,
                onClick: a[0] || (a[0] = o => n.$emit("switchMode"))
            }, {
                default: k( () => [ce(n.$slots, "not-active")]),
                _: 3
            }))
        }
    }
};
const uO = {
    key: 0,
    class: "label"
}
  , fO = {
    class: "fileinput"
}
  , dO = {
    key: 0,
    class: "filename"
}
  , pO = {
    key: 1,
    class: "placeholder"
}
  , hO = {
    class: "brows-action"
}
  , mO = {
    __name: "InputFile",
    props: {
        modelValue: {
            type: Object,
            required: !0
        },
        placeholder: {
            type: String,
            default: "file"
        },
        label: {
            type: String,
            default: ""
        },
        acceptedExtensions: {
            type: Array,
            default: () => []
        }
    },
    emits: ["update:modelValue"],
    setup(e, {emit: t}) {
        const n = e
          , a = oe(null)
          , r = oe(null)
          , o = t;
        df( () => {
            n.modelValue && (a.value = n.modelValue)
        }
        );
        const i = l => {
            const c = l.target.files[0];
            if (!c)
                return;
            const u = c.name.split(".").pop();
            if (!n.acceptedExtensions.includes(u)) {
                D.dialog.alert(`Invalid file extension. Available extensions: ${n.acceptedExtensions.join(", ")}`, "Error");
                return
            }
            r.value = c,
            o("update:modelValue", r.value)
        }
          , s = () => {
            a.value.click()
        }
        ;
        return (l, c) => (O(),
        G(Be, null, [V("input", {
            ref_key: "fileInput",
            ref: a,
            style: {
                display: "none"
            },
            type: "file",
            onChange: i
        }, null, 544), n.label !== "" ? (O(),
        G("div", uO, Me(n.label), 1)) : pe("", !0), V("div", fO, [r.value ? (O(),
        G("div", dO, Me(r.value.name), 1)) : (O(),
        G("div", pO, Me(n.placeholder), 1)), V("div", hO, [ce(l.$slots, "button", {
            handleClick: s
        }, void 0, !0)])])], 64))
    }
}
  , _u = it(mO, [["__scopeId", "data-v-90f45d71"]]);
const gO = e => (qt("data-v-5c40f8f8"),
e = e(),
Wt(),
e)
  , vO = {
    class: "divider"
}
  , bO = gO( () => V("hr", null, null, -1))
  , yO = {
    key: 0
}
  , CO = {
    __name: "Divider",
    props: {
        title: {
            type: String,
            default: ""
        },
        colored: {
            type: Boolean,
            default: !1
        }
    },
    setup(e) {
        const t = e;
        return (n, a) => (O(),
        G("div", vO, [bO, t.title.length ? (O(),
        G("div", yO, [V("span", {
            class: Ae(t.colored && "colored-title")
        }, Me(t.title), 3)])) : pe("", !0)]))
    }
}
  , M1 = it(CO, [["__scopeId", "data-v-5c40f8f8"]]);
const wO = {
    class: "color-theme-orange"
}
  , _O = {
    __name: "WarningCard",
    props: {
        text: {
            type: String,
            default: ""
        },
        hideMedia: {
            type: Boolean,
            default: !1
        }
    },
    setup(e) {
        const t = e
          , n = Q0();
        return (a, r) => {
            const o = P("f7-icon")
              , i = P("f7-list-item")
              , s = P("f7-list");
            return O(),
            K(s, {
                class: "margin-horizontal no-margin-vertical",
                inset: "",
                "media-list": ""
            }, {
                default: k( () => [S(i, {
                    subtitle: t.text
                }, lr({
                    subtitle: k( () => [ce(a.$slots, "default", {}, void 0, !0)]),
                    _: 2
                }, [e.hideMedia ? void 0 : {
                    name: "media",
                    fn: k( () => [V("div", wO, [B(n).media ? pe("", !0) : (O(),
                    K(o, {
                        key: 0,
                        f7: "exclamationmark_triangle"
                    })), ce(a.$slots, "media", {}, void 0, !0)])]),
                    key: "0"
                }]), 1032, ["subtitle"])]),
                _: 3
            })
        }
    }
}
  , ol = it(_O, [["__scopeId", "data-v-02e6e338"]]);
const j8 = {
    __name: "BetaIosWarning",
    props: {
        iosVersion: {
            type: String,
            required: !0
        }
    },
    setup(e) {
        return (t, n) => (O(),
        K(B(ol), {
            text: `Your device is running iOS beta version ${e.iosVersion}. Betas bring certificate monitoring to Apple's attention, leading to revocations. We strongly recommend that you roll back to the release version!`
        }, null, 8, ["text"]))
    }
}
  , kO = V("div", {
    style: {
        "text-align": "center",
        "margin-top": "10vh"
    }
}, [V("p", {
    style: {
        "font-size": "16px"
    }
}, " To get started with the FlekSt0re app you need to add your device. ")], -1)
  , SO = V("b", null, "macOS", -1)
  , $O = V("b", null, "macOS", -1)
  , EO = V("p", null, [J(" When adding a device, we will receive your device UDID, device type and model number. "), V("br"), V("br"), J(" UDID is an abbreviation for unique device identifier. Every Apple mobile device has it. "), V("br"), V("br"), J(" You need to provide us with the UDID of your device so that we can sign apps for this device. ")], -1)
  , xO = V("div", {
    style: {
        "text-align": "center"
    }
}, " By adding a device, you agree to the processing of data about your device. ", -1)
  , TO = {
    __name: "RegisterDevice",
    setup(e) {
        const t = ht();
        let n;
        const a = () => {
            t.hasDeviceId || t.getAndSaveDeviceIdByClientUid()
        }
          , r = () => {
            n.open(),
            window.open(`https://nestapi.flekstore.com/device/get-udid/${localStorage.fsAppUUID}?deal_id=${localStorage.deal_id}`, "_self"),
            setTimeout( () => {
                window.addEventListener("focus", a)
            }
            )
        }
        ;
        return Xe( () => {
            ut( () => {
                n = D.toast.create({
                    text: `
        1) Tap <b>Allow</b> button <br/>
        2) Open the <b>Settings app</b> <br/>
        3) Tap <b>Profile Downloaded</b> <br/>
        4) Tap <b>Install</b> and follow the instructions <br/>
        <br/><br/>
        After installation, you can return to the FlekSt0re app and pull to refresh device page.
        `,
                    position: "top",
                    horizontalPosition: "center",
                    closeButton: !0,
                    closeButtonText: "Close",
                    closeButtonColor: "red",
                    on: {
                        close() {
                            t.getAndSaveDeviceIdByClientUid()
                        }
                    }
                })
            }
            )
        }
        ),
        Ca( () => {
            n.close(),
            window.removeEventListener("focus", a)
        }
        ),
        (o, i) => {
            const s = P("f7-block")
              , l = P("f7-button")
              , c = P("f7-icon")
              , u = P("f7-accordion-content")
              , f = P("f7-list-item")
              , d = P("f7-list");
            return O(),
            G(Be, null, [S(s, null, {
                default: k( () => [kO]),
                _: 1
            }), B(D).device.desktop ? (O(),
            K(B(ol), {
                key: 0,
                class: "margin-top-half no-margin-bottom"
            }, {
                default: k( () => [J(" If you are visiting this page on "), SO, J(", then we inform you that FlekSt0re only supports iOS and iPadOS. There is no point in continuing to use the app on "), $O, J(". ")]),
                _: 1
            })) : pe("", !0), S(s, null, {
                default: k( () => [V("p", null, [S(l, {
                    fill: "",
                    large: "",
                    round: "",
                    onClick: r
                }, {
                    default: k( () => [J(" Add device ")]),
                    _: 1
                })]), V("p", null, [S(l, {
                    class: "button-glass",
                    external: "",
                    href: "https://youtu.be/G5h5IBuIuv8",
                    large: "",
                    round: "",
                    target: "_blank"
                }, {
                    default: k( () => [S(c, {
                        f7: "play_rectangle_fill"
                    }), J("  Watch tutorial ")]),
                    _: 1
                })])]),
                _: 1
            }), S(d, {
                "accordion-list": "",
                inset: ""
            }, {
                default: k( () => [S(f, {
                    "accordion-item": "",
                    title: "What data will we receive?"
                }, {
                    default: k( () => [S(u, null, {
                        default: k( () => [S(s, null, {
                            default: k( () => [EO]),
                            _: 1
                        })]),
                        _: 1
                    })]),
                    _: 1
                })]),
                _: 1
            }), S(s, {
                "text-color": "gray"
            }, {
                default: k( () => [xO]),
                _: 1
            })], 64)
        }
    }
}
  , MO = "" + new URL("../icons/CertPlusPremium.jpg",import.meta.url).href
  , zO = "" + new URL("../icons/PriorityRecoveryIcon.jpg",import.meta.url).href
  , U8 = "" + new URL("../icons/developerIcon.webp",import.meta.url).href
  , q8 = "" + new URL("../icons/CertIcon26.jpg?1",import.meta.url).href
  , AO = "/invoice";
var R1;
class OO {
    constructor() {
        mn(this, R1, Ur)
    }
    getDeviceHasFreeRecovery(t) {
        return pt(this, R1).get(`${AO}/has-free-restore/${t}`)
    }
}
R1 = new WeakMap;
const W8 = new OO;
const il = e => (qt("data-v-68f7ca28"),
e = e(),
Wt(),
e)
  , PO = il( () => V("img", {
    alt: "Premium Certificate icon",
    src: MO
}, null, -1))
  , LO = il( () => V("span", null, "  Favorable offer! ", -1))
  , IO = il( () => V("img", {
    alt: "Priority recovery icon",
    src: zO
}, null, -1))
  , BO = il( () => V("img", {
    alt: "Apple Developer icon",
    src: U8
}, null, -1))
  , RO = il( () => V("img", {
    alt: "Certificate icon",
    src: q8
}, null, -1))
  , DO = {
    __name: "CertificateOffers",
    setup(e) {
        const t = ht()
          , n = new Date("2024-01-14T14:54:59Z")
          , a = Date.now()
          , r = oe(n - a);
        return Xe(async () => {
            var o, i, s;
            setInterval( () => {
                const l = Date.now();
                r.value = n - l
            }
            , 1e3);
            try {
                const l = await W8.getDeviceHasFreeRecovery((o = t == null ? void 0 : t.device) == null ? void 0 : o.id);
                t.device.hasFreeRecovery = ((i = l.data) == null ? void 0 : i.isFreeRestoreAvailable) && !((s = t.device) != null && s.isUserStream)
            } catch {
                t.device.hasFreeRecovery = !1
            }
        }
        ),
        (o, i) => {
            const s = P("f7-list-item")
              , l = P("f7-list");
            return O(),
            K(l, {
                class: "rounded-items margin-top margin-bottom",
                inset: "",
                "media-list": ""
            }, {
                default: k( () => [B(t).tariff && B(t).tariff.tariff < 4 ? (O(),
                K(s, {
                    key: 0,
                    class: "item-premium",
                    link: "/device/certificate-offer-details/",
                    "route-props": {
                        offerAlias: "certificateByFlekStore"
                    },
                    title: "Developer Certificate + Premium Access"
                }, {
                    media: k( () => [PO]),
                    text: k( () => [LO]),
                    _: 1
                })) : pe("", !0), B(t).tariff && B(t).tariff.tariff === 4 ? (O(),
                K(s, {
                    key: 1,
                    class: "item-premium",
                    link: "/device/certificate-offer-details/",
                    "route-props": {
                        offerAlias: "priorityRecovery"
                    },
                    text: "The most convenient way",
                    title: "Certificate recovery"
                }, {
                    media: k( () => [IO]),
                    _: 1
                })) : pe("", !0), S(s, {
                    link: "/device/certificate-offer-details/",
                    "route-props": {
                        offerAlias: "linkDeveloperAccount"
                    },
                    title: "Link Developer Account"
                }, {
                    media: k( () => [BO]),
                    text: k( () => [J(" If you have own developer account ")]),
                    _: 1
                }), S(s, {
                    link: "/device/certificate-offer-details/",
                    "route-props": {
                        offerAlias: "ownCertificate"
                    },
                    subtitle: "",
                    text: "If you have own certificate",
                    title: "Add Certificate"
                }, {
                    media: k( () => [RO]),
                    _: 1
                })]),
                _: 1
            })
        }
    }
}
  , NO = it(DO, [["__scopeId", "data-v-68f7ca28"]])
  , Y8 = "" + new URL("../icons/Crown_icon26.jpg?3",import.meta.url).href;
const HO = ["alt", "src", "title"]
  , VO = {
    key: 0,
    class: "item-text"
}
  , FO = {
    key: 1,
    class: "item-text text-color-green"
}
  , jO = {
    key: 0,
    style: {
        "font-size": "13px"
    }
}
  , UO = {
    __name: "TaskListItem",
    props: {
        icon: {
            type: String,
            required: !0
        },
        title: {
            type: String,
            required: !0
        },
        isUnlimit: {
            type: Boolean,
            required: !0
        },
        completed: {
            type: Boolean,
            required: !0
        },
        subtitle: {
            type: String,
            required: !0
        },
        bonusAmount: {
            type: Number,
            required: !0
        },
        bonusReason: {
            type: String,
            default: ""
        }
    },
    setup(e) {
        return (t, n) => {
            const a = P("f7-badge")
              , r = P("f7-list-item");
            return O(),
            K(r, {
                class: "partner-main__task-list-item",
                disabled: e.completed,
                link: ""
            }, {
                media: k( () => [V("img", {
                    alt: e.title,
                    src: e.icon,
                    title: e.title
                }, null, 8, HO)]),
                title: k( () => [J(Me(e.title) + " ", 1), e.completed ? (O(),
                G("div", FO, " Completed ")) : (O(),
                G("div", VO, Me(e.isUnlimit ? " unlimited task" : "one-time task"), 1))]),
                after: k( () => [V("div", null, [S(a, {
                    color: "blue"
                }, {
                    default: k( () => [J(" +" + Me(e.bonusAmount) + " coins ", 1)]),
                    _: 1
                }), e.bonusReason.length ? (O(),
                G("div", jO, Me(e.bonusReason), 1)) : pe("", !0)])]),
                _: 1
            }, 8, ["disabled"])
        }
    }
};
const qO = V("div", {
    class: "colored-bg"
}, null, -1)
  , WO = V("div", {
    class: "item-text"
}, " one-time task ", -1)
  , YO = {
    __name: "TaskListSkeleton",
    props: {
        number: {
            type: Number,
            required: !0
        }
    },
    setup(e) {
        return (t, n) => {
            const a = P("f7-skeleton-block")
              , r = P("f7-list-item")
              , o = P("f7-list");
            return O(),
            K(o, {
                class: "partner-main__task-list-skeleton skeleton-text skeleton-effect-wave",
                inset: "",
                "media-list": "",
                "no-chevron": ""
            }, {
                default: k( () => [qO, (O(!0),
                G(Be, null, vt(Array(e.number).fill(), (i, s) => (O(),
                K(r, {
                    key: s,
                    class: "partner-main__task-list-skeleton-item"
                }, {
                    media: k( () => [S(a)]),
                    title: k( () => [J(" ------------- --------- "), WO]),
                    _: 2
                }, 1024))), 128))]),
                _: 1
            })
        }
    }
}
  , GO = "" + new URL("../icons/PartnerAccountIcon26.jpg?3",import.meta.url).href
  , XO = V("img", {
    alt: "Service icon",
    height: "65",
    src: GO,
    style: {
        "border-radius": "23%"
    }
}, null, -1)
  , KO = {
    __name: "PartnerActiveServiceListItem",
    props: {
        hasStartedService: {
            type: Boolean,
            required: !0
        },
        balance: {
            type: Number,
            default: 0
        }
    },
    setup(e) {
        return (t, n) => {
            const a = P("f7-list-item");
            return e.hasStartedService ? (O(),
            K(a, {
                key: 0,
                class: "item-inner-center",
                inset: "",
                link: "/partner/main/",
                subtitle: `Balance: ${e.balance} coins`,
                title: "Partner Wallet"
            }, {
                media: k( () => [XO]),
                _: 1
            }, 8, ["subtitle"])) : pe("", !0)
        }
    }
}
  , Ll = "/partners"
  , A4 = "/bonus-invoices";
var Ma;
class ZO {
    constructor() {
        mn(this, Ma, Ur)
    }
    startPartnerProgramForDevice(t) {
        return pt(this, Ma).post(`${Ll}/referral`, t)
    }
    getReferralCode(t, n) {
        return pt(this, Ma).get(`${Ll}/referral/${t}`, n)
    }
    getBalance(t) {
        return pt(this, Ma).get(`${Ll}/balance/${t}`)
    }
    getTasks(t) {
        return pt(this, Ma).get(`/partners-tasks/${t}`)
    }
    getInvoiceList(t, n) {
        return pt(this, Ma).get(`${A4}/${t}/${n}`)
    }
    boostService(t, n) {
        return pt(this, Ma).patch(`${Ll}/referral/${t}`, n)
    }
    completeTask(t) {
        return pt(this, Ma).post(`${A4}/by-task/`, t)
    }
}
Ma = new WeakMap;
const eo = new ZO
  , _a = oa("partner", {
    state: () => ({
        referralCode: null,
        balance: 0,
        tasks: [],
        isLoading: !1,
        loadingError: !1
    }),
    getters: {
        getTaskById: e => t => e.tasks.find(n => n.id === t)
    },
    actions: {
        resetLoadingState() {
            this.isLoading = !0,
            this.loadingError = !1
        },
        async startPartnerProgramForDevice(e) {
            D.dialog.preloader();
            try {
                const t = await eo.startPartnerProgramForDevice({
                    device_id: Number(localStorage.device_id)
                });
                this.referralCode = t.data.code,
                e()
            } catch {
                D.dialog.alert("Error initializing the affiliate program", "Error")
            } finally {
                D.dialog.close()
            }
        },
        async getReferralCode() {
            this.resetLoadingState();
            try {
                const e = await eo.getReferralCode(localStorage.device_id);
                this.referralCode = e.data[0].code
            } catch {
                this.referralCode = !1,
                this.loadingError = !0
            } finally {
                this.isLoading = !1
            }
        },
        async getBalance() {
            try {
                const e = await eo.getBalance(localStorage.device_id);
                this.balance = e.data.bonus_balance
            } catch {
                this.loadingError = !0
            } finally {
                this.isLoading = !1
            }
        },
        async getTasks() {
            try {
                const e = await eo.getTasks(this.referralCode);
                this.tasks = e.data,
                this.tasks.sort( (t, n) => t.completed === !0 ? 1 : n.completed === !0 ? -1 : 0)
            } catch {
                this.loadingError = !0
            } finally {
                this.isLoading = !1
            }
        },
        async getInvoiceList() {
            try {
                return (await eo.getInvoiceList(localStorage.device_id, this.referralCode)).data.reduce( (t, n) => {
                    const a = n.date.split(" ")[0];
                    return t[a] || (t[a] = []),
                    t[a].push(n),
                    t
                }
                , {})
            } catch {
                return !1
            }
        },
        async boostService(e, t) {
            try {
                return (await eo.boostService(localStorage.device_id, {
                    amount: e,
                    partners_tasks_id: t
                })).data.status
            } catch {
                return !1
            }
        }
    }
});
const JO = V("div", {
    class: "colored-bg"
}, null, -1)
  , QO = V("img", {
    alt: "Premium icon",
    class: "app-list-icon",
    src: Y8
}, null, -1)
  , eP = {
    __name: "ServicesOffers",
    setup(e) {
        const t = ht()
          , n = _a();
        return (a, r) => {
            const o = P("f7-list-item")
              , i = P("f7-button")
              , s = P("f7-list");
            return B(t).device.hasPremium ? pe("", !0) : (O(),
            K(s, {
                key: 0,
                class: "margin-bottom services-offers__colored-list",
                inset: "",
                "media-list": "",
                "no-hairlines-between": ""
            }, {
                default: k( () => [JO, S(o, {
                    class: "item-premium",
                    link: "/device/service-offer-details/",
                    "route-props": {
                        offerId: 1
                    },
                    title: "Premium Access"
                }, {
                    media: k( () => [QO]),
                    text: k( () => [J(" Get the best experience ")]),
                    _: 1
                }), B(n).referralCode ? pe("", !0) : (O(),
                K(o, {
                    key: 0
                }, {
                    default: k( () => [V("div", null, [S(i, {
                        class: "button-lite",
                        href: "/partner/description-popup/",
                        large: ""
                    }, {
                        default: k( () => [J(" Get for free ")]),
                        _: 1
                    })])]),
                    _: 1
                }))]),
                _: 1
            }))
        }
    }
}
  , tP = {
    __name: "ui",
    props: {
        subscriptionMerchant: {
            type: String,
            default: "false"
        },
        subscriptionId: {
            type: String,
            default: "false"
        }
    },
    setup(e) {
        const t = e
          , n = ht();
        let a = "";
        switch (t.subscriptionMerchant) {
        case "stripe":
            a = "https://nestapi.flekstore.com/stripe/cancel-subscription-immediately";
            break;
        default:
            a = "https://nestapi.flekstore.com/stripe/cancel-subscription-immediately"
        }
        const r = D.dialog.create({
            title: "Are you sure?",
            text: "The subscription will be canceled, but you will be able to use the service until it expires.",
            buttons: [{
                text: "OK",
                color: "red",
                onClick: () => {
                    Ht.patch(a, {
                        subscription_id: t.subscriptionId
                    }).then( () => {
                        n.getDevice(),
                        D.dialog.alert("The subscription has been successfully cancelled.", "")
                    }
                    ).catch(i => {
                        console.error(i)
                    }
                    )
                }
            }, {
                text: "Cancel",
                bold: !0,
                onClick: () => {
                    D.dialog.alert("Thank you for staying with us!", "")
                }
            }]
        })
          , o = () => {
            D.dialog.create({
                title: "Actions",
                buttons: [{
                    text: "Unsubscribe",
                    onClick: () => {
                        r.open()
                    }
                }, {
                    text: "Cancel",
                    bold: !0
                }],
                verticalButtons: !0
            }).open()
        }
        ;
        return Ca( () => {
            r.destroy()
        }
        ),
        (i, s) => {
            const l = P("f7-button");
            return O(),
            K(l, {
                class: "button-lite",
                "icon-f7": "gear_alt",
                large: "",
                round: "",
                onClick: o
            }, {
                default: k( () => [J(" Manage subscription ")]),
                _: 1
            })
        }
    }
}
  , jt = {
    forAll: [{
        icon: "layers_alt_fill",
        text: "Access to install apps from the app library"
    }, {
        icon: "pencil_outline",
        text: "Access to Signer"
    }, {
        icon: "signature",
        text: "App signature certificate"
    }],
    premiumOnly: [{
        icon: "bolt_fill",
        color: "yellow",
        text: "<b>2x faster</b> file uploading and app signing!"
    }, {
        icon: "square_fill_on_square_fill",
        color: "yellow",
        text: "Install <b>duplicates</b> in one click"
    }, {
        icon: "square_stack_fill",
        color: "yellow",
        text: "Apps from third party <b>sources</b>"
    }, {
        icon: "arrow_down_doc_fill",
        color: "yellow",
        text: "Ability to <b>download</b> .IPA app files"
    }, {
        icon: "suit_heart_fill",
        color: "yellow",
        text: "<b>Your support</b> for FlekSt0re developers"
    }],
    liveContainer: [{
        icon: "doc_fill",
        color: "blue",
        text: "Signing apps using <b>by IPA files</b>"
    }, {
        icon: "link",
        color: "blue",
        text: "Signing apps using <b>external links</b>"
    }, {
        icon: "shippingbox_fill",
        color: "blue",
        text: "Inject <b>.dylib tweaks</b>"
    }, {
        icon: "gear",
        color: "blue",
        text: "Changing the app <b>Bundle ID</b>"
    }, {
        icon: "square_split_1x2_fill",
        color: "blue",
        text: "Launching an application in <b>split-screen mode</b>"
    }, {
        icon: "square_fill_on_square_fill",
        color: "blue",
        text: "Install <b>duplicates</b>"
    }],
    userStreamOnly: [{
        icon: "checkmark_shield_fill",
        text: "<b>99%</b> that the certificate will <b>not be revoked!</b>"
    }],
    serviceStreamOnly: [{
        icon: "heart_circle",
        text: "1 free recovery if the certificate is revoked"
    }],
    serviceStreamOnlyForOffer: []
};
const nP = ["src"]
  , aP = {
    class: "padding-horizontal-half"
}
  , rP = ["innerHTML"]
  , oP = {
    key: 0,
    style: {
        padding: "10px 15px 15px"
    }
}
  , iP = {
    __name: "ActiveServices",
    setup(e) {
        const t = ht()
          , n = _a()
          , a = s => {
            const l = s.replace(" ", "T")
              , c = new Date(l);
            return isFinite(c) ? Si.format(c) : "Invalid Date"
        }
          , r = s => {
            let l;
            switch (s) {
            case "premium":
                l = "Premium Access";
                break;
            default:
                l = "Premium Access"
            }
            return l
        }
          , o = (s, l, c) => l ? "Service has expired" : s === "false" ? `Expires ${a(c)}` : `Will be extended ${a(c)}`
          , i = s => {
            let l;
            switch (s) {
            case "premium":
                l = "./icons/Crown_icon26.jpg?3";
                break;
            default:
                l = "./icons/Crown_icon26.jpg?3"
            }
            return l
        }
        ;
        return Xe(async () => {
            await n.getReferralCode(),
            await n.getBalance()
        }
        ),
        (s, l) => {
            const c = P("f7-button")
              , u = P("f7-icon")
              , f = P("f7-list-item")
              , d = P("f7-list")
              , p = P("f7-accordion-content")
              , h = P("f7-card");
            return O(),
            K(h, {
                class: "card-green"
            }, {
                default: k( () => [S(d, {
                    "accordion-list": "",
                    class: "fetures-list",
                    inset: "",
                    "media-list": "",
                    "no-hairlines-between": ""
                }, {
                    default: k( () => [V("ul", null, [(O(!0),
                    G(Be, null, vt(B(t).device.service, m => (O(),
                    K(f, {
                        key: m.id,
                        "accordion-item": "",
                        class: "item-inner-center",
                        footer: m.subscription_merchant !== "false" ? "$2.99 per month" : "",
                        inset: "",
                        title: r(m.name)
                    }, {
                        media: k( () => [V("img", {
                            alt: "Service icon",
                            height: "65",
                            src: i(m.name),
                            style: {
                                "border-radius": "23%"
                            }
                        }, null, 8, nP)]),
                        subtitle: k( () => [V("div", {
                            class: Ae({
                                "text-color-red": m.isExpired
                            })
                        }, Me(o(m.subscription_merchant, m.isExpired, m.end_date)), 3)]),
                        default: k( () => [S(p, null, {
                            default: k( () => [V("div", aP, [m.isExpired ? (O(),
                            K(c, {
                                key: 0,
                                class: "button-lite margin-vertical-half",
                                href: "/device/service-offer-details/",
                                "icon-f7": "goforward",
                                large: "",
                                round: "",
                                "route-props": {
                                    offerId: 1
                                }
                            }, {
                                default: k( () => [J(" Renew service ")]),
                                _: 1
                            })) : pe("", !0), m.subscription_merchant !== "false" && m.subscription_id !== "false" ? (O(),
                            K(B(tP), {
                                key: 1,
                                class: "margin-vertical-half",
                                "subscription-id": m.subscription_id,
                                "subscription-merchant": m.subscription_merchant
                            }, null, 8, ["subscription-id", "subscription-merchant"])) : pe("", !0)]), S(d, {
                                class: "list-accordion"
                            }, {
                                default: k( () => [(O(!0),
                                G(Be, null, vt(B(jt).premiumOnly, g => (O(),
                                K(f, {
                                    key: g
                                }, {
                                    title: k( () => [V("span", {
                                        innerHTML: g.text
                                    }, null, 8, rP)]),
                                    media: k( () => [S(u, {
                                        f7: g.icon
                                    }, null, 8, ["f7"])]),
                                    _: 2
                                }, 1024))), 128))]),
                                _: 1
                            })]),
                            _: 2
                        }, 1024)]),
                        _: 2
                    }, 1032, ["footer", "title"]))), 128)), !B(n).referralCode && B(t).device.hasPremium ? (O(),
                    G("li", oP, [V("div", null, [S(c, {
                        class: "button-lite",
                        href: "/partner/description-popup/",
                        "icon-color": "yellow",
                        "icon-f7": "rocket_fill",
                        large: "",
                        round: ""
                    }, {
                        default: k( () => [J(" Boost for free ")]),
                        _: 1
                    })])])) : pe("", !0), B(n).referralCode !== null ? (O(),
                    K(B(KO), {
                        key: 1,
                        balance: B(n).balance,
                        "has-started-service": !!B(n).referralCode
                    }, null, 8, ["balance", "has-started-service"])) : pe("", !0)])]),
                    _: 1
                })]),
                _: 1
            })
        }
    }
}
  , sP = it(iP, [["__scopeId", "data-v-66eaa3fe"]])
  , lP = "" + new URL("../icons/ActivationProcessIcon.jpg",import.meta.url).href;
var G8 = "en"
  , nd = {}
  , ku = {};
function X8() {
    return G8
}
function cP(e) {
    G8 = e
}
function uP(e) {
    return nd[e]
}
function fP(e) {
    if (!e)
        throw new Error("No locale data passed");
    nd[e.locale] = e,
    ku[e.locale.toLowerCase()] = e.locale
}
function O4(e) {
    if (nd[e])
        return e;
    if (ku[e.toLowerCase()])
        return ku[e.toLowerCase()]
}
function K8(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
      , n = t.localeMatcher || "lookup";
    switch (n) {
    case "lookup":
        return P4(e);
    case "best fit":
        return P4(e);
    default:
        throw new RangeError('Invalid "localeMatcher" option: '.concat(n))
    }
}
function P4(e) {
    var t = O4(e);
    if (t)
        return t;
    for (var n = e.split("-"); e.length > 1; ) {
        n.pop(),
        e = n.join("-");
        var a = O4(e);
        if (a)
            return a
    }
}
var fe = {
    af: function(t) {
        return t == 1 ? "one" : "other"
    },
    am: function(t) {
        return t >= 0 && t <= 1 ? "one" : "other"
    },
    ar: function(t) {
        var n = String(t).split(".")
          , a = Number(n[0]) == t
          , r = a && n[0].slice(-2);
        return t == 0 ? "zero" : t == 1 ? "one" : t == 2 ? "two" : r >= 3 && r <= 10 ? "few" : r >= 11 && r <= 99 ? "many" : "other"
    },
    ast: function(t) {
        var n = String(t).split(".")
          , a = !n[1];
        return t == 1 && a ? "one" : "other"
    },
    be: function(t) {
        var n = String(t).split(".")
          , a = Number(n[0]) == t
          , r = a && n[0].slice(-1)
          , o = a && n[0].slice(-2);
        return r == 1 && o != 11 ? "one" : r >= 2 && r <= 4 && (o < 12 || o > 14) ? "few" : a && r == 0 || r >= 5 && r <= 9 || o >= 11 && o <= 14 ? "many" : "other"
    },
    br: function(t) {
        var n = String(t).split(".")
          , a = Number(n[0]) == t
          , r = a && n[0].slice(-1)
          , o = a && n[0].slice(-2)
          , i = a && n[0].slice(-6);
        return r == 1 && o != 11 && o != 71 && o != 91 ? "one" : r == 2 && o != 12 && o != 72 && o != 92 ? "two" : (r == 3 || r == 4 || r == 9) && (o < 10 || o > 19) && (o < 70 || o > 79) && (o < 90 || o > 99) ? "few" : t != 0 && a && i == 0 ? "many" : "other"
    },
    bs: function(t) {
        var n = String(t).split(".")
          , a = n[0]
          , r = n[1] || ""
          , o = !n[1]
          , i = a.slice(-1)
          , s = a.slice(-2)
          , l = r.slice(-1)
          , c = r.slice(-2);
        return o && i == 1 && s != 11 || l == 1 && c != 11 ? "one" : o && i >= 2 && i <= 4 && (s < 12 || s > 14) || l >= 2 && l <= 4 && (c < 12 || c > 14) ? "few" : "other"
    },
    ca: function(t) {
        var n = String(t).split(".")
          , a = n[0]
          , r = !n[1]
          , o = a.slice(-6);
        return t == 1 && r ? "one" : a != 0 && o == 0 && r ? "many" : "other"
    },
    ceb: function(t) {
        var n = String(t).split(".")
          , a = n[0]
          , r = n[1] || ""
          , o = !n[1]
          , i = a.slice(-1)
          , s = r.slice(-1);
        return o && (a == 1 || a == 2 || a == 3) || o && i != 4 && i != 6 && i != 9 || !o && s != 4 && s != 6 && s != 9 ? "one" : "other"
    },
    cs: function(t) {
        var n = String(t).split(".")
          , a = n[0]
          , r = !n[1];
        return t == 1 && r ? "one" : a >= 2 && a <= 4 && r ? "few" : r ? "other" : "many"
    },
    cy: function(t) {
        return t == 0 ? "zero" : t == 1 ? "one" : t == 2 ? "two" : t == 3 ? "few" : t == 6 ? "many" : "other"
    },
    da: function(t) {
        var n = String(t).split(".")
          , a = n[0]
          , r = Number(n[0]) == t;
        return t == 1 || !r && (a == 0 || a == 1) ? "one" : "other"
    },
    dsb: function(t) {
        var n = String(t).split(".")
          , a = n[0]
          , r = n[1] || ""
          , o = !n[1]
          , i = a.slice(-2)
          , s = r.slice(-2);
        return o && i == 1 || s == 1 ? "one" : o && i == 2 || s == 2 ? "two" : o && (i == 3 || i == 4) || s == 3 || s == 4 ? "few" : "other"
    },
    dz: function(t) {
        return "other"
    },
    es: function(t) {
        var n = String(t).split(".")
          , a = n[0]
          , r = !n[1]
          , o = a.slice(-6);
        return t == 1 ? "one" : a != 0 && o == 0 && r ? "many" : "other"
    },
    ff: function(t) {
        return t >= 0 && t < 2 ? "one" : "other"
    },
    fr: function(t) {
        var n = String(t).split(".")
          , a = n[0]
          , r = !n[1]
          , o = a.slice(-6);
        return t >= 0 && t < 2 ? "one" : a != 0 && o == 0 && r ? "many" : "other"
    },
    ga: function(t) {
        var n = String(t).split(".")
          , a = Number(n[0]) == t;
        return t == 1 ? "one" : t == 2 ? "two" : a && t >= 3 && t <= 6 ? "few" : a && t >= 7 && t <= 10 ? "many" : "other"
    },
    gd: function(t) {
        var n = String(t).split(".")
          , a = Number(n[0]) == t;
        return t == 1 || t == 11 ? "one" : t == 2 || t == 12 ? "two" : a && t >= 3 && t <= 10 || a && t >= 13 && t <= 19 ? "few" : "other"
    },
    he: function(t) {
        var n = String(t).split(".")
          , a = n[0]
          , r = !n[1];
        return a == 1 && r || a == 0 && !r ? "one" : a == 2 && r ? "two" : "other"
    },
    is: function(t) {
        var n = String(t).split(".")
          , a = n[0]
          , r = (n[1] || "").replace(/0+$/, "")
          , o = Number(n[0]) == t
          , i = a.slice(-1)
          , s = a.slice(-2);
        return o && i == 1 && s != 11 || r % 10 == 1 && r % 100 != 11 ? "one" : "other"
    },
    ksh: function(t) {
        return t == 0 ? "zero" : t == 1 ? "one" : "other"
    },
    lt: function(t) {
        var n = String(t).split(".")
          , a = n[1] || ""
          , r = Number(n[0]) == t
          , o = r && n[0].slice(-1)
          , i = r && n[0].slice(-2);
        return o == 1 && (i < 11 || i > 19) ? "one" : o >= 2 && o <= 9 && (i < 11 || i > 19) ? "few" : a != 0 ? "many" : "other"
    },
    lv: function(t) {
        var n = String(t).split(".")
          , a = n[1] || ""
          , r = a.length
          , o = Number(n[0]) == t
          , i = o && n[0].slice(-1)
          , s = o && n[0].slice(-2)
          , l = a.slice(-2)
          , c = a.slice(-1);
        return o && i == 0 || s >= 11 && s <= 19 || r == 2 && l >= 11 && l <= 19 ? "zero" : i == 1 && s != 11 || r == 2 && c == 1 && l != 11 || r != 2 && c == 1 ? "one" : "other"
    },
    mk: function(t) {
        var n = String(t).split(".")
          , a = n[0]
          , r = n[1] || ""
          , o = !n[1]
          , i = a.slice(-1)
          , s = a.slice(-2)
          , l = r.slice(-1)
          , c = r.slice(-2);
        return o && i == 1 && s != 11 || l == 1 && c != 11 ? "one" : "other"
    },
    mt: function(t) {
        var n = String(t).split(".")
          , a = Number(n[0]) == t
          , r = a && n[0].slice(-2);
        return t == 1 ? "one" : t == 2 ? "two" : t == 0 || r >= 3 && r <= 10 ? "few" : r >= 11 && r <= 19 ? "many" : "other"
    },
    pa: function(t) {
        return t == 0 || t == 1 ? "one" : "other"
    },
    pl: function(t) {
        var n = String(t).split(".")
          , a = n[0]
          , r = !n[1]
          , o = a.slice(-1)
          , i = a.slice(-2);
        return t == 1 && r ? "one" : r && o >= 2 && o <= 4 && (i < 12 || i > 14) ? "few" : r && a != 1 && (o == 0 || o == 1) || r && o >= 5 && o <= 9 || r && i >= 12 && i <= 14 ? "many" : "other"
    },
    pt: function(t) {
        var n = String(t).split(".")
          , a = n[0]
          , r = !n[1]
          , o = a.slice(-6);
        return a == 0 || a == 1 ? "one" : a != 0 && o == 0 && r ? "many" : "other"
    },
    ro: function(t) {
        var n = String(t).split(".")
          , a = !n[1]
          , r = Number(n[0]) == t
          , o = r && n[0].slice(-2);
        return t == 1 && a ? "one" : !a || t == 0 || t != 1 && o >= 1 && o <= 19 ? "few" : "other"
    },
    ru: function(t) {
        var n = String(t).split(".")
          , a = n[0]
          , r = !n[1]
          , o = a.slice(-1)
          , i = a.slice(-2);
        return r && o == 1 && i != 11 ? "one" : r && o >= 2 && o <= 4 && (i < 12 || i > 14) ? "few" : r && o == 0 || r && o >= 5 && o <= 9 || r && i >= 11 && i <= 14 ? "many" : "other"
    },
    se: function(t) {
        return t == 1 ? "one" : t == 2 ? "two" : "other"
    },
    si: function(t) {
        var n = String(t).split(".")
          , a = n[0]
          , r = n[1] || "";
        return t == 0 || t == 1 || a == 0 && r == 1 ? "one" : "other"
    },
    sl: function(t) {
        var n = String(t).split(".")
          , a = n[0]
          , r = !n[1]
          , o = a.slice(-2);
        return r && o == 1 ? "one" : r && o == 2 ? "two" : r && (o == 3 || o == 4) || !r ? "few" : "other"
    }
};
fe.as = fe.am;
fe.az = fe.af;
fe.bg = fe.af;
fe.bn = fe.am;
fe.brx = fe.af;
fe.ce = fe.af;
fe.chr = fe.af;
fe.de = fe.ast;
fe.ee = fe.af;
fe.el = fe.af;
fe.en = fe.ast;
fe.et = fe.ast;
fe.eu = fe.af;
fe.fa = fe.am;
fe.fi = fe.ast;
fe.fil = fe.ceb;
fe.fo = fe.af;
fe.fur = fe.af;
fe.fy = fe.ast;
fe.gl = fe.ast;
fe.gu = fe.am;
fe.ha = fe.af;
fe.hi = fe.am;
fe.hr = fe.bs;
fe.hsb = fe.dsb;
fe.hu = fe.af;
fe.hy = fe.ff;
fe.ia = fe.ast;
fe.id = fe.dz;
fe.ig = fe.dz;
fe.it = fe.ca;
fe.ja = fe.dz;
fe.jgo = fe.af;
fe.jv = fe.dz;
fe.ka = fe.af;
fe.kea = fe.dz;
fe.kk = fe.af;
fe.kl = fe.af;
fe.km = fe.dz;
fe.kn = fe.am;
fe.ko = fe.dz;
fe.ks = fe.af;
fe.ku = fe.af;
fe.ky = fe.af;
fe.lb = fe.af;
fe.lkt = fe.dz;
fe.lo = fe.dz;
fe.ml = fe.af;
fe.mn = fe.af;
fe.mr = fe.af;
fe.ms = fe.dz;
fe.my = fe.dz;
fe.nb = fe.af;
fe.ne = fe.af;
fe.nl = fe.ast;
fe.nn = fe.af;
fe.no = fe.af;
fe.or = fe.af;
fe.pcm = fe.am;
fe.ps = fe.af;
fe.rm = fe.af;
fe.sah = fe.dz;
fe.sc = fe.ast;
fe.sd = fe.af;
fe.sk = fe.cs;
fe.so = fe.af;
fe.sq = fe.af;
fe.sr = fe.bs;
fe.su = fe.dz;
fe.sv = fe.ast;
fe.sw = fe.ast;
fe.ta = fe.af;
fe.te = fe.af;
fe.th = fe.dz;
fe.ti = fe.pa;
fe.tk = fe.af;
fe.to = fe.dz;
fe.tr = fe.af;
fe.ug = fe.af;
fe.uk = fe.ru;
fe.ur = fe.ast;
fe.uz = fe.af;
fe.vi = fe.dz;
fe.wae = fe.af;
fe.wo = fe.dz;
fe.xh = fe.af;
fe.yi = fe.ast;
fe.yo = fe.dz;
fe.yue = fe.dz;
fe.zh = fe.dz;
fe.zu = fe.am;
function L4(e) {
    return e === "pt-PT" ? e : pP(e)
}
var dP = /^([a-z0-9]+)/i;
function pP(e) {
    var t = e.match(dP);
    if (!t)
        throw new TypeError("Invalid locale: ".concat(e));
    return t[1]
}
function hP(e, t) {
    if (!(e instanceof t))
        throw new TypeError("Cannot call a class as a function")
}
function I4(e, t) {
    for (var n = 0; n < t.length; n++) {
        var a = t[n];
        a.enumerable = a.enumerable || !1,
        a.configurable = !0,
        "value"in a && (a.writable = !0),
        Object.defineProperty(e, a.key, a)
    }
}
function mP(e, t, n) {
    return t && I4(e.prototype, t),
    n && I4(e, n),
    Object.defineProperty(e, "prototype", {
        writable: !1
    }),
    e
}
var Su = function() {
    function e(t, n) {
        hP(this, e);
        var a = e.supportedLocalesOf(t);
        if (a.length === 0)
            throw new RangeError("Unsupported locale: " + t);
        if (n && n.type !== "cardinal")
            throw new RangeError('Only "cardinal" "type" is supported');
        this.$ = fe[L4(a[0])]
    }
    return mP(e, [{
        key: "select",
        value: function(n) {
            return this.$(n)
        }
    }], [{
        key: "supportedLocalesOf",
        value: function(n) {
            return typeof n == "string" && (n = [n]),
            n.filter(function(a) {
                return fe[L4(a)]
            })
        }
    }]),
    e
}();
function $u(e) {
    return $u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    }
    : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }
    ,
    $u(e)
}
function B4(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var a = Object.getOwnPropertySymbols(e);
        t && (a = a.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable
        })),
        n.push.apply(n, a)
    }
    return n
}
function R4(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? B4(Object(n), !0).forEach(function(a) {
            gP(e, a, n[a])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : B4(Object(n)).forEach(function(a) {
            Object.defineProperty(e, a, Object.getOwnPropertyDescriptor(n, a))
        })
    }
    return e
}
function gP(e, t, n) {
    return t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n,
    e
}
function D4(e, t) {
    return CP(e) || yP(e, t) || bP(e, t) || vP()
}
function vP() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function bP(e, t) {
    if (e) {
        if (typeof e == "string")
            return N4(e, t);
        var n = Object.prototype.toString.call(e).slice(8, -1);
        if (n === "Object" && e.constructor && (n = e.constructor.name),
        n === "Map" || n === "Set")
            return Array.from(e);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return N4(e, t)
    }
}
function N4(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var n = 0, a = new Array(t); n < t; n++)
        a[n] = e[n];
    return a
}
function yP(e, t) {
    var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (n != null) {
        var a = [], r = !0, o = !1, i, s;
        try {
            for (n = n.call(e); !(r = (i = n.next()).done) && (a.push(i.value),
            !(t && a.length === t)); r = !0)
                ;
        } catch (l) {
            o = !0,
            s = l
        } finally {
            try {
                !r && n.return != null && n.return()
            } finally {
                if (o)
                    throw s
            }
        }
        return a
    }
}
function CP(e) {
    if (Array.isArray(e))
        return e
}
function wP(e, t) {
    if (!(e instanceof t))
        throw new TypeError("Cannot call a class as a function")
}
function H4(e, t) {
    for (var n = 0; n < t.length; n++) {
        var a = t[n];
        a.enumerable = a.enumerable || !1,
        a.configurable = !0,
        "value"in a && (a.writable = !0),
        Object.defineProperty(e, a.key, a)
    }
}
function _P(e, t, n) {
    return t && H4(e.prototype, t),
    n && H4(e, n),
    Object.defineProperty(e, "prototype", {
        writable: !1
    }),
    e
}
var kP = ["second", "minute", "hour", "day", "week", "month", "quarter", "year"]
  , SP = ["auto", "always"]
  , $P = ["long", "short", "narrow"]
  , EP = ["lookup", "best fit"]
  , Hr = function() {
    function e() {
        var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []
          , n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        wP(this, e);
        var a = n.numeric
          , r = n.style
          , o = n.localeMatcher;
        if (this.numeric = "always",
        this.style = "long",
        this.localeMatcher = "lookup",
        a !== void 0) {
            if (SP.indexOf(a) < 0)
                throw new RangeError('Invalid "numeric" option: '.concat(a));
            this.numeric = a
        }
        if (r !== void 0) {
            if ($P.indexOf(r) < 0)
                throw new RangeError('Invalid "style" option: '.concat(r));
            this.style = r
        }
        if (o !== void 0) {
            if (EP.indexOf(o) < 0)
                throw new RangeError('Invalid "localeMatcher" option: '.concat(o));
            this.localeMatcher = o
        }
        if (typeof t == "string" && (t = [t]),
        t.push(X8()),
        this.locale = e.supportedLocalesOf(t, {
            localeMatcher: this.localeMatcher
        })[0],
        !this.locale)
            throw new Error("No supported locale was found");
        Su.supportedLocalesOf(this.locale).length > 0 ? this.pluralRules = new Su(this.locale) : console.warn('"'.concat(this.locale, '" locale is not supported')),
        typeof Intl < "u" && Intl.NumberFormat ? (this.numberFormat = new Intl.NumberFormat(this.locale),
        this.numberingSystem = this.numberFormat.resolvedOptions().numberingSystem) : this.numberingSystem = "latn",
        this.locale = K8(this.locale, {
            localeMatcher: this.localeMatcher
        })
    }
    return _P(e, [{
        key: "format",
        value: function() {
            var n = V4(arguments)
              , a = D4(n, 2)
              , r = a[0]
              , o = a[1];
            return this.getRule(r, o).replace("{0}", this.formatNumber(Math.abs(r)))
        }
    }, {
        key: "formatToParts",
        value: function() {
            var n = V4(arguments)
              , a = D4(n, 2)
              , r = a[0]
              , o = a[1]
              , i = this.getRule(r, o)
              , s = i.indexOf("{0}");
            if (s < 0)
                return [{
                    type: "literal",
                    value: i
                }];
            var l = [];
            return s > 0 && l.push({
                type: "literal",
                value: i.slice(0, s)
            }),
            l = l.concat(this.formatNumberToParts(Math.abs(r)).map(function(c) {
                return R4(R4({}, c), {}, {
                    unit: o
                })
            })),
            s + 3 < i.length - 1 && l.push({
                type: "literal",
                value: i.slice(s + 3)
            }),
            l
        }
    }, {
        key: "getRule",
        value: function(n, a) {
            var r = uP(this.locale)[this.style][a];
            if (typeof r == "string")
                return r;
            if (this.numeric === "auto") {
                if (n === -2 || n === -1) {
                    var o = r["previous".concat(n === -1 ? "" : "-" + Math.abs(n))];
                    if (o)
                        return o
                } else if (n === 1 || n === 2) {
                    var i = r["next".concat(n === 1 ? "" : "-" + Math.abs(n))];
                    if (i)
                        return i
                } else if (n === 0 && r.current)
                    return r.current
            }
            var s = r[AP(n) ? "past" : "future"];
            if (typeof s == "string")
                return s;
            var l = this.pluralRules && this.pluralRules.select(Math.abs(n)) || "other";
            return s[l] || s.other
        }
    }, {
        key: "formatNumber",
        value: function(n) {
            return this.numberFormat ? this.numberFormat.format(n) : String(n)
        }
    }, {
        key: "formatNumberToParts",
        value: function(n) {
            return this.numberFormat && this.numberFormat.formatToParts ? this.numberFormat.formatToParts(n) : [{
                type: "integer",
                value: this.formatNumber(n)
            }]
        }
    }, {
        key: "resolvedOptions",
        value: function() {
            return {
                locale: this.locale,
                style: this.style,
                numeric: this.numeric,
                numberingSystem: this.numberingSystem
            }
        }
    }]),
    e
}();
Hr.supportedLocalesOf = function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (typeof e == "string")
        e = [e];
    else if (!Array.isArray(e))
        throw new TypeError('Invalid "locales" argument');
    return e.filter(function(n) {
        return K8(n, t)
    })
}
;
Hr.addLocale = fP;
Hr.setDefaultLocale = cP;
Hr.getDefaultLocale = X8;
Hr.PluralRules = Su;
var u2 = 'Invalid "unit" argument';
function xP(e) {
    if ($u(e) === "symbol")
        throw new TypeError(u2);
    if (typeof e != "string")
        throw new RangeError("".concat(u2, ": ").concat(e));
    if (e[e.length - 1] === "s" && (e = e.slice(0, e.length - 1)),
    kP.indexOf(e) < 0)
        throw new RangeError("".concat(u2, ": ").concat(e));
    return e
}
var TP = 'Invalid "number" argument';
function MP(e) {
    if (e = Number(e),
    Number.isFinite && !Number.isFinite(e))
        throw new RangeError("".concat(TP, ": ").concat(e));
    return e
}
function zP(e) {
    return 1 / e === -1 / 0
}
function AP(e) {
    return e < 0 || e === 0 && zP(e)
}
function V4(e) {
    if (e.length < 2)
        throw new TypeError('"unit" argument is required');
    return [MP(e[0]), xP(e[1])]
}
function z1(e) {
    return z1 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    }
    : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }
    ,
    z1(e)
}
function OP(e, t) {
    if (!(e instanceof t))
        throw new TypeError("Cannot call a class as a function")
}
function F4(e, t) {
    for (var n = 0; n < t.length; n++) {
        var a = t[n];
        a.enumerable = a.enumerable || !1,
        a.configurable = !0,
        "value"in a && (a.writable = !0),
        Object.defineProperty(e, a.key, a)
    }
}
function PP(e, t, n) {
    return t && F4(e.prototype, t),
    n && F4(e, n),
    Object.defineProperty(e, "prototype", {
        writable: !1
    }),
    e
}
var j4 = function() {
    function e() {
        OP(this, e),
        this.cache = {}
    }
    return PP(e, [{
        key: "get",
        value: function() {
            for (var n = this.cache, a = arguments.length, r = new Array(a), o = 0; o < a; o++)
                r[o] = arguments[o];
            for (var i = 0, s = r; i < s.length; i++) {
                var l = s[i];
                if (z1(n) !== "object")
                    return;
                n = n[l]
            }
            return n
        }
    }, {
        key: "put",
        value: function() {
            for (var n = arguments.length, a = new Array(n), r = 0; r < n; r++)
                a[r] = arguments[r];
            for (var o = a.pop(), i = a.pop(), s = this.cache, l = 0, c = a; l < c.length; l++) {
                var u = c[l];
                z1(s[u]) !== "object" && (s[u] = {}),
                s = s[u]
            }
            return s[i] = o
        }
    }]),
    e
}();
function Eu(e) {
    return Eu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    }
    : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }
    ,
    Eu(e)
}
function LP(e, t) {
    var n = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (n)
        return (n = n.call(e)).next.bind(n);
    if (Array.isArray(e) || (n = IP(e)) || t && e && typeof e.length == "number") {
        n && (e = n);
        var a = 0;
        return function() {
            return a >= e.length ? {
                done: !0
            } : {
                done: !1,
                value: e[a++]
            }
        }
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function IP(e, t) {
    if (e) {
        if (typeof e == "string")
            return U4(e, t);
        var n = Object.prototype.toString.call(e).slice(8, -1);
        if (n === "Object" && e.constructor && (n = e.constructor.name),
        n === "Map" || n === "Set")
            return Array.from(e);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return U4(e, t)
    }
}
function U4(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var n = 0, a = new Array(t); n < t; n++)
        a[n] = e[n];
    return a
}
function BP(e, t) {
    for (var n = LP(e), a; !(a = n()).done; ) {
        var r = a.value;
        if (t(r))
            return r;
        for (var o = r.split("-"); o.length > 1; )
            if (o.pop(),
            r = o.join("-"),
            t(r))
                return r
    }
    throw new Error("No locale data has been registered for any of the locales: ".concat(e.join(", ")))
}
function RP() {
    var e = (typeof Intl > "u" ? "undefined" : Eu(Intl)) === "object";
    return e && typeof Intl.DateTimeFormat == "function"
}
function xu(e) {
    return xu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    }
    : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }
    ,
    xu(e)
}
function DP(e) {
    return HP(e) && (Array.isArray(e.steps) || Array.isArray(e.gradation) || Array.isArray(e.flavour) || typeof e.flavour == "string" || Array.isArray(e.labels) || typeof e.labels == "string" || Array.isArray(e.units) || typeof e.custom == "function")
}
var NP = {}.constructor;
function HP(e) {
    return xu(e) !== void 0 && e !== null && e.constructor === NP
}
var Ka = 60
  , A1 = 60 * Ka
  , vo = 24 * A1
  , Tu = 7 * vo
  , Mu = 30.44 * vo
  , Z8 = 146097 / 400 * vo;
function ii(e) {
    switch (e) {
    case "second":
        return 1;
    case "minute":
        return Ka;
    case "hour":
        return A1;
    case "day":
        return vo;
    case "week":
        return Tu;
    case "month":
        return Mu;
    case "year":
        return Z8
    }
}
function J8(e) {
    return e.factor !== void 0 ? e.factor : ii(e.unit || e.formatAs) || 1
}
function Os(e) {
    switch (e) {
    case "floor":
        return Math.floor;
    default:
        return Math.round
    }
}
function ad(e) {
    switch (e) {
    case "floor":
        return 1;
    default:
        return .5
    }
}
function zu(e) {
    return zu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    }
    : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }
    ,
    zu(e)
}
function Q8(e, t) {
    var n = t.prevStep, a = t.timestamp, r = t.now, o = t.future, i = t.round, s;
    return n && (n.id || n.unit) && (s = e["threshold_for_".concat(n.id || n.unit)]),
    s === void 0 && e.threshold !== void 0 && (s = e.threshold,
    typeof s == "function" && (s = s(r, o))),
    s === void 0 && (s = e.minTime),
    zu(s) === "object" && (n && n.id && s[n.id] !== void 0 ? s = s[n.id] : s = s.default),
    typeof s == "function" && (s = s(a, {
        future: o,
        getMinTimeForUnit: function(c, u) {
            return q4(c, u || n && n.formatAs, {
                round: i
            })
        }
    })),
    s === void 0 && e.test && (e.test(a, {
        now: r,
        future: o
    }) ? s = 0 : s = 9007199254740991),
    s === void 0 && (n ? e.formatAs && n.formatAs && (s = q4(e.formatAs, n.formatAs, {
        round: i
    })) : s = 0),
    s === void 0 && console.warn("[javascript-time-ago] A step should specify `minTime`:\n" + JSON.stringify(e, null, 2)),
    s
}
function q4(e, t, n) {
    var a = n.round, r = ii(e), o;
    if (t === "now" ? o = ii(e) : o = ii(t),
    r !== void 0 && o !== void 0)
        return r - o * (1 - ad(a))
}
function W4(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var a = Object.getOwnPropertySymbols(e);
        t && (a = a.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable
        })),
        n.push.apply(n, a)
    }
    return n
}
function VP(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? W4(Object(n), !0).forEach(function(a) {
            FP(e, a, n[a])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : W4(Object(n)).forEach(function(a) {
            Object.defineProperty(e, a, Object.getOwnPropertyDescriptor(n, a))
        })
    }
    return e
}
function FP(e, t, n) {
    return t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n,
    e
}
function jP(e, t, n) {
    var a = n.now
      , r = n.future
      , o = n.round
      , i = n.units
      , s = n.getNextStep;
    e = qP(e, i);
    var l = UP(e, t, {
        now: a,
        future: r,
        round: o
    });
    if (s) {
        if (l) {
            var c = e[e.indexOf(l) - 1]
              , u = e[e.indexOf(l) + 1];
            return [c, l, u]
        }
        return [void 0, void 0, e[0]]
    }
    return l
}
function UP(e, t, n) {
    var a = n.now
      , r = n.future
      , o = n.round;
    if (e.length !== 0) {
        var i = eh(e, t, {
            now: a,
            future: r || t < 0,
            round: o
        });
        if (i !== -1) {
            var s = e[i];
            if (s.granularity) {
                var l = Os(o)(Math.abs(t) / J8(s) / s.granularity) * s.granularity;
                if (l === 0 && i > 0)
                    return e[i - 1]
            }
            return s
        }
    }
}
function eh(e, t, n) {
    var a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0
      , r = Q8(e[a], VP({
        prevStep: e[a - 1],
        timestamp: n.now - t * 1e3
    }, n));
    return r === void 0 || Math.abs(t) < r ? a - 1 : a === e.length - 1 ? a : eh(e, t, n, a + 1)
}
function qP(e, t) {
    return e.filter(function(n) {
        var a = n.unit
          , r = n.formatAs;
        return a = a || r,
        a ? t.indexOf(a) >= 0 : !0
    })
}
function WP(e, t, n) {
    var a = n.now
      , r = n.round;
    if (ii(e)) {
        var o = ii(e) * 1e3
          , i = t > a
          , s = Math.abs(t - a)
          , l = Os(r)(s / o) * o;
        return i ? l > 0 ? s - l + GP(r, o) : s - l + 1 : -(s - l) + YP(r, o)
    }
}
function YP(e, t) {
    return ad(e) * t
}
function GP(e, t) {
    return (1 - ad(e)) * t + 1
}
var XP = 365 * 24 * 60 * 60 * 1e3
  , th = 1e3 * XP;
function KP(e, t, n) {
    var a = n.prevStep
      , r = n.nextStep
      , o = n.now
      , i = n.future
      , s = n.round
      , l = e.getTime ? e.getTime() : e
      , c = function(h) {
        return WP(h, l, {
            now: o,
            round: s
        })
    }
      , u = JP(i ? t : r, l, {
        future: i,
        now: o,
        round: s,
        prevStep: i ? a : t
    });
    if (u !== void 0) {
        var f;
        if (t && (t.getTimeToNextUpdate && (f = t.getTimeToNextUpdate(l, {
            getTimeToNextUpdateForUnit: c,
            getRoundFunction: Os,
            now: o,
            future: i,
            round: s
        })),
        f === void 0)) {
            var d = t.unit || t.formatAs;
            d && (f = c(d))
        }
        return f === void 0 ? u : Math.min(f, u)
    }
}
function ZP(e, t, n) {
    var a = n.now
      , r = n.future
      , o = n.round
      , i = n.prevStep
      , s = Q8(e, {
        timestamp: t,
        now: a,
        future: r,
        round: o,
        prevStep: i
    });
    if (s !== void 0)
        return r ? t - s * 1e3 + 1 : s === 0 && t === a ? th : t + s * 1e3
}
function JP(e, t, n) {
    var a = n.now
      , r = n.future
      , o = n.round
      , i = n.prevStep;
    if (e) {
        var s = ZP(e, t, {
            now: a,
            future: r,
            round: o,
            prevStep: i
        });
        return s === void 0 ? void 0 : s - a
    } else
        return r ? t - a + 1 : th
}
var nh = {};
function Jo(e) {
    return nh[e]
}
function ah(e) {
    if (!e)
        throw new Error("[javascript-time-ago] No locale data passed.");
    nh[e.locale] = e
}
const QP = [{
    formatAs: "now"
}, {
    formatAs: "second"
}, {
    formatAs: "minute"
}, {
    formatAs: "hour"
}, {
    formatAs: "day"
}, {
    formatAs: "week"
}, {
    formatAs: "month"
}, {
    formatAs: "year"
}]
  , Au = {
    steps: QP,
    labels: "long"
};
function Y4(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var a = Object.getOwnPropertySymbols(e);
        t && (a = a.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable
        })),
        n.push.apply(n, a)
    }
    return n
}
function G4(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? Y4(Object(n), !0).forEach(function(a) {
            eL(e, a, n[a])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Y4(Object(n)).forEach(function(a) {
            Object.defineProperty(e, a, Object.getOwnPropertyDescriptor(n, a))
        })
    }
    return e
}
function eL(e, t, n) {
    return t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n,
    e
}
const Ou = G4(G4({}, Au), {}, {
    steps: Au.steps.filter(function(e) {
        return e.formatAs !== "second"
    })
})
  , rh = [{
    factor: 1,
    unit: "now"
}, {
    threshold: 1,
    threshold_for_now: 45.5,
    factor: 1,
    unit: "second"
}, {
    threshold: 45.5,
    factor: Ka,
    unit: "minute"
}, {
    threshold: 2.5 * Ka,
    granularity: 5,
    factor: Ka,
    unit: "minute"
}, {
    threshold: 22.5 * Ka,
    factor: .5 * A1,
    unit: "half-hour"
}, {
    threshold: 42.5 * Ka,
    threshold_for_minute: 52.5 * Ka,
    factor: A1,
    unit: "hour"
}, {
    threshold: 20.5 / 24 * vo,
    factor: vo,
    unit: "day"
}, {
    threshold: 5.5 * vo,
    factor: Tu,
    unit: "week"
}, {
    threshold: 3.5 * Tu,
    factor: Mu,
    unit: "month"
}, {
    threshold: 10.5 * Mu,
    factor: Z8,
    unit: "year"
}]
  , X4 = {
    gradation: rh,
    flavour: "long",
    units: ["now", "minute", "hour", "day", "week", "month", "year"]
}
  , tL = {
    gradation: rh,
    flavour: "long-time",
    units: ["now", "minute", "hour", "day", "week", "month", "year"]
};
function oh(e) {
    return e instanceof Date ? e : new Date(e)
}
var Pu = [{
    formatAs: "second"
}, {
    formatAs: "minute"
}, {
    formatAs: "hour"
}]
  , Aa = {}
  , nL = {
    minTime: function(t, n) {
        var a = n.future
          , r = n.getMinTimeForUnit;
        return r("day")
    },
    format: function(t, n) {
        return Aa[n] || (Aa[n] = {}),
        Aa[n].dayMonth || (Aa[n].dayMonth = new Intl.DateTimeFormat(n,{
            month: "short",
            day: "numeric"
        })),
        Aa[n].dayMonth.format(oh(t))
    }
}
  , aL = {
    minTime: function(t, n) {
        var a = n.future;
        if (a) {
            var r = new Date(new Date(t).getFullYear(),0).getTime() - 1;
            return (t - r) / 1e3
        } else {
            var o = new Date(new Date(t).getFullYear() + 1,0).getTime();
            return (o - t) / 1e3
        }
    },
    format: function(t, n) {
        return Aa[n] || (Aa[n] = {}),
        Aa[n].dayMonthYear || (Aa[n].dayMonthYear = new Intl.DateTimeFormat(n,{
            year: "numeric",
            month: "short",
            day: "numeric"
        })),
        Aa[n].dayMonthYear.format(oh(t))
    }
};
RP() ? Pu.push(nL, aL) : Pu.push({
    formatAs: "day"
}, {
    formatAs: "week"
}, {
    formatAs: "month"
}, {
    formatAs: "year"
});
const $o = {
    steps: Pu,
    labels: ["mini", "short-time", "narrow", "short"]
};
function K4(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var a = Object.getOwnPropertySymbols(e);
        t && (a = a.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable
        })),
        n.push.apply(n, a)
    }
    return n
}
function Z4(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? K4(Object(n), !0).forEach(function(a) {
            rL(e, a, n[a])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : K4(Object(n)).forEach(function(a) {
            Object.defineProperty(e, a, Object.getOwnPropertyDescriptor(n, a))
        })
    }
    return e
}
function rL(e, t, n) {
    return t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n,
    e
}
const oL = Z4(Z4({}, $o), {}, {
    steps: [{
        formatAs: "now"
    }].concat($o.steps)
});
function J4(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var a = Object.getOwnPropertySymbols(e);
        t && (a = a.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable
        })),
        n.push.apply(n, a)
    }
    return n
}
function Q4(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? J4(Object(n), !0).forEach(function(a) {
            iL(e, a, n[a])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : J4(Object(n)).forEach(function(a) {
            Object.defineProperty(e, a, Object.getOwnPropertyDescriptor(n, a))
        })
    }
    return e
}
function iL(e, t, n) {
    return t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n,
    e
}
const Lu = Q4(Q4({}, $o), {}, {
    steps: $o.steps.filter(function(e) {
        return e.formatAs !== "second"
    })
});
function ep(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var a = Object.getOwnPropertySymbols(e);
        t && (a = a.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable
        })),
        n.push.apply(n, a)
    }
    return n
}
function tp(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? ep(Object(n), !0).forEach(function(a) {
            sL(e, a, n[a])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ep(Object(n)).forEach(function(a) {
            Object.defineProperty(e, a, Object.getOwnPropertyDescriptor(n, a))
        })
    }
    return e
}
function sL(e, t, n) {
    return t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n,
    e
}
const lL = tp(tp({}, Lu), {}, {
    steps: [{
        formatAs: "now"
    }].concat(Lu.steps)
});
function np(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var a = Object.getOwnPropertySymbols(e);
        t && (a = a.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable
        })),
        n.push.apply(n, a)
    }
    return n
}
function Il(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? np(Object(n), !0).forEach(function(a) {
            cL(e, a, n[a])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : np(Object(n)).forEach(function(a) {
            Object.defineProperty(e, a, Object.getOwnPropertyDescriptor(n, a))
        })
    }
    return e
}
function cL(e, t, n) {
    return t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n,
    e
}
const uL = Il(Il({}, $o), {}, {
    steps: $o.steps.filter(function(e) {
        return e.formatAs !== "second"
    }).map(function(e) {
        return e.formatAs === "minute" ? Il(Il({}, e), {}, {
            minTime: Ka
        }) : e
    })
})
  , Ps = {
    steps: [{
        formatAs: "second"
    }, {
        formatAs: "minute"
    }, {
        formatAs: "hour"
    }, {
        formatAs: "day"
    }, {
        formatAs: "month"
    }, {
        formatAs: "year"
    }],
    labels: ["mini", "short-time", "narrow", "short"]
};
function ap(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var a = Object.getOwnPropertySymbols(e);
        t && (a = a.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable
        })),
        n.push.apply(n, a)
    }
    return n
}
function rp(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? ap(Object(n), !0).forEach(function(a) {
            fL(e, a, n[a])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ap(Object(n)).forEach(function(a) {
            Object.defineProperty(e, a, Object.getOwnPropertyDescriptor(n, a))
        })
    }
    return e
}
function fL(e, t, n) {
    return t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n,
    e
}
const dL = rp(rp({}, Ps), {}, {
    steps: [{
        formatAs: "now"
    }].concat(Ps.steps)
});
function op(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var a = Object.getOwnPropertySymbols(e);
        t && (a = a.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable
        })),
        n.push.apply(n, a)
    }
    return n
}
function ip(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? op(Object(n), !0).forEach(function(a) {
            pL(e, a, n[a])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : op(Object(n)).forEach(function(a) {
            Object.defineProperty(e, a, Object.getOwnPropertyDescriptor(n, a))
        })
    }
    return e
}
function pL(e, t, n) {
    return t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n,
    e
}
const Iu = ip(ip({}, Ps), {}, {
    steps: Ps.steps.filter(function(e) {
        return e.formatAs !== "second"
    })
});
function sp(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var a = Object.getOwnPropertySymbols(e);
        t && (a = a.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable
        })),
        n.push.apply(n, a)
    }
    return n
}
function lp(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? sp(Object(n), !0).forEach(function(a) {
            hL(e, a, n[a])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : sp(Object(n)).forEach(function(a) {
            Object.defineProperty(e, a, Object.getOwnPropertyDescriptor(n, a))
        })
    }
    return e
}
function hL(e, t, n) {
    return t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n,
    e
}
const mL = lp(lp({}, Iu), {}, {
    steps: [{
        formatAs: "now"
    }].concat(Iu.steps)
});
function gL(e) {
    switch (e) {
    case "default":
    case "round":
        return Au;
    case "round-minute":
        return Ou;
    case "approximate":
        return X4;
    case "time":
    case "approximate-time":
        return tL;
    case "mini":
        return Ps;
    case "mini-now":
        return dL;
    case "mini-minute":
        return Iu;
    case "mini-minute-now":
        return mL;
    case "twitter":
        return $o;
    case "twitter-now":
        return oL;
    case "twitter-minute":
        return Lu;
    case "twitter-minute-now":
        return lL;
    case "twitter-first-minute":
        return uL;
    default:
        return X4
    }
}
function O1(e) {
    return O1 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    }
    : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }
    ,
    O1(e)
}
function vL(e, t) {
    var n = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (n)
        return (n = n.call(e)).next.bind(n);
    if (Array.isArray(e) || (n = ih(e)) || t && e && typeof e.length == "number") {
        n && (e = n);
        var a = 0;
        return function() {
            return a >= e.length ? {
                done: !0
            } : {
                done: !1,
                value: e[a++]
            }
        }
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function bL(e, t) {
    return wL(e) || CL(e, t) || ih(e, t) || yL()
}
function yL() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function ih(e, t) {
    if (e) {
        if (typeof e == "string")
            return cp(e, t);
        var n = Object.prototype.toString.call(e).slice(8, -1);
        if (n === "Object" && e.constructor && (n = e.constructor.name),
        n === "Map" || n === "Set")
            return Array.from(e);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return cp(e, t)
    }
}
function cp(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var n = 0, a = new Array(t); n < t; n++)
        a[n] = e[n];
    return a
}
function CL(e, t) {
    var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (n != null) {
        var a = [], r = !0, o = !1, i, s;
        try {
            for (n = n.call(e); !(r = (i = n.next()).done) && (a.push(i.value),
            !(t && a.length === t)); r = !0)
                ;
        } catch (l) {
            o = !0,
            s = l
        } finally {
            try {
                !r && n.return != null && n.return()
            } finally {
                if (o)
                    throw s
            }
        }
        return a
    }
}
function wL(e) {
    if (Array.isArray(e))
        return e
}
function _L(e, t) {
    if (!(e instanceof t))
        throw new TypeError("Cannot call a class as a function")
}
function up(e, t) {
    for (var n = 0; n < t.length; n++) {
        var a = t[n];
        a.enumerable = a.enumerable || !1,
        a.configurable = !0,
        "value"in a && (a.writable = !0),
        Object.defineProperty(e, a.key, a)
    }
}
function kL(e, t, n) {
    return t && up(e.prototype, t),
    n && up(e, n),
    Object.defineProperty(e, "prototype", {
        writable: !1
    }),
    e
}
var na = function() {
    function e() {
        var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []
          , n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
          , a = n.polyfill;
        _L(this, e),
        typeof t == "string" && (t = [t]),
        this.locale = BP(t.concat(e.getDefaultLocale()), Jo),
        typeof Intl < "u" && Intl.NumberFormat && (this.numberFormat = new Intl.NumberFormat(this.locale)),
        a === !1 ? (this.IntlRelativeTimeFormat = Intl.RelativeTimeFormat,
        this.IntlPluralRules = Intl.PluralRules) : (this.IntlRelativeTimeFormat = Hr,
        this.IntlPluralRules = Hr.PluralRules),
        this.relativeTimeFormatCache = new j4,
        this.pluralRulesCache = new j4
    }
    return kL(e, [{
        key: "format",
        value: function(n, a, r) {
            r || (a && !TL(a) ? (r = a,
            a = void 0) : r = {}),
            a || (a = Ou),
            typeof a == "string" && (a = gL(a));
            var o = SL(n), i = this.getLabels(a.flavour || a.labels), s = i.labels, l = i.labelsType, c;
            a.now !== void 0 && (c = a.now),
            c === void 0 && r.now !== void 0 && (c = r.now),
            c === void 0 && (c = Date.now());
            var u = (c - o) / 1e3
              , f = r.future || u < 0
              , d = xL(s, Jo(this.locale).now, Jo(this.locale).long, f);
            if (a.custom) {
                var p = a.custom({
                    now: c,
                    date: new Date(o),
                    time: o,
                    elapsed: u,
                    locale: this.locale
                });
                if (p !== void 0)
                    return p
            }
            var h = EL(a.units, s, d)
              , m = r.round || a.round
              , g = jP(a.gradation || a.steps || Ou.steps, u, {
                now: c,
                units: h,
                round: m,
                future: f,
                getNextStep: !0
            })
              , b = bL(g, 3)
              , v = b[0]
              , y = b[1]
              , w = b[2]
              , C = this.formatDateForStep(o, y, u, {
                labels: s,
                labelsType: l,
                nowLabel: d,
                now: c,
                future: f,
                round: m
            }) || "";
            if (r.getTimeToNextUpdate) {
                var _ = KP(o, y, {
                    nextStep: w,
                    prevStep: v,
                    now: c,
                    future: f,
                    round: m
                });
                return [C, _]
            }
            return C
        }
    }, {
        key: "formatDateForStep",
        value: function(n, a, r, o) {
            var i = this
              , s = o.labels
              , l = o.labelsType
              , c = o.nowLabel
              , u = o.now
              , f = o.future
              , d = o.round;
            if (a) {
                if (a.format)
                    return a.format(n, this.locale, {
                        formatAs: function(b, v) {
                            return i.formatValue(v, b, {
                                labels: s,
                                future: f
                            })
                        },
                        now: u,
                        future: f
                    });
                var p = a.unit || a.formatAs;
                if (!p)
                    throw new Error("[javascript-time-ago] Each step must define either `formatAs` or `format()`. Step: ".concat(JSON.stringify(a)));
                if (p === "now")
                    return c;
                var h = Math.abs(r) / J8(a);
                a.granularity && (h = Os(d)(h / a.granularity) * a.granularity);
                var m = -1 * Math.sign(r) * Os(d)(h);
                switch (m === 0 && (f ? m = 0 : m = -0),
                l) {
                case "long":
                case "short":
                case "narrow":
                    return this.getFormatter(l).format(m, p);
                default:
                    return this.formatValue(m, p, {
                        labels: s,
                        future: f
                    })
                }
            }
        }
    }, {
        key: "formatValue",
        value: function(n, a, r) {
            var o = r.labels
              , i = r.future;
            return this.getFormattingRule(o, a, n, {
                future: i
            }).replace("{0}", this.formatNumber(Math.abs(n)))
        }
    }, {
        key: "getFormattingRule",
        value: function(n, a, r, o) {
            var i = o.future
              , s = this.locale;
            if (n = n[a],
            typeof n == "string")
                return n;
            var l = r === 0 ? i ? "future" : "past" : r < 0 ? "past" : "future"
              , c = n[l] || n;
            if (typeof c == "string")
                return c;
            var u = this.getPluralRules().select(Math.abs(r));
            return c[u] || c.other
        }
    }, {
        key: "formatNumber",
        value: function(n) {
            return this.numberFormat ? this.numberFormat.format(n) : String(n)
        }
    }, {
        key: "getFormatter",
        value: function(n) {
            return this.relativeTimeFormatCache.get(this.locale, n) || this.relativeTimeFormatCache.put(this.locale, n, new this.IntlRelativeTimeFormat(this.locale,{
                style: n
            }))
        }
    }, {
        key: "getPluralRules",
        value: function() {
            return this.pluralRulesCache.get(this.locale) || this.pluralRulesCache.put(this.locale, new this.IntlPluralRules(this.locale))
        }
    }, {
        key: "getLabels",
        value: function() {
            var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
            typeof n == "string" && (n = [n]),
            n = n.map(function(s) {
                switch (s) {
                case "tiny":
                case "mini-time":
                    return "mini";
                default:
                    return s
                }
            }),
            n = n.concat("long");
            for (var a = Jo(this.locale), r = vL(n), o; !(o = r()).done; ) {
                var i = o.value;
                if (a[i])
                    return {
                        labelsType: i,
                        labels: a[i]
                    }
            }
        }
    }]),
    e
}()
  , sh = "en";
na.getDefaultLocale = function() {
    return sh
}
;
na.setDefaultLocale = function(e) {
    return sh = e
}
;
na.addDefaultLocale = function(e) {
    if (fp)
        return console.error("[javascript-time-ago] `TimeAgo.addDefaultLocale()` can only be called once. To add other locales, use `TimeAgo.addLocale()`.");
    fp = !0,
    na.setDefaultLocale(e.locale),
    na.addLocale(e)
}
;
var fp;
na.addLocale = function(e) {
    ah(e),
    Hr.addLocale(e)
}
;
na.locale = na.addLocale;
na.addLabels = function(e, t, n) {
    var a = Jo(e);
    a || (ah({
        locale: e
    }),
    a = Jo(e)),
    a[t] = n
}
;
function SL(e) {
    if (e.constructor === Date || $L(e))
        return e.getTime();
    if (typeof e == "number")
        return e;
    throw new Error("Unsupported relative time formatter input: ".concat(O1(e), ", ").concat(e))
}
function $L(e) {
    return O1(e) === "object" && typeof e.getTime == "function"
}
function EL(e, t, n) {
    var a = Object.keys(t);
    return n && a.push("now"),
    e && (a = e.filter(function(r) {
        return r === "now" || a.indexOf(r) >= 0
    })),
    a
}
function xL(e, t, n, a) {
    var r = e.now || t && t.now;
    if (r)
        return typeof r == "string" ? r : a ? r.future : r.past;
    if (n && n.second && n.second.current)
        return n.second.current
}
function TL(e) {
    return typeof e == "string" || DP(e)
}
const ML = {
    locale: "en",
    long: {
        year: {
            previous: "last year",
            current: "this year",
            next: "next year",
            past: {
                one: "{0} year ago",
                other: "{0} years ago"
            },
            future: {
                one: "in {0} year",
                other: "in {0} years"
            }
        },
        quarter: {
            previous: "last quarter",
            current: "this quarter",
            next: "next quarter",
            past: {
                one: "{0} quarter ago",
                other: "{0} quarters ago"
            },
            future: {
                one: "in {0} quarter",
                other: "in {0} quarters"
            }
        },
        month: {
            previous: "last month",
            current: "this month",
            next: "next month",
            past: {
                one: "{0} month ago",
                other: "{0} months ago"
            },
            future: {
                one: "in {0} month",
                other: "in {0} months"
            }
        },
        week: {
            previous: "last week",
            current: "this week",
            next: "next week",
            past: {
                one: "{0} week ago",
                other: "{0} weeks ago"
            },
            future: {
                one: "in {0} week",
                other: "in {0} weeks"
            }
        },
        day: {
            previous: "yesterday",
            current: "today",
            next: "tomorrow",
            past: {
                one: "{0} day ago",
                other: "{0} days ago"
            },
            future: {
                one: "in {0} day",
                other: "in {0} days"
            }
        },
        hour: {
            current: "this hour",
            past: {
                one: "{0} hour ago",
                other: "{0} hours ago"
            },
            future: {
                one: "in {0} hour",
                other: "in {0} hours"
            }
        },
        minute: {
            current: "this minute",
            past: {
                one: "{0} minute ago",
                other: "{0} minutes ago"
            },
            future: {
                one: "in {0} minute",
                other: "in {0} minutes"
            }
        },
        second: {
            current: "now",
            past: {
                one: "{0} second ago",
                other: "{0} seconds ago"
            },
            future: {
                one: "in {0} second",
                other: "in {0} seconds"
            }
        }
    },
    short: {
        year: {
            previous: "last yr.",
            current: "this yr.",
            next: "next yr.",
            past: "{0} yr. ago",
            future: "in {0} yr."
        },
        quarter: {
            previous: "last qtr.",
            current: "this qtr.",
            next: "next qtr.",
            past: {
                one: "{0} qtr. ago",
                other: "{0} qtrs. ago"
            },
            future: {
                one: "in {0} qtr.",
                other: "in {0} qtrs."
            }
        },
        month: {
            previous: "last mo.",
            current: "this mo.",
            next: "next mo.",
            past: "{0} mo. ago",
            future: "in {0} mo."
        },
        week: {
            previous: "last wk.",
            current: "this wk.",
            next: "next wk.",
            past: "{0} wk. ago",
            future: "in {0} wk."
        },
        day: {
            previous: "yesterday",
            current: "today",
            next: "tomorrow",
            past: {
                one: "{0} day ago",
                other: "{0} days ago"
            },
            future: {
                one: "in {0} day",
                other: "in {0} days"
            }
        },
        hour: {
            current: "this hour",
            past: "{0} hr. ago",
            future: "in {0} hr."
        },
        minute: {
            current: "this minute",
            past: "{0} min. ago",
            future: "in {0} min."
        },
        second: {
            current: "now",
            past: "{0} sec. ago",
            future: "in {0} sec."
        }
    },
    narrow: {
        year: {
            previous: "last yr.",
            current: "this yr.",
            next: "next yr.",
            past: "{0}y ago",
            future: "in {0}y"
        },
        quarter: {
            previous: "last qtr.",
            current: "this qtr.",
            next: "next qtr.",
            past: "{0}q ago",
            future: "in {0}q"
        },
        month: {
            previous: "last mo.",
            current: "this mo.",
            next: "next mo.",
            past: "{0}mo ago",
            future: "in {0}mo"
        },
        week: {
            previous: "last wk.",
            current: "this wk.",
            next: "next wk.",
            past: "{0}w ago",
            future: "in {0}w"
        },
        day: {
            previous: "yesterday",
            current: "today",
            next: "tomorrow",
            past: "{0}d ago",
            future: "in {0}d"
        },
        hour: {
            current: "this hour",
            past: "{0}h ago",
            future: "in {0}h"
        },
        minute: {
            current: "this minute",
            past: "{0}m ago",
            future: "in {0}m"
        },
        second: {
            current: "now",
            past: "{0}s ago",
            future: "in {0}s"
        }
    },
    now: {
        now: {
            current: "now",
            future: "in a moment",
            past: "just now"
        }
    },
    mini: {
        year: "{0}yr",
        month: "{0}mo",
        week: "{0}wk",
        day: "{0}d",
        hour: "{0}h",
        minute: "{0}m",
        second: "{0}s",
        now: "now"
    },
    "short-time": {
        year: "{0} yr.",
        month: "{0} mo.",
        week: "{0} wk.",
        day: {
            one: "{0} day",
            other: "{0} days"
        },
        hour: "{0} hr.",
        minute: "{0} min.",
        second: "{0} sec."
    },
    "long-time": {
        year: {
            one: "{0} year",
            other: "{0} years"
        },
        month: {
            one: "{0} month",
            other: "{0} months"
        },
        week: {
            one: "{0} week",
            other: "{0} weeks"
        },
        day: {
            one: "{0} day",
            other: "{0} days"
        },
        hour: {
            one: "{0} hour",
            other: "{0} hours"
        },
        minute: {
            one: "{0} minute",
            other: "{0} minutes"
        },
        second: {
            one: "{0} second",
            other: "{0} seconds"
        }
    }
}
  , dp = {
    1: {
        description: "Queue for registration in Apple Developer Account.",
        waitingTime: " Max 72 hours",
        docsRoute: "/docs/71/"
    },
    2: {
        description: "Queue for registration in Apple Developer Account.",
        waitingTime: " Max 1-14 days",
        docsRoute: "/docs/72/"
    },
    3: {
        description: "The device is registered with an Apple Developer Account and is waiting to be activated.",
        waitingTime: " Max 24-72 hours",
        docsRoute: "/docs/38/"
    },
    4: {
        description: "The device is registered with an Apple Developer Account and is waiting to be activated.",
        waitingTime: ' Max <s class="text-color-gray">24-72</s> 7-30 days',
        docsRoute: "/docs/38/"
    }
}
  , zL = [{
    minQueue: 1,
    maxQueue: 2,
    name: "The device is waiting for its turn to register with an Apple Developer Account."
}, {
    minQueue: 3,
    maxQueue: 5,
    name: "The device is registered with an Apple Developer Account and is waiting to be activated."
}]
  , AL = {
    class: ""
}
  , OL = {
    class: "timeline-item-title"
}
  , PL = {
    key: 0,
    class: "block-footer no-margin no-padding"
}
  , LL = {
    class: "timeline-item-subtitle padding-vertical-half"
}
  , IL = {
    class: "timeline-item-text"
}
  , BL = {
    key: 1,
    class: "display-flex align-items-center justify-content-space-between"
}
  , RL = ["innerHTML"]
  , DL = {
    __name: "ActivationStepsTimeline",
    props: {
        queue: {
            type: Number,
            required: !0
        },
        stepChangedAt: {
            type: String,
            required: !0
        }
    },
    setup(e) {
        const t = new na("en-US")
          , n = e
          , a = o => n.queue >= o.minQueue && n.queue <= o.maxQueue
          , r = t.format(Date.parse(n.stepChangedAt.replace(/-/g, "/")), "mini");
        return (o, i) => {
            const s = P("f7-icon")
              , l = P("f7-chip")
              , c = P("f7-link")
              , u = P("f7-button")
              , f = P("f7-card-content")
              , d = P("f7-card");
            return O(!0),
            G(Be, null, vt(B(zL), (p, h) => (O(),
            K(d, {
                key: h,
                class: "card-green"
            }, {
                default: k( () => [S(f, {
                    class: Ae({
                        disabled: !a(p)
                    })
                }, {
                    default: k( () => [V("div", AL, [V("div", OL, " Step " + Me(++h), 1), a(p) ? (O(),
                    G("div", PL, " You've been here " + Me(B(r)), 1)) : pe("", !0)]), V("div", LL, Me(p.name), 1), V("div", IL, [e.queue > p.maxQueue ? (O(),
                    K(l, {
                        key: 0,
                        class: "chip-with-icon",
                        outline: ""
                    }, {
                        text: k( () => [S(s, {
                            class: "chip-icon",
                            f7: "checkmark_alt",
                            "text-color": "green"
                        }), J(" Done ")]),
                        _: 1
                    })) : pe("", !0), a(p) ? (O(),
                    G("div", BL, [S(l, {
                        class: "chip-with-icon",
                        outline: ""
                    }, {
                        text: k( () => [S(s, {
                            class: "chip-icon",
                            f7: "timer",
                            "text-color": "orange"
                        }), V("span", {
                            innerHTML: B(dp)[e.queue].waitingTime
                        }, null, 8, RL)]),
                        _: 1
                    }), S(c, {
                        color: "blue",
                        href: B(dp)[e.queue].docsRoute
                    }, {
                        default: k( () => [J(" more info ")]),
                        _: 1
                    }, 8, ["href"])])) : pe("", !0), a(p) && e.queue === 2 ? (O(),
                    K(u, {
                        key: 2,
                        class: "button-lite margin-top-half",
                        href: "/device/certificate-offer-details/",
                        large: "",
                        round: "",
                        "route-props": {
                            offerAlias: "priorityRecovery"
                        }
                    }, {
                        default: k( () => [J(" Skip this Step + Gift ")]),
                        _: 1
                    })) : pe("", !0)])]),
                    _: 2
                }, 1032, ["class"])]),
                _: 2
            }, 1024))), 128)
        }
    }
};
const rd = e => (qt("data-v-cfddc1f0"),
e = e(),
Wt(),
e)
  , NL = rd( () => V("img", {
    alt: "Activation process icon",
    height: "60",
    src: lP,
    style: {
        "border-radius": "23%"
    }
}, null, -1))
  , HL = rd( () => V("p", {
    style: {
        "text-align": "center"
    }
}, " This information is based on data obtained through the Apple Developer API ", -1))
  , VL = {
    style: {
        "text-align": "center",
        padding: "10px 15px 15px"
    }
}
  , FL = rd( () => V("b", null, "Why should I wait?", -1))
  , jL = {
    __name: "ActivationStatusCard",
    setup(e) {
        na.addDefaultLocale(ML);
        const t = new na("en-US")
          , n = ht()
          , a = t.format(Date.parse(n.device.date.replace(/-/g, "/")), "twitter");
        return n.device.isUserStream || n.checkActivation(),
        (r, o) => {
            const i = P("f7-preloader")
              , s = P("f7-list-item")
              , l = P("f7-list")
              , c = P("f7-card-content")
              , u = P("f7-link")
              , f = P("f7-block")
              , d = P("f7-card");
            return O(),
            K(d, {
                class: "card-green"
            }, {
                default: k( () => {
                    var p, h;
                    return [S(c, {
                        class: "padding-bottom-half"
                    }, {
                        default: k( () => [S(l, {
                            "media-list": ""
                        }, {
                            default: k( () => [S(s, {
                                "no-chevron": "",
                                text: `Activation requested ${B(a)}`,
                                title: "Activation process"
                            }, lr({
                                media: k( () => [NL]),
                                _: 2
                            }, [B(n).isLoading ? {
                                name: "after",
                                fn: k( () => [S(i)]),
                                key: "0"
                            } : void 0]), 1032, ["text"])]),
                            _: 1
                        })]),
                        _: 1
                    }), S(DL, {
                        queue: Number((p = B(n).device) == null ? void 0 : p.queue),
                        "step-changed-at": (h = B(n).device) == null ? void 0 : h.status_changed_date
                    }, null, 8, ["queue", "step-changed-at"]), B(n).device.stream && B(n).device.stream.connected_via_api ? (O(),
                    K(c, {
                        key: 0
                    }, {
                        default: k( () => [HL]),
                        _: 1
                    })) : pe("", !0), V("div", VL, [S(u, {
                        href: "/docs/38/",
                        "text-color": "blue"
                    }, {
                        default: k( () => [FL]),
                        _: 1
                    })]), B(n).device.isUserStream ? (O(),
                    K(c, {
                        key: 1
                    }, {
                        default: k( () => [S(f, {
                            class: "actions padding-bottom"
                        }, {
                            default: k( () => [ce(r.$slots, "userStreamButton", {}, void 0, !0)]),
                            _: 3
                        })]),
                        _: 3
                    })) : pe("", !0)]
                }
                ),
                _: 3
            })
        }
    }
}
  , UL = it(jL, [["__scopeId", "data-v-cfddc1f0"]]);
const qL = e => (qt("data-v-cdca2b3b"),
e = e(),
Wt(),
e)
  , WL = qL( () => V("img", {
    alt: "Certificate icon",
    height: "65",
    src: q8,
    style: {
        "border-radius": "23%"
    }
}, null, -1))
  , YL = ["innerHTML"]
  , GL = {
    __name: "CurrentCertificateInfo",
    setup(e) {
        const t = ht()
          , n = ae( () => t.device.isUserStream ? jt.forAll.concat(t.device.stream.connected_via_api ? jt.userStreamOnly : []) : jt.forAll.concat(t.device.hasFreeRecovery ? jt.serviceStreamOnly : []))
          , a = r => {
            const o = r.replace(" ", "T")
              , i = new Date(o);
            if (!isFinite(i))
                throw new Error("Invalid date format");
            const s = new Date(i);
            return s.setFullYear(i.getFullYear() + 1),
            Si.format(s)
        }
        ;
        return (r, o) => {
            const i = P("f7-badge")
              , s = P("f7-icon")
              , l = P("f7-list-item")
              , c = P("f7-list")
              , u = P("f7-accordion-content")
              , f = P("f7-card");
            return O(),
            K(f, {
                class: "card-green"
            }, {
                default: k( () => [S(c, {
                    "accordion-list": "",
                    class: "fetures-list",
                    inset: "",
                    "media-list": "",
                    "no-hairlines-between": ""
                }, {
                    default: k( () => [S(l, {
                        "accordion-item": "",
                        class: "item-inner-center",
                        inset: "",
                        subtitle: `Expires ${a(B(t).device.date)}`,
                        title: "Your Certificate"
                    }, lr({
                        media: k( () => [WL]),
                        default: k( () => [S(u, null, {
                            default: k( () => [S(c, {
                                class: "list-accordion"
                            }, {
                                default: k( () => [(O(!0),
                                G(Be, null, vt(n.value, d => (O(),
                                K(l, {
                                    key: d
                                }, {
                                    title: k( () => [V("span", {
                                        innerHTML: d.text
                                    }, null, 8, YL)]),
                                    media: k( () => [S(s, {
                                        f7: d.icon
                                    }, null, 8, ["f7"])]),
                                    _: 2
                                }, 1024))), 128))]),
                                _: 1
                            })]),
                            _: 1
                        })]),
                        _: 2
                    }, [B(t).device.streamRevoked ? {
                        name: "after",
                        fn: k( () => [S(i, {
                            color: "red"
                        }, {
                            default: k( () => [J(" Revoked ")]),
                            _: 1
                        })]),
                        key: "0"
                    } : void 0]), 1032, ["subtitle"]), V("li", null, [ce(r.$slots, "actions", {}, void 0, !0)])]),
                    _: 3
                })]),
                _: 3
            })
        }
    }
}
  , XL = it(GL, [["__scopeId", "data-v-cdca2b3b"]]);
const KL = ["alt", "src"]
  , ZL = ["innerHTML"]
  , JL = {
    class: "item-subtitle",
    style: {
        "white-space": "pre-line"
    }
}
  , QL = {
    class: "item-footer",
    style: {
        "white-space": "pre-line"
    }
}
  , eI = {
    class: "text-align-right"
}
  , tI = {
    key: 0,
    class: "margin-right-half"
}
  , nI = {
    key: 0
}
  , aI = ["innerHTML"]
  , rI = {
    __name: "OfferCard",
    props: {
        logo: {
            type: String,
            default: "Icon.png"
        },
        cardClass: {
            type: String,
            default: ""
        },
        title: {
            type: String,
            default: ""
        },
        subtitle: {
            type: String,
            default: ""
        },
        text: {
            type: String,
            default: ""
        },
        header: {
            type: String,
            default: ""
        },
        footer: {
            type: String,
            default: ""
        },
        price: {
            type: String,
            default: ""
        },
        strikethrough: {
            type: String,
            default: ""
        },
        afterPrice: {
            type: String,
            default: ""
        },
        priceColor: {
            type: String,
            default: "yellow"
        },
        description: {
            type: String,
            default: ""
        },
        features: {
            type: Array,
            default: Array
        }
    },
    setup(e) {
        const t = e;
        return (n, a) => {
            const r = P("f7-badge")
              , o = P("f7-list-item")
              , i = P("f7-list")
              , s = P("f7-card-content")
              , l = P("f7-card")
              , c = P("f7-icon")
              , u = P("f7-block");
            return O(),
            G("div", {
                class: Ae(t.cardClass)
            }, [S(i, {
                class: "rounded-items margin",
                inset: "",
                "media-list": ""
            }, {
                default: k( () => [S(o, {
                    class: "no-margin-top",
                    "no-chevron": ""
                }, lr({
                    media: k( () => [V("img", {
                        alt: t.title,
                        src: `./icons/${t.logo}`
                    }, null, 8, KL)]),
                    title: k( () => [J(Me(t.title) + " ", 1), V("div", {
                        class: "item-text",
                        style: {
                            "white-space": "pre-line"
                        },
                        innerHTML: e.text
                    }, null, 8, ZL), V("div", JL, Me(t.subtitle), 1), V("div", QL, Me(t.footer), 1)]),
                    _: 2
                }, [t.price ? {
                    name: "after",
                    fn: k( () => [V("div", eI, [e.strikethrough ? (O(),
                    G("s", tI, Me(e.strikethrough), 1)) : pe("", !0), S(r, {
                        color: t.priceColor,
                        "text-color": "black"
                    }, {
                        default: k( () => [J(Me(t.price), 1)]),
                        _: 1
                    }, 8, ["color"]), V("div", null, [e.afterPrice ? (O(),
                    G("div", nI, Me(e.afterPrice), 1)) : pe("", !0)])])]),
                    key: "0"
                } : void 0]), 1024)]),
                _: 1
            }), S(l, null, {
                default: k( () => [t.description ? (O(),
                K(s, {
                    key: 0,
                    style: {
                        "text-align": "center"
                    },
                    innerHTML: t.description
                }, null, 8, ["innerHTML"])) : pe("", !0)]),
                _: 1
            }), t.features ? (O(),
            K(i, {
                key: 0,
                class: "features-list no-margin",
                "no-hairlines": "",
                "no-hairlines-between": ""
            }, {
                default: k( () => [(O(!0),
                G(Be, null, vt(t.features, f => (O(),
                K(o, {
                    key: f
                }, {
                    title: k( () => [V("span", {
                        innerHTML: f.text
                    }, null, 8, aI)]),
                    media: k( () => [S(c, {
                        f7: f.icon,
                        "text-color": f.color || "green"
                    }, null, 8, ["f7", "text-color"])]),
                    _: 2
                }, 1024))), 128))]),
                _: 1
            })) : pe("", !0), S(u, {
                class: "margin-top-half margin-bottom"
            }, {
                default: k( () => [ce(n.$slots, "default", {}, void 0, !0)]),
                _: 3
            })], 2)
        }
    }
}
  , pa = it(rI, [["__scopeId", "data-v-f0e60646"]])
  , oI = {
    __name: "ui",
    setup(e) {
        const t = ht();
        let n;
        const a = () => {
            tl(t.device.udid),
            n.open()
        }
        ;
        return Xe( () => {
            ut( () => {
                n = D.toast.create({
                    text: "UDID copied",
                    position: "top",
                    horizontalPosition: "center",
                    closeTimeout: 1500,
                    closeButton: !0
                })
            }
            )
        }
        ),
        (r, o) => {
            const i = P("f7-button");
            return O(),
            K(i, {
                large: "",
                round: "",
                onClick: a
            }, {
                default: k( () => [J(" Copy UDID ")]),
                _: 1
            })
        }
    }
}
  , iI = {
    __name: "ui",
    setup(e) {
        return (t, n) => (O(),
        K(B(nO), null, {
            default: k( () => [S(B(oI))]),
            _: 1
        }))
    }
}
  , Bl = "/stream";
var so;
class sI {
    constructor() {
        mn(this, so, Ur)
    }
    createStreamWithApiKeys(t) {
        return pt(this, so).post(`${Bl}/with-api-keys`, t)
    }
    createStreamWithCertificate(t) {
        return pt(this, so).post(`${Bl}/with-certificate`, t)
    }
    checkUserStream(t, n) {
        return pt(this, so).get(`${Bl}/check-user-stream/${t}?device_id=${n}`)
    }
    deleteUserStream(t, n, a) {
        return pt(this, so).delete(`${Bl}/${t}?owner_device_id=${n}`, a)
    }
}
so = new WeakMap;
const Rl = new sI
  , sl = oa("stream", {
    state: () => ({}),
    getters: {},
    actions: {
        resetAppSettingsForm() {},
        async createStreamWithCertificate(e={}, t= () => {}
        ) {
            var n;
            try {
                D.dialog.preloader();
                const a = new FormData;
                for (const r in e)
                    e.hasOwnProperty(r) && a.append(r, e[r]);
                await Rl.createStreamWithCertificate(a),
                t(),
                D.view.current.router.back()
            } catch (a) {
                D.dialog.alert((n = a.response.data) == null ? void 0 : n.message, "Error")
            } finally {
                D.dialog.close()
            }
        },
        async createStreamWithApiKeys(e={}, t= () => {}
        ) {
            var n;
            try {
                D.dialog.preloader();
                const a = new FormData;
                for (const r in e)
                    e.hasOwnProperty(r) && a.append(r, e[r]);
                await Rl.createStreamWithApiKeys(a),
                t(),
                D.view.current.router.back()
            } catch (a) {
                D.dialog.alert((n = a.response.data) == null ? void 0 : n.message, "Error")
            } finally {
                D.dialog.close()
            }
        },
        async unlinkAndDeleteStream(e, t, n= () => {}
        ) {
            try {
                D.dialog.preloader(),
                await Rl.deleteUserStream(e, t),
                n()
            } catch (a) {
                D.dialog.alert("Server error.", "Error"),
                console.log(a)
            } finally {
                D.dialog.close()
            }
        },
        async checkUserCertificate(e, t, n= () => {}
        ) {
            try {
                await Rl.checkUserStream(e, t)
            } catch (a) {
                console.log(a),
                D.dialog.alert("Unfortunately, your certificate has been revoked.<br> Please unlink it in the Device section.", "Attention!", () => {
                    n()
                }
                )
            }
        }
    }
});
const xi = e => (qt("data-v-9487f8f7"),
e = e(),
Wt(),
e)
  , lI = xi( () => V("b", null, "Provide access API keys", -1))
  , cI = xi( () => V("br", null, null, -1))
  , uI = {
    style: {
        "font-size": "15px"
    }
}
  , fI = xi( () => V("p", null, [J(" API Keys are required by us so that we can interact with your Developer Account programmatically. "), V("br"), J(" Our programs use the API to link your device's UDID to your account and create a certificate that will be used to sign apps. ")], -1))
  , dI = xi( () => V("br", null, null, -1))
  , pI = xi( () => V("br", null, null, -1))
  , hI = xi( () => V("br", null, null, -1))
  , mI = {
    __name: "ProvideDeveloperApiKeysCard",
    setup(e) {
        return (t, n) => {
            const a = P("f7-link")
              , r = P("f7-card-header")
              , o = P("f7-block")
              , i = P("f7-accordion-content")
              , s = P("f7-list-item")
              , l = P("f7-list")
              , c = P("f7-card");
            return O(),
            K(c, null, {
                default: k( () => [S(r, null, {
                    default: k( () => [V("div", null, [lI, cI, V("div", uI, [S(a, {
                        color: "blue",
                        onClick: n[0] || (n[0] = u => B(D).view.current.router.navigate("/article/", {
                            props: {
                                articleId: 11
                            }
                        }))
                    }, {
                        default: k( () => [J(" Where can I get API keys? ")]),
                        _: 1
                    })])])]),
                    _: 1
                }), ce(t.$slots, "form", {}, void 0, !0), S(o, {
                    class: "padding-bottom"
                }, {
                    default: k( () => [ce(t.$slots, "formActions", {}, void 0, !0)]),
                    _: 3
                }), S(l, {
                    "accordion-list": "",
                    inset: ""
                }, {
                    default: k( () => [S(s, {
                        "accordion-item": "",
                        title: "Why do we need API keys?"
                    }, {
                        default: k( () => [S(i, null, {
                            default: k( () => [S(o, null, {
                                default: k( () => [fI]),
                                _: 1
                            })]),
                            _: 1
                        })]),
                        _: 1
                    }), S(s, {
                        "accordion-item": "",
                        title: "It is safe?"
                    }, {
                        default: k( () => [S(i, null, {
                            default: k( () => [S(o, null, {
                                default: k( () => [V("p", null, [J(" Yes.These API keys can't interact with Apple ID or iCloud personal data. This API only works in the Developer Functions space (AppStore Connect). "), dI, pI, J(" We will store the API keys on our server as we will need access to your account's developer tools at various stages. However, you can unlink your account from FlekSt0re at any time and then we will delete the API key data from the server. "), hI, J(" Read more in the "), S(a, {
                                    color: "blue",
                                    href: "/docs/4/"
                                }, {
                                    default: k( () => [J(" privacy policy ")]),
                                    _: 1
                                }), J(". ")])]),
                                _: 1
                            })]),
                            _: 1
                        })]),
                        _: 1
                    })]),
                    _: 1
                })]),
                _: 3
            })
        }
    }
}
  , gI = it(mI, [["__scopeId", "data-v-9487f8f7"]]);
const vI = {}
  , yc = e => (qt("data-v-380694ef"),
e = e(),
Wt(),
e)
  , bI = yc( () => V("p", null, " We need these files in order to use them to sign applications. ", -1))
  , yI = yc( () => V("br", null, null, -1))
  , CI = yc( () => V("br", null, null, -1))
  , wI = yc( () => V("br", null, null, -1));
function _I(e, t) {
    const n = P("f7-block")
      , a = P("f7-accordion-content")
      , r = P("f7-list-item")
      , o = P("f7-link")
      , i = P("f7-list")
      , s = P("f7-card");
    return O(),
    K(s, null, {
        default: k( () => [ce(e.$slots, "form", {}, void 0, !0), S(n, {
            class: "padding-bottom"
        }, {
            default: k( () => [ce(e.$slots, "formActions", {}, void 0, !0)]),
            _: 3
        }), S(i, {
            "accordion-list": "",
            inset: ""
        }, {
            default: k( () => [S(r, {
                "accordion-item": "",
                title: "Why do we need this files?"
            }, {
                default: k( () => [S(a, null, {
                    default: k( () => [S(n, null, {
                        default: k( () => [bI]),
                        _: 1
                    })]),
                    _: 1
                })]),
                _: 1
            }), S(r, {
                "accordion-item": "",
                title: "It is safe?"
            }, {
                default: k( () => [S(a, null, {
                    default: k( () => [S(n, null, {
                        default: k( () => [V("p", null, [J(" Yes. These files do not provide access to your sensitive data and can only be used to sign applications. "), yI, CI, J(" We will store these files on our server as they are required each time you make an app signing request. However, you can unlink the certificate from FlekSt0re at any time and we will remove the certificate files from our server. "), wI, J(" Read more in the "), S(o, {
                            color: "blue",
                            href: "/docs/4/"
                        }, {
                            default: k( () => [J(" privacy policy ")]),
                            _: 1
                        }), J(". ")])]),
                        _: 1
                    })]),
                    _: 1
                })]),
                _: 1
            })]),
            _: 1
        })]),
        _: 3
    })
}
const kI = it(vI, [["render", _I], ["__scopeId", "data-v-380694ef"]])
  , lh = {
    __name: "ui",
    setup(e) {
        const t = sl()
          , n = ht()
          , a = () => {
            D.dialog.confirm("This action will remove this certificate from the FlekSt0re.", "Are you sure?", () => {
                t.unlinkAndDeleteStream(n.device.stream.id, localStorage.device_id, n.getDevice)
            }
            )
        }
        ;
        return (r, o) => {
            const i = P("f7-button");
            return O(),
            K(i, {
                class: "button-lite",
                "icon-color": "red",
                "icon-f7": "escape",
                large: "",
                round: "",
                onClick: o[0] || (o[0] = s => a())
            }, {
                default: k( () => [J(" Unlink ")]),
                _: 1
            })
        }
    }
}
  , SI = {
    __name: "ui",
    setup(e) {
        return (t, n) => (O(),
        K(B(UL), null, {
            userStreamButton: k( () => [S(B(lh))]),
            _: 1
        }))
    }
}
  , $I = {
    __name: "ui",
    setup(e) {
        var i, s, l;
        const t = ht()
          , a = `https://sign.flekstore.com/getCert${`?sID=${(s = (i = t.device) == null ? void 0 : i.stream) == null ? void 0 : s.id}&dID=${(l = t.device) == null ? void 0 : l.id}`}`;
        let r;
        const o = () => {
            D.dialog.create({
                text: "Download certificate",
                verticalButtons: !0,
                buttons: [{
                    text: "Copy link",
                    bold: !0,
                    onClick: () => {
                        tl(a),
                        r.open()
                    }
                }, {
                    text: "Open in browser",
                    bold: !0,
                    onClick: () => {
                        window.open(a, "_blank")
                    }
                }, {
                    text: "Usage guide",
                    onClick: () => {
                        D.view.current.router.navigate("/article/", {
                            props: {
                                articleId: 1
                            }
                        })
                    }
                }, {
                    text: "Close"
                }]
            }).open()
        }
        ;
        return Xe( () => {
            ut( () => {
                r = D.toast.create({
                    text: "Download link copied",
                    position: "top",
                    horizontalPosition: "center",
                    closeTimeout: 1500,
                    closeButton: !0
                })
            }
            )
        }
        ),
        Ca( () => {
            r.destroy()
        }
        ),
        (c, u) => {
            const f = P("f7-button");
            return O(),
            K(f, {
                class: "button-lite",
                "icon-f7": "cloud_download",
                large: "",
                round: "",
                onClick: o
            }, {
                default: k( () => [J(" Download ")]),
                _: 1
            })
        }
    }
};
const EI = {
    key: 0,
    class: "device-certificate-info__actions-block"
}
  , xI = {
    __name: "ui",
    setup(e) {
        const t = ht();
        return (n, a) => {
            const r = P("f7-col")
              , o = P("f7-row");
            return O(),
            K(B(XL), null, {
                actions: k( () => [B(t).device.isUserStream ? (O(),
                G("div", EI, [S(o, null, {
                    default: k( () => [S(r, null, {
                        default: k( () => [S(B($I))]),
                        _: 1
                    }), S(r, null, {
                        default: k( () => [S(B(lh))]),
                        _: 1
                    })]),
                    _: 1
                })])) : pe("", !0)]),
                _: 1
            })
        }
    }
}
  , ct = {
    premiumOnly: {
        logo: "Crown_icon26.jpg?3",
        name: "Premium Access",
        features: jt.premiumOnly,
        cardClass: "premium-only-offer",
        offerId: 1
    },
    certificateByFlekStore: {
        logo: "CertIcon26.jpg?1",
        name: "Developer Certificate",
        features: [...jt.forAll, ...jt.serviceStreamOnly, ...jt.serviceStreamOnlyForOffer],
        cardClass: "developer-offer",
        offerId: 2
    },
    certificateByFSPlusPremiumDiscount: {
        logo: "CertPlusPremium.jpg?1",
        name: "Certificate + Premium",
        features: [...jt.forAll, ...jt.serviceStreamOnly, ...jt.serviceStreamOnlyForOffer],
        cardClass: "premium-only-offer",
        description: "The device will be registered in the developer's account <b>outside the free queue</b>. You will also receive 2 months of premium as a gift. All this with a <b>12.5% discount.</b><br></br><b> Important</b><br>You will skip waiting to be registered to Developer Account, but this will not give you certificate instantly, you will still have to wait 1533 days until activation in the Developer Account, because your device was in a revoked account recently (Apple rules).",
        offerId: 6
    },
    certificateByFlekStore1399: {
        logo: "CertIcon26.jpg?1",
        name: "Developer Certificate",
        features: [...jt.forAll, ...jt.serviceStreamOnly, ...jt.serviceStreamOnlyForOffer],
        cardClass: "developer-offer",
        offerId: 6
    },
    certificateByFlekStore12: {
        logo: "CertIcon26.jpg?1",
        name: "Developer Certificate",
        features: [...jt.forAll, ...jt.serviceStreamOnly, ...jt.serviceStreamOnlyForOffer],
        cardClass: "developer-offer",
        offerId: 4
    },
    priorityRecovery: {
        logo: "PriorityRecoveryIcon.jpg",
        name: "Priority recovery + 1 month Premium access",
        description: "The device is added to the developer account and gets access to apps in a priority order, unlike standard recovery.",
        features: !1,
        cardClass: "priority-recovery-offer",
        offerId: 3
    },
    freeRecovery: {
        logo: "RecoverIcon.jpg",
        name: "Standard recovery + 1 month Premium access",
        description: "The device will be registered in the Apple Developer Account during <b>3-14 days</b> absolutely for free.<br><br>After that, you will still have to wait <b>1533 days until activation</b> in the Developer Account, because your device was in a revoked account recently (Apple rules). The total waiting time will be 18 - 47 days.",
        features: !1,
        cardClass: "free-recovery-offer",
        offerId: 3
    },
    linkDeveloperAccount: {
        logo: "developerIcon.webp",
        name: "Link Developer Account",
        description: "If you want to avoid revokes - this is the most reliable method! Your device will be added to your personal Apple Developer Account.",
        features: [...jt.userStreamOnly, ...jt.forAll],
        cardClass: "developer-offer"
    },
    ownCertificate: {
        logo: "CertIcon26.jpg?1",
        name: "Own Certificate",
        description: "If you have developer or enterprise certificate files, you can link it to the FlekSt0re.",
        features: jt.forAll,
        cardClass: "developer-offer"
    }
};
const TI = {
    class: "offer-toolbar-pricing width-auto margin-right margin-left-half"
}
  , MI = V("div", {
    class: "header"
}, " Total ", -1)
  , zI = {
    class: "final-price"
}
  , AI = V("div", {
    class: "footer"
}, null, -1)
  , OI = {
    style: {
        margin: "0 0 25px"
    }
}
  , PI = {
    style: {
        margin: "0 0 25px"
    }
}
  , pp = {
    __name: "ui",
    props: {
        offerAlias: {
            type: String,
            default: null
        }
    },
    setup(e) {
        const t = e
          , n = oe()
          , a = oe(0)
          , r = ht()
          , i = (t.offerAlias === "certificateByFlekStore1399" ? [6, 7] : [2, 5]).map( (c, u) => ({
            tabIndex: u,
            ...r.offers.find(f => f.id === c)
        }))
          , s = c => {
            n.value = D.swiper.get(c.$el[0])
        }
          , l = c => {
            n.value.slideTo(c),
            a.value = c
        }
        ;
        return (c, u) => {
            const f = P("f7-icon")
              , d = P("f7-button")
              , p = P("f7-toolbar")
              , h = P("f7-segmented")
              , m = P("f7-swiper-slide")
              , g = P("f7-swiper");
            return O(),
            G(Be, null, [S(p, {
                position: "bottom",
                style: {
                    height: "calc(62px + var(--f7-safe-area-bottom))",
                    position: "fixed"
                }
            }, {
                default: k( () => [V("div", TI, [MI, V("div", zI, " $" + Me(B(i)[a.value].trial_price / 100), 1), AI]), S(d, {
                    class: "width-auto",
                    fill: "",
                    href: `/purchase/${B(i)[a.value].id}/`,
                    large: "",
                    "popup-close": "",
                    round: "",
                    style: {
                        padding: "0 26px 0 32px"
                    }
                }, {
                    default: k( () => [J(" Buy Now "), S(f, {
                        class: "margin-left-half",
                        f7: "cart_fill",
                        size: "22"
                    })]),
                    _: 1
                }, 8, ["href"])]),
                _: 1
            }), S(h, {
                class: "margin-horizontal margin-top",
                round: "",
                strong: "",
                tag: "div"
            }, {
                default: k( () => [S(d, {
                    active: a.value === 0,
                    round: "",
                    "tab-link": "#tab-tariff-standard",
                    onClick: u[0] || (u[0] = b => l(0))
                }, {
                    default: k( () => [J(" Standard ")]),
                    _: 1
                }, 8, ["active"]), S(d, {
                    active: a.value === 1,
                    "icon-f7": "star_fill",
                    round: "",
                    "tab-link": "#tab-tariff-special",
                    onClick: u[1] || (u[1] = b => l(1))
                }, {
                    default: k( () => [J(" Special ")]),
                    _: 1
                }, 8, ["active"])]),
                _: 1
            }), S(g, {
                style: {
                    "padding-bottom": "80px"
                },
                onActiveIndexChange: u[2] || (u[2] = b => a.value = b.activeIndex),
                onInit: s
            }, {
                default: k( () => [S(m, {
                    id: "tab-1"
                }, {
                    default: k( () => [S(pa, {
                        "after-price": "365-300 days",
                        "card-class": B(ct).certificateByFlekStore.cardClass,
                        features: B(ct).certificateByFlekStore.features,
                        footer: "one-time payment",
                        logo: B(i)[0].logo,
                        price: `$${B(i)[0].trial_price / 100}`,
                        strikethrough: B(i)[0].trial_price === 1599 ? !1 : "$15.99",
                        title: B(ct).certificateByFlekStore.name
                    }, null, 8, ["card-class", "features", "logo", "price", "strikethrough", "title"]), V("div", OI, [S(B(M1), {
                        colored: "",
                        title: "PLUS"
                    })]), S(pa, {
                        "after-price": `${B(i)[0].trial_months} month`,
                        "card-class": B(ct).premiumOnly.cardClass,
                        features: B(ct).premiumOnly.features,
                        footer: `subscription $${B(i)[0].subscription_price / 100} per month`,
                        logo: B(ct).premiumOnly.logo,
                        price: "FREE",
                        title: B(ct).premiumOnly.name
                    }, null, 8, ["after-price", "card-class", "features", "footer", "logo", "title"])]),
                    _: 1
                }), S(m, {
                    id: "tab-2"
                }, {
                    default: k( () => [S(pa, {
                        "after-price": "365-300 days",
                        "card-class": B(ct).certificateByFlekStore.cardClass,
                        features: B(ct).certificateByFlekStore.features,
                        footer: "one-time payment",
                        logo: B(i)[1].logo,
                        price: `$${B(i)[0].trial_price / 100}`,
                        strikethrough: B(i)[0].trial_price === 1599 ? !1 : "$15.99",
                        title: B(ct).certificateByFlekStore.name
                    }, null, 8, ["card-class", "features", "logo", "price", "strikethrough", "title"]), V("div", PI, [S(B(M1), {
                        colored: "",
                        title: "PLUS"
                    })]), S(pa, {
                        "after-price": `${B(i)[1].trial_months} month`,
                        "card-class": B(ct).premiumOnly.cardClass,
                        features: B(ct).premiumOnly.features,
                        footer: "one-time payment",
                        logo: B(ct).premiumOnly.logo,
                        price: `$${((B(i)[a.value].trial_price - B(i)[0].trial_price) / 100).toFixed(2)}`,
                        title: B(ct).premiumOnly.name
                    }, null, 8, ["after-price", "card-class", "features", "logo", "price", "title"])]),
                    _: 1
                })]),
                _: 1
            })], 64)
        }
    }
};
const LI = V("div", {
    class: "colored-bg"
}, null, -1)
  , II = {
    __name: "ui",
    setup(e) {
        const t = _a()
          , n = o => {
            D.view.current.router.navigate("/partner/referral-task-description-popup/", {
                props: {
                    taskId: o
                }
            })
        }
          , a = (o, i) => {
            D.view.current.router.navigate("/partner/youtube-task-description-popup/", {
                props: {
                    taskId: o,
                    youTubeLink: i
                }
            })
        }
          , r = o => {
            switch (console.log(o),
            o) {
            case 16:
                window.open(`https://t.me/FlekstoreSubBot?start=${localStorage.getItem("device_id")}/`, "_self");
                break;
            case 15:
                n(o);
                break;
            case 14:
                n(o);
                break;
            case 20:
                a(o, "https://www.youtube.com/@Esmandaucom");
                break
            }
        }
        ;
        return Xe(async () => {
            await t.getTasks()
        }
        ),
        (o, i) => {
            const s = P("f7-block-title")
              , l = P("f7-list");
            return O(),
            G(Be, null, [S(s, {
                medium: ""
            }, {
                default: k( () => [J(" Tasks ")]),
                _: 1
            }), B(t).tasks.length ? (O(),
            K(l, {
                key: 0,
                class: "partner-main___task-list",
                inset: "",
                "media-list": "",
                "no-chevron": ""
            }, {
                default: k( () => [LI, (O(!0),
                G(Be, null, vt(B(t).tasks, (c, u) => (O(),
                K(B(UO), {
                    key: u,
                    "bonus-amount": c.bonus_amount,
                    "bonus-reason": c.bonus_reason || "",
                    completed: c.completed || !1,
                    icon: `./icons/${c.icon}?3`,
                    "is-unlimit": c.is_unlimit,
                    subtitle: c.subtitle || "",
                    title: c.title,
                    onClick: f => r(c.id)
                }, null, 8, ["bonus-amount", "bonus-reason", "completed", "icon", "is-unlimit", "subtitle", "title", "onClick"]))), 128))]),
                _: 1
            })) : (O(),
            K(B(YO), {
                key: 1,
                number: 4
            }))], 64)
        }
    }
}
  , ch = "" + new URL("../icons/FlekCoinIcon26.png",import.meta.url).href;
const hp = `Really freedom sideload store for iOS!

Amazing app library and available worldwide without regional restrictions.
No cables, no computer, no jailbreak.

Follow the link below to use FlekSt0re:
`
  , uh = {
    __name: "ui",
    props: {
        code: {
            type: String,
            required: !0
        }
    },
    setup(e, {expose: t}) {
        const n = e
          , a = "https://flekstore.com"
          , r = oe(null);
        let o;
        const i = encodeURIComponent(`${a}/${n.code}`)
          , s = encodeURIComponent(hp)
          , l = async f => {
            const d = {
                url: `${a}/${n.code}`,
                title: "FlekSt0re - Install any iOS app no cables, no PC, no Jailbreak",
                text: hp
            };
            try {
                await navigator.share(d)
            } catch (p) {
                p.name !== "AbortError" && D.popover.get(r.value.$el).open(f.target, !0)
            }
        }
          , c = f => {
            b8(f),
            window.dispatchEvent(new Event("resize"))
        }
          , u = (f="") => {
            tl(f),
            o.open()
        }
        ;
        return Xe( () => {
            ut( () => {
                o = D.toast.create({
                    text: "Link copied",
                    position: "top",
                    horizontalPosition: "center",
                    closeTimeout: 1500,
                    closeButton: !0
                })
            }
            )
        }
        ),
        t({
            handleCopyClick: u
        }),
        (f, d) => {
            const p = P("f7-icon")
              , h = P("f7-link")
              , m = P("f7-list-item")
              , g = P("f7-list")
              , b = P("f7-popover");
            return O(),
            G(Be, null, [S(h, {
                class: "partner-referral-link-share-menu-button___referral-url-menu-button",
                onClick: l
            }, {
                default: k( () => [S(p, {
                    class: "no-margin-right",
                    f7: "square_arrow_up",
                    size: "22"
                })]),
                _: 1
            }), S(b, {
                ref_key: "popover",
                ref: r,
                class: "partner-referral-link-share-menu-button___popover-menu",
                "vertical-position": "bottom",
                "onPopover:open": c
            }, {
                default: k( () => [S(g, {
                    "no-hairlines": ""
                }, {
                    default: k( () => [S(m, {
                        class: "selected-source-item",
                        link: "",
                        "no-chevron": "",
                        "popover-close": "",
                        title: "Copy link",
                        onClick: d[0] || (d[0] = v => u(`${B(a)}/${e.code}`))
                    }, {
                        media: k( () => [S(p, {
                            f7: "square_on_square",
                            size: "22"
                        })]),
                        _: 1
                    }), S(m, {
                        class: "selected-source-item",
                        external: "",
                        link: `https://t.me/share/url?url=${B(i)}`,
                        "no-chevron": "",
                        "popover-close": "",
                        target: "_blank",
                        title: "Telegram"
                    }, {
                        media: k( () => [S(p, {
                            f7: "paperplane_fill",
                            size: "22"
                        })]),
                        _: 1
                    }, 8, ["link"]), S(m, {
                        class: "selected-source-item",
                        external: "",
                        link: `https://twitter.com/intent/tweet?text=${B(s) + B(i)}`,
                        "no-chevron": "",
                        "popover-close": "",
                        target: "_blank",
                        title: "X.com"
                    }, {
                        media: k( () => [S(m8, {
                            size: "22"
                        })]),
                        _: 1
                    }, 8, ["link"])]),
                    _: 1
                })]),
                _: 1
            }, 512)], 64)
        }
    }
};
const BI = {
    class: "partner-main__earned-coins"
}
  , RI = V("span", null, "coins", -1)
  , DI = V("img", {
    class: "partner-main__coin-image",
    src: ch
}, null, -1)
  , NI = V("div", null, " Referral Link ", -1)
  , HI = {
    __name: "ui",
    setup(e) {
        const t = _a()
          , n = "https://flekstore.com"
          , a = oe(null);
        return (r, o) => {
            const i = P("f7-row")
              , s = P("f7-button")
              , l = P("f7-col")
              , c = P("f7-icon")
              , u = P("f7-card-content")
              , f = P("f7-link")
              , d = P("f7-card-footer")
              , p = P("f7-card");
            return O(),
            K(p, null, {
                default: k( () => [S(u, null, {
                    default: k( () => [V("div", null, [J(" Balance "), S(i, {
                        class: "align-items-center"
                    }, {
                        default: k( () => [V("div", null, [V("h1", BI, [J(Me(B(t).balance) + " ", 1), RI])]), DI]),
                        _: 1
                    })]), S(i, {
                        class: "padding-top padding-bottom-half"
                    }, {
                        default: k( () => [S(l, null, {
                            default: k( () => [S(s, {
                                class: "button-lite",
                                href: "/partner/history-popup/",
                                "icon-f7": "book",
                                "icon-size": "22",
                                large: "",
                                round: ""
                            }, {
                                default: k( () => [J(" History ")]),
                                _: 1
                            })]),
                            _: 1
                        }), S(l, null, {
                            default: k( () => [S(s, {
                                fill: "",
                                href: "/partner/to-spend-popup/",
                                large: "",
                                round: ""
                            }, {
                                default: k( () => [J(" To spend "), S(c, {
                                    class: "no-margin-right",
                                    f7: "arrow_right_circle_fill",
                                    size: "22",
                                    style: {
                                        "margin-left": "5px"
                                    }
                                })]),
                                _: 1
                            })]),
                            _: 1
                        })]),
                        _: 1
                    })]),
                    _: 1
                }), S(d, null, {
                    default: k( () => [V("div", null, [NI, S(i, {
                        class: "padding-bottom-half align-items-center"
                    }, {
                        default: k( () => [S(f, {
                            class: "partner-main__referral-url",
                            onClick: o[0] || (o[0] = h => {
                                var m;
                                return (m = a.value) == null ? void 0 : m.handleCopyClick(` ${B(n)}/${B(t).referralCode}`)
                            }
                            )
                        }, {
                            default: k( () => [J(Me(B(n)) + "/" + Me(B(t).referralCode), 1)]),
                            _: 1
                        }), S(B(uh), {
                            ref_key: "shareLinkRef",
                            ref: a,
                            code: B(t).referralCode
                        }, null, 8, ["code"])]),
                        _: 1
                    })])]),
                    _: 1
                })]),
                _: 1
            })
        }
    }
}
  , mp = "/news";
var Ls;
class VI {
    constructor() {
        mn(this, Ls, td)
    }
    getArticles(t) {
        return pt(this, Ls).get(`${mp}/getArticlesPreview`, t)
    }
    getArticle(t) {
        return pt(this, Ls).get(`${mp}/getArticle`, t)
    }
}
Ls = new WeakMap;
const gp = new VI
  , od = oa("article", {
    state: () => ({
        articles: null,
        article: null,
        isLoading: !1,
        loadingError: !1
    }),
    getters: {},
    actions: {
        resetLoadingState() {
            this.isLoading = !0,
            this.loadingError = !1,
            this.article = null
        },
        async getArticles(e= () => {}
        ) {
            this.resetLoadingState();
            try {
                const t = await gp.getArticles();
                t.data && (this.articles = t.data)
            } catch {
                this.loadingError = !0
            } finally {
                e(),
                this.isLoading = !1
            }
        },
        async getArticle(e) {
            this.resetLoadingState();
            try {
                const t = await gp.getArticle(e);
                t.data && (this.article = t.data,
                this.article.text = this.article.text.replace(/<a/g, '<a class="external text-color-blue" target="_blank" ').trim())
            } catch {
                this.loadingError = !0
            } finally {
                this.isLoading = !1
            }
        }
    }
})
  , FI = {}
  , jI = V("div", {
    class: "backout"
}, null, -1)
  , UI = V("div", {
    class: "title"
}, " ------- ------ ------ ", -1);
function qI(e, t) {
    const n = P("f7-skeleton-block")
      , a = P("f7-link")
      , r = P("f7-swiper-slide")
      , o = P("f7-swiper");
    return O(),
    K(o, {
        class: "article-swiper skeleton-text skeleton-effect-wave",
        "grab-cursor": "",
        mousewheel: "",
        "slides-offset-after": 15,
        "slides-offset-before": 15,
        "slides-per-view": "auto",
        "space-between": 15
    }, {
        default: k( () => [(O(!0),
        G(Be, null, vt(Array(10).fill(), (i, s) => (O(),
        K(r, {
            key: s
        }, {
            default: k( () => [S(a, null, {
                default: k( () => [S(n), jI, UI]),
                _: 1
            })]),
            _: 2
        }, 1024))), 128))]),
        _: 1
    })
}
const WI = it(FI, [["render", qI]])
  , YI = V("div", {
    class: "backout"
}, null, -1)
  , GI = {
    class: "title text-color-white"
}
  , XI = {
    __name: "ui",
    setup(e) {
        const t = od();
        return (n, a) => {
            const r = P("f7-link")
              , o = P("f7-swiper-slide")
              , i = P("f7-swiper")
              , s = Hs("lazy");
            return B(t).articles ? (O(),
            K(i, {
                key: 0,
                class: "article-swiper",
                "grab-cursor": "",
                mousewheel: "",
                "slides-offset-after": 15,
                "slides-offset-before": 15,
                "slides-per-view": "auto",
                "space-between": 15
            }, {
                default: k( () => [(O(!0),
                G(Be, null, vt(B(t).articles, l => (O(),
                K(o, {
                    key: l.id
                }, {
                    default: k( () => [S(r, {
                        href: "/article/",
                        "route-props": {
                            articleItem: l
                        }
                    }, {
                        default: k( () => [Fs(V("img", null, null, 512), [[s, l.image]]), YI, V("div", GI, Me(l.title), 1)]),
                        _: 2
                    }, 1032, ["route-props"])]),
                    _: 2
                }, 1024))), 128))]),
                _: 1
            })) : (O(),
            K(B(WI), {
                key: 1
            }))
        }
    }
}
  , f2 = "/app";
var ci;
class KI {
    constructor() {
        mn(this, ci, Ur)
    }
    getApps(t) {
        return pt(this, ci).get(`${f2}`, t)
    }
    getApp(t) {
        return pt(this, ci).get(`${f2}/${t}`)
    }
    getIpaUrl(t, n) {
        return pt(this, ci).get(`${f2}/${t}/ipa-url`, n)
    }
}
ci = new WeakMap;
const d2 = new KI
  , Ti = oa("apps", {
    state: () => ({
        apps: [],
        app: null,
        launchMode: "production",
        isLoading: !1,
        loadingError: !1,
        preparingIpaFile: !1,
        allowInfinite: !0,
        showPreloader: !0,
        pageItemsLimit: 50,
        filters: {
            page: 0,
            search: !1,
            filter: "updates"
        }
    }),
    getters: {},
    actions: {
        resetLoadingState() {
            this.allowInfinite = !1,
            this.showPreloader = !0,
            this.isLoading = !0,
            this.loadingError = !1,
            this.app = null
        },
        resetCatalog() {
            this.apps.length = 0,
            this.filters.page = 0,
            this.filters.search = !1,
            this.filters.filter = "updates"
        },
        async getApps(e={}, t= () => {}
        ) {
            this.resetLoadingState();
            try {
                const n = await d2.getApps(this.filters);
                n.data && (this.apps.push(...n.data),
                n.data.length === this.pageItemsLimit && (this.allowInfinite = !0))
            } catch {
                this.loadingError = !0
            } finally {
                t(),
                ++this.filters.page,
                this.isLoading = !1,
                this.showPreloader = !1
            }
        },
        async getApp(e) {
            try {
                const t = await d2.getApp(e);
                return t.data && (this.app = t.data,
                this.app.nameChangingDisabled = this.app.install_url.search(/_igd/g) !== -1,
                this.app.description = this.app.description.replace(/<a/g, '<a class="external text-color-blue" target="_blank" ').trim(),
                t.data.nameChangingDisabled = this.app.install_url.search(/_igd/g) !== -1,
                t.data.description = this.app.description.replace(/<a/g, '<a class="external text-color-blue" target="_blank" ').trim()),
                t.data
            } catch (t) {
                throw this.loadingError = !0,
                new Error(t.response.data.message)
            } finally {
                this.isLoading = !1
            }
        },
        async downloadIpa(e, t) {
            this.preparingIpaFile = !0;
            try {
                const n = await d2.getIpaUrl(e, {
                    device_id: t
                });
                if (n.data && this.preparingIpaFile)
                    return n.data
            } catch (n) {
                throw new Error(n.response.data.message)
            } finally {
                this.preparingIpaFile = !1
            }
        }
    }
})
  , ZI = {
    __name: "ListSkeleton",
    props: {
        hasMarginTop: Boolean
    },
    setup(e) {
        return (t, n) => {
            const a = P("f7-skeleton-block")
              , r = P("f7-list-item")
              , o = P("f7-row")
              , i = P("f7-list");
            return O(),
            K(i, {
                ref: "appsListEl",
                class: Ae(["rounded-items skeleton-text skeleton-effect-wave", {
                    "no-margin-top": !e.hasMarginTop,
                    "margin-top": e.hasMarginTop
                }]),
                inset: "",
                "media-list": ""
            }, {
                default: k( () => [S(o, null, {
                    default: k( () => [(O(!0),
                    G(Be, null, vt(Array(30).fill(), (s, l) => (O(),
                    K(r, {
                        key: l,
                        class: "col-100 medium-50",
                        footer: "------------- ----------- ----------- --------- ------- -------",
                        link: "",
                        subtitle: "--------",
                        title: "----- ----- --"
                    }, {
                        media: k( () => [S(a, {
                            class: "app-list-icon"
                        })]),
                        _: 2
                    }, 1024))), 128))]),
                    _: 1
                })]),
                _: 1
            }, 8, ["class"])
        }
    }
};
const Mi = {
    __name: "FsAppIcon",
    props: {
        src: {
            type: String,
            required: !0
        },
        size: {
            type: Number,
            default: 80
        },
        borderRadius: {
            type: Number,
            default: 23
        }
    },
    setup(e) {
        const t = n => {
            n.target.src = "./icons/tweakicon.png"
        }
        ;
        return (n, a) => {
            const r = Hs("lazy");
            return O(),
            G("div", {
                class: "fs-app-icon-wrapper",
                style: Rt({
                    borderRadius: e.borderRadius + "%",
                    width: e.size + "px",
                    height: e.size + "px"
                })
            }, [Fs(V("img", {
                alt: "App Icon",
                style: Rt({
                    borderRadius: e.borderRadius + "%",
                    width: e.size + "px",
                    height: e.size + "px"
                }),
                onError: t,
                "onLazy:error": t
            }, null, 36), [[r, e.src]]), V("div", {
                class: "shadow",
                style: Rt({
                    borderRadius: e.borderRadius + "%"
                })
            }, null, 4)], 4)
        }
    }
}
  , ra = {
    LC_APP_ID: 1404,
    LC_URL_SCHEME: "livecontainer://install?url="
};
const fh = {
    __name: "LiveContainerWarning",
    setup(e) {
        const t = ra.LC_APP_ID
          , n = () => {
            D.views.current.router.navigate("/app/", {
                props: {
                    appItem: {
                        id: t
                    }
                }
            })
        }
        ;
        return (a, r) => {
            const o = P("f7-button")
              , i = P("f7-list-item")
              , s = P("f7-list");
            return O(),
            K(s, {
                class: "live-container-warning margin-top no-margin-bottom",
                inset: "",
                "media-list": ""
            }, {
                default: k( () => [S(i, {
                    title: "Live Container is required to install apps"
                }, {
                    media: k( () => [S(Mi, {
                        size: 44,
                        src: "./icons/LC-icon.jpg"
                    })]),
                    after: k( () => [S(o, {
                        fill: "",
                        round: "",
                        onClick: r[0] || (r[0] = l => n())
                    }, {
                        default: k( () => [J(" GET ")]),
                        _: 1
                    })]),
                    _: 1
                })]),
                _: 1
            })
        }
    }
};
const JI = {
    __name: "AppViewHeader",
    props: {
        signerObject: {
            type: Object,
            required: !0
        },
        appName: {
            type: String,
            default: null
        },
        appDeveloper: {
            type: String,
            default: null
        },
        appIcon: {
            type: String,
            default: null
        }
    },
    setup(e) {
        return (t, n) => {
            const a = P("f7-button")
              , r = P("f7-col")
              , o = P("f7-row")
              , i = P("f7-list-item")
              , s = P("f7-accordion-content")
              , l = P("f7-list")
              , c = P("f7-accordion-item")
              , u = P("f7-block");
            return e.appName ? (O(),
            K(u, {
                key: 0,
                class: "no-padding no-margin-bottom"
            }, {
                default: k( () => [S(c, null, {
                    default: k( () => [S(l, {
                        "media-list": "",
                        "no-hairlines": ""
                    }, {
                        default: k( () => [S(i, {
                            text: `By ${e.appDeveloper || "Loading..."}`,
                            title: e.appName
                        }, {
                            media: k( () => [S(Mi, {
                                size: 120,
                                src: e.appIcon
                            }, null, 8, ["src"])]),
                            default: k( () => {
                                var f, d;
                                return [!((f = e.signerObject) != null && f.signingStage.key) || ((d = e.signerObject) == null ? void 0 : d.signingStage.key) === "ready_to_install" ? (O(),
                                K(o, {
                                    key: 0,
                                    class: "justify-content-flex-start align-content-flex-end"
                                }, {
                                    default: k( () => [S(r, null, {
                                        default: k( () => {
                                            var p;
                                            return [((p = e.signerObject) == null ? void 0 : p.signingStage.key) !== "ready_to_install" ? ce(t.$slots, "button", {
                                                key: 0
                                            }, void 0, !0) : (O(),
                                            K(a, {
                                                key: 1,
                                                class: "apps__app-view-header__install-button bounce-tap",
                                                fill: "",
                                                round: "",
                                                onClick: n[0] || (n[0] = h => {
                                                    var m;
                                                    return (m = e.signerObject) == null ? void 0 : m.installApp()
                                                }
                                                )
                                            }, {
                                                default: k( () => [J(" INSTALL ")]),
                                                _: 1
                                            }))]
                                        }
                                        ),
                                        _: 3
                                    }), S(r, {
                                        class: "margin-left"
                                    }, {
                                        default: k( () => [ce(t.$slots, "accordion-toggle", {}, void 0, !0)]),
                                        _: 3
                                    }), S(r, {
                                        style: {
                                            "margin-left": "auto",
                                            height: "28px"
                                        }
                                    }, {
                                        default: k( () => [ce(t.$slots, "download-button", {}, void 0, !0)]),
                                        _: 3
                                    })]),
                                    _: 3
                                })) : ce(t.$slots, "signing-info", {
                                    key: 1
                                }, void 0, !0)]
                            }
                            ),
                            _: 3
                        }, 8, ["text", "title"]), S(s, null, {
                            default: k( () => [ce(t.$slots, "accordion-content", {}, void 0, !0)]),
                            _: 3
                        })]),
                        _: 3
                    })]),
                    _: 3
                })]),
                _: 3
            })) : pe("", !0)
        }
    }
}
  , QI = it(JI, [["__scopeId", "data-v-cc034c0f"]]);
const eB = {}
  , dh = e => (qt("data-v-442887ac"),
e = e(),
Wt(),
e)
  , tB = dh( () => V("b", null, "read the instructions", -1))
  , nB = dh( () => V("b", {
    class: "text-color-orange"
}, "Warning:", -1));
function aB(e, t) {
    const n = P("f7-link")
      , a = P("f7-block-header")
      , r = P("f7-block-footer")
      , o = P("f7-block");
    return O(),
    K(o, {
        class: "signer-settings"
    }, {
        default: k( () => [S(a, {
            style: {
                "text-align": "center"
            }
        }, {
            default: k( () => [J(" This is an advanced settings. We recommend that you "), S(n, {
                href: "/docs/70/"
            }, {
                default: k( () => [tB]),
                _: 1
            }), J(" before use. ")]),
            _: 1
        }), ce(e.$slots, "settings-form", {}, void 0, !0), S(r, {
            class: "margin-top margin-bottom",
            style: {
                "text-align": "center"
            }
        }, {
            default: k( () => [nB, J(" Bundle ID changing can break certain apps or increase the chances of tweaked apps being detected. ")]),
            _: 1
        }), ce(e.$slots, "bottom-area", {}, void 0, !0)]),
        _: 3
    })
}
const rB = it(eB, [["render", aB], ["__scopeId", "data-v-442887ac"]])
  , oB = {
    class: "display-flex align-items-center justify-content-space-between"
}
  , iB = V("p", null, [J(" ---------------------------- -------------- --------"), V("br"), J(" ----------------------------"), V("br"), J(" -------------------- ---- --------------- --------"), V("br"), J(" ----------------------"), V("br"), J(" ---------------------------------------"), V("br"), J(" ---------------------------- -------------- --------"), V("br"), J(" ----------------------------"), V("br"), J(" -------------------- ---- --------------- --------"), V("br"), J(" ----------------------"), V("br"), J(" ---------------------------------------"), V("br")], -1)
  , sB = {
    __name: "AppViewDescription",
    props: {
        description: {
            type: String,
            default: ""
        }
    },
    setup(e) {
        return (t, n) => {
            const a = P("f7-block-title")
              , r = P("f7-block");
            return e.description.length ? (O(),
            G(Be, {
                key: 0
            }, [S(a, {
                medium: ""
            }, {
                default: k( () => [V("div", oB, [J(" Description "), ce(t.$slots, "titleRight")])]),
                _: 3
            }), S(r, {
                innerHTML: e.description
            }, null, 8, ["innerHTML"])], 64)) : (O(),
            G(Be, {
                key: 1
            }, [S(a, {
                medium: ""
            }, {
                default: k( () => [J(" Description ")]),
                _: 1
            }), S(r, {
                class: "skeleton-text skeleton-effect-wave"
            }, {
                default: k( () => [iB]),
                _: 1
            })], 64))
        }
    }
};
const lB = {
    __name: "AppViewInfoSwiper",
    props: {
        appVersion: {
            type: String,
            default: null
        },
        appUpdatedAt: {
            type: String,
            default: null
        },
        appSize: {
            type: Number,
            default: null
        },
        appDownloads: {
            type: Number,
            default: null
        }
    },
    setup(e) {
        return (t, n) => {
            const a = P("f7-block-title")
              , r = P("f7-block")
              , o = P("f7-swiper-slide")
              , i = P("f7-swiper");
            return e.appUpdatedAt ? (O(),
            K(i, {
                key: 0,
                "free-mode": "",
                "grab-cursor": "",
                "slides-offset-after": 15,
                "slides-offset-before": 15,
                "slides-per-view": "auto",
                "space-between": 10
            }, {
                default: k( () => [S(o, null, {
                    default: k( () => [S(r, {
                        class: "app-view-info-swiper__card",
                        inset: ""
                    }, {
                        default: k( () => [S(a, {
                            medium: ""
                        }, {
                            default: k( () => [J(Me(e.appVersion), 1)]),
                            _: 1
                        }), J(" Version ")]),
                        _: 1
                    })]),
                    _: 1
                }), S(o, null, {
                    default: k( () => [S(r, {
                        class: "app-view-info-swiper__card",
                        inset: ""
                    }, {
                        default: k( () => [S(a, {
                            medium: ""
                        }, {
                            default: k( () => [J(Me(B(mc)(e.appSize, !0)), 1)]),
                            _: 1
                        }), J(" Size ")]),
                        _: 1
                    })]),
                    _: 1
                }), S(o, null, {
                    default: k( () => [S(r, {
                        class: "app-view-info-swiper__card",
                        inset: ""
                    }, {
                        default: k( () => [S(a, {
                            medium: ""
                        }, {
                            default: k( () => [J(Me(B(Si).format(Date.parse(e.appUpdatedAt))), 1)]),
                            _: 1
                        }), J(" Updated ")]),
                        _: 1
                    })]),
                    _: 1
                }), S(o, null, {
                    default: k( () => [S(r, {
                        class: "app-view-info-swiper__card",
                        inset: ""
                    }, {
                        default: k( () => [S(a, {
                            medium: ""
                        }, {
                            default: k( () => [J(Me(e.appDownloads), 1)]),
                            _: 1
                        }), J(" Downloads ")]),
                        _: 1
                    })]),
                    _: 1
                })]),
                _: 1
            })) : (O(),
            K(i, {
                key: 1,
                "free-mode": "",
                "grab-cursor": "",
                "slides-offset-after": 15,
                "slides-offset-before": 15,
                "slides-per-view": "auto",
                "space-between": 10
            }, {
                default: k( () => [(O(!0),
                G(Be, null, vt(Array(4).fill(), (s, l) => (O(),
                K(o, {
                    key: l,
                    class: "skeleton-text skeleton-effect-wave"
                }, {
                    default: k( () => [S(r, {
                        class: "app-view-info-swiper__card",
                        inset: ""
                    }, {
                        default: k( () => [S(a, {
                            medium: ""
                        }, {
                            default: k( () => [J(" ----- ----- ")]),
                            _: 1
                        }), J(" ------- ")]),
                        _: 1
                    })]),
                    _: 2
                }, 1024))), 128))]),
                _: 1
            }))
        }
    }
}
  , cB = it(lB, [["__scopeId", "data-v-f4015073"]])
  , uB = {}
  , fB = {
    class: "padding-vertical"
};
function dB(e, t) {
    const n = P("f7-icon")
      , a = P("f7-block");
    return O(),
    K(a, {
        style: {
            "text-align": "center"
        }
    }, {
        default: k( () => [V("div", fB, [S(n, {
            f7: "lock_fill",
            size: "50"
        })]), J(" This section is not available due to the Privacy and Security settings. You can change this option in the application settings. ")]),
        _: 1
    })
}
const pB = it(uB, [["render", dB]]);
const hB = {
    style: {
        "text-align": "center"
    }
}
  , mB = {
    class: "app-nothing-found__icon-wrapper"
}
  , gB = V("p", {
    class: "padding-bottom"
}, " Check the spelling or try a new search. ", -1)
  , vB = {
    class: "margin-top"
}
  , bB = {
    __name: "AppNothingFound",
    props: {
        searchText: {
            type: String,
            required: !0
        }
    },
    setup(e) {
        return (t, n) => {
            const a = P("f7-icon");
            return O(),
            G("div", hB, [V("div", mB, [S(a, {
                f7: "app",
                size: "74",
                style: {
                    opacity: "0.4"
                }
            }), S(a, {
                f7: "xmark",
                size: "34"
            })]), V("h2", null, 'Nothing found for "' + Me(e.searchText) + '"', 1), gB, V("div", vB, [ce(t.$slots, "default")])])
        }
    }
}
  , yB = {
    __name: "ui",
    setup(e) {
        const t = oe(null)
          , n = nl()
          , a = Ti()
          , r = ae( () => a.apps.filter(s => !(s.isAdult === !0 && n.isAdultUser === !1)))
          , o = () => {
            a.resetCatalog(),
            a.getApps()
        }
          , i = s => {
            D.views.current.router.navigate("/app/", {
                props: {
                    appItem: s
                }
            })
        }
        ;
        return (s, l) => {
            const c = P("f7-list-item")
              , u = P("f7-row")
              , f = P("f7-list")
              , d = P("f7-icon")
              , p = P("f7-button");
            return O(),
            G(Be, null, [B(a).loadingError ? (O(),
            K(bc, {
                key: 0,
                "icon-name": "wifi_exclamationmark",
                text: "Loading error! Pull down to reload page."
            })) : pe("", !0), B(a).filters.page === 0 && B(a).apps.length === 0 ? (O(),
            K(B(ZI), {
                key: 1,
                "has-margin-top": Boolean(B(a).filters.search.length)
            }, null, 8, ["has-margin-top"])) : pe("", !0), S(f, {
                ref_key: "appsListEl",
                ref: t,
                class: Ae(["rounded-items", {
                    "no-margin-top": !B(a).filters.search.length,
                    "margin-top": B(a).filters.search.length
                }]),
                inset: "",
                "media-list": ""
            }, {
                default: k( () => [B(a).apps ? (O(),
                K(u, {
                    key: 0
                }, {
                    default: k( () => [(O(!0),
                    G(Be, null, vt(r.value, h => (O(),
                    K(c, {
                        key: h.id,
                        class: "col-100 medium-50",
                        footer: h == null ? void 0 : h.short_description,
                        link: "",
                        subtitle: `v${h.version}`,
                        title: h == null ? void 0 : h.name,
                        onClick: m => i(h)
                    }, {
                        media: k( () => [S(Mi, {
                            size: 75,
                            src: h == null ? void 0 : h.icon
                        }, null, 8, ["src"])]),
                        _: 2
                    }, 1032, ["footer", "subtitle", "title", "onClick"]))), 128))]),
                    _: 1
                })) : pe("", !0)]),
                _: 1
            }, 8, ["class"]), B(a).filters.filter === "3" && !B(n).isAdultUser ? (O(),
            K(B(pB), {
                key: 2
            })) : pe("", !0), !B(a).apps.length && B(a).filters.search && !B(a).showPreloader ? (O(),
            K(B(bB), {
                key: 3,
                "search-text": B(a).filters.search
            }, {
                default: k( () => [S(p, {
                    class: "button-glass button-fit button-center",
                    large: "",
                    round: "",
                    onClick: o
                }, {
                    default: k( () => [S(d, {
                        f7: "arrow_left_circle",
                        size: "24"
                    }), J(" Return to catalog ")]),
                    _: 1
                })]),
                _: 1
            }, 8, ["search-text"])) : pe("", !0)], 64)
        }
    }
}
  , CB = "/categories";
var D1;
class wB {
    constructor() {
        mn(this, D1, td)
    }
    getCategories(t) {
        return pt(this, D1).get(`${CB}/getCategories`, t)
    }
}
D1 = new WeakMap;
const _B = new wB
  , ph = oa("category", {
    state: () => ({
        items: [],
        isLoading: !1,
        loadingError: !1
    }),
    getters: {},
    actions: {
        resetLoadingState() {
            this.items.length = 0,
            this.isLoading = !0,
            this.loadingError = !1
        },
        async getCategories(e={}, t= () => {}
        ) {
            this.resetLoadingState();
            try {
                const n = await _B.getCategories(e);
                n.data && (this.items = n.data)
            } catch {
                this.loadingError = !0
            } finally {
                t(),
                this.isLoading = !1
            }
        }
    }
});
const kB = {};
function SB(e, t) {
    const n = P("f7-link")
      , a = P("f7-swiper-slide")
      , r = P("f7-swiper");
    return O(),
    K(r, {
        class: "margin-top skeleton-text skeleton-effect-wave",
        "free-mode": "",
        "grab-cursor": "",
        mousewheel: "",
        "slides-offset-after": 15,
        "slides-offset-before": 15,
        "slides-per-view": "auto",
        "space-between": 10
    }, {
        default: k( () => [(O(!0),
        G(Be, null, vt(Array(15).fill(), (o, i) => (O(),
        K(a, {
            key: i
        }, {
            default: k( () => [S(n, {
                class: "category-switcher"
            })]),
            _: 2
        }, 1024))), 128))]),
        _: 1
    })
}
const $B = it(kB, [["render", SB], ["__scopeId", "data-v-0716d19c"]]);
const EB = {
    __name: "ui",
    setup(e) {
        const t = ph()
          , n = Ti()
          , a = oe("updates");
        t.getCategories();
        const r = o => {
            n.resetCatalog(),
            typeof o == "string" ? (a.value = o,
            n.filters.filter = o) : (a.value = o.name,
            n.filters.filter = o.id),
            D.view.current.$el[0].lastElementChild.firstElementChild.scrollTop = 0,
            n.getApps()
        }
        ;
        return (o, i) => {
            const s = P("f7-link")
              , l = P("f7-swiper-slide")
              , c = P("f7-swiper");
            return B(t).items.length ? (O(),
            K(c, {
                key: 0,
                class: "category-switcher-swiper-ui__swiper",
                "free-mode": "",
                "grab-cursor": "",
                mousewheel: "",
                "slides-offset-after": 15,
                "slides-offset-before": 15,
                "slides-per-view": "auto",
                "space-between": 10
            }, {
                default: k( () => [S(l, null, {
                    default: k( () => [S(s, {
                        class: "bounce-tap",
                        "tab-link-active": a.value === "updates",
                        onClick: i[0] || (i[0] = u => r("updates"))
                    }, {
                        default: k( () => [J(" Updates ")]),
                        _: 1
                    }, 8, ["tab-link-active"])]),
                    _: 1
                }), S(l, null, {
                    default: k( () => [S(s, {
                        class: "bounce-tap",
                        "tab-link-active": a.value === "downloads",
                        onClick: i[1] || (i[1] = u => r("downloads"))
                    }, {
                        default: k( () => [J(" Top ")]),
                        _: 1
                    }, 8, ["tab-link-active"])]),
                    _: 1
                }), (O(!0),
                G(Be, null, vt(B(t).items, u => (O(),
                K(l, {
                    key: u.id
                }, {
                    default: k( () => [V("div", null, [S(s, {
                        class: "category-switcher bounce-tap",
                        "tab-link-active": a.value === u.name,
                        onClick: f => r(u)
                    }, {
                        default: k( () => [J(Me(u.name), 1)]),
                        _: 2
                    }, 1032, ["tab-link-active", "onClick"])])]),
                    _: 2
                }, 1024))), 128))]),
                _: 1
            })) : (O(),
            K(B($B), {
                key: 1
            }))
        }
    }
}
  , xB = it(EB, [["__scopeId", "data-v-426ad806"]])
  , Bu = "" + new URL("../icons/apple-touch-icon.png",import.meta.url).href
  , Cc = oa("source", {
    state: () => ({
        sourcesList: JSON.parse(localStorage.sources),
        app: null
    }),
    getters: {},
    actions: {
        resetLoadingState() {
            this.allowInfinite = !1,
            this.showPreloader = !0,
            this.isLoading = !0,
            this.loadingError = !1,
            this.app = null
        },
        async fetchRepoData(e, t= () => {}
        , n= () => {}
        ) {
	    fetch(e
            //Ht.post("https://nestapi.flekstore.com/repo/get-json", {
            //    link: e}
            ).then(a => {
                a.status === 200 || a.status === 201 ? t(a) : console.log("Failed to fetch data:", `${a.status} ${a.statusText}`)
            }
            ).catch(a => {
                console.log("Error fetching JSON:", `${a.message}`)
            }
            ).finally( () => {
                n()
            }
            )
        },
        async downloadIpa() {
            try {
                return this.app.downloadURL || this.app.versions[0].downloadURL
            } catch (e) {
                throw new Error(e.response.data.message)
            }
        }
    }
})
  , TB = {};
function MB(e, t) {
    const n = P("f7-skeleton-block")
      , a = P("f7-list-item")
      , r = P("f7-row")
      , o = P("f7-list");
    return O(),
    K(o, {
        ref: "appsListEl",
        class: "rounded-items margin-top-half skeleton-text skeleton-effect-wave",
        inset: "",
        "media-list": ""
    }, {
        default: k( () => [S(r, null, {
            default: k( () => [(O(!0),
            G(Be, null, vt(Array(30).fill(), (i, s) => (O(),
            K(a, {
                key: s,
                class: "col-100 medium-50 no-margin",
                footer: "------------- ----------- ----------- --------- ------- -------",
                link: "",
                subtitle: "--------",
                title: "----- ----- --"
            }, {
                media: k( () => [S(n, {
                    style: {
                        width: "75px",
                        height: "75px",
                        "border-radius": "23%"
                    }
                })]),
                _: 2
            }, 1024))), 128))]),
            _: 1
        })]),
        _: 1
    }, 512)
}
const zB = it(TB, [["render", MB]]);
const AB = {
    __name: "AppViewHeader",
    props: {
        signerObject: {
            type: Object,
            required: !0
        },
        appName: {
            type: String,
            default: null
        },
        appDeveloper: {
            type: String,
            default: null
        },
        appIcon: {
            type: String,
            default: null
        }
    },
    setup(e) {
        return (t, n) => {
            const a = P("f7-button")
              , r = P("f7-col")
              , o = P("f7-row")
              , i = P("f7-list-item")
              , s = P("f7-accordion-content")
              , l = P("f7-list")
              , c = P("f7-accordion-item")
              , u = P("f7-block");
            return e.appName ? (O(),
            K(u, {
                key: 0,
                class: "no-padding no-margin-bottom"
            }, {
                default: k( () => [S(c, null, {
                    default: k( () => [S(l, {
                        "media-list": "",
                        "no-hairlines": ""
                    }, {
                        default: k( () => [S(i, {
                            text: `By ${e.appDeveloper || "somebody"}`,
                            title: e.appName
                        }, {
                            media: k( () => [S(Mi, {
                                size: 120,
                                src: e.appIcon
                            }, null, 8, ["src"])]),
                            default: k( () => [!e.signerObject.signingStage.key || e.signerObject.signingStage.key === "ready_to_install" ? (O(),
                            K(o, {
                                key: 0,
                                class: "justify-content-flex-start align-content-flex-end"
                            }, {
                                default: k( () => [S(r, null, {
                                    default: k( () => [e.signerObject.signingStage.key !== "ready_to_install" ? ce(t.$slots, "button", {
                                        key: 0
                                    }, void 0, !0) : (O(),
                                    K(a, {
                                        key: 1,
                                        class: "app-view-header__install-button bounce-tap",
                                        fill: "",
                                        round: "",
                                        onClick: n[0] || (n[0] = f => e.signerObject.installApp())
                                    }, {
                                        default: k( () => [J(" INSTALL ")]),
                                        _: 1
                                    }))]),
                                    _: 3
                                }), S(r, {
                                    class: "margin-left"
                                }, {
                                    default: k( () => [ce(t.$slots, "accordion-toggle", {}, void 0, !0)]),
                                    _: 3
                                }), S(r, {
                                    style: {
                                        "margin-left": "auto",
                                        height: "28px"
                                    }
                                }, {
                                    default: k( () => [ce(t.$slots, "download-button", {}, void 0, !0)]),
                                    _: 3
                                })]),
                                _: 3
                            })) : ce(t.$slots, "signing-info", {
                                key: 1
                            }, void 0, !0)]),
                            _: 3
                        }, 8, ["text", "title"]), S(s, null, {
                            default: k( () => [ce(t.$slots, "accordion-content", {}, void 0, !0)]),
                            _: 3
                        })]),
                        _: 3
                    })]),
                    _: 3
                })]),
                _: 3
            })) : pe("", !0)
        }
    }
}
  , OB = it(AB, [["__scopeId", "data-v-74754ede"]])
  , PB = {
    class: "display-flex justify-content-space-between"
}
  , LB = {
    __name: "AppViewDescription",
    props: {
        text: {
            type: String,
            default: "",
            required: !0
        }
    },
    setup(e) {
        const t = e;
        return (n, a) => {
            const r = P("f7-block-title")
              , o = P("f7-block");
            return t.text !== "" ? (O(),
            G(Be, {
                key: 0
            }, [S(r, {
                medium: ""
            }, {
                default: k( () => [V("div", PB, [J(" Description "), ce(n.$slots, "titleRight")])]),
                _: 3
            }), S(o, {
                style: {
                    "white-space": "pre-line"
                }
            }, {
                default: k( () => [J(Me(t.text), 1)]),
                _: 1
            })], 64)) : pe("", !0)
        }
    }
};
const IB = {
    __name: "AppViewInfoSwiper",
    props: {
        version: {
            type: String,
            default: "1.0",
            required: !0
        },
        size: {
            type: Number,
            default: 0,
            required: !0
        },
        updatedDate: {
            type: String,
            default: "",
            required: !0
        }
    },
    setup(e) {
        const t = e;
        return (n, a) => {
            const r = P("f7-block-title")
              , o = P("f7-block")
              , i = P("f7-swiper-slide")
              , s = P("f7-swiper");
            return O(),
            K(s, {
                "free-mode": "",
                "grab-cursor": "",
                "slides-offset-after": 15,
                "slides-offset-before": 15,
                "slides-per-view": "auto",
                "space-between": 10
            }, {
                default: k( () => [S(i, null, {
                    default: k( () => [S(o, {
                        class: "app-view-info-swiper__card",
                        inset: ""
                    }, {
                        default: k( () => [S(r, {
                            medium: ""
                        }, {
                            default: k( () => [J(Me(t.version), 1)]),
                            _: 1
                        }), J(" Version ")]),
                        _: 1
                    })]),
                    _: 1
                }), S(i, null, {
                    default: k( () => [S(o, {
                        class: "app-view-info-swiper__card",
                        inset: ""
                    }, {
                        default: k( () => [S(r, {
                            medium: ""
                        }, {
                            default: k( () => [J(Me(B(mc)(t.size, !0)), 1)]),
                            _: 1
                        }), J(" Size ")]),
                        _: 1
                    })]),
                    _: 1
                }), S(i, null, {
                    default: k( () => [S(o, {
                        class: "app-view-info-swiper__card",
                        inset: ""
                    }, {
                        default: k( () => [S(r, {
                            medium: ""
                        }, {
                            default: k( () => [J(Me(B(mz)(t.updatedDate)), 1)]),
                            _: 1
                        }), J(" Updated ")]),
                        _: 1
                    })]),
                    _: 1
                })]),
                _: 1
            })
        }
    }
}
  , BB = it(IB, [["__scopeId", "data-v-3f4d21c9"]]);
const hh = {
    __name: "AltContextMenu",
    setup(e, {expose: t}) {
        const n = oe(!1)
          , a = oe(!1)
          , r = oe({})
          , o = oe(null)
          , i = f => {
            f.stopPropagation(),
            !(n.value || a.value) && (n.value = !0,
            Zn( () => {
                l(f)
            }
            ))
        }
          , s = () => {
            !n.value || a.value || (a.value = !0,
            setTimeout( () => {
                n.value = !1,
                a.value = !1
            }
            , 230))
        }
          , l = f => {
            const d = o.value;
            if (!d)
                return;
            const p = d.offsetWidth
              , h = d.offsetHeight
              , {top: m, left: g, transformOrigin: b} = c(f, p, h);
            r.value = {
                top: m,
                left: g,
                position: "absolute",
                "transform-origin": b
            }
        }
          , c = (f, d, p) => {
            const h = window.innerWidth
              , m = window.innerHeight
              , g = 10
              , b = 12
              , v = f.clientX
              , y = f.clientY;
            let w = v - d / 2
              , C = y + b
              , _ = d / 2
              , E = 0;
            return w < g ? (w = g,
            _ = v - w) : w + d > h - g && (w = h - d - g,
            _ = v - w),
            C + p > m - g && (C = y - p - b,
            E = p),
            C < g && (C = g,
            E = y - C),
            {
                top: `${C}px`,
                left: `${w}px`,
                transformOrigin: `${_}px ${E}px`
            }
        }
          , u = f => {
            const d = ["A", "BUTTON", "INPUT", "TEXTAREA", "SELECT"];
            let {target: p} = f;
            for (; p && p !== o.value; ) {
                if (d.includes(p.tagName)) {
                    s();
                    break
                }
                p = p.parentElement
            }
        }
        ;
        return t({
            open: i,
            close: s
        }),
        (f, d) => (O(),
        K(p5, {
            to: "body"
        }, [n.value ? (O(),
        G("div", {
            key: 0,
            class: "dropdown-backdrop",
            onClick: s
        }, [V("div", {
            ref_key: "dropdownContentRef",
            ref: o,
            class: Ae(["dropdown-content", {
                "modal-out": a.value
            }]),
            style: Rt(r.value),
            onClick: H5(u, ["stop"])
        }, [ce(f.$slots, "default")], 6)])) : pe("", !0)]))
    }
};
const RB = {
    class: "display-flex"
}
  , DB = {
    class: "search-apps-ui__sources-list__selected-icon-border"
}
  , NB = ["src"]
  , HB = {
    __name: "ui",
    setup(e) {
        const t = Ti()
          , n = Fa()
          , a = Cc()
          , r = oe("")
          , o = oe(null)
          , i = s => {
            r.value = s,
            t.apps.length = 0,
            t.filters.page = 0,
            t.filters.filter = "updates",
            t.filters.search = s,
            t.getApps()
        }
        ;
        return st(t.filters, () => {
            t.filters.search || (r.value = "")
        }
        ),
        (s, l) => {
            const c = P("f7-icon")
              , u = P("f7-list-input")
              , f = P("f7-list")
              , d = P("f7-link")
              , p = P("f7-list-item")
              , h = Hs("debounce");
            return O(),
            G(Be, null, [V("div", RB, [S(f, {
                class: "fs-search-input no-margin-top no-margin-bottom width-100 no-margin-right",
                inset: ""
            }, {
                default: k( () => [Fs((O(),
                K(u, {
                    "clear-button": "",
                    placeholder: "Search by app name",
                    type: "text",
                    value: r.value,
                    "onInput:clear": l[0] || (l[0] = m => i(""))
                }, {
                    media: k( () => [S(c, {
                        f7: "search"
                    })]),
                    _: 1
                }, 8, ["value"])), [[h, i, "300"]])]),
                _: 1
            }), S(d, {
                class: "margin-horizontal bounce-tap",
                "icon-only": "",
                onClick: l[2] || (l[2] = m => o.value.open(m))
            }, {
                default: k( () => [V("img", {
                    alt: "source icon",
                    class: "search-apps-ui__source-icon",
                    src: Bu,
                    title: "source icon",
                    onError: l[1] || (l[1] = (...m) => s.handleImgError && s.handleImgError(...m))
                }, null, 32)]),
                _: 1
            })]), S(hh, {
                ref_key: "dropdownRef",
                ref: o
            }, {
                default: k( () => [S(f, {
                    class: "search-apps-ui__sources-list no-margin",
                    "no-hairlines": "",
                    "no-hairlines-between": ""
                }, {
                    default: k( () => [S(p, {
                        class: "selected-source-item",
                        link: "",
                        "no-chevron": "",
                        "popover-close": "",
                        title: "FlekSt0re Lib"
                    }, {
                        media: k( () => [V("div", DB, [V("img", {
                            alt: "source icon",
                            class: "search-apps-ui__sources-list__source-icon selected",
                            src: Bu,
                            title: "source icon",
                            onError: l[3] || (l[3] = (...m) => s.handleImgError && s.handleImgError(...m))
                        }, null, 32)])]),
                        _: 1
                    }), (O(!0),
                    G(Be, null, vt(B(a).sourcesList, (m, g) => (O(),
                    K(p, {
                        key: g,
                        link: `/source/catalog/${g}/`,
                        "no-chevron": "",
                        title: m.name
                    }, {
                        media: k( () => [V("img", {
                            alt: "source icon",
                            class: "search-apps-ui__sources-list__source-icon",
                            src: m.iconURL,
                            title: "source icon",
                            onError: l[4] || (l[4] = (...b) => s.handleImgError && s.handleImgError(...b))
                        }, null, 40, NB)]),
                        _: 2
                    }, 1032, ["link", "title"]))), 128)), S(p, {
                        link: "",
                        "no-chevron": "",
                        title: "Manage",
                        onClick: l[5] || (l[5] = m => B(n).setActiveTab("view-sources"))
                    }, {
                        media: k( () => [S(c, {
                            ios: "f7:gear",
                            size: "24"
                        })]),
                        _: 1
                    })]),
                    _: 1
                })]),
                _: 1
            }, 512)], 64)
        }
    }
};
const ll = {
    __name: "ui",
    props: {
        signerObject: {
            type: Object,
            required: !0
        },
        fill: {
            type: Boolean,
            default: !1
        },
        round: {
            type: Boolean,
            default: !1
        },
        outline: {
            type: Boolean,
            default: !1
        },
        large: {
            type: Boolean,
            default: !1
        },
        disabled: {
            type: Boolean,
            default: !1
        },
        onlyForPremium: {
            type: Boolean,
            default: !1
        }
    },
    setup(e) {
        const t = e
          , n = ht()
          , a = Fa()
          , r = oe(!1)
          , o = oe(!1)
          , i = ae( () => {
            var l, c, u;
            return t.disabled || !((l = t.signerObject) != null && l.appGeneralSettings.name) || ((c = t.signerObject) == null ? void 0 : c.signingStage.key) && ((u = t.signerObject) == null ? void 0 : u.signingStage.key) !== "ready_to_install"
        }
        )
          , s = () => {
            var l;
            if (!n.device || !n.device.hasActivation) {
                a.setActiveTab("view-device"),
                D.popup.close();
                return
            }
            if (t.onlyForPremium && (!n.device || (l = n == null ? void 0 : n.getServiceByName("premium")) != null && l.isExpired)) {
                D.dialog.create({
                    title: "Function not available",
                    text: "Only Premium Access owners can use this feature.",
                    verticalButtons: !0,
                    buttons: [{
                        text: "Upgrade to Premium",
                        color: "blue",
                        bold: !0,
                        onClick: () => {
                            D.view.current.router.navigate("/device/service-offer-details/", {
                                props: {
                                    offerId: 1
                                }
                            })
                        }
                    }, {
                        text: "Close"
                    }]
                }).open();
                return
            }
            t.signerObject.sign()
        }
        ;
        return (l, c) => {
            const u = P("f7-button");
            return O(),
            K(u, {
                class: Ae(["sign-app-button-ui", {
                    "bounce-tap": !t.large
                }]),
                disabled: i.value,
                fill: t.fill,
                large: t.large,
                outline: t.outline,
                "popup-close": r.value,
                round: t.round,
                "tab-link": o.value,
                onClick: s
            }, {
                default: k( () => [ce(l.$slots, "default")]),
                _: 3
            }, 8, ["class", "disabled", "fill", "large", "outline", "popup-close", "round", "tab-link"])
        }
    }
}
  , p2 = () => {
    try {
        D.dialog.close()
    } catch {}
}
  , VB = e => {
    try {
        window.location.assign(e)
    } catch {
        window.location.href = e
    }
}
;
function mh({timeoutMs: e=2200, awayThresholdMs: t=1100, pauseJitterMs: n=300, preloaderText: a="Preparing...", showPreloader: r=!0, onFallback: o}) {
    const i = oe(!1);
    let s = null
      , l = !1;
    const c = oe(!1)
      , u = oe(0)
      , f = oe(0)
      , d = () => {
        l || (l = !0,
        w(),
        s && (clearTimeout(s),
        s = null),
        i.value = !1)
    }
      , p = () => {
        c.value || (c.value = !0,
        p2(),
        d())
    }
      , h = () => {
        if (document.visibilityState === "hidden") {
            p();
            return
        }
        document.visibilityState === "visible" && Date.now() - u.value >= t && p()
    }
      , m = () => {
        p()
    }
      , g = () => {
        Date.now() - u.value >= t && p()
    }
      , b = () => {
        f.value = Date.now()
    }
      , v = () => {
        const _ = Date.now()
          , E = _ - u.value
          , z = f.value ? _ - f.value : 0;
        (E >= t || z >= t) && p()
    }
      , y = () => {
        document.addEventListener("visibilitychange", h, {
            capture: !0,
            passive: !0
        }),
        window.addEventListener("pagehide", m, {
            capture: !0,
            passive: !0
        }),
        window.addEventListener("pageshow", g, {
            capture: !0,
            passive: !0
        }),
        window.addEventListener("blur", b, {
            capture: !0,
            passive: !0
        }),
        window.addEventListener("focus", v, {
            capture: !0,
            passive: !0
        })
    }
      , w = () => {
        document.removeEventListener("visibilitychange", h, !0),
        window.removeEventListener("pagehide", m, !0),
        window.removeEventListener("pageshow", g, !0),
        window.removeEventListener("blur", b, !0),
        window.removeEventListener("focus", v, !0)
    }
      , C = _ => {
        i.value || (i.value = !0,
        l = !1,
        c.value = !1,
        f.value = 0,
        u.value = Date.now(),
        r && D.dialog.preloader(a),
        y(),
        VB(_),
        s = setTimeout( () => {
            const z = Date.now() - u.value > e + n
              , T = document.visibilityState === "visible";
            if (c.value || z || !T) {
                p2(),
                d();
                return
            }
            o == null || o(),
            p2(),
            d()
        }
        , e))
    }
    ;
    return lt( () => d()),
    {
        busy: i,
        launch: C
    }
}
const gh = {
    __name: "ui",
    props: {
        fill: {
            type: Boolean,
            default: !1
        },
        round: {
            type: Boolean,
            default: !1
        },
        outline: {
            type: Boolean,
            default: !1
        },
        large: {
            type: Boolean,
            default: !1
        },
        disabled: {
            type: Boolean,
            default: !1
        },
        onlyForPremium: {
            type: Boolean,
            default: !1
        },
        ipaUrl: {
            type: String,
            required: !0
        },
        timeoutMs: {
            type: Number,
            default: 2200
        },
        awayThresholdMs: {
            type: Number,
            default: 1100
        },
        pauseJitterMs: {
            type: Number,
            default: 300
        },
        preloaderText: {
            type: String,
            default: "Preparing..."
        }
    },
    setup(e) {
        const t = e
          , n = ht()
          , a = Fa()
          , r = oe(!1)
          , o = oe(!1)
          , {busy: i, launch: s} = mh({
            timeoutMs: t.timeoutMs,
            awayThresholdMs: t.awayThresholdMs,
            pauseJitterMs: t.pauseJitterMs,
            onFallback: () => {
                D.views.current.router.navigate("/app/", {
                    props: {
                        appItem: {
                            id: ra.LC_APP_ID
                        }
                    }
                })
            }
        })
          , l = () => {
            if (!n.device || !n.device.hasActivation) {
                a.setActiveTab("view-device"),
                D.popup.close();
                return
            }
            const c = `${ra.LC_URL_SCHEME}${encodeURIComponent(t.ipaUrl)}`;
            s(c)
        }
        ;
        return (c, u) => {
            const f = P("f7-button");
            return O(),
            K(f, {
                class: Ae(["sign-app-button-ui", {
                    "bounce-tap": !t.large
                }]),
                disabled: B(i),
                fill: t.fill,
                large: t.large,
                outline: t.outline,
                "popup-close": r.value,
                round: t.round,
                "tab-link": o.value,
                onClick: l
            }, {
                default: k( () => [ce(c.$slots, "default")]),
                _: 3
            }, 8, ["class", "disabled", "fill", "large", "outline", "popup-close", "round", "tab-link"])
        }
    }
}
  , FB = {
    __name: "ui",
    props: {
        fromSource: {
            type: Boolean,
            default: !1
        }
    },
    setup(e) {
        const t = e
          , n = ht()
          , a = Fa()
          , r = t.fromSource ? Cc() : Ti()
          , o = ae( () => {
            var s;
            return Array.isArray((s = n.device) == null ? void 0 : s.service) ? n.device.service.some(l => l.name === "premium" && !l.isExpired) : !1
        }
        )
          , i = async () => {
            if (!n.device || !n.device.hasActivation && !n.device.hasPremium) {
                a.setActiveTab("view-device"),
                D.popup.close();
                return
            }
            if (!n.device.hasPremium) {
                D.dialog.create({
                    title: "Download .IPA file",
                    text: "App files can only be accessed by Premium Access members",
                    verticalButtons: !0,
                    buttons: [{
                        text: "Upgrade to Premium",
                        color: "blue",
                        bold: !0,
                        onClick: () => {
                            D.view.current.router.navigate("/device/service-offer-details/", {
                                props: {
                                    offerId: 1
                                }
                            })
                        }
                    }, {
                        text: "Close"
                    }]
                }).open();
                return
            }
            if (!o.value) {
                D.dialog.create({
                    title: "Oops!",
                    text: "Looks like your premium has expired. App files can only be accessed by Premium Access members.",
                    verticalButtons: !0,
                    buttons: [{
                        text: "Manage Premium",
                        color: "blue",
                        bold: !0,
                        onClick: () => {
                            a.setActiveTab("view-device"),
                            D.popup.close()
                        }
                    }, {
                        text: "Close"
                    }]
                }).open();
                return
            }
            try {
                const s = await r.downloadIpa(r.app.id, localStorage.device_id);
                D.dialog.create({
                    title: "Success",
                    text: "The file is ready for downloading.",
                    verticalButtons: !0,
                    buttons: [{
                        text: "Copy link",
                        bold: !0,
                        onClick: () => {
                            tl(s);
                            const l = D.toast.create({
                                text: "Link copied",
                                position: "top",
                                horizontalPosition: "center",
                                closeTimeout: 1500,
                                closeButton: !0,
                                on: {
                                    close: () => l.destroy()
                                }
                            }).open()
                        }
                    }, {
                        text: "Open in browser",
                        bold: !0,
                        onClick: () => {
                            window.open(s, "_blank")
                        }
                    }, {
                        text: "Close"
                    }]
                }).open()
            } catch (s) {
                D.dialog.alert(s, "")
            }
        }
        ;
        return (s, l) => {
            const c = P("f7-icon")
              , u = P("f7-list-item");
            return O(),
            K(u, {
                link: "",
                "no-chevron": "",
                title: "Download IPA",
                onClick: i
            }, {
                media: k( () => [S(c, {
                    ios: "f7:arrow_down_doc",
                    size: "24"
                })]),
                _: 1
            })
        }
    }
}
  , jB = {
    __name: "ui",
    props: {
        signerObject: {
            type: Object,
            required: !0
        },
        ipaUrl: {
            type: String,
            default: ""
        },
        fill: {
            type: Boolean,
            default: !1
        },
        round: {
            type: Boolean,
            default: !1
        },
        outline: {
            type: Boolean,
            default: !1
        },
        large: {
            type: Boolean,
            default: !1
        }
    },
    setup(e) {
        const t = e
          , n = ht()
          , a = oe(!1)
          , r = oe(!1)
          , {busy: o, launch: i} = mh({
            showPreloader: !1,
            onFallback: () => {
                D.views.current.router.navigate("/app/", {
                    props: {
                        appItem: {
                            id: ra.LC_APP_ID
                        }
                    }
                })
            }
        })
          , s = ae( () => {
            var p, h, m, g;
            const u = !((h = (p = t.signerObject) == null ? void 0 : p.appGeneralSettings) != null && h.name)
              , f = (g = (m = t.signerObject) == null ? void 0 : m.signingStage) == null ? void 0 : g.key
              , d = !!(f && f !== "ready_to_install");
            return o.value || u || d
        }
        )
          , l = ae( () => {
            var u;
            return Array.isArray((u = n.device) == null ? void 0 : u.service) ? n.device.service.some(f => f.name === "premium" && !f.isExpired) : !1
        }
        )
          , c = async () => {
            var f;
            if (!((f = n.device) != null && f.hasActivation))
                return;
            if (!l.value) {
                D.dialog.create({
                    title: "Installation of duplicates",
                    text: "Quick installation of duplicate applications is only available to Premium Access owners.",
                    verticalButtons: !0,
                    buttons: [{
                        text: "Upgrade to Premium",
                        color: "blue",
                        bold: !0,
                        onClick: () => {
                            D.view.current.router.navigate("/device/service-offer-details/", {
                                props: {
                                    offerId: 1
                                }
                            })
                        }
                    }, {
                        text: "Close"
                    }]
                }).open();
                return
            }
            if (n.oldSignerUI) {
                await t.signerObject.signDuplicate();
                return
            }
            const u = `${ra.LC_URL_SCHEME}${encodeURIComponent(t.ipaUrl)}`;
            i(u)
        }
        ;
        return Xe( () => {
            var u;
            (u = n == null ? void 0 : n.device) != null && u.hasActivation || (r.value = "#view-device",
            a.value = !0)
        }
        ),
        (u, f) => {
            const d = P("f7-icon")
              , p = P("f7-list-item");
            return O(),
            K(p, {
                disabled: s.value,
                link: "",
                "no-chevron": "",
                "popup-close": a.value,
                "tab-link": r.value,
                title: "Duplicate App",
                onClick: c
            }, {
                media: k( () => [S(d, {
                    ios: "f7:plus_square_on_square",
                    size: "24"
                })]),
                _: 1
            }, 8, ["disabled", "popup-close", "tab-link"])
        }
    }
};
const vh = {
    __name: "ui",
    props: {
        signerObject: {
            type: Object,
            required: !0
        },
        ipaUrl: {
            type: String,
            default: ""
        }
    },
    setup(e) {
        const t = oe(null);
        return (n, a) => {
            const r = P("f7-link")
              , o = P("f7-list");
            return O(),
            G(Be, null, [S(r, {
                class: "app-sign-additional-actions-button-ui button-glass bounce-tap",
                "icon-f7": "ellipsis",
                "icon-size": "26",
                onClick: a[0] || (a[0] = i => t.value.open(i))
            }), S(hh, {
                ref_key: "dropdownRef",
                ref: t
            }, {
                default: k( () => [S(o, {
                    class: "search-apps-ui__sources-list no-margin",
                    "no-hairlines": "",
                    "no-hairlines-between": ""
                }, {
                    default: k( () => [V("ul", null, [S(B(jB), {
                        class: "sign-duplicate-button",
                        "ipa-url": e.ipaUrl,
                        "signer-object": e.signerObject
                    }, null, 8, ["ipa-url", "signer-object"]), S(B(FB))])]),
                    _: 1
                })]),
                _: 1
            }, 512)], 64)
        }
    }
};
const UB = e => (qt("data-v-d4f28ae9"),
e = e(),
Wt(),
e)
  , qB = {
    style: {
        "margin-top": "auto"
    }
}
  , WB = UB( () => V("div", {
    class: "item-header"
}, " Please wait ", -1))
  , YB = {
    class: "item-subtitle"
}
  , GB = {
    class: "item-subtitle"
}
  , XB = {
    __name: "ui",
    props: {
        signerObject: {
            type: Object,
            required: !0
        }
    },
    setup(e) {
        const t = e
          , n = oe(null);
        return st( () => t.signerObject.signingStage.data, () => {
            var a, r;
            t.signerObject.signingStage.key === "uploading" && D.progressbar.set((a = n.value) == null ? void 0 : a.$el, (r = t.signerObject.signingStage.data) == null ? void 0 : r.uploadingPercent)
        }
        ),
        (a, r) => {
            var i;
            const o = P("f7-progressbar");
            return O(),
            G("div", qB, [WB, e.signerObject.signingStage.key === "uploading" ? (O(),
            G(Be, {
                key: 0
            }, [V("div", YB, Me((i = e.signerObject.signingStage.data) == null ? void 0 : i.message), 1), S(o, {
                ref_key: "uploadProgressRef",
                ref: n,
                progress: 0
            }, null, 512)], 64)) : (O(),
            G(Be, {
                key: 1
            }, [V("div", GB, Me(e.signerObject.signingStage.data), 1), S(o, {
                infinite: ""
            })], 64))])
        }
    }
}
  , wc = it(XB, [["__scopeId", "data-v-d4f28ae9"]]);
const KB = {
    style: {
        "text-align": "center",
        display: "flex",
        gap: "8px"
    }
}
  , ZB = {
    __name: "ui",
    props: {
        signerObject: {
            type: Object,
            required: !0
        },
        ipaUrl: {
            type: String,
            default: ""
        },
        appId: {
            type: Number,
            required: !0
        },
        appName: {
            type: [String, null],
            default: ""
        },
        appDeveloper: {
            type: [String, null],
            default: ""
        },
        appIcon: {
            type: [String, null],
            default: ""
        },
        oldSignerUi: {
            type: Boolean,
            default: !1
        }
    },
    setup(e) {
        const t = e
          , n = oe(!1)
          , a = ae( () => t.oldSignerUi || ra.LC_APP_ID === t.appId);
        return (r, o) => {
            const i = P("f7-icon")
              , s = P("f7-accordion-toggle");
            return O(),
            K(B(QI), {
                "app-developer": e.appDeveloper,
                "app-icon": e.appIcon,
                "app-name": e.appName,
                "signer-object": e.signerObject
            }, lr({
                button: k( () => [V("div", KB, [a.value ? (O(),
                K(B(ll), {
                    key: 0,
                    fill: "",
                    round: "",
                    "signer-object": e.signerObject
                }, {
                    default: k( () => [J(" SIGN APP ")]),
                    _: 1
                }, 8, ["signer-object"])) : (O(),
                K(B(gh), {
                    key: 1,
                    fill: "",
                    "ipa-url": e.ipaUrl,
                    round: ""
                }, {
                    default: k( () => [J(" INSTALL ")]),
                    _: 1
                }, 8, ["ipa-url"]))])]),
                "signing-info": k( () => [S(B(wc), {
                    "signer-object": e.signerObject
                }, null, 8, ["signer-object"])]),
                "accordion-content": k( () => [ce(r.$slots, "accordion-content", {}, void 0, !0)]),
                _: 2
            }, [e.oldSignerUi ? {
                name: "accordion-toggle",
                fn: k( () => [S(s, null, {
                    default: k( () => [S(B(F8), {
                        class: "app-view-header-ui__sign-settings-button button-glass bounce-tap",
                        "is-active": n.value,
                        onSwitchMode: o[0] || (o[0] = l => n.value = !n.value)
                    }, {
                        "not-active": k( () => [S(i, {
                            f7: "gear",
                            size: "26"
                        })]),
                        active: k( () => [S(i, {
                            f7: "chevron_up",
                            size: "24"
                        })]),
                        _: 1
                    }, 8, ["is-active"])]),
                    _: 1
                })]),
                key: "0"
            } : void 0, B(ra).LC_APP_ID !== e.appId ? {
                name: "download-button",
                fn: k( () => [S(B(vh), {
                    "ipa-url": e.ipaUrl,
                    "signer-object": e.signerObject
                }, null, 8, ["ipa-url", "signer-object"])]),
                key: "1"
            } : void 0]), 1032, ["app-developer", "app-icon", "app-name", "signer-object"])
        }
    }
}
  , JB = it(ZB, [["__scopeId", "data-v-a0f9a32d"]]);
var bh = {};
const QB = ib(Tv);
var P1 = {}
  , eR = {
    get exports() {
        return P1
    },
    set exports(e) {
        P1 = e
    }
};
/*!
 * Cropper.js v1.6.1
 * https://fengyuanchen.github.io/cropperjs
 *
 * Copyright 2015-present Chen Fengyuan
 * Released under the MIT license
 *
 * Date: 2023-09-17T03:44:19.860Z
 */
(function(e, t) {
    (function(n, a) {
        e.exports = a()
    }
    )(s7, function() {
        "use strict";
        function n(X, I) {
            var F = Object.keys(X);
            if (Object.getOwnPropertySymbols) {
                var N = Object.getOwnPropertySymbols(X);
                I && (N = N.filter(function(ue) {
                    return Object.getOwnPropertyDescriptor(X, ue).enumerable
                })),
                F.push.apply(F, N)
            }
            return F
        }
        function a(X) {
            for (var I = 1; I < arguments.length; I++) {
                var F = arguments[I] != null ? arguments[I] : {};
                I % 2 ? n(Object(F), !0).forEach(function(N) {
                    l(X, N, F[N])
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(X, Object.getOwnPropertyDescriptors(F)) : n(Object(F)).forEach(function(N) {
                    Object.defineProperty(X, N, Object.getOwnPropertyDescriptor(F, N))
                })
            }
            return X
        }
        function r(X) {
            return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(I) {
                return typeof I
            }
            : function(I) {
                return I && typeof Symbol == "function" && I.constructor === Symbol && I !== Symbol.prototype ? "symbol" : typeof I
            }
            ,
            r(X)
        }
        function o(X, I) {
            if (!(X instanceof I))
                throw new TypeError("Cannot call a class as a function")
        }
        function i(X, I) {
            for (var F = 0; F < I.length; F++) {
                var N = I[F];
                N.enumerable = N.enumerable || !1,
                N.configurable = !0,
                "value"in N && (N.writable = !0),
                Object.defineProperty(X, g(N.key), N)
            }
        }
        function s(X, I, F) {
            return I && i(X.prototype, I),
            F && i(X, F),
            Object.defineProperty(X, "prototype", {
                writable: !1
            }),
            X
        }
        function l(X, I, F) {
            return I = g(I),
            I in X ? Object.defineProperty(X, I, {
                value: F,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : X[I] = F,
            X
        }
        function c(X) {
            return u(X) || f(X) || d(X) || h()
        }
        function u(X) {
            if (Array.isArray(X))
                return p(X)
        }
        function f(X) {
            if (typeof Symbol < "u" && X[Symbol.iterator] != null || X["@@iterator"] != null)
                return Array.from(X)
        }
        function d(X, I) {
            if (X) {
                if (typeof X == "string")
                    return p(X, I);
                var F = Object.prototype.toString.call(X).slice(8, -1);
                if (F === "Object" && X.constructor && (F = X.constructor.name),
                F === "Map" || F === "Set")
                    return Array.from(X);
                if (F === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(F))
                    return p(X, I)
            }
        }
        function p(X, I) {
            (I == null || I > X.length) && (I = X.length);
            for (var F = 0, N = new Array(I); F < I; F++)
                N[F] = X[F];
            return N
        }
        function h() {
            throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
        }
        function m(X, I) {
            if (typeof X != "object" || X === null)
                return X;
            var F = X[Symbol.toPrimitive];
            if (F !== void 0) {
                var N = F.call(X, I || "default");
                if (typeof N != "object")
                    return N;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return (I === "string" ? String : Number)(X)
        }
        function g(X) {
            var I = m(X, "string");
            return typeof I == "symbol" ? I : String(I)
        }
        var b = typeof window < "u" && typeof window.document < "u"
          , v = b ? window : {}
          , y = b && v.document.documentElement ? "ontouchstart"in v.document.documentElement : !1
          , w = b ? "PointerEvent"in v : !1
          , C = "cropper"
          , _ = "all"
          , E = "crop"
          , z = "move"
          , T = "zoom"
          , A = "e"
          , x = "w"
          , M = "s"
          , L = "n"
          , U = "ne"
          , Y = "nw"
          , H = "se"
          , W = "sw"
          , j = "".concat(C, "-crop")
          , Q = "".concat(C, "-disabled")
          , ne = "".concat(C, "-hidden")
          , re = "".concat(C, "-hide")
          , ve = "".concat(C, "-invisible")
          , Ne = "".concat(C, "-modal")
          , Ge = "".concat(C, "-move")
          , Ye = "".concat(C, "Action")
          , tt = "".concat(C, "Preview")
          , ee = "crop"
          , ye = "move"
          , Le = "none"
          , Se = "crop"
          , Re = "cropend"
          , Ve = "cropmove"
          , Ze = "cropstart"
          , q = "dblclick"
          , Z = y ? "touchstart" : "mousedown"
          , de = y ? "touchmove" : "mousemove"
          , me = y ? "touchend touchcancel" : "mouseup"
          , ge = w ? "pointerdown" : Z
          , ie = w ? "pointermove" : de
          , Ee = w ? "pointerup pointercancel" : me
          , $e = "ready"
          , xe = "resize"
          , he = "wheel"
          , We = "zoom"
          , Te = "image/jpeg"
          , Fe = /^e|w|s|n|se|sw|ne|nw|all|crop|move|zoom$/
          , at = /^data:/
          , dt = /^data:image\/jpeg;base64,/
          , St = /^img|canvas$/i
          , Tt = 200
          , Ft = 100
          , wn = {
            viewMode: 0,
            dragMode: ee,
            initialAspectRatio: NaN,
            aspectRatio: NaN,
            data: null,
            preview: "",
            responsive: !0,
            restore: !0,
            checkCrossOrigin: !0,
            checkOrientation: !0,
            modal: !0,
            guides: !0,
            center: !0,
            highlight: !0,
            background: !0,
            autoCrop: !0,
            autoCropArea: .8,
            movable: !0,
            rotatable: !0,
            scalable: !0,
            zoomable: !0,
            zoomOnTouch: !0,
            zoomOnWheel: !0,
            wheelZoomRatio: .1,
            cropBoxMovable: !0,
            cropBoxResizable: !0,
            toggleDragModeOnDblclick: !0,
            minCanvasWidth: 0,
            minCanvasHeight: 0,
            minCropBoxWidth: 0,
            minCropBoxHeight: 0,
            minContainerWidth: Tt,
            minContainerHeight: Ft,
            ready: null,
            cropstart: null,
            cropmove: null,
            cropend: null,
            crop: null,
            zoom: null
        }
          , dr = '<div class="cropper-container" touch-action="none"><div class="cropper-wrap-box"><div class="cropper-canvas"></div></div><div class="cropper-drag-box"></div><div class="cropper-crop-box"><span class="cropper-view-box"></span><span class="cropper-dashed dashed-h"></span><span class="cropper-dashed dashed-v"></span><span class="cropper-center"></span><span class="cropper-face"></span><span class="cropper-line line-e" data-cropper-action="e"></span><span class="cropper-line line-n" data-cropper-action="n"></span><span class="cropper-line line-w" data-cropper-action="w"></span><span class="cropper-line line-s" data-cropper-action="s"></span><span class="cropper-point point-e" data-cropper-action="e"></span><span class="cropper-point point-n" data-cropper-action="n"></span><span class="cropper-point point-w" data-cropper-action="w"></span><span class="cropper-point point-s" data-cropper-action="s"></span><span class="cropper-point point-ne" data-cropper-action="ne"></span><span class="cropper-point point-nw" data-cropper-action="nw"></span><span class="cropper-point point-sw" data-cropper-action="sw"></span><span class="cropper-point point-se" data-cropper-action="se"></span></div></div>'
          , ul = Number.isNaN || v.isNaN;
        function ft(X) {
            return typeof X == "number" && !ul(X)
        }
        var Oi = function(I) {
            return I > 0 && I < 1 / 0
        };
        function fn(X) {
            return typeof X > "u"
        }
        function on(X) {
            return r(X) === "object" && X !== null
        }
        var fl = Object.prototype.hasOwnProperty;
        function Io(X) {
            if (!on(X))
                return !1;
            try {
                var I = X.constructor
                  , F = I.prototype;
                return I && F && fl.call(F, "isPrototypeOf")
            } catch {
                return !1
            }
        }
        function _n(X) {
            return typeof X == "function"
        }
        var Vh = Array.prototype.slice;
        function md(X) {
            return Array.from ? Array.from(X) : Vh.call(X)
        }
        function Xt(X, I) {
            return X && _n(I) && (Array.isArray(X) || ft(X.length) ? md(X).forEach(function(F, N) {
                I.call(X, F, N, X)
            }) : on(X) && Object.keys(X).forEach(function(F) {
                I.call(X, X[F], F, X)
            })),
            X
        }
        var Lt = Object.assign || function(I) {
            for (var F = arguments.length, N = new Array(F > 1 ? F - 1 : 0), ue = 1; ue < F; ue++)
                N[ue - 1] = arguments[ue];
            return on(I) && N.length > 0 && N.forEach(function(te) {
                on(te) && Object.keys(te).forEach(function(le) {
                    I[le] = te[le]
                })
            }),
            I
        }
          , Fh = /\.\d*(?:0|9){12}\d*$/;
        function Bo(X) {
            var I = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e11;
            return Fh.test(X) ? Math.round(X * I) / I : X
        }
        var jh = /^width|height|left|top|marginLeft|marginTop$/;
        function pr(X, I) {
            var F = X.style;
            Xt(I, function(N, ue) {
                jh.test(ue) && ft(N) && (N = "".concat(N, "px")),
                F[ue] = N
            })
        }
        function Uh(X, I) {
            return X.classList ? X.classList.contains(I) : X.className.indexOf(I) > -1
        }
        function sn(X, I) {
            if (I) {
                if (ft(X.length)) {
                    Xt(X, function(N) {
                        sn(N, I)
                    });
                    return
                }
                if (X.classList) {
                    X.classList.add(I);
                    return
                }
                var F = X.className.trim();
                F ? F.indexOf(I) < 0 && (X.className = "".concat(F, " ").concat(I)) : X.className = I
            }
        }
        function ka(X, I) {
            if (I) {
                if (ft(X.length)) {
                    Xt(X, function(F) {
                        ka(F, I)
                    });
                    return
                }
                if (X.classList) {
                    X.classList.remove(I);
                    return
                }
                X.className.indexOf(I) >= 0 && (X.className = X.className.replace(I, ""))
            }
        }
        function Ro(X, I, F) {
            if (I) {
                if (ft(X.length)) {
                    Xt(X, function(N) {
                        Ro(N, I, F)
                    });
                    return
                }
                F ? sn(X, I) : ka(X, I)
            }
        }
        var qh = /([a-z\d])([A-Z])/g;
        function $c(X) {
            return X.replace(qh, "$1-$2").toLowerCase()
        }
        function Ec(X, I) {
            return on(X[I]) ? X[I] : X.dataset ? X.dataset[I] : X.getAttribute("data-".concat($c(I)))
        }
        function Pi(X, I, F) {
            on(F) ? X[I] = F : X.dataset ? X.dataset[I] = F : X.setAttribute("data-".concat($c(I)), F)
        }
        function Wh(X, I) {
            if (on(X[I]))
                try {
                    delete X[I]
                } catch {
                    X[I] = void 0
                }
            else if (X.dataset)
                try {
                    delete X.dataset[I]
                } catch {
                    X.dataset[I] = void 0
                }
            else
                X.removeAttribute("data-".concat($c(I)))
        }
        var gd = /\s\s*/
          , vd = function() {
            var X = !1;
            if (b) {
                var I = !1
                  , F = function() {}
                  , N = Object.defineProperty({}, "once", {
                    get: function() {
                        return X = !0,
                        I
                    },
                    set: function(te) {
                        I = te
                    }
                });
                v.addEventListener("test", F, N),
                v.removeEventListener("test", F, N)
            }
            return X
        }();
        function sa(X, I, F) {
            var N = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}
              , ue = F;
            I.trim().split(gd).forEach(function(te) {
                if (!vd) {
                    var le = X.listeners;
                    le && le[te] && le[te][F] && (ue = le[te][F],
                    delete le[te][F],
                    Object.keys(le[te]).length === 0 && delete le[te],
                    Object.keys(le).length === 0 && delete X.listeners)
                }
                X.removeEventListener(te, ue, N)
            })
        }
        function Wn(X, I, F) {
            var N = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}
              , ue = F;
            I.trim().split(gd).forEach(function(te) {
                if (N.once && !vd) {
                    var le = X.listeners
                      , be = le === void 0 ? {} : le;
                    ue = function() {
                        delete be[te][F],
                        X.removeEventListener(te, ue, N);
                        for (var ze = arguments.length, Ce = new Array(ze), we = 0; we < ze; we++)
                            Ce[we] = arguments[we];
                        F.apply(X, Ce)
                    }
                    ,
                    be[te] || (be[te] = {}),
                    be[te][F] && X.removeEventListener(te, be[te][F], N),
                    be[te][F] = ue,
                    X.listeners = be
                }
                X.addEventListener(te, ue, N)
            })
        }
        function Do(X, I, F) {
            var N;
            return _n(Event) && _n(CustomEvent) ? N = new CustomEvent(I,{
                detail: F,
                bubbles: !0,
                cancelable: !0
            }) : (N = document.createEvent("CustomEvent"),
            N.initCustomEvent(I, !0, !0, F)),
            X.dispatchEvent(N)
        }
        function bd(X) {
            var I = X.getBoundingClientRect();
            return {
                left: I.left + (window.pageXOffset - document.documentElement.clientLeft),
                top: I.top + (window.pageYOffset - document.documentElement.clientTop)
            }
        }
        var xc = v.location
          , Yh = /^(\w+:)\/\/([^:/?#]*):?(\d*)/i;
        function yd(X) {
            var I = X.match(Yh);
            return I !== null && (I[1] !== xc.protocol || I[2] !== xc.hostname || I[3] !== xc.port)
        }
        function Cd(X) {
            var I = "timestamp=".concat(new Date().getTime());
            return X + (X.indexOf("?") === -1 ? "?" : "&") + I
        }
        function Li(X) {
            var I = X.rotate
              , F = X.scaleX
              , N = X.scaleY
              , ue = X.translateX
              , te = X.translateY
              , le = [];
            ft(ue) && ue !== 0 && le.push("translateX(".concat(ue, "px)")),
            ft(te) && te !== 0 && le.push("translateY(".concat(te, "px)")),
            ft(I) && I !== 0 && le.push("rotate(".concat(I, "deg)")),
            ft(F) && F !== 1 && le.push("scaleX(".concat(F, ")")),
            ft(N) && N !== 1 && le.push("scaleY(".concat(N, ")"));
            var be = le.length ? le.join(" ") : "none";
            return {
                WebkitTransform: be,
                msTransform: be,
                transform: be
            }
        }
        function Gh(X) {
            var I = a({}, X)
              , F = 0;
            return Xt(X, function(N, ue) {
                delete I[ue],
                Xt(I, function(te) {
                    var le = Math.abs(N.startX - te.startX)
                      , be = Math.abs(N.startY - te.startY)
                      , De = Math.abs(N.endX - te.endX)
                      , ze = Math.abs(N.endY - te.endY)
                      , Ce = Math.sqrt(le * le + be * be)
                      , we = Math.sqrt(De * De + ze * ze)
                      , Ie = (we - Ce) / Ce;
                    Math.abs(Ie) > Math.abs(F) && (F = Ie)
                })
            }),
            F
        }
        function dl(X, I) {
            var F = X.pageX
              , N = X.pageY
              , ue = {
                endX: F,
                endY: N
            };
            return I ? ue : a({
                startX: F,
                startY: N
            }, ue)
        }
        function Xh(X) {
            var I = 0
              , F = 0
              , N = 0;
            return Xt(X, function(ue) {
                var te = ue.startX
                  , le = ue.startY;
                I += te,
                F += le,
                N += 1
            }),
            I /= N,
            F /= N,
            {
                pageX: I,
                pageY: F
            }
        }
        function hr(X) {
            var I = X.aspectRatio
              , F = X.height
              , N = X.width
              , ue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "contain"
              , te = Oi(N)
              , le = Oi(F);
            if (te && le) {
                var be = F * I;
                ue === "contain" && be > N || ue === "cover" && be < N ? F = N / I : N = F * I
            } else
                te ? F = N / I : le && (N = F * I);
            return {
                width: N,
                height: F
            }
        }
        function Kh(X) {
            var I = X.width
              , F = X.height
              , N = X.degree;
            if (N = Math.abs(N) % 180,
            N === 90)
                return {
                    width: F,
                    height: I
                };
            var ue = N % 90 * Math.PI / 180
              , te = Math.sin(ue)
              , le = Math.cos(ue)
              , be = I * le + F * te
              , De = I * te + F * le;
            return N > 90 ? {
                width: De,
                height: be
            } : {
                width: be,
                height: De
            }
        }
        function Zh(X, I, F, N) {
            var ue = I.aspectRatio
              , te = I.naturalWidth
              , le = I.naturalHeight
              , be = I.rotate
              , De = be === void 0 ? 0 : be
              , ze = I.scaleX
              , Ce = ze === void 0 ? 1 : ze
              , we = I.scaleY
              , Ie = we === void 0 ? 1 : we
              , bt = F.aspectRatio
              , mt = F.naturalWidth
              , It = F.naturalHeight
              , $t = N.fillColor
              , Qt = $t === void 0 ? "transparent" : $t
              , ln = N.imageSmoothingEnabled
              , Kt = ln === void 0 ? !0 : ln
              , ja = N.imageSmoothingQuality
              , Pn = ja === void 0 ? "low" : ja
              , Ue = N.maxWidth
              , Et = Ue === void 0 ? 1 / 0 : Ue
              , en = N.maxHeight
              , Yn = en === void 0 ? 1 / 0 : en
              , Ua = N.minWidth
              , qr = Ua === void 0 ? 0 : Ua
              , Wr = N.minHeight
              , mr = Wr === void 0 ? 0 : Wr
              , Sa = document.createElement("canvas")
              , kn = Sa.getContext("2d")
              , Yr = hr({
                aspectRatio: bt,
                width: Et,
                height: Yn
            })
              , pl = hr({
                aspectRatio: bt,
                width: qr,
                height: mr
            }, "cover")
              , Tc = Math.min(Yr.width, Math.max(pl.width, mt))
              , Mc = Math.min(Yr.height, Math.max(pl.height, It))
              , kd = hr({
                aspectRatio: ue,
                width: Et,
                height: Yn
            })
              , Sd = hr({
                aspectRatio: ue,
                width: qr,
                height: mr
            }, "cover")
              , $d = Math.min(kd.width, Math.max(Sd.width, te))
              , Ed = Math.min(kd.height, Math.max(Sd.height, le))
              , fm = [-$d / 2, -Ed / 2, $d, Ed];
            return Sa.width = Bo(Tc),
            Sa.height = Bo(Mc),
            kn.fillStyle = Qt,
            kn.fillRect(0, 0, Tc, Mc),
            kn.save(),
            kn.translate(Tc / 2, Mc / 2),
            kn.rotate(De * Math.PI / 180),
            kn.scale(Ce, Ie),
            kn.imageSmoothingEnabled = Kt,
            kn.imageSmoothingQuality = Pn,
            kn.drawImage.apply(kn, [X].concat(c(fm.map(function(dm) {
                return Math.floor(Bo(dm))
            })))),
            kn.restore(),
            Sa
        }
        var wd = String.fromCharCode;
        function Jh(X, I, F) {
            var N = "";
            F += I;
            for (var ue = I; ue < F; ue += 1)
                N += wd(X.getUint8(ue));
            return N
        }
        var Qh = /^data:.*,/;
        function em(X) {
            var I = X.replace(Qh, "")
              , F = atob(I)
              , N = new ArrayBuffer(F.length)
              , ue = new Uint8Array(N);
            return Xt(ue, function(te, le) {
                ue[le] = F.charCodeAt(le)
            }),
            N
        }
        function tm(X, I) {
            for (var F = [], N = 8192, ue = new Uint8Array(X); ue.length > 0; )
                F.push(wd.apply(null, md(ue.subarray(0, N)))),
                ue = ue.subarray(N);
            return "data:".concat(I, ";base64,").concat(btoa(F.join("")))
        }
        function nm(X) {
            var I = new DataView(X), F;
            try {
                var N, ue, te;
                if (I.getUint8(0) === 255 && I.getUint8(1) === 216)
                    for (var le = I.byteLength, be = 2; be + 1 < le; ) {
                        if (I.getUint8(be) === 255 && I.getUint8(be + 1) === 225) {
                            ue = be;
                            break
                        }
                        be += 1
                    }
                if (ue) {
                    var De = ue + 4
                      , ze = ue + 10;
                    if (Jh(I, De, 4) === "Exif") {
                        var Ce = I.getUint16(ze);
                        if (N = Ce === 18761,
                        (N || Ce === 19789) && I.getUint16(ze + 2, N) === 42) {
                            var we = I.getUint32(ze + 4, N);
                            we >= 8 && (te = ze + we)
                        }
                    }
                }
                if (te) {
                    var Ie = I.getUint16(te, N), bt, mt;
                    for (mt = 0; mt < Ie; mt += 1)
                        if (bt = te + mt * 12 + 2,
                        I.getUint16(bt, N) === 274) {
                            bt += 8,
                            F = I.getUint16(bt, N),
                            I.setUint16(bt, 1, N);
                            break
                        }
                }
            } catch {
                F = 1
            }
            return F
        }
        function am(X) {
            var I = 0
              , F = 1
              , N = 1;
            switch (X) {
            case 2:
                F = -1;
                break;
            case 3:
                I = -180;
                break;
            case 4:
                N = -1;
                break;
            case 5:
                I = 90,
                N = -1;
                break;
            case 6:
                I = 90;
                break;
            case 7:
                I = 90,
                F = -1;
                break;
            case 8:
                I = -90;
                break
            }
            return {
                rotate: I,
                scaleX: F,
                scaleY: N
            }
        }
        var rm = {
            render: function() {
                this.initContainer(),
                this.initCanvas(),
                this.initCropBox(),
                this.renderCanvas(),
                this.cropped && this.renderCropBox()
            },
            initContainer: function() {
                var I = this.element
                  , F = this.options
                  , N = this.container
                  , ue = this.cropper
                  , te = Number(F.minContainerWidth)
                  , le = Number(F.minContainerHeight);
                sn(ue, ne),
                ka(I, ne);
                var be = {
                    width: Math.max(N.offsetWidth, te >= 0 ? te : Tt),
                    height: Math.max(N.offsetHeight, le >= 0 ? le : Ft)
                };
                this.containerData = be,
                pr(ue, {
                    width: be.width,
                    height: be.height
                }),
                sn(I, ne),
                ka(ue, ne)
            },
            initCanvas: function() {
                var I = this.containerData
                  , F = this.imageData
                  , N = this.options.viewMode
                  , ue = Math.abs(F.rotate) % 180 === 90
                  , te = ue ? F.naturalHeight : F.naturalWidth
                  , le = ue ? F.naturalWidth : F.naturalHeight
                  , be = te / le
                  , De = I.width
                  , ze = I.height;
                I.height * be > I.width ? N === 3 ? De = I.height * be : ze = I.width / be : N === 3 ? ze = I.width / be : De = I.height * be;
                var Ce = {
                    aspectRatio: be,
                    naturalWidth: te,
                    naturalHeight: le,
                    width: De,
                    height: ze
                };
                this.canvasData = Ce,
                this.limited = N === 1 || N === 2,
                this.limitCanvas(!0, !0),
                Ce.width = Math.min(Math.max(Ce.width, Ce.minWidth), Ce.maxWidth),
                Ce.height = Math.min(Math.max(Ce.height, Ce.minHeight), Ce.maxHeight),
                Ce.left = (I.width - Ce.width) / 2,
                Ce.top = (I.height - Ce.height) / 2,
                Ce.oldLeft = Ce.left,
                Ce.oldTop = Ce.top,
                this.initialCanvasData = Lt({}, Ce)
            },
            limitCanvas: function(I, F) {
                var N = this.options
                  , ue = this.containerData
                  , te = this.canvasData
                  , le = this.cropBoxData
                  , be = N.viewMode
                  , De = te.aspectRatio
                  , ze = this.cropped && le;
                if (I) {
                    var Ce = Number(N.minCanvasWidth) || 0
                      , we = Number(N.minCanvasHeight) || 0;
                    be > 1 ? (Ce = Math.max(Ce, ue.width),
                    we = Math.max(we, ue.height),
                    be === 3 && (we * De > Ce ? Ce = we * De : we = Ce / De)) : be > 0 && (Ce ? Ce = Math.max(Ce, ze ? le.width : 0) : we ? we = Math.max(we, ze ? le.height : 0) : ze && (Ce = le.width,
                    we = le.height,
                    we * De > Ce ? Ce = we * De : we = Ce / De));
                    var Ie = hr({
                        aspectRatio: De,
                        width: Ce,
                        height: we
                    });
                    Ce = Ie.width,
                    we = Ie.height,
                    te.minWidth = Ce,
                    te.minHeight = we,
                    te.maxWidth = 1 / 0,
                    te.maxHeight = 1 / 0
                }
                if (F)
                    if (be > (ze ? 0 : 1)) {
                        var bt = ue.width - te.width
                          , mt = ue.height - te.height;
                        te.minLeft = Math.min(0, bt),
                        te.minTop = Math.min(0, mt),
                        te.maxLeft = Math.max(0, bt),
                        te.maxTop = Math.max(0, mt),
                        ze && this.limited && (te.minLeft = Math.min(le.left, le.left + (le.width - te.width)),
                        te.minTop = Math.min(le.top, le.top + (le.height - te.height)),
                        te.maxLeft = le.left,
                        te.maxTop = le.top,
                        be === 2 && (te.width >= ue.width && (te.minLeft = Math.min(0, bt),
                        te.maxLeft = Math.max(0, bt)),
                        te.height >= ue.height && (te.minTop = Math.min(0, mt),
                        te.maxTop = Math.max(0, mt))))
                    } else
                        te.minLeft = -te.width,
                        te.minTop = -te.height,
                        te.maxLeft = ue.width,
                        te.maxTop = ue.height
            },
            renderCanvas: function(I, F) {
                var N = this.canvasData
                  , ue = this.imageData;
                if (F) {
                    var te = Kh({
                        width: ue.naturalWidth * Math.abs(ue.scaleX || 1),
                        height: ue.naturalHeight * Math.abs(ue.scaleY || 1),
                        degree: ue.rotate || 0
                    })
                      , le = te.width
                      , be = te.height
                      , De = N.width * (le / N.naturalWidth)
                      , ze = N.height * (be / N.naturalHeight);
                    N.left -= (De - N.width) / 2,
                    N.top -= (ze - N.height) / 2,
                    N.width = De,
                    N.height = ze,
                    N.aspectRatio = le / be,
                    N.naturalWidth = le,
                    N.naturalHeight = be,
                    this.limitCanvas(!0, !1)
                }
                (N.width > N.maxWidth || N.width < N.minWidth) && (N.left = N.oldLeft),
                (N.height > N.maxHeight || N.height < N.minHeight) && (N.top = N.oldTop),
                N.width = Math.min(Math.max(N.width, N.minWidth), N.maxWidth),
                N.height = Math.min(Math.max(N.height, N.minHeight), N.maxHeight),
                this.limitCanvas(!1, !0),
                N.left = Math.min(Math.max(N.left, N.minLeft), N.maxLeft),
                N.top = Math.min(Math.max(N.top, N.minTop), N.maxTop),
                N.oldLeft = N.left,
                N.oldTop = N.top,
                pr(this.canvas, Lt({
                    width: N.width,
                    height: N.height
                }, Li({
                    translateX: N.left,
                    translateY: N.top
                }))),
                this.renderImage(I),
                this.cropped && this.limited && this.limitCropBox(!0, !0)
            },
            renderImage: function(I) {
                var F = this.canvasData
                  , N = this.imageData
                  , ue = N.naturalWidth * (F.width / F.naturalWidth)
                  , te = N.naturalHeight * (F.height / F.naturalHeight);
                Lt(N, {
                    width: ue,
                    height: te,
                    left: (F.width - ue) / 2,
                    top: (F.height - te) / 2
                }),
                pr(this.image, Lt({
                    width: N.width,
                    height: N.height
                }, Li(Lt({
                    translateX: N.left,
                    translateY: N.top
                }, N)))),
                I && this.output()
            },
            initCropBox: function() {
                var I = this.options
                  , F = this.canvasData
                  , N = I.aspectRatio || I.initialAspectRatio
                  , ue = Number(I.autoCropArea) || .8
                  , te = {
                    width: F.width,
                    height: F.height
                };
                N && (F.height * N > F.width ? te.height = te.width / N : te.width = te.height * N),
                this.cropBoxData = te,
                this.limitCropBox(!0, !0),
                te.width = Math.min(Math.max(te.width, te.minWidth), te.maxWidth),
                te.height = Math.min(Math.max(te.height, te.minHeight), te.maxHeight),
                te.width = Math.max(te.minWidth, te.width * ue),
                te.height = Math.max(te.minHeight, te.height * ue),
                te.left = F.left + (F.width - te.width) / 2,
                te.top = F.top + (F.height - te.height) / 2,
                te.oldLeft = te.left,
                te.oldTop = te.top,
                this.initialCropBoxData = Lt({}, te)
            },
            limitCropBox: function(I, F) {
                var N = this.options
                  , ue = this.containerData
                  , te = this.canvasData
                  , le = this.cropBoxData
                  , be = this.limited
                  , De = N.aspectRatio;
                if (I) {
                    var ze = Number(N.minCropBoxWidth) || 0
                      , Ce = Number(N.minCropBoxHeight) || 0
                      , we = be ? Math.min(ue.width, te.width, te.width + te.left, ue.width - te.left) : ue.width
                      , Ie = be ? Math.min(ue.height, te.height, te.height + te.top, ue.height - te.top) : ue.height;
                    ze = Math.min(ze, ue.width),
                    Ce = Math.min(Ce, ue.height),
                    De && (ze && Ce ? Ce * De > ze ? Ce = ze / De : ze = Ce * De : ze ? Ce = ze / De : Ce && (ze = Ce * De),
                    Ie * De > we ? Ie = we / De : we = Ie * De),
                    le.minWidth = Math.min(ze, we),
                    le.minHeight = Math.min(Ce, Ie),
                    le.maxWidth = we,
                    le.maxHeight = Ie
                }
                F && (be ? (le.minLeft = Math.max(0, te.left),
                le.minTop = Math.max(0, te.top),
                le.maxLeft = Math.min(ue.width, te.left + te.width) - le.width,
                le.maxTop = Math.min(ue.height, te.top + te.height) - le.height) : (le.minLeft = 0,
                le.minTop = 0,
                le.maxLeft = ue.width - le.width,
                le.maxTop = ue.height - le.height))
            },
            renderCropBox: function() {
                var I = this.options
                  , F = this.containerData
                  , N = this.cropBoxData;
                (N.width > N.maxWidth || N.width < N.minWidth) && (N.left = N.oldLeft),
                (N.height > N.maxHeight || N.height < N.minHeight) && (N.top = N.oldTop),
                N.width = Math.min(Math.max(N.width, N.minWidth), N.maxWidth),
                N.height = Math.min(Math.max(N.height, N.minHeight), N.maxHeight),
                this.limitCropBox(!1, !0),
                N.left = Math.min(Math.max(N.left, N.minLeft), N.maxLeft),
                N.top = Math.min(Math.max(N.top, N.minTop), N.maxTop),
                N.oldLeft = N.left,
                N.oldTop = N.top,
                I.movable && I.cropBoxMovable && Pi(this.face, Ye, N.width >= F.width && N.height >= F.height ? z : _),
                pr(this.cropBox, Lt({
                    width: N.width,
                    height: N.height
                }, Li({
                    translateX: N.left,
                    translateY: N.top
                }))),
                this.cropped && this.limited && this.limitCanvas(!0, !0),
                this.disabled || this.output()
            },
            output: function() {
                this.preview(),
                Do(this.element, Se, this.getData())
            }
        }
          , om = {
            initPreview: function() {
                var I = this.element
                  , F = this.crossOrigin
                  , N = this.options.preview
                  , ue = F ? this.crossOriginUrl : this.url
                  , te = I.alt || "The image to preview"
                  , le = document.createElement("img");
                if (F && (le.crossOrigin = F),
                le.src = ue,
                le.alt = te,
                this.viewBox.appendChild(le),
                this.viewBoxImage = le,
                !!N) {
                    var be = N;
                    typeof N == "string" ? be = I.ownerDocument.querySelectorAll(N) : N.querySelector && (be = [N]),
                    this.previews = be,
                    Xt(be, function(De) {
                        var ze = document.createElement("img");
                        Pi(De, tt, {
                            width: De.offsetWidth,
                            height: De.offsetHeight,
                            html: De.innerHTML
                        }),
                        F && (ze.crossOrigin = F),
                        ze.src = ue,
                        ze.alt = te,
                        ze.style.cssText = 'display:block;width:100%;height:auto;min-width:0!important;min-height:0!important;max-width:none!important;max-height:none!important;image-orientation:0deg!important;"',
                        De.innerHTML = "",
                        De.appendChild(ze)
                    })
                }
            },
            resetPreview: function() {
                Xt(this.previews, function(I) {
                    var F = Ec(I, tt);
                    pr(I, {
                        width: F.width,
                        height: F.height
                    }),
                    I.innerHTML = F.html,
                    Wh(I, tt)
                })
            },
            preview: function() {
                var I = this.imageData
                  , F = this.canvasData
                  , N = this.cropBoxData
                  , ue = N.width
                  , te = N.height
                  , le = I.width
                  , be = I.height
                  , De = N.left - F.left - I.left
                  , ze = N.top - F.top - I.top;
                !this.cropped || this.disabled || (pr(this.viewBoxImage, Lt({
                    width: le,
                    height: be
                }, Li(Lt({
                    translateX: -De,
                    translateY: -ze
                }, I)))),
                Xt(this.previews, function(Ce) {
                    var we = Ec(Ce, tt)
                      , Ie = we.width
                      , bt = we.height
                      , mt = Ie
                      , It = bt
                      , $t = 1;
                    ue && ($t = Ie / ue,
                    It = te * $t),
                    te && It > bt && ($t = bt / te,
                    mt = ue * $t,
                    It = bt),
                    pr(Ce, {
                        width: mt,
                        height: It
                    }),
                    pr(Ce.getElementsByTagName("img")[0], Lt({
                        width: le * $t,
                        height: be * $t
                    }, Li(Lt({
                        translateX: -De * $t,
                        translateY: -ze * $t
                    }, I))))
                }))
            }
        }
          , im = {
            bind: function() {
                var I = this.element
                  , F = this.options
                  , N = this.cropper;
                _n(F.cropstart) && Wn(I, Ze, F.cropstart),
                _n(F.cropmove) && Wn(I, Ve, F.cropmove),
                _n(F.cropend) && Wn(I, Re, F.cropend),
                _n(F.crop) && Wn(I, Se, F.crop),
                _n(F.zoom) && Wn(I, We, F.zoom),
                Wn(N, ge, this.onCropStart = this.cropStart.bind(this)),
                F.zoomable && F.zoomOnWheel && Wn(N, he, this.onWheel = this.wheel.bind(this), {
                    passive: !1,
                    capture: !0
                }),
                F.toggleDragModeOnDblclick && Wn(N, q, this.onDblclick = this.dblclick.bind(this)),
                Wn(I.ownerDocument, ie, this.onCropMove = this.cropMove.bind(this)),
                Wn(I.ownerDocument, Ee, this.onCropEnd = this.cropEnd.bind(this)),
                F.responsive && Wn(window, xe, this.onResize = this.resize.bind(this))
            },
            unbind: function() {
                var I = this.element
                  , F = this.options
                  , N = this.cropper;
                _n(F.cropstart) && sa(I, Ze, F.cropstart),
                _n(F.cropmove) && sa(I, Ve, F.cropmove),
                _n(F.cropend) && sa(I, Re, F.cropend),
                _n(F.crop) && sa(I, Se, F.crop),
                _n(F.zoom) && sa(I, We, F.zoom),
                sa(N, ge, this.onCropStart),
                F.zoomable && F.zoomOnWheel && sa(N, he, this.onWheel, {
                    passive: !1,
                    capture: !0
                }),
                F.toggleDragModeOnDblclick && sa(N, q, this.onDblclick),
                sa(I.ownerDocument, ie, this.onCropMove),
                sa(I.ownerDocument, Ee, this.onCropEnd),
                F.responsive && sa(window, xe, this.onResize)
            }
        }
          , sm = {
            resize: function() {
                if (!this.disabled) {
                    var I = this.options
                      , F = this.container
                      , N = this.containerData
                      , ue = F.offsetWidth / N.width
                      , te = F.offsetHeight / N.height
                      , le = Math.abs(ue - 1) > Math.abs(te - 1) ? ue : te;
                    if (le !== 1) {
                        var be, De;
                        I.restore && (be = this.getCanvasData(),
                        De = this.getCropBoxData()),
                        this.render(),
                        I.restore && (this.setCanvasData(Xt(be, function(ze, Ce) {
                            be[Ce] = ze * le
                        })),
                        this.setCropBoxData(Xt(De, function(ze, Ce) {
                            De[Ce] = ze * le
                        })))
                    }
                }
            },
            dblclick: function() {
                this.disabled || this.options.dragMode === Le || this.setDragMode(Uh(this.dragBox, j) ? ye : ee)
            },
            wheel: function(I) {
                var F = this
                  , N = Number(this.options.wheelZoomRatio) || .1
                  , ue = 1;
                this.disabled || (I.preventDefault(),
                !this.wheeling && (this.wheeling = !0,
                setTimeout(function() {
                    F.wheeling = !1
                }, 50),
                I.deltaY ? ue = I.deltaY > 0 ? 1 : -1 : I.wheelDelta ? ue = -I.wheelDelta / 120 : I.detail && (ue = I.detail > 0 ? 1 : -1),
                this.zoom(-ue * N, I)))
            },
            cropStart: function(I) {
                var F = I.buttons
                  , N = I.button;
                if (!(this.disabled || (I.type === "mousedown" || I.type === "pointerdown" && I.pointerType === "mouse") && (ft(F) && F !== 1 || ft(N) && N !== 0 || I.ctrlKey))) {
                    var ue = this.options, te = this.pointers, le;
                    I.changedTouches ? Xt(I.changedTouches, function(be) {
                        te[be.identifier] = dl(be)
                    }) : te[I.pointerId || 0] = dl(I),
                    Object.keys(te).length > 1 && ue.zoomable && ue.zoomOnTouch ? le = T : le = Ec(I.target, Ye),
                    Fe.test(le) && Do(this.element, Ze, {
                        originalEvent: I,
                        action: le
                    }) !== !1 && (I.preventDefault(),
                    this.action = le,
                    this.cropping = !1,
                    le === E && (this.cropping = !0,
                    sn(this.dragBox, Ne)))
                }
            },
            cropMove: function(I) {
                var F = this.action;
                if (!(this.disabled || !F)) {
                    var N = this.pointers;
                    I.preventDefault(),
                    Do(this.element, Ve, {
                        originalEvent: I,
                        action: F
                    }) !== !1 && (I.changedTouches ? Xt(I.changedTouches, function(ue) {
                        Lt(N[ue.identifier] || {}, dl(ue, !0))
                    }) : Lt(N[I.pointerId || 0] || {}, dl(I, !0)),
                    this.change(I))
                }
            },
            cropEnd: function(I) {
                if (!this.disabled) {
                    var F = this.action
                      , N = this.pointers;
                    I.changedTouches ? Xt(I.changedTouches, function(ue) {
                        delete N[ue.identifier]
                    }) : delete N[I.pointerId || 0],
                    F && (I.preventDefault(),
                    Object.keys(N).length || (this.action = ""),
                    this.cropping && (this.cropping = !1,
                    Ro(this.dragBox, Ne, this.cropped && this.options.modal)),
                    Do(this.element, Re, {
                        originalEvent: I,
                        action: F
                    }))
                }
            }
        }
          , lm = {
            change: function(I) {
                var F = this.options, N = this.canvasData, ue = this.containerData, te = this.cropBoxData, le = this.pointers, be = this.action, De = F.aspectRatio, ze = te.left, Ce = te.top, we = te.width, Ie = te.height, bt = ze + we, mt = Ce + Ie, It = 0, $t = 0, Qt = ue.width, ln = ue.height, Kt = !0, ja;
                !De && I.shiftKey && (De = we && Ie ? we / Ie : 1),
                this.limited && (It = te.minLeft,
                $t = te.minTop,
                Qt = It + Math.min(ue.width, N.width, N.left + N.width),
                ln = $t + Math.min(ue.height, N.height, N.top + N.height));
                var Pn = le[Object.keys(le)[0]]
                  , Ue = {
                    x: Pn.endX - Pn.startX,
                    y: Pn.endY - Pn.startY
                }
                  , Et = function(Yn) {
                    switch (Yn) {
                    case A:
                        bt + Ue.x > Qt && (Ue.x = Qt - bt);
                        break;
                    case x:
                        ze + Ue.x < It && (Ue.x = It - ze);
                        break;
                    case L:
                        Ce + Ue.y < $t && (Ue.y = $t - Ce);
                        break;
                    case M:
                        mt + Ue.y > ln && (Ue.y = ln - mt);
                        break
                    }
                };
                switch (be) {
                case _:
                    ze += Ue.x,
                    Ce += Ue.y;
                    break;
                case A:
                    if (Ue.x >= 0 && (bt >= Qt || De && (Ce <= $t || mt >= ln))) {
                        Kt = !1;
                        break
                    }
                    Et(A),
                    we += Ue.x,
                    we < 0 && (be = x,
                    we = -we,
                    ze -= we),
                    De && (Ie = we / De,
                    Ce += (te.height - Ie) / 2);
                    break;
                case L:
                    if (Ue.y <= 0 && (Ce <= $t || De && (ze <= It || bt >= Qt))) {
                        Kt = !1;
                        break
                    }
                    Et(L),
                    Ie -= Ue.y,
                    Ce += Ue.y,
                    Ie < 0 && (be = M,
                    Ie = -Ie,
                    Ce -= Ie),
                    De && (we = Ie * De,
                    ze += (te.width - we) / 2);
                    break;
                case x:
                    if (Ue.x <= 0 && (ze <= It || De && (Ce <= $t || mt >= ln))) {
                        Kt = !1;
                        break
                    }
                    Et(x),
                    we -= Ue.x,
                    ze += Ue.x,
                    we < 0 && (be = A,
                    we = -we,
                    ze -= we),
                    De && (Ie = we / De,
                    Ce += (te.height - Ie) / 2);
                    break;
                case M:
                    if (Ue.y >= 0 && (mt >= ln || De && (ze <= It || bt >= Qt))) {
                        Kt = !1;
                        break
                    }
                    Et(M),
                    Ie += Ue.y,
                    Ie < 0 && (be = L,
                    Ie = -Ie,
                    Ce -= Ie),
                    De && (we = Ie * De,
                    ze += (te.width - we) / 2);
                    break;
                case U:
                    if (De) {
                        if (Ue.y <= 0 && (Ce <= $t || bt >= Qt)) {
                            Kt = !1;
                            break
                        }
                        Et(L),
                        Ie -= Ue.y,
                        Ce += Ue.y,
                        we = Ie * De
                    } else
                        Et(L),
                        Et(A),
                        Ue.x >= 0 ? bt < Qt ? we += Ue.x : Ue.y <= 0 && Ce <= $t && (Kt = !1) : we += Ue.x,
                        Ue.y <= 0 ? Ce > $t && (Ie -= Ue.y,
                        Ce += Ue.y) : (Ie -= Ue.y,
                        Ce += Ue.y);
                    we < 0 && Ie < 0 ? (be = W,
                    Ie = -Ie,
                    we = -we,
                    Ce -= Ie,
                    ze -= we) : we < 0 ? (be = Y,
                    we = -we,
                    ze -= we) : Ie < 0 && (be = H,
                    Ie = -Ie,
                    Ce -= Ie);
                    break;
                case Y:
                    if (De) {
                        if (Ue.y <= 0 && (Ce <= $t || ze <= It)) {
                            Kt = !1;
                            break
                        }
                        Et(L),
                        Ie -= Ue.y,
                        Ce += Ue.y,
                        we = Ie * De,
                        ze += te.width - we
                    } else
                        Et(L),
                        Et(x),
                        Ue.x <= 0 ? ze > It ? (we -= Ue.x,
                        ze += Ue.x) : Ue.y <= 0 && Ce <= $t && (Kt = !1) : (we -= Ue.x,
                        ze += Ue.x),
                        Ue.y <= 0 ? Ce > $t && (Ie -= Ue.y,
                        Ce += Ue.y) : (Ie -= Ue.y,
                        Ce += Ue.y);
                    we < 0 && Ie < 0 ? (be = H,
                    Ie = -Ie,
                    we = -we,
                    Ce -= Ie,
                    ze -= we) : we < 0 ? (be = U,
                    we = -we,
                    ze -= we) : Ie < 0 && (be = W,
                    Ie = -Ie,
                    Ce -= Ie);
                    break;
                case W:
                    if (De) {
                        if (Ue.x <= 0 && (ze <= It || mt >= ln)) {
                            Kt = !1;
                            break
                        }
                        Et(x),
                        we -= Ue.x,
                        ze += Ue.x,
                        Ie = we / De
                    } else
                        Et(M),
                        Et(x),
                        Ue.x <= 0 ? ze > It ? (we -= Ue.x,
                        ze += Ue.x) : Ue.y >= 0 && mt >= ln && (Kt = !1) : (we -= Ue.x,
                        ze += Ue.x),
                        Ue.y >= 0 ? mt < ln && (Ie += Ue.y) : Ie += Ue.y;
                    we < 0 && Ie < 0 ? (be = U,
                    Ie = -Ie,
                    we = -we,
                    Ce -= Ie,
                    ze -= we) : we < 0 ? (be = H,
                    we = -we,
                    ze -= we) : Ie < 0 && (be = Y,
                    Ie = -Ie,
                    Ce -= Ie);
                    break;
                case H:
                    if (De) {
                        if (Ue.x >= 0 && (bt >= Qt || mt >= ln)) {
                            Kt = !1;
                            break
                        }
                        Et(A),
                        we += Ue.x,
                        Ie = we / De
                    } else
                        Et(M),
                        Et(A),
                        Ue.x >= 0 ? bt < Qt ? we += Ue.x : Ue.y >= 0 && mt >= ln && (Kt = !1) : we += Ue.x,
                        Ue.y >= 0 ? mt < ln && (Ie += Ue.y) : Ie += Ue.y;
                    we < 0 && Ie < 0 ? (be = Y,
                    Ie = -Ie,
                    we = -we,
                    Ce -= Ie,
                    ze -= we) : we < 0 ? (be = W,
                    we = -we,
                    ze -= we) : Ie < 0 && (be = U,
                    Ie = -Ie,
                    Ce -= Ie);
                    break;
                case z:
                    this.move(Ue.x, Ue.y),
                    Kt = !1;
                    break;
                case T:
                    this.zoom(Gh(le), I),
                    Kt = !1;
                    break;
                case E:
                    if (!Ue.x || !Ue.y) {
                        Kt = !1;
                        break
                    }
                    ja = bd(this.cropper),
                    ze = Pn.startX - ja.left,
                    Ce = Pn.startY - ja.top,
                    we = te.minWidth,
                    Ie = te.minHeight,
                    Ue.x > 0 ? be = Ue.y > 0 ? H : U : Ue.x < 0 && (ze -= we,
                    be = Ue.y > 0 ? W : Y),
                    Ue.y < 0 && (Ce -= Ie),
                    this.cropped || (ka(this.cropBox, ne),
                    this.cropped = !0,
                    this.limited && this.limitCropBox(!0, !0));
                    break
                }
                Kt && (te.width = we,
                te.height = Ie,
                te.left = ze,
                te.top = Ce,
                this.action = be,
                this.renderCropBox()),
                Xt(le, function(en) {
                    en.startX = en.endX,
                    en.startY = en.endY
                })
            }
        }
          , cm = {
            crop: function() {
                return this.ready && !this.cropped && !this.disabled && (this.cropped = !0,
                this.limitCropBox(!0, !0),
                this.options.modal && sn(this.dragBox, Ne),
                ka(this.cropBox, ne),
                this.setCropBoxData(this.initialCropBoxData)),
                this
            },
            reset: function() {
                return this.ready && !this.disabled && (this.imageData = Lt({}, this.initialImageData),
                this.canvasData = Lt({}, this.initialCanvasData),
                this.cropBoxData = Lt({}, this.initialCropBoxData),
                this.renderCanvas(),
                this.cropped && this.renderCropBox()),
                this
            },
            clear: function() {
                return this.cropped && !this.disabled && (Lt(this.cropBoxData, {
                    left: 0,
                    top: 0,
                    width: 0,
                    height: 0
                }),
                this.cropped = !1,
                this.renderCropBox(),
                this.limitCanvas(!0, !0),
                this.renderCanvas(),
                ka(this.dragBox, Ne),
                sn(this.cropBox, ne)),
                this
            },
            replace: function(I) {
                var F = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
                return !this.disabled && I && (this.isImg && (this.element.src = I),
                F ? (this.url = I,
                this.image.src = I,
                this.ready && (this.viewBoxImage.src = I,
                Xt(this.previews, function(N) {
                    N.getElementsByTagName("img")[0].src = I
                }))) : (this.isImg && (this.replaced = !0),
                this.options.data = null,
                this.uncreate(),
                this.load(I))),
                this
            },
            enable: function() {
                return this.ready && this.disabled && (this.disabled = !1,
                ka(this.cropper, Q)),
                this
            },
            disable: function() {
                return this.ready && !this.disabled && (this.disabled = !0,
                sn(this.cropper, Q)),
                this
            },
            destroy: function() {
                var I = this.element;
                return I[C] ? (I[C] = void 0,
                this.isImg && this.replaced && (I.src = this.originalUrl),
                this.uncreate(),
                this) : this
            },
            move: function(I) {
                var F = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : I
                  , N = this.canvasData
                  , ue = N.left
                  , te = N.top;
                return this.moveTo(fn(I) ? I : ue + Number(I), fn(F) ? F : te + Number(F))
            },
            moveTo: function(I) {
                var F = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : I
                  , N = this.canvasData
                  , ue = !1;
                return I = Number(I),
                F = Number(F),
                this.ready && !this.disabled && this.options.movable && (ft(I) && (N.left = I,
                ue = !0),
                ft(F) && (N.top = F,
                ue = !0),
                ue && this.renderCanvas(!0)),
                this
            },
            zoom: function(I, F) {
                var N = this.canvasData;
                return I = Number(I),
                I < 0 ? I = 1 / (1 - I) : I = 1 + I,
                this.zoomTo(N.width * I / N.naturalWidth, null, F)
            },
            zoomTo: function(I, F, N) {
                var ue = this.options
                  , te = this.canvasData
                  , le = te.width
                  , be = te.height
                  , De = te.naturalWidth
                  , ze = te.naturalHeight;
                if (I = Number(I),
                I >= 0 && this.ready && !this.disabled && ue.zoomable) {
                    var Ce = De * I
                      , we = ze * I;
                    if (Do(this.element, We, {
                        ratio: I,
                        oldRatio: le / De,
                        originalEvent: N
                    }) === !1)
                        return this;
                    if (N) {
                        var Ie = this.pointers
                          , bt = bd(this.cropper)
                          , mt = Ie && Object.keys(Ie).length ? Xh(Ie) : {
                            pageX: N.pageX,
                            pageY: N.pageY
                        };
                        te.left -= (Ce - le) * ((mt.pageX - bt.left - te.left) / le),
                        te.top -= (we - be) * ((mt.pageY - bt.top - te.top) / be)
                    } else
                        Io(F) && ft(F.x) && ft(F.y) ? (te.left -= (Ce - le) * ((F.x - te.left) / le),
                        te.top -= (we - be) * ((F.y - te.top) / be)) : (te.left -= (Ce - le) / 2,
                        te.top -= (we - be) / 2);
                    te.width = Ce,
                    te.height = we,
                    this.renderCanvas(!0)
                }
                return this
            },
            rotate: function(I) {
                return this.rotateTo((this.imageData.rotate || 0) + Number(I))
            },
            rotateTo: function(I) {
                return I = Number(I),
                ft(I) && this.ready && !this.disabled && this.options.rotatable && (this.imageData.rotate = I % 360,
                this.renderCanvas(!0, !0)),
                this
            },
            scaleX: function(I) {
                var F = this.imageData.scaleY;
                return this.scale(I, ft(F) ? F : 1)
            },
            scaleY: function(I) {
                var F = this.imageData.scaleX;
                return this.scale(ft(F) ? F : 1, I)
            },
            scale: function(I) {
                var F = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : I
                  , N = this.imageData
                  , ue = !1;
                return I = Number(I),
                F = Number(F),
                this.ready && !this.disabled && this.options.scalable && (ft(I) && (N.scaleX = I,
                ue = !0),
                ft(F) && (N.scaleY = F,
                ue = !0),
                ue && this.renderCanvas(!0, !0)),
                this
            },
            getData: function() {
                var I = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, F = this.options, N = this.imageData, ue = this.canvasData, te = this.cropBoxData, le;
                if (this.ready && this.cropped) {
                    le = {
                        x: te.left - ue.left,
                        y: te.top - ue.top,
                        width: te.width,
                        height: te.height
                    };
                    var be = N.width / N.naturalWidth;
                    if (Xt(le, function(Ce, we) {
                        le[we] = Ce / be
                    }),
                    I) {
                        var De = Math.round(le.y + le.height)
                          , ze = Math.round(le.x + le.width);
                        le.x = Math.round(le.x),
                        le.y = Math.round(le.y),
                        le.width = ze - le.x,
                        le.height = De - le.y
                    }
                } else
                    le = {
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0
                    };
                return F.rotatable && (le.rotate = N.rotate || 0),
                F.scalable && (le.scaleX = N.scaleX || 1,
                le.scaleY = N.scaleY || 1),
                le
            },
            setData: function(I) {
                var F = this.options
                  , N = this.imageData
                  , ue = this.canvasData
                  , te = {};
                if (this.ready && !this.disabled && Io(I)) {
                    var le = !1;
                    F.rotatable && ft(I.rotate) && I.rotate !== N.rotate && (N.rotate = I.rotate,
                    le = !0),
                    F.scalable && (ft(I.scaleX) && I.scaleX !== N.scaleX && (N.scaleX = I.scaleX,
                    le = !0),
                    ft(I.scaleY) && I.scaleY !== N.scaleY && (N.scaleY = I.scaleY,
                    le = !0)),
                    le && this.renderCanvas(!0, !0);
                    var be = N.width / N.naturalWidth;
                    ft(I.x) && (te.left = I.x * be + ue.left),
                    ft(I.y) && (te.top = I.y * be + ue.top),
                    ft(I.width) && (te.width = I.width * be),
                    ft(I.height) && (te.height = I.height * be),
                    this.setCropBoxData(te)
                }
                return this
            },
            getContainerData: function() {
                return this.ready ? Lt({}, this.containerData) : {}
            },
            getImageData: function() {
                return this.sized ? Lt({}, this.imageData) : {}
            },
            getCanvasData: function() {
                var I = this.canvasData
                  , F = {};
                return this.ready && Xt(["left", "top", "width", "height", "naturalWidth", "naturalHeight"], function(N) {
                    F[N] = I[N]
                }),
                F
            },
            setCanvasData: function(I) {
                var F = this.canvasData
                  , N = F.aspectRatio;
                return this.ready && !this.disabled && Io(I) && (ft(I.left) && (F.left = I.left),
                ft(I.top) && (F.top = I.top),
                ft(I.width) ? (F.width = I.width,
                F.height = I.width / N) : ft(I.height) && (F.height = I.height,
                F.width = I.height * N),
                this.renderCanvas(!0)),
                this
            },
            getCropBoxData: function() {
                var I = this.cropBoxData, F;
                return this.ready && this.cropped && (F = {
                    left: I.left,
                    top: I.top,
                    width: I.width,
                    height: I.height
                }),
                F || {}
            },
            setCropBoxData: function(I) {
                var F = this.cropBoxData, N = this.options.aspectRatio, ue, te;
                return this.ready && this.cropped && !this.disabled && Io(I) && (ft(I.left) && (F.left = I.left),
                ft(I.top) && (F.top = I.top),
                ft(I.width) && I.width !== F.width && (ue = !0,
                F.width = I.width),
                ft(I.height) && I.height !== F.height && (te = !0,
                F.height = I.height),
                N && (ue ? F.height = F.width / N : te && (F.width = F.height * N)),
                this.renderCropBox()),
                this
            },
            getCroppedCanvas: function() {
                var I = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                if (!this.ready || !window.HTMLCanvasElement)
                    return null;
                var F = this.canvasData
                  , N = Zh(this.image, this.imageData, F, I);
                if (!this.cropped)
                    return N;
                var ue = this.getData(I.rounded)
                  , te = ue.x
                  , le = ue.y
                  , be = ue.width
                  , De = ue.height
                  , ze = N.width / Math.floor(F.naturalWidth);
                ze !== 1 && (te *= ze,
                le *= ze,
                be *= ze,
                De *= ze);
                var Ce = be / De
                  , we = hr({
                    aspectRatio: Ce,
                    width: I.maxWidth || 1 / 0,
                    height: I.maxHeight || 1 / 0
                })
                  , Ie = hr({
                    aspectRatio: Ce,
                    width: I.minWidth || 0,
                    height: I.minHeight || 0
                }, "cover")
                  , bt = hr({
                    aspectRatio: Ce,
                    width: I.width || (ze !== 1 ? N.width : be),
                    height: I.height || (ze !== 1 ? N.height : De)
                })
                  , mt = bt.width
                  , It = bt.height;
                mt = Math.min(we.width, Math.max(Ie.width, mt)),
                It = Math.min(we.height, Math.max(Ie.height, It));
                var $t = document.createElement("canvas")
                  , Qt = $t.getContext("2d");
                $t.width = Bo(mt),
                $t.height = Bo(It),
                Qt.fillStyle = I.fillColor || "transparent",
                Qt.fillRect(0, 0, mt, It);
                var ln = I.imageSmoothingEnabled
                  , Kt = ln === void 0 ? !0 : ln
                  , ja = I.imageSmoothingQuality;
                Qt.imageSmoothingEnabled = Kt,
                ja && (Qt.imageSmoothingQuality = ja);
                var Pn = N.width, Ue = N.height, Et = te, en = le, Yn, Ua, qr, Wr, mr, Sa;
                Et <= -be || Et > Pn ? (Et = 0,
                Yn = 0,
                qr = 0,
                mr = 0) : Et <= 0 ? (qr = -Et,
                Et = 0,
                Yn = Math.min(Pn, be + Et),
                mr = Yn) : Et <= Pn && (qr = 0,
                Yn = Math.min(be, Pn - Et),
                mr = Yn),
                Yn <= 0 || en <= -De || en > Ue ? (en = 0,
                Ua = 0,
                Wr = 0,
                Sa = 0) : en <= 0 ? (Wr = -en,
                en = 0,
                Ua = Math.min(Ue, De + en),
                Sa = Ua) : en <= Ue && (Wr = 0,
                Ua = Math.min(De, Ue - en),
                Sa = Ua);
                var kn = [Et, en, Yn, Ua];
                if (mr > 0 && Sa > 0) {
                    var Yr = mt / be;
                    kn.push(qr * Yr, Wr * Yr, mr * Yr, Sa * Yr)
                }
                return Qt.drawImage.apply(Qt, [N].concat(c(kn.map(function(pl) {
                    return Math.floor(Bo(pl))
                })))),
                $t
            },
            setAspectRatio: function(I) {
                var F = this.options;
                return !this.disabled && !fn(I) && (F.aspectRatio = Math.max(0, I) || NaN,
                this.ready && (this.initCropBox(),
                this.cropped && this.renderCropBox())),
                this
            },
            setDragMode: function(I) {
                var F = this.options
                  , N = this.dragBox
                  , ue = this.face;
                if (this.ready && !this.disabled) {
                    var te = I === ee
                      , le = F.movable && I === ye;
                    I = te || le ? I : Le,
                    F.dragMode = I,
                    Pi(N, Ye, I),
                    Ro(N, j, te),
                    Ro(N, Ge, le),
                    F.cropBoxMovable || (Pi(ue, Ye, I),
                    Ro(ue, j, te),
                    Ro(ue, Ge, le))
                }
                return this
            }
        }
          , um = v.Cropper
          , _d = function() {
            function X(I) {
                var F = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                if (o(this, X),
                !I || !St.test(I.tagName))
                    throw new Error("The first argument is required and must be an <img> or <canvas> element.");
                this.element = I,
                this.options = Lt({}, wn, Io(F) && F),
                this.cropped = !1,
                this.disabled = !1,
                this.pointers = {},
                this.ready = !1,
                this.reloading = !1,
                this.replaced = !1,
                this.sized = !1,
                this.sizing = !1,
                this.init()
            }
            return s(X, [{
                key: "init",
                value: function() {
                    var F = this.element, N = F.tagName.toLowerCase(), ue;
                    if (!F[C]) {
                        if (F[C] = this,
                        N === "img") {
                            if (this.isImg = !0,
                            ue = F.getAttribute("src") || "",
                            this.originalUrl = ue,
                            !ue)
                                return;
                            ue = F.src
                        } else
                            N === "canvas" && window.HTMLCanvasElement && (ue = F.toDataURL());
                        this.load(ue)
                    }
                }
            }, {
                key: "load",
                value: function(F) {
                    var N = this;
                    if (F) {
                        this.url = F,
                        this.imageData = {};
                        var ue = this.element
                          , te = this.options;
                        if (!te.rotatable && !te.scalable && (te.checkOrientation = !1),
                        !te.checkOrientation || !window.ArrayBuffer) {
                            this.clone();
                            return
                        }
                        if (at.test(F)) {
                            dt.test(F) ? this.read(em(F)) : this.clone();
                            return
                        }
                        var le = new XMLHttpRequest
                          , be = this.clone.bind(this);
                        this.reloading = !0,
                        this.xhr = le,
                        le.onabort = be,
                        le.onerror = be,
                        le.ontimeout = be,
                        le.onprogress = function() {
                            le.getResponseHeader("content-type") !== Te && le.abort()
                        }
                        ,
                        le.onload = function() {
                            N.read(le.response)
                        }
                        ,
                        le.onloadend = function() {
                            N.reloading = !1,
                            N.xhr = null
                        }
                        ,
                        te.checkCrossOrigin && yd(F) && ue.crossOrigin && (F = Cd(F)),
                        le.open("GET", F, !0),
                        le.responseType = "arraybuffer",
                        le.withCredentials = ue.crossOrigin === "use-credentials",
                        le.send()
                    }
                }
            }, {
                key: "read",
                value: function(F) {
                    var N = this.options
                      , ue = this.imageData
                      , te = nm(F)
                      , le = 0
                      , be = 1
                      , De = 1;
                    if (te > 1) {
                        this.url = tm(F, Te);
                        var ze = am(te);
                        le = ze.rotate,
                        be = ze.scaleX,
                        De = ze.scaleY
                    }
                    N.rotatable && (ue.rotate = le),
                    N.scalable && (ue.scaleX = be,
                    ue.scaleY = De),
                    this.clone()
                }
            }, {
                key: "clone",
                value: function() {
                    var F = this.element
                      , N = this.url
                      , ue = F.crossOrigin
                      , te = N;
                    this.options.checkCrossOrigin && yd(N) && (ue || (ue = "anonymous"),
                    te = Cd(N)),
                    this.crossOrigin = ue,
                    this.crossOriginUrl = te;
                    var le = document.createElement("img");
                    ue && (le.crossOrigin = ue),
                    le.src = te || N,
                    le.alt = F.alt || "The image to crop",
                    this.image = le,
                    le.onload = this.start.bind(this),
                    le.onerror = this.stop.bind(this),
                    sn(le, re),
                    F.parentNode.insertBefore(le, F.nextSibling)
                }
            }, {
                key: "start",
                value: function() {
                    var F = this
                      , N = this.image;
                    N.onload = null,
                    N.onerror = null,
                    this.sizing = !0;
                    var ue = v.navigator && /(?:iPad|iPhone|iPod).*?AppleWebKit/i.test(v.navigator.userAgent)
                      , te = function(ze, Ce) {
                        Lt(F.imageData, {
                            naturalWidth: ze,
                            naturalHeight: Ce,
                            aspectRatio: ze / Ce
                        }),
                        F.initialImageData = Lt({}, F.imageData),
                        F.sizing = !1,
                        F.sized = !0,
                        F.build()
                    };
                    if (N.naturalWidth && !ue) {
                        te(N.naturalWidth, N.naturalHeight);
                        return
                    }
                    var le = document.createElement("img")
                      , be = document.body || document.documentElement;
                    this.sizingImage = le,
                    le.onload = function() {
                        te(le.width, le.height),
                        ue || be.removeChild(le)
                    }
                    ,
                    le.src = N.src,
                    ue || (le.style.cssText = "left:0;max-height:none!important;max-width:none!important;min-height:0!important;min-width:0!important;opacity:0;position:absolute;top:0;z-index:-1;",
                    be.appendChild(le))
                }
            }, {
                key: "stop",
                value: function() {
                    var F = this.image;
                    F.onload = null,
                    F.onerror = null,
                    F.parentNode.removeChild(F),
                    this.image = null
                }
            }, {
                key: "build",
                value: function() {
                    if (!(!this.sized || this.ready)) {
                        var F = this.element
                          , N = this.options
                          , ue = this.image
                          , te = F.parentNode
                          , le = document.createElement("div");
                        le.innerHTML = dr;
                        var be = le.querySelector(".".concat(C, "-container"))
                          , De = be.querySelector(".".concat(C, "-canvas"))
                          , ze = be.querySelector(".".concat(C, "-drag-box"))
                          , Ce = be.querySelector(".".concat(C, "-crop-box"))
                          , we = Ce.querySelector(".".concat(C, "-face"));
                        this.container = te,
                        this.cropper = be,
                        this.canvas = De,
                        this.dragBox = ze,
                        this.cropBox = Ce,
                        this.viewBox = be.querySelector(".".concat(C, "-view-box")),
                        this.face = we,
                        De.appendChild(ue),
                        sn(F, ne),
                        te.insertBefore(be, F.nextSibling),
                        ka(ue, re),
                        this.initPreview(),
                        this.bind(),
                        N.initialAspectRatio = Math.max(0, N.initialAspectRatio) || NaN,
                        N.aspectRatio = Math.max(0, N.aspectRatio) || NaN,
                        N.viewMode = Math.max(0, Math.min(3, Math.round(N.viewMode))) || 0,
                        sn(Ce, ne),
                        N.guides || sn(Ce.getElementsByClassName("".concat(C, "-dashed")), ne),
                        N.center || sn(Ce.getElementsByClassName("".concat(C, "-center")), ne),
                        N.background && sn(be, "".concat(C, "-bg")),
                        N.highlight || sn(we, ve),
                        N.cropBoxMovable && (sn(we, Ge),
                        Pi(we, Ye, _)),
                        N.cropBoxResizable || (sn(Ce.getElementsByClassName("".concat(C, "-line")), ne),
                        sn(Ce.getElementsByClassName("".concat(C, "-point")), ne)),
                        this.render(),
                        this.ready = !0,
                        this.setDragMode(N.dragMode),
                        N.autoCrop && this.crop(),
                        this.setData(N.data),
                        _n(N.ready) && Wn(F, $e, N.ready, {
                            once: !0
                        }),
                        Do(F, $e)
                    }
                }
            }, {
                key: "unbuild",
                value: function() {
                    if (this.ready) {
                        this.ready = !1,
                        this.unbind(),
                        this.resetPreview();
                        var F = this.cropper.parentNode;
                        F && F.removeChild(this.cropper),
                        ka(this.element, ne)
                    }
                }
            }, {
                key: "uncreate",
                value: function() {
                    this.ready ? (this.unbuild(),
                    this.ready = !1,
                    this.cropped = !1) : this.sizing ? (this.sizingImage.onload = null,
                    this.sizing = !1,
                    this.sized = !1) : this.reloading ? (this.xhr.onabort = null,
                    this.xhr.abort()) : this.image && this.stop()
                }
            }], [{
                key: "noConflict",
                value: function() {
                    return window.Cropper = um,
                    X
                }
            }, {
                key: "setDefaults",
                value: function(F) {
                    Lt(wn, Io(F) && F)
                }
            }]),
            X
        }();
        return Lt(_d.prototype, rm, om, im, sm, lm, cm),
        _d
    })
}
)(eR, P1);
Object.defineProperty(bh, "__esModule", {
    value: !0
});
var vp = QB
  , tR = P1
  , nR = aR(tR);
function aR(e) {
    return e && e.__esModule ? e : {
        default: e
    }
}
function rR(e, t) {
    var n = {};
    for (var a in e)
        t.indexOf(a) >= 0 || Object.prototype.hasOwnProperty.call(e, a) && (n[a] = e[a]);
    return n
}
var oR = typeof window > "u" ? [String, Array] : [String, Array, Element, NodeList]
  , iR = bh.default = {
    render: function() {
        var t = this.crossorigin || void 0;
        return (0,
        vp.h)("div", {
            style: this.containerStyle
        }, [(0,
        vp.h)("img", {
            ref: "img",
            src: this.src,
            alt: this.alt || "image",
            style: [{
                "max-width": "100%"
            }, this.imgStyle],
            crossorigin: t
        })])
    },
    props: {
        containerStyle: Object,
        src: {
            type: String,
            default: ""
        },
        alt: String,
        imgStyle: Object,
        viewMode: Number,
        dragMode: String,
        initialAspectRatio: Number,
        aspectRatio: Number,
        data: Object,
        preview: oR,
        responsive: {
            type: Boolean,
            default: !0
        },
        restore: {
            type: Boolean,
            default: !0
        },
        checkCrossOrigin: {
            type: Boolean,
            default: !0
        },
        checkOrientation: {
            type: Boolean,
            default: !0
        },
        crossorigin: {
            type: String
        },
        modal: {
            type: Boolean,
            default: !0
        },
        guides: {
            type: Boolean,
            default: !0
        },
        center: {
            type: Boolean,
            default: !0
        },
        highlight: {
            type: Boolean,
            default: !0
        },
        background: {
            type: Boolean,
            default: !0
        },
        autoCrop: {
            type: Boolean,
            default: !0
        },
        autoCropArea: Number,
        movable: {
            type: Boolean,
            default: !0
        },
        rotatable: {
            type: Boolean,
            default: !0
        },
        scalable: {
            type: Boolean,
            default: !0
        },
        zoomable: {
            type: Boolean,
            default: !0
        },
        zoomOnTouch: {
            type: Boolean,
            default: !0
        },
        zoomOnWheel: {
            type: Boolean,
            default: !0
        },
        wheelZoomRatio: Number,
        cropBoxMovable: {
            type: Boolean,
            default: !0
        },
        cropBoxResizable: {
            type: Boolean,
            default: !0
        },
        toggleDragModeOnDblclick: {
            type: Boolean,
            default: !0
        },
        minCanvasWidth: Number,
        minCanvasHeight: Number,
        minCropBoxWidth: Number,
        minCropBoxHeight: Number,
        minContainerWidth: Number,
        minContainerHeight: Number,
        ready: Function,
        cropstart: Function,
        cropmove: Function,
        cropend: Function,
        crop: Function,
        zoom: Function
    },
    mounted: function() {
        var t = this.$options.props
          , n = t.containerStyle
          , a = t.src
          , r = t.alt
          , o = t.imgStyle
          , i = rR(t, ["containerStyle", "src", "alt", "imgStyle"])
          , s = {};
        for (var l in i)
            this[l] !== void 0 && (s[l] = this[l]);
        this.cropper = new nR.default(this.$refs.img,s)
    },
    methods: {
        reset: function() {
            return this.cropper.reset()
        },
        clear: function() {
            return this.cropper.clear()
        },
        initCrop: function() {
            return this.cropper.crop()
        },
        replace: function(t) {
            var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
            return this.cropper.replace(t, n)
        },
        enable: function() {
            return this.cropper.enable()
        },
        disable: function() {
            return this.cropper.disable()
        },
        destroy: function() {
            return this.cropper.destroy()
        },
        move: function(t, n) {
            return this.cropper.move(t, n)
        },
        moveTo: function(t) {
            var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : t;
            return this.cropper.moveTo(t, n)
        },
        relativeZoom: function(t, n) {
            return this.cropper.zoom(t, n)
        },
        zoomTo: function(t, n) {
            return this.cropper.zoomTo(t, n)
        },
        rotate: function(t) {
            return this.cropper.rotate(t)
        },
        rotateTo: function(t) {
            return this.cropper.rotateTo(t)
        },
        scaleX: function(t) {
            return this.cropper.scaleX(t)
        },
        scaleY: function(t) {
            return this.cropper.scaleY(t)
        },
        scale: function(t) {
            var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : t;
            return this.cropper.scale(t, n)
        },
        getData: function() {
            var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
            return this.cropper.getData(t)
        },
        setData: function(t) {
            return this.cropper.setData(t)
        },
        getContainerData: function() {
            return this.cropper.getContainerData()
        },
        getImageData: function() {
            return this.cropper.getImageData()
        },
        getCanvasData: function() {
            return this.cropper.getCanvasData()
        },
        setCanvasData: function(t) {
            return this.cropper.setCanvasData(t)
        },
        getCropBoxData: function() {
            return this.cropper.getCropBoxData()
        },
        setCropBoxData: function(t) {
            return this.cropper.setCropBoxData(t)
        },
        getCroppedCanvas: function() {
            var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            return this.cropper.getCroppedCanvas(t)
        },
        setAspectRatio: function(t) {
            return this.cropper.setAspectRatio(t)
        },
        setDragMode: function(t) {
            return this.cropper.setDragMode(t)
        }
    }
};
const sR = {
    class: "display-flex justify-content-space-around margin-vertical"
}
  , lR = {
    __name: "CropperActionBar",
    props: {
        cropper: {
            type: [Object, null],
            required: !0
        }
    },
    setup(e) {
        const t = e
          , n = oe(1)
          , a = oe(1)
          , r = () => {
            n.value *= -1,
            t.cropper.scaleX(n.value)
        }
          , o = () => {
            a.value *= -1,
            t.cropper.scaleY(a.value)
        }
        ;
        return (i, s) => {
            const l = P("f7-icon")
              , c = P("f7-link");
            return O(),
            G("div", sR, [S(c, {
                onClick: s[0] || (s[0] = u => {
                    e.cropper.rotate(90)
                }
                )
            }, {
                default: k( () => [S(l, {
                    f7: "goforward_90"
                })]),
                _: 1
            }), S(c, {
                onClick: s[1] || (s[1] = u => r())
            }, {
                default: k( () => [S(l, {
                    f7: "resize_h"
                })]),
                _: 1
            }), S(c, {
                onClick: s[2] || (s[2] = u => o())
            }, {
                default: k( () => [S(l, {
                    f7: "resize_v"
                })]),
                _: 1
            }), S(c, {
                onClick: s[3] || (s[3] = u => e.cropper.relativeZoom(.1))
            }, {
                default: k( () => [S(l, {
                    f7: "arrow_up_left_arrow_down_right"
                })]),
                _: 1
            }), S(c, {
                onClick: s[4] || (s[4] = u => e.cropper.relativeZoom(-.1))
            }, {
                default: k( () => [S(l, {
                    f7: "arrow_down_right_arrow_up_left"
                })]),
                _: 1
            }), S(c, {
                onClick: s[5] || (s[5] = u => {
                    e.cropper.reset()
                }
                )
            }, {
                default: k( () => [S(l, {
                    f7: "arrow_2_circlepath"
                })]),
                _: 1
            })])
        }
    }
};
const cR = V("br", null, null, -1)
  , uR = {
    __name: "imageCropperPopup",
    props: {
        aspectRatio: {
            type: Number,
            default: 1
        },
        minWidth: {
            type: Number,
            default: 200
        },
        minHeight: {
            type: Number,
            default: 200
        },
        iconRadius: {
            type: Boolean,
            default: !1
        }
    },
    emits: ["onClose", "onDone"],
    setup(e, {expose: t, emit: n}) {
        const a = n
          , r = oe(null)
          , o = oe(null)
          , i = oe(null)
          , s = oe(null)
          , l = {
            maxHeight: "450px",
            width: "100%",
            height: "fit-content",
            position: "relative",
            boxSizing: "border-box"
        }
          , c = (p=null) => {
            if (!p) {
                o.value.click();
                return
            }
            s.value.replace(p),
            i.value.open()
        }
          , u = () => {
            i.value.close()
        }
        ;
        t({
            open: c,
            close: u
        });
        const f = p => {
            const [h] = p.target.files
              , m = new FileReader;
            m.onload = g => {
                s.value.replace(g.target.result),
                i.value.opened || i.value.open()
            }
            ,
            m.readAsDataURL(h)
        }
          , d = () => {
            const p = s.value.getCroppedCanvas().toDataURL();
            a("onDone", p),
            u()
        }
        ;
        return Xe( () => {
            ut( () => {
                i.value = D.popup.get(r.value.$el),
                i.value.on("close", () => {
                    s.value.replace(null),
                    o.value.value = ""
                }
                ),
                s.value.$refs.img.onerror = p => {
                    o.value.value && (console.error(p),
                    hc("Image loading error")),
                    u()
                }
            }
            )
        }
        ),
        lt( () => {
            u()
        }
        ),
        (p, h) => {
            const m = P("f7-col")
              , g = P("f7-button")
              , b = P("f7-row")
              , v = P("f7-page")
              , y = P("f7-popup");
            return O(),
            K(y, {
                ref_key: "popupRef",
                ref: r,
                "close-on-escape": "",
                push: ""
            }, {
                default: k( () => [S(B(ia)), S(v, null, {
                    default: k( () => [V("input", {
                        ref_key: "fileInputRef",
                        ref: o,
                        accept: ".jpg, .jpeg, .png, .webp",
                        class: "display-none",
                        type: "file",
                        onChange: f
                    }, null, 544), cR, V("div", {
                        class: Ae(["vue-cropper-container", {
                            "icon-radius": e.iconRadius
                        }])
                    }, [S(B(iR), {
                        ref_key: "cropper",
                        ref: s,
                        "aspect-ratio": e.aspectRatio,
                        "auto-crop-area": 1,
                        "check-cross-origin": !1,
                        "check-orientation": !1,
                        "container-style": l,
                        "drag-mode": "move",
                        "min-container-height": 340,
                        "min-container-width": 340,
                        "min-crop-box-height": e.minHeight,
                        "min-crop-box-width": e.minWidth,
                        src: null,
                        "view-mode": 1
                    }, null, 8, ["aspect-ratio", "min-crop-box-height", "min-crop-box-width"]), S(lR, {
                        cropper: s.value
                    }, null, 8, ["cropper"]), S(b, null, {
                        default: k( () => [S(m, null, {
                            default: k( () => [V("label", {
                                class: "button button-lite button-large",
                                onClick: h[0] || (h[0] = w => u())
                            }, " Cancel ")]),
                            _: 1
                        }), S(m, null, {
                            default: k( () => [S(g, {
                                fill: "",
                                large: "",
                                onClick: d
                            }, {
                                default: k( () => [J(" Done ")]),
                                _: 1
                            })]),
                            _: 1
                        })]),
                        _: 1
                    })], 2)]),
                    _: 1
                })]),
                _: 1
            }, 512)
        }
    }
}
  , h2 = (e, t) => e ? {
    files: [new File([e],t,{
        type: e.type
    })]
} : !1
  , fR = e => {
    const t = window.atob(e.split(",")[1])
      , n = new Uint8Array(t.length);
    for (let a = 0; a < t.length; a++)
        n[a] = t.charCodeAt(a);
    return new Blob([n],{
        type: "image/png"
    })
}
;
const dR = {
    class: "item-content item-input"
}
  , pR = {
    class: "item-inner"
}
  , hR = {
    class: "item-title item-label"
}
  , mR = {
    class: "item-input-wrap display-flex align-items-center"
}
  , gR = ["src"]
  , vR = ["placeholder", "value"]
  , bR = {
    __name: "ui",
    props: {
        modelValue: {
            type: [Object, null],
            required: !0
        },
        imagePreview: {
            type: String,
            default: ""
        },
        label: {
            type: String,
            default: ""
        },
        placeholder: {
            type: String,
            default: "file"
        },
        buttonText: {
            type: String,
            default: "Browse"
        },
        disabled: {
            type: Boolean,
            default: !1
        },
        acceptedExtensions: {
            type: Array,
            default: () => []
        },
        iconRadius: {
            type: Boolean,
            default: !1
        }
    },
    emits: ["update:modelValue", "update:imagePreview", "onClear"],
    setup(e, {emit: t}) {
        const n = e
          , a = t
          , r = oe(null)
          , o = oe(null)
          , i = async u => {
            D.dialog.preloader();
            try {
                a("update:imagePreview", u);
                const f = fR(u)
                  , d = new File([f],`${Gf("xxxx-xxxx-xxxx-xxxx")}.png`,{
                    type: "image/png"
                });
                a("update:modelValue", d)
            } catch {
                hc("Error when cropping image")
            } finally {
                D.dialog.close()
            }
        }
          , s = u => {
            const f = u.target.files[0];
            if (!f)
                return;
            const d = f.name.split(".").pop();
            if (!n.acceptedExtensions.includes(d)) {
                D.dialog.alert(`Invalid file extension. Available extensions: ${n.acceptedExtensions.join(", ")}`, "Error");
                return
            }
            if (f.type.startsWith("image")) {
                const p = new FileReader;
                p.onload = h => {
                    o.value.open(h.target.result)
                }
                ,
                p.readAsDataURL(f),
                r.value.value = null;
                return
            }
            a("update:modelValue", f),
            r.value.value = null
        }
          , l = () => {
            r.value.click()
        }
          , c = () => {
            a("update:modelValue", {}),
            a("update:imagePreview", null),
            a("onClear")
        }
        ;
        return (u, f) => {
            var h, m, g;
            const d = P("f7-icon")
              , p = P("f7-button");
            return O(),
            G("li", null, [V("input", {
                ref_key: "fileInput",
                ref: r,
                style: {
                    display: "none"
                },
                type: "file",
                onChange: s
            }, null, 544), V("div", dR, [V("div", pR, [V("div", hR, Me(e.label), 1), V("div", mR, [(h = e.modelValue) != null && h.name ? (O(),
            G(Be, {
                key: 0
            }, [e.imagePreview.length ? (O(),
            G("img", {
                key: 1,
                alt: "input-image-file-preview",
                class: "input-image-file-preview",
                src: e.imagePreview
            }, null, 8, gR)) : (O(),
            K(d, {
                key: 0,
                class: "margin-right-half",
                f7: "doc_fill",
                size: "20"
            }))], 64)) : pe("", !0), V("input", {
                class: "input-with-value",
                disabled: "",
                placeholder: e.placeholder,
                type: "text",
                value: (m = e.modelValue) == null ? void 0 : m.name
            }, null, 8, vR), (g = e.modelValue) != null && g.name ? (O(),
            K(p, {
                key: 2,
                class: "button-lite flex-none",
                onClick: c
            }, {
                default: k( () => [J(" Clear ")]),
                _: 1
            })) : (O(),
            K(p, {
                key: 1,
                class: "button-lite flex-none",
                disabled: e.disabled,
                onClick: l
            }, {
                default: k( () => [J(Me(e.buttonText), 1)]),
                _: 1
            }, 8, ["disabled"]))])])]), S(B(uR), {
                ref_key: "imageCropper",
                ref: o,
                "icon-radius": e.iconRadius,
                onOnDone: f[0] || (f[0] = b => i(b))
            }, null, 8, ["icon-radius"])])
        }
    }
}
  , bp = it(bR, [["__scopeId", "data-v-87f12147"]]);
const yR = {
    class: "display-flex justify-content-space-between align-items-center"
}
  , CR = V("div", {
    class: "item-subtitle"
}, " Remove mobileprovision ", -1)
  , wR = {
    __name: "ui",
    props: {
        signerObject: {
            type: Object,
            required: !0
        }
    },
    setup(e) {
        const t = e
          , n = ht()
          , a = () => {
            t.signerObject.appCustomSettings.dylibFileContent = null
        }
          , r = () => {
            t.signerObject.appCustomSettings.iconFileContent = null
        }
          , o = i => {
            localStorage.dontShowRemoveProfileMessage || i && D.dialog.create({
                title: "Warning!",
                text: "Before installing an app without a mobileprovision, make sure that your device already has at least one app with a mobileprovision installed. Otherwise, an installation error will occur.",
                verticalButtons: !0,
                buttons: [{
                    text: "Don't show again",
                    bold: !0,
                    onClick: () => {
                        localStorage.dontShowRemoveProfileMessage = !0
                    }
                }, {
                    text: "Got it"
                }]
            }).open()
        }
        ;
        return (i, s) => {
            const l = P("f7-list-input")
              , c = P("f7-toggle")
              , u = P("f7-list-item")
              , f = P("f7-list");
            return O(),
            K(f, {
                class: "app-sign-settings-form__list",
                inset: ""
            }, {
                default: k( () => {
                    var d, p, h, m, g, b;
                    return [V("ul", null, [S(B(bp), {
                        "image-preview": e.signerObject.appCustomSettings.iconFilePreview,
                        "onUpdate:imagePreview": s[0] || (s[0] = v => e.signerObject.appCustomSettings.iconFilePreview = v),
                        "model-value": e.signerObject.appCustomSettings.iconFileContent,
                        "onUpdate:modelValue": s[1] || (s[1] = v => e.signerObject.appCustomSettings.iconFileContent = v),
                        "accepted-extensions": ["png", "jpg", "jpeg"],
                        disabled: !((p = (d = B(n)) == null ? void 0 : d.device) != null && p.hasPremium),
                        "icon-radius": !0,
                        label: "App icon",
                        placeholder: ".png .jpg .jpeg file",
                        onOnClear: r
                    }, null, 8, ["image-preview", "model-value", "disabled"]), S(l, {
                        value: e.signerObject.appCustomSettings.name,
                        "onUpdate:value": s[2] || (s[2] = v => e.signerObject.appCustomSettings.name = v),
                        disabled: !e.signerObject.appCustomSettings.enabled || !((m = (h = B(n)) == null ? void 0 : h.device) != null && m.hasPremium),
                        label: "Custom app name",
                        placeholder: "App name",
                        type: "text"
                    }, null, 8, ["value", "disabled"]), S(B(bp), {
                        "model-value": e.signerObject.appCustomSettings.dylibFileContent,
                        "onUpdate:modelValue": s[3] || (s[3] = v => e.signerObject.appCustomSettings.dylibFileContent = v),
                        "accepted-extensions": ["dylib"],
                        disabled: !((b = (g = B(n)) == null ? void 0 : g.device) != null && b.hasPremium),
                        label: "Inject tweak",
                        placeholder: ".dylib file",
                        onOnClear: a
                    }, null, 8, ["model-value", "disabled"]), S(u, {
                        class: "app-sign-settings-form__no-flex-inner"
                    }, {
                        inner: k( () => [V("div", yR, [CR, S(c, {
                            checked: e.signerObject.appCustomSettings.removeProfile,
                            "onUpdate:checked": [s[4] || (s[4] = v => e.signerObject.appCustomSettings.removeProfile = v), o]
                        }, null, 8, ["checked"])])]),
                        _: 1
                    })])]
                }
                ),
                _: 1
            })
        }
    }
}
  , _R = V("p", {
    style: {
        "text-align": "center"
    }
}, [V("b", null, "This section is available only to premium owners!")], -1)
  , L1 = {
    __name: "ui",
    props: {
        signerObject: {
            type: Object,
            required: !0
        },
        noSignAppButton: {
            type: Boolean,
            default: !1
        },
        hasPremium: {
            type: Boolean,
            required: !0
        },
        hasDevice: {
            type: Boolean,
            required: !0
        }
    },
    setup(e) {
        const t = e
          , n = () => {
            if (!t.hasDevice) {
                D.tab.show("#view-device"),
                D.popup.close();
                return
            }
            D.view.current.router.navigate("/device/service-offer-details/", {
                props: {
                    offerId: 1
                }
            })
        }
        ;
        return (a, r) => {
            const o = P("f7-button")
              , i = P("f7-icon");
            return O(),
            K(B(rB), null, {
                "settings-form": k( () => [S(B(wR), {
                    "signer-object": e.signerObject
                }, null, 8, ["signer-object"])]),
                "bottom-area": k( () => [e.hasPremium ? (O(),
                G(Be, {
                    key: 1
                }, [e.noSignAppButton ? pe("", !0) : (O(),
                K(B(ll), {
                    key: 0,
                    class: "margin-bottom",
                    fill: "",
                    large: "",
                    "only-for-premium": !0,
                    round: "",
                    "signer-object": e.signerObject
                }, {
                    default: k( () => [J(" Sign app ")]),
                    _: 1
                }, 8, ["signer-object"])), S(o, {
                    class: "button-lite",
                    large: "",
                    round: "",
                    onClick: r[0] || (r[0] = s => e.signerObject.resetAppSettingsForm())
                }, {
                    default: k( () => [S(i, {
                        f7: "arrow_clockwise"
                    }), J(" Reset Settings ")]),
                    _: 1
                })], 64)) : (O(),
                G(Be, {
                    key: 0
                }, [_R, S(o, {
                    color: "yellow",
                    fill: "",
                    large: "",
                    round: "",
                    "text-color": "black",
                    onClick: n
                }, {
                    default: k( () => [J(" Upgrade to premium ")]),
                    _: 1
                })], 64))]),
                _: 1
            })
        }
    }
};
const kR = ["src"]
  , SR = {
    __name: "ui",
    props: {
        images: {
            type: Array,
            default: Array,
            required: !0
        }
    },
    setup(e) {
        const t = e;
        return (n, a) => {
            const r = P("f7-photo-browser")
              , o = P("f7-link")
              , i = P("f7-swiper-slide")
              , s = P("f7-swiper");
            return t.images && typeof t.images == "object" ? (O(),
            G(Be, {
                key: 0
            }, [S(r, {
                ref: "standaloneDark",
                photos: t.images,
                "routable-modals": !1,
                theme: "dark"
            }, null, 8, ["photos"]), S(s, {
                "grab-cursor": "",
                "slides-offset-after": 15,
                "slides-offset-before": 15,
                "slides-per-view": "auto",
                "space-between": 10
            }, {
                default: k( () => [(O(!0),
                G(Be, null, vt(t.images, (l, c) => (O(),
                K(i, {
                    key: c
                }, {
                    default: k( () => [S(o, {
                        onClick: u => n.$refs.standaloneDark.open(c)
                    }, {
                        default: k( () => [V("img", {
                            alt: "app screenshot",
                            src: l
                        }, null, 8, kR)]),
                        _: 2
                    }, 1032, ["onClick"])]),
                    _: 2
                }, 1024))), 128))]),
                _: 1
            })], 64)) : pe("", !0)
        }
    }
}
  , yh = it(SR, [["__scopeId", "data-v-9b4949c4"]])
  , id = oa("signer", {
    state: () => ({
        app: {},
        signerOpened: !1
    }),
    getters: {},
    actions: {
        async readIpaFile(e={}) {
            var t;
            try {
                const n = new window.AppInfoParser(e.files[0]);
                try {
                    const a = await n.parse()
                      , r = e.files[0];
                    return this.app.icon = a.icon || "icons/error_icon.png",
                    this.app.name = a.package || a.CFBundleName || a.CFBundleDisplayName,
                    this.app.customAppName = (t = this.app) == null ? void 0 : t.name,
                    this.app.size = r == null ? void 0 : r.size,
                    this.app.version = a.versionName || a.CFBundleShortVersionString,
                    this.app.bundleId = "",
                    r
                } catch (a) {
                    return console.log(a),
                    D.dialog.alert("Incorrect file format. Please make sure the file is in the right format and not damaged."),
                    !1
                } finally {
                    e.value = null
                }
            } catch (n) {
                return console.log(n),
                D.dialog.alert("Incorrect file format. Please make sure the file is in the right format and not damaged."),
                e.value = null,
                !1
            }
        }
    }
})
  , $R = {}
  , ER = V("p", null, " Sign and install any app you want. You just need to find the .ipa file of the app that interests you on the Internet. ", -1)
  , xR = {
    class: "margin-top",
    style: {
        "text-align": "center"
    }
};
function TR(e, t) {
    const n = P("f7-card-content")
      , a = P("f7-card");
    return O(),
    K(a, null, {
        default: k( () => [S(n, null, {
            default: k( () => [ER, V("div", xR, [ce(e.$slots, "default")])]),
            _: 3
        })]),
        _: 3
    })
}
const MR = it($R, [["render", TR]])
  , zR = {
    class: "display-flex justify-content-center"
}
  , AR = V("p", {
    class: "text-align-center"
}, [J(" Previously you uploaded an IPA to sign. Now its one step: install "), V("b", null, "LiveContainer"), J(". Import apps into it and run themsigning happens in the background. ")], -1)
  , OR = {
    class: "margin-top"
}
  , PR = {
    __name: "SignerLCAbout",
    setup(e) {
        return (t, n) => {
            const a = P("f7-card-content")
              , r = P("f7-card");
            return O(),
            K(r, null, {
                default: k( () => [S(a, null, {
                    default: k( () => [V("div", zR, [S(Mi, {
                        size: 60,
                        src: "./icons/LC-icon.jpg"
                    })]), AR, V("div", OR, [ce(t.$slots, "default")])]),
                    _: 3
                })]),
                _: 3
            })
        }
    }
};
const Ch = e => (qt("data-v-4623c336"),
e = e(),
Wt(),
e)
  , LR = ["src"]
  , IR = Ch( () => V("li", null, null, -1))
  , BR = Ch( () => V("li", null, null, -1))
  , RR = {
    __name: "SignerCard",
    props: {
        signerObject: {
            type: Object,
            required: !0
        }
    },
    setup(e) {
        const t = id();
        return (n, a) => {
            const r = P("f7-list-item")
              , o = P("f7-list")
              , i = P("f7-icon")
              , s = P("f7-accordion-content")
              , l = P("f7-card-content")
              , c = P("f7-card");
            return O(),
            K(c, {
                class: "no-margin"
            }, {
                default: k( () => [S(o, {
                    "media-list": ""
                }, {
                    default: k( () => [S(r, {
                        after: B(mc)(B(t).app.size, 1),
                        text: `v${B(t).app.version}`,
                        title: B(t).app.name
                    }, {
                        media: k( () => [V("img", {
                            src: B(t).app.icon
                        }, null, 8, LR)]),
                        _: 1
                    }, 8, ["after", "text", "title"])]),
                    _: 1
                }), e.signerObject.signingStage.key ? pe("", !0) : (O(),
                K(o, {
                    key: 0,
                    "accordion-list": ""
                }, {
                    default: k( () => [IR, S(r, {
                        "accordion-item": "",
                        title: "Customize"
                    }, {
                        media: k( () => [S(i, {
                            f7: "gear"
                        })]),
                        default: k( () => [S(s, null, {
                            default: k( () => [ce(n.$slots, "accordionContent", {}, void 0, !0)]),
                            _: 3
                        })]),
                        _: 3
                    }), BR]),
                    _: 3
                })), e.signerObject.signingStage.key && e.signerObject.signingStage.key !== "ready_to_install" ? (O(),
                K(l, {
                    key: 1
                }, {
                    default: k( () => [S(B(wc), {
                        "signer-object": e.signerObject
                    }, null, 8, ["signer-object"])]),
                    _: 1
                })) : pe("", !0), S(l, null, {
                    default: k( () => [e.signerObject.signingStage.key ? pe("", !0) : ce(n.$slots, "beforeSigningActions", {
                        key: 0
                    }, void 0, !0), e.signerObject.signingStage.key === "ready_to_install" ? ce(n.$slots, "afterSigningActions", {
                        key: 1
                    }, void 0, !0) : pe("", !0), e.signerObject.signingStage.key ? ce(n.$slots, "afterStartSigning", {
                        key: 2
                    }, void 0, !0) : pe("", !0)]),
                    _: 3
                })]),
                _: 3
            })
        }
    }
}
  , DR = it(RR, [["__scopeId", "data-v-4623c336"]])
  , yp = {
    __name: "ui",
    props: {
        fill: {
            type: Boolean,
            default: !1
        },
        round: {
            type: Boolean,
            default: !1
        },
        outline: {
            type: Boolean,
            default: !1
        },
        large: {
            type: Boolean,
            default: !1
        },
        lite: {
            type: Boolean,
            default: !1
        }
    },
    emits: ["onSelect"],
    setup(e, {emit: t}) {
        const n = e
          , a = t
          , r = ht()
          , o = Fa()
          , i = id()
          , s = oe(null)
          , l = () => {
            if (!r.device || !r.device.hasActivation) {
                o.setActiveTab("view-device");
                return
            }
            s.value.click()
        }
          , c = async u => {
            const f = await i.readIpaFile(u.target);
            a("onSelect", f),
            u.target.value = ""
        }
        ;
        return (u, f) => {
            const d = P("f7-button");
            return O(),
            G(Be, null, [V("input", {
                ref_key: "fileInput",
                ref: s,
                style: {
                    display: "none"
                },
                type: "file",
                onChange: c
            }, null, 544), S(d, {
                class: Ae(n.lite && "button-lite"),
                fill: n.fill,
                "icon-f7": "arrow_up_doc",
                large: n.large,
                outline: n.outline,
                round: n.round,
                onClick: l
            }, {
                default: k( () => [J(" Select IPA file ")]),
                _: 1
            }, 8, ["class", "fill", "large", "outline", "round"])], 64)
        }
    }
}
  , Na = Object.create(null);
Na.open = "0";
Na.close = "1";
Na.ping = "2";
Na.pong = "3";
Na.message = "4";
Na.upgrade = "5";
Na.noop = "6";
const n1 = Object.create(null);
Object.keys(Na).forEach(e => {
    n1[Na[e]] = e
}
);
const NR = {
    type: "error",
    data: "parser error"
}
  , HR = typeof Blob == "function" || typeof Blob < "u" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]"
  , VR = typeof ArrayBuffer == "function"
  , FR = e => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(e) : e && e.buffer instanceof ArrayBuffer
  , wh = ({type: e, data: t}, n, a) => HR && t instanceof Blob ? n ? a(t) : Cp(t, a) : VR && (t instanceof ArrayBuffer || FR(t)) ? n ? a(t) : Cp(new Blob([t]), a) : a(Na[e] + (t || ""))
  , Cp = (e, t) => {
    const n = new FileReader;
    return n.onload = function() {
        const a = n.result.split(",")[1];
        t("b" + (a || ""))
    }
    ,
    n.readAsDataURL(e)
}
  , wp = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
  , ts = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (let e = 0; e < wp.length; e++)
    ts[wp.charCodeAt(e)] = e;
const jR = e => {
    let t = e.length * .75, n = e.length, a, r = 0, o, i, s, l;
    e[e.length - 1] === "=" && (t--,
    e[e.length - 2] === "=" && t--);
    const c = new ArrayBuffer(t)
      , u = new Uint8Array(c);
    for (a = 0; a < n; a += 4)
        o = ts[e.charCodeAt(a)],
        i = ts[e.charCodeAt(a + 1)],
        s = ts[e.charCodeAt(a + 2)],
        l = ts[e.charCodeAt(a + 3)],
        u[r++] = o << 2 | i >> 4,
        u[r++] = (i & 15) << 4 | s >> 2,
        u[r++] = (s & 3) << 6 | l & 63;
    return c
}
  , UR = typeof ArrayBuffer == "function"
  , _h = (e, t) => {
    if (typeof e != "string")
        return {
            type: "message",
            data: kh(e, t)
        };
    const n = e.charAt(0);
    return n === "b" ? {
        type: "message",
        data: qR(e.substring(1), t)
    } : n1[n] ? e.length > 1 ? {
        type: n1[n],
        data: e.substring(1)
    } : {
        type: n1[n]
    } : NR
}
  , qR = (e, t) => {
    if (UR) {
        const n = jR(e);
        return kh(n, t)
    } else
        return {
            base64: !0,
            data: e
        }
}
  , kh = (e, t) => {
    switch (t) {
    case "blob":
        return e instanceof ArrayBuffer ? new Blob([e]) : e;
    case "arraybuffer":
    default:
        return e
    }
}
  , Sh = String.fromCharCode(30)
  , WR = (e, t) => {
    const n = e.length
      , a = new Array(n);
    let r = 0;
    e.forEach( (o, i) => {
        wh(o, !1, s => {
            a[i] = s,
            ++r === n && t(a.join(Sh))
        }
        )
    }
    )
}
  , YR = (e, t) => {
    const n = e.split(Sh)
      , a = [];
    for (let r = 0; r < n.length; r++) {
        const o = _h(n[r], t);
        if (a.push(o),
        o.type === "error")
            break
    }
    return a
}
  , $h = 4;
function Jt(e) {
    if (e)
        return GR(e)
}
function GR(e) {
    for (var t in Jt.prototype)
        e[t] = Jt.prototype[t];
    return e
}
Jt.prototype.on = Jt.prototype.addEventListener = function(e, t) {
    return this._callbacks = this._callbacks || {},
    (this._callbacks["$" + e] = this._callbacks["$" + e] || []).push(t),
    this
}
;
Jt.prototype.once = function(e, t) {
    function n() {
        this.off(e, n),
        t.apply(this, arguments)
    }
    return n.fn = t,
    this.on(e, n),
    this
}
;
Jt.prototype.off = Jt.prototype.removeListener = Jt.prototype.removeAllListeners = Jt.prototype.removeEventListener = function(e, t) {
    if (this._callbacks = this._callbacks || {},
    arguments.length == 0)
        return this._callbacks = {},
        this;
    var n = this._callbacks["$" + e];
    if (!n)
        return this;
    if (arguments.length == 1)
        return delete this._callbacks["$" + e],
        this;
    for (var a, r = 0; r < n.length; r++)
        if (a = n[r],
        a === t || a.fn === t) {
            n.splice(r, 1);
            break
        }
    return n.length === 0 && delete this._callbacks["$" + e],
    this
}
;
Jt.prototype.emit = function(e) {
    this._callbacks = this._callbacks || {};
    for (var t = new Array(arguments.length - 1), n = this._callbacks["$" + e], a = 1; a < arguments.length; a++)
        t[a - 1] = arguments[a];
    if (n) {
        n = n.slice(0);
        for (var a = 0, r = n.length; a < r; ++a)
            n[a].apply(this, t)
    }
    return this
}
;
Jt.prototype.emitReserved = Jt.prototype.emit;
Jt.prototype.listeners = function(e) {
    return this._callbacks = this._callbacks || {},
    this._callbacks["$" + e] || []
}
;
Jt.prototype.hasListeners = function(e) {
    return !!this.listeners(e).length
}
;
const Kn = ( () => typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")())();
function Eh(e, ...t) {
    return t.reduce( (n, a) => (e.hasOwnProperty(a) && (n[a] = e[a]),
    n), {})
}
const XR = Kn.setTimeout
  , KR = Kn.clearTimeout;
function _c(e, t) {
    t.useNativeTimers ? (e.setTimeoutFn = XR.bind(Kn),
    e.clearTimeoutFn = KR.bind(Kn)) : (e.setTimeoutFn = Kn.setTimeout.bind(Kn),
    e.clearTimeoutFn = Kn.clearTimeout.bind(Kn))
}
const ZR = 1.33;
function JR(e) {
    return typeof e == "string" ? QR(e) : Math.ceil((e.byteLength || e.size) * ZR)
}
function QR(e) {
    let t = 0
      , n = 0;
    for (let a = 0, r = e.length; a < r; a++)
        t = e.charCodeAt(a),
        t < 128 ? n += 1 : t < 2048 ? n += 2 : t < 55296 || t >= 57344 ? n += 3 : (a++,
        n += 4);
    return n
}
class eD extends Error {
    constructor(t, n, a) {
        super(t),
        this.description = n,
        this.context = a,
        this.type = "TransportError"
    }
}
class xh extends Jt {
    constructor(t) {
        super(),
        this.writable = !1,
        _c(this, t),
        this.opts = t,
        this.query = t.query,
        this.socket = t.socket
    }
    onError(t, n, a) {
        return super.emitReserved("error", new eD(t,n,a)),
        this
    }
    open() {
        return this.readyState = "opening",
        this.doOpen(),
        this
    }
    close() {
        return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(),
        this.onClose()),
        this
    }
    send(t) {
        this.readyState === "open" && this.write(t)
    }
    onOpen() {
        this.readyState = "open",
        this.writable = !0,
        super.emitReserved("open")
    }
    onData(t) {
        const n = _h(t, this.socket.binaryType);
        this.onPacket(n)
    }
    onPacket(t) {
        super.emitReserved("packet", t)
    }
    onClose(t) {
        this.readyState = "closed",
        super.emitReserved("close", t)
    }
    pause(t) {}
}
const Th = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split("")
  , Ru = 64
  , tD = {};
let _p = 0, Dl = 0, kp;
function Sp(e) {
    let t = "";
    do
        t = Th[e % Ru] + t,
        e = Math.floor(e / Ru);
    while (e > 0);
    return t
}
function Mh() {
    const e = Sp(+new Date);
    return e !== kp ? (_p = 0,
    kp = e) : e + "." + Sp(_p++)
}
for (; Dl < Ru; Dl++)
    tD[Th[Dl]] = Dl;
function zh(e) {
    let t = "";
    for (let n in e)
        e.hasOwnProperty(n) && (t.length && (t += "&"),
        t += encodeURIComponent(n) + "=" + encodeURIComponent(e[n]));
    return t
}
function nD(e) {
    let t = {}
      , n = e.split("&");
    for (let a = 0, r = n.length; a < r; a++) {
        let o = n[a].split("=");
        t[decodeURIComponent(o[0])] = decodeURIComponent(o[1])
    }
    return t
}
let Ah = !1;
try {
    Ah = typeof XMLHttpRequest < "u" && "withCredentials"in new XMLHttpRequest
} catch {}
const aD = Ah;
function Oh(e) {
    const t = e.xdomain;
    try {
        if (typeof XMLHttpRequest < "u" && (!t || aD))
            return new XMLHttpRequest
    } catch {}
    if (!t)
        try {
            return new Kn[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP")
        } catch {}
}
function rD() {}
const oD = function() {
    return new Oh({
        xdomain: !1
    }).responseType != null
}();
class iD extends xh {
    constructor(t) {
        if (super(t),
        this.polling = !1,
        typeof location < "u") {
            const a = location.protocol === "https:";
            let r = location.port;
            r || (r = a ? "443" : "80"),
            this.xd = typeof location < "u" && t.hostname !== location.hostname || r !== t.port,
            this.xs = t.secure !== a
        }
        const n = t && t.forceBase64;
        this.supportsBinary = oD && !n
    }
    get name() {
        return "polling"
    }
    doOpen() {
        this.poll()
    }
    pause(t) {
        this.readyState = "pausing";
        const n = () => {
            this.readyState = "paused",
            t()
        }
        ;
        if (this.polling || !this.writable) {
            let a = 0;
            this.polling && (a++,
            this.once("pollComplete", function() {
                --a || n()
            })),
            this.writable || (a++,
            this.once("drain", function() {
                --a || n()
            }))
        } else
            n()
    }
    poll() {
        this.polling = !0,
        this.doPoll(),
        this.emitReserved("poll")
    }
    onData(t) {
        const n = a => {
            if (this.readyState === "opening" && a.type === "open" && this.onOpen(),
            a.type === "close")
                return this.onClose({
                    description: "transport closed by the server"
                }),
                !1;
            this.onPacket(a)
        }
        ;
        YR(t, this.socket.binaryType).forEach(n),
        this.readyState !== "closed" && (this.polling = !1,
        this.emitReserved("pollComplete"),
        this.readyState === "open" && this.poll())
    }
    doClose() {
        const t = () => {
            this.write([{
                type: "close"
            }])
        }
        ;
        this.readyState === "open" ? t() : this.once("open", t)
    }
    write(t) {
        this.writable = !1,
        WR(t, n => {
            this.doWrite(n, () => {
                this.writable = !0,
                this.emitReserved("drain")
            }
            )
        }
        )
    }
    uri() {
        let t = this.query || {};
        const n = this.opts.secure ? "https" : "http";
        let a = "";
        this.opts.timestampRequests !== !1 && (t[this.opts.timestampParam] = Mh()),
        !this.supportsBinary && !t.sid && (t.b64 = 1),
        this.opts.port && (n === "https" && Number(this.opts.port) !== 443 || n === "http" && Number(this.opts.port) !== 80) && (a = ":" + this.opts.port);
        const r = zh(t)
          , o = this.opts.hostname.indexOf(":") !== -1;
        return n + "://" + (o ? "[" + this.opts.hostname + "]" : this.opts.hostname) + a + this.opts.path + (r.length ? "?" + r : "")
    }
    request(t={}) {
        return Object.assign(t, {
            xd: this.xd,
            xs: this.xs
        }, this.opts),
        new Ra(this.uri(),t)
    }
    doWrite(t, n) {
        const a = this.request({
            method: "POST",
            data: t
        });
        a.on("success", n),
        a.on("error", (r, o) => {
            this.onError("xhr post error", r, o)
        }
        )
    }
    doPoll() {
        const t = this.request();
        t.on("data", this.onData.bind(this)),
        t.on("error", (n, a) => {
            this.onError("xhr poll error", n, a)
        }
        ),
        this.pollXhr = t
    }
}
class Ra extends Jt {
    constructor(t, n) {
        super(),
        _c(this, n),
        this.opts = n,
        this.method = n.method || "GET",
        this.uri = t,
        this.async = n.async !== !1,
        this.data = n.data !== void 0 ? n.data : null,
        this.create()
    }
    create() {
        const t = Eh(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
        t.xdomain = !!this.opts.xd,
        t.xscheme = !!this.opts.xs;
        const n = this.xhr = new Oh(t);
        try {
            n.open(this.method, this.uri, this.async);
            try {
                if (this.opts.extraHeaders) {
                    n.setDisableHeaderCheck && n.setDisableHeaderCheck(!0);
                    for (let a in this.opts.extraHeaders)
                        this.opts.extraHeaders.hasOwnProperty(a) && n.setRequestHeader(a, this.opts.extraHeaders[a])
                }
            } catch {}
            if (this.method === "POST")
                try {
                    n.setRequestHeader("Content-type", "text/plain;charset=UTF-8")
                } catch {}
            try {
                n.setRequestHeader("Accept", "*/*")
            } catch {}
            "withCredentials"in n && (n.withCredentials = this.opts.withCredentials),
            this.opts.requestTimeout && (n.timeout = this.opts.requestTimeout),
            n.onreadystatechange = () => {
                n.readyState === 4 && (n.status === 200 || n.status === 1223 ? this.onLoad() : this.setTimeoutFn( () => {
                    this.onError(typeof n.status == "number" ? n.status : 0)
                }
                , 0))
            }
            ,
            n.send(this.data)
        } catch (a) {
            this.setTimeoutFn( () => {
                this.onError(a)
            }
            , 0);
            return
        }
        typeof document < "u" && (this.index = Ra.requestsCount++,
        Ra.requests[this.index] = this)
    }
    onError(t) {
        this.emitReserved("error", t, this.xhr),
        this.cleanup(!0)
    }
    cleanup(t) {
        if (!(typeof this.xhr > "u" || this.xhr === null)) {
            if (this.xhr.onreadystatechange = rD,
            t)
                try {
                    this.xhr.abort()
                } catch {}
            typeof document < "u" && delete Ra.requests[this.index],
            this.xhr = null
        }
    }
    onLoad() {
        const t = this.xhr.responseText;
        t !== null && (this.emitReserved("data", t),
        this.emitReserved("success"),
        this.cleanup())
    }
    abort() {
        this.cleanup()
    }
}
Ra.requestsCount = 0;
Ra.requests = {};
if (typeof document < "u") {
    if (typeof attachEvent == "function")
        attachEvent("onunload", $p);
    else if (typeof addEventListener == "function") {
        const e = "onpagehide"in Kn ? "pagehide" : "unload";
        addEventListener(e, $p, !1)
    }
}
function $p() {
    for (let e in Ra.requests)
        Ra.requests.hasOwnProperty(e) && Ra.requests[e].abort()
}
const Ph = ( () => typeof Promise == "function" && typeof Promise.resolve == "function" ? t => Promise.resolve().then(t) : (t, n) => n(t, 0))()
  , Nl = Kn.WebSocket || Kn.MozWebSocket
  , m2 = !0
  , sD = "arraybuffer"
  , Ep = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative";
class lD extends xh {
    constructor(t) {
        super(t),
        this.supportsBinary = !t.forceBase64
    }
    get name() {
        return "websocket"
    }
    doOpen() {
        if (!this.check())
            return;
        const t = this.uri()
          , n = this.opts.protocols
          , a = Ep ? {} : Eh(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
        this.opts.extraHeaders && (a.headers = this.opts.extraHeaders);
        try {
            this.ws = m2 && !Ep ? n ? new Nl(t,n) : new Nl(t) : new Nl(t,n,a)
        } catch (r) {
            return this.emitReserved("error", r)
        }
        this.ws.binaryType = this.socket.binaryType || sD,
        this.addEventListeners()
    }
    addEventListeners() {
        this.ws.onopen = () => {
            this.opts.autoUnref && this.ws._socket.unref(),
            this.onOpen()
        }
        ,
        this.ws.onclose = t => this.onClose({
            description: "websocket connection closed",
            context: t
        }),
        this.ws.onmessage = t => this.onData(t.data),
        this.ws.onerror = t => this.onError("websocket error", t)
    }
    write(t) {
        this.writable = !1;
        for (let n = 0; n < t.length; n++) {
            const a = t[n]
              , r = n === t.length - 1;
            wh(a, this.supportsBinary, o => {
                const i = {};
                m2 || (a.options && (i.compress = a.options.compress),
                this.opts.perMessageDeflate && (typeof o == "string" ? Buffer.byteLength(o) : o.length) < this.opts.perMessageDeflate.threshold && (i.compress = !1));
                try {
                    m2 ? this.ws.send(o) : this.ws.send(o, i)
                } catch {}
                r && Ph( () => {
                    this.writable = !0,
                    this.emitReserved("drain")
                }
                , this.setTimeoutFn)
            }
            )
        }
    }
    doClose() {
        typeof this.ws < "u" && (this.ws.close(),
        this.ws = null)
    }
    uri() {
        let t = this.query || {};
        const n = this.opts.secure ? "wss" : "ws";
        let a = "";
        this.opts.port && (n === "wss" && Number(this.opts.port) !== 443 || n === "ws" && Number(this.opts.port) !== 80) && (a = ":" + this.opts.port),
        this.opts.timestampRequests && (t[this.opts.timestampParam] = Mh()),
        this.supportsBinary || (t.b64 = 1);
        const r = zh(t)
          , o = this.opts.hostname.indexOf(":") !== -1;
        return n + "://" + (o ? "[" + this.opts.hostname + "]" : this.opts.hostname) + a + this.opts.path + (r.length ? "?" + r : "")
    }
    check() {
        return !!Nl
    }
}
const cD = {
    websocket: lD,
    polling: iD
}
  , uD = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
  , fD = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"];
function Du(e) {
    const t = e
      , n = e.indexOf("[")
      , a = e.indexOf("]");
    n != -1 && a != -1 && (e = e.substring(0, n) + e.substring(n, a).replace(/:/g, ";") + e.substring(a, e.length));
    let r = uD.exec(e || "")
      , o = {}
      , i = 14;
    for (; i--; )
        o[fD[i]] = r[i] || "";
    return n != -1 && a != -1 && (o.source = t,
    o.host = o.host.substring(1, o.host.length - 1).replace(/;/g, ":"),
    o.authority = o.authority.replace("[", "").replace("]", "").replace(/;/g, ":"),
    o.ipv6uri = !0),
    o.pathNames = dD(o, o.path),
    o.queryKey = pD(o, o.query),
    o
}
function dD(e, t) {
    const n = /\/{2,9}/g
      , a = t.replace(n, "/").split("/");
    return (t.slice(0, 1) == "/" || t.length === 0) && a.splice(0, 1),
    t.slice(-1) == "/" && a.splice(a.length - 1, 1),
    a
}
function pD(e, t) {
    const n = {};
    return t.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(a, r, o) {
        r && (n[r] = o)
    }),
    n
}
let sd = class qo extends Jt {
    constructor(t, n={}) {
        super(),
        this.writeBuffer = [],
        t && typeof t == "object" && (n = t,
        t = null),
        t ? (t = Du(t),
        n.hostname = t.host,
        n.secure = t.protocol === "https" || t.protocol === "wss",
        n.port = t.port,
        t.query && (n.query = t.query)) : n.host && (n.hostname = Du(n.host).host),
        _c(this, n),
        this.secure = n.secure != null ? n.secure : typeof location < "u" && location.protocol === "https:",
        n.hostname && !n.port && (n.port = this.secure ? "443" : "80"),
        this.hostname = n.hostname || (typeof location < "u" ? location.hostname : "localhost"),
        this.port = n.port || (typeof location < "u" && location.port ? location.port : this.secure ? "443" : "80"),
        this.transports = n.transports || ["polling", "websocket"],
        this.writeBuffer = [],
        this.prevBufferLen = 0,
        this.opts = Object.assign({
            path: "/engine.io",
            agent: !1,
            withCredentials: !1,
            upgrade: !0,
            timestampParam: "t",
            rememberUpgrade: !1,
            addTrailingSlash: !0,
            rejectUnauthorized: !0,
            perMessageDeflate: {
                threshold: 1024
            },
            transportOptions: {},
            closeOnBeforeunload: !0
        }, n),
        this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : ""),
        typeof this.opts.query == "string" && (this.opts.query = nD(this.opts.query)),
        this.id = null,
        this.upgrades = null,
        this.pingInterval = null,
        this.pingTimeout = null,
        this.pingTimeoutTimer = null,
        typeof addEventListener == "function" && (this.opts.closeOnBeforeunload && (this.beforeunloadEventListener = () => {
            this.transport && (this.transport.removeAllListeners(),
            this.transport.close())
        }
        ,
        addEventListener("beforeunload", this.beforeunloadEventListener, !1)),
        this.hostname !== "localhost" && (this.offlineEventListener = () => {
            this.onClose("transport close", {
                description: "network connection lost"
            })
        }
        ,
        addEventListener("offline", this.offlineEventListener, !1))),
        this.open()
    }
    createTransport(t) {
        const n = Object.assign({}, this.opts.query);
        n.EIO = $h,
        n.transport = t,
        this.id && (n.sid = this.id);
        const a = Object.assign({}, this.opts.transportOptions[t], this.opts, {
            query: n,
            socket: this,
            hostname: this.hostname,
            secure: this.secure,
            port: this.port
        });
        return new cD[t](a)
    }
    open() {
        let t;
        if (this.opts.rememberUpgrade && qo.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1)
            t = "websocket";
        else if (this.transports.length === 0) {
            this.setTimeoutFn( () => {
                this.emitReserved("error", "No transports available")
            }
            , 0);
            return
        } else
            t = this.transports[0];
        this.readyState = "opening";
        try {
            t = this.createTransport(t)
        } catch {
            this.transports.shift(),
            this.open();
            return
        }
        t.open(),
        this.setTransport(t)
    }
    setTransport(t) {
        this.transport && this.transport.removeAllListeners(),
        this.transport = t,
        t.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", n => this.onClose("transport close", n))
    }
    probe(t) {
        let n = this.createTransport(t)
          , a = !1;
        qo.priorWebsocketSuccess = !1;
        const r = () => {
            a || (n.send([{
                type: "ping",
                data: "probe"
            }]),
            n.once("packet", f => {
                if (!a)
                    if (f.type === "pong" && f.data === "probe") {
                        if (this.upgrading = !0,
                        this.emitReserved("upgrading", n),
                        !n)
                            return;
                        qo.priorWebsocketSuccess = n.name === "websocket",
                        this.transport.pause( () => {
                            a || this.readyState !== "closed" && (u(),
                            this.setTransport(n),
                            n.send([{
                                type: "upgrade"
                            }]),
                            this.emitReserved("upgrade", n),
                            n = null,
                            this.upgrading = !1,
                            this.flush())
                        }
                        )
                    } else {
                        const d = new Error("probe error");
                        d.transport = n.name,
                        this.emitReserved("upgradeError", d)
                    }
            }
            ))
        }
        ;
        function o() {
            a || (a = !0,
            u(),
            n.close(),
            n = null)
        }
        const i = f => {
            const d = new Error("probe error: " + f);
            d.transport = n.name,
            o(),
            this.emitReserved("upgradeError", d)
        }
        ;
        function s() {
            i("transport closed")
        }
        function l() {
            i("socket closed")
        }
        function c(f) {
            n && f.name !== n.name && o()
        }
        const u = () => {
            n.removeListener("open", r),
            n.removeListener("error", i),
            n.removeListener("close", s),
            this.off("close", l),
            this.off("upgrading", c)
        }
        ;
        n.once("open", r),
        n.once("error", i),
        n.once("close", s),
        this.once("close", l),
        this.once("upgrading", c),
        n.open()
    }
    onOpen() {
        if (this.readyState = "open",
        qo.priorWebsocketSuccess = this.transport.name === "websocket",
        this.emitReserved("open"),
        this.flush(),
        this.readyState === "open" && this.opts.upgrade) {
            let t = 0;
            const n = this.upgrades.length;
            for (; t < n; t++)
                this.probe(this.upgrades[t])
        }
    }
    onPacket(t) {
        if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing")
            switch (this.emitReserved("packet", t),
            this.emitReserved("heartbeat"),
            t.type) {
            case "open":
                this.onHandshake(JSON.parse(t.data));
                break;
            case "ping":
                this.resetPingTimeout(),
                this.sendPacket("pong"),
                this.emitReserved("ping"),
                this.emitReserved("pong");
                break;
            case "error":
                const n = new Error("server error");
                n.code = t.data,
                this.onError(n);
                break;
            case "message":
                this.emitReserved("data", t.data),
                this.emitReserved("message", t.data);
                break
            }
    }
    onHandshake(t) {
        this.emitReserved("handshake", t),
        this.id = t.sid,
        this.transport.query.sid = t.sid,
        this.upgrades = this.filterUpgrades(t.upgrades),
        this.pingInterval = t.pingInterval,
        this.pingTimeout = t.pingTimeout,
        this.maxPayload = t.maxPayload,
        this.onOpen(),
        this.readyState !== "closed" && this.resetPingTimeout()
    }
    resetPingTimeout() {
        this.clearTimeoutFn(this.pingTimeoutTimer),
        this.pingTimeoutTimer = this.setTimeoutFn( () => {
            this.onClose("ping timeout")
        }
        , this.pingInterval + this.pingTimeout),
        this.opts.autoUnref && this.pingTimeoutTimer.unref()
    }
    onDrain() {
        this.writeBuffer.splice(0, this.prevBufferLen),
        this.prevBufferLen = 0,
        this.writeBuffer.length === 0 ? this.emitReserved("drain") : this.flush()
    }
    flush() {
        if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
            const t = this.getWritablePackets();
            this.transport.send(t),
            this.prevBufferLen = t.length,
            this.emitReserved("flush")
        }
    }
    getWritablePackets() {
        if (!(this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1))
            return this.writeBuffer;
        let n = 1;
        for (let a = 0; a < this.writeBuffer.length; a++) {
            const r = this.writeBuffer[a].data;
            if (r && (n += JR(r)),
            a > 0 && n > this.maxPayload)
                return this.writeBuffer.slice(0, a);
            n += 2
        }
        return this.writeBuffer
    }
    write(t, n, a) {
        return this.sendPacket("message", t, n, a),
        this
    }
    send(t, n, a) {
        return this.sendPacket("message", t, n, a),
        this
    }
    sendPacket(t, n, a, r) {
        if (typeof n == "function" && (r = n,
        n = void 0),
        typeof a == "function" && (r = a,
        a = null),
        this.readyState === "closing" || this.readyState === "closed")
            return;
        a = a || {},
        a.compress = a.compress !== !1;
        const o = {
            type: t,
            data: n,
            options: a
        };
        this.emitReserved("packetCreate", o),
        this.writeBuffer.push(o),
        r && this.once("flush", r),
        this.flush()
    }
    close() {
        const t = () => {
            this.onClose("forced close"),
            this.transport.close()
        }
          , n = () => {
            this.off("upgrade", n),
            this.off("upgradeError", n),
            t()
        }
          , a = () => {
            this.once("upgrade", n),
            this.once("upgradeError", n)
        }
        ;
        return (this.readyState === "opening" || this.readyState === "open") && (this.readyState = "closing",
        this.writeBuffer.length ? this.once("drain", () => {
            this.upgrading ? a() : t()
        }
        ) : this.upgrading ? a() : t()),
        this
    }
    onError(t) {
        qo.priorWebsocketSuccess = !1,
        this.emitReserved("error", t),
        this.onClose("transport error", t)
    }
    onClose(t, n) {
        (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") && (this.clearTimeoutFn(this.pingTimeoutTimer),
        this.transport.removeAllListeners("close"),
        this.transport.close(),
        this.transport.removeAllListeners(),
        typeof removeEventListener == "function" && (removeEventListener("beforeunload", this.beforeunloadEventListener, !1),
        removeEventListener("offline", this.offlineEventListener, !1)),
        this.readyState = "closed",
        this.id = null,
        this.emitReserved("close", t, n),
        this.writeBuffer = [],
        this.prevBufferLen = 0)
    }
    filterUpgrades(t) {
        const n = [];
        let a = 0;
        const r = t.length;
        for (; a < r; a++)
            ~this.transports.indexOf(t[a]) && n.push(t[a]);
        return n
    }
}
;
sd.protocol = $h;
const OU = sd.protocol;
function hD(e, t="", n) {
    let a = e;
    n = n || typeof location < "u" && location,
    e == null && (e = n.protocol + "//" + n.host),
    typeof e == "string" && (e.charAt(0) === "/" && (e.charAt(1) === "/" ? e = n.protocol + e : e = n.host + e),
    /^(https?|wss?):\/\//.test(e) || (typeof n < "u" ? e = n.protocol + "//" + e : e = "https://" + e),
    a = Du(e)),
    a.port || (/^(http|ws)$/.test(a.protocol) ? a.port = "80" : /^(http|ws)s$/.test(a.protocol) && (a.port = "443")),
    a.path = a.path || "/";
    const o = a.host.indexOf(":") !== -1 ? "[" + a.host + "]" : a.host;
    return a.id = a.protocol + "://" + o + ":" + a.port + t,
    a.href = a.protocol + "://" + o + (n && n.port === a.port ? "" : ":" + a.port),
    a
}
const mD = typeof ArrayBuffer == "function"
  , gD = e => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(e) : e.buffer instanceof ArrayBuffer
  , Lh = Object.prototype.toString
  , vD = typeof Blob == "function" || typeof Blob < "u" && Lh.call(Blob) === "[object BlobConstructor]"
  , bD = typeof File == "function" || typeof File < "u" && Lh.call(File) === "[object FileConstructor]";
function ld(e) {
    return mD && (e instanceof ArrayBuffer || gD(e)) || vD && e instanceof Blob || bD && e instanceof File
}
function a1(e, t) {
    if (!e || typeof e != "object")
        return !1;
    if (Array.isArray(e)) {
        for (let n = 0, a = e.length; n < a; n++)
            if (a1(e[n]))
                return !0;
        return !1
    }
    if (ld(e))
        return !0;
    if (e.toJSON && typeof e.toJSON == "function" && arguments.length === 1)
        return a1(e.toJSON(), !0);
    for (const n in e)
        if (Object.prototype.hasOwnProperty.call(e, n) && a1(e[n]))
            return !0;
    return !1
}
function yD(e) {
    const t = []
      , n = e.data
      , a = e;
    return a.data = Nu(n, t),
    a.attachments = t.length,
    {
        packet: a,
        buffers: t
    }
}
function Nu(e, t) {
    if (!e)
        return e;
    if (ld(e)) {
        const n = {
            _placeholder: !0,
            num: t.length
        };
        return t.push(e),
        n
    } else if (Array.isArray(e)) {
        const n = new Array(e.length);
        for (let a = 0; a < e.length; a++)
            n[a] = Nu(e[a], t);
        return n
    } else if (typeof e == "object" && !(e instanceof Date)) {
        const n = {};
        for (const a in e)
            Object.prototype.hasOwnProperty.call(e, a) && (n[a] = Nu(e[a], t));
        return n
    }
    return e
}
function CD(e, t) {
    return e.data = Hu(e.data, t),
    delete e.attachments,
    e
}
function Hu(e, t) {
    if (!e)
        return e;
    if (e && e._placeholder === !0) {
        if (typeof e.num == "number" && e.num >= 0 && e.num < t.length)
            return t[e.num];
        throw new Error("illegal attachments")
    } else if (Array.isArray(e))
        for (let n = 0; n < e.length; n++)
            e[n] = Hu(e[n], t);
    else if (typeof e == "object")
        for (const n in e)
            Object.prototype.hasOwnProperty.call(e, n) && (e[n] = Hu(e[n], t));
    return e
}
const wD = 5;
var gt;
(function(e) {
    e[e.CONNECT = 0] = "CONNECT",
    e[e.DISCONNECT = 1] = "DISCONNECT",
    e[e.EVENT = 2] = "EVENT",
    e[e.ACK = 3] = "ACK",
    e[e.CONNECT_ERROR = 4] = "CONNECT_ERROR",
    e[e.BINARY_EVENT = 5] = "BINARY_EVENT",
    e[e.BINARY_ACK = 6] = "BINARY_ACK"
}
)(gt || (gt = {}));
class _D {
    constructor(t) {
        this.replacer = t
    }
    encode(t) {
        return (t.type === gt.EVENT || t.type === gt.ACK) && a1(t) ? this.encodeAsBinary({
            type: t.type === gt.EVENT ? gt.BINARY_EVENT : gt.BINARY_ACK,
            nsp: t.nsp,
            data: t.data,
            id: t.id
        }) : [this.encodeAsString(t)]
    }
    encodeAsString(t) {
        let n = "" + t.type;
        return (t.type === gt.BINARY_EVENT || t.type === gt.BINARY_ACK) && (n += t.attachments + "-"),
        t.nsp && t.nsp !== "/" && (n += t.nsp + ","),
        t.id != null && (n += t.id),
        t.data != null && (n += JSON.stringify(t.data, this.replacer)),
        n
    }
    encodeAsBinary(t) {
        const n = yD(t)
          , a = this.encodeAsString(n.packet)
          , r = n.buffers;
        return r.unshift(a),
        r
    }
}
class cd extends Jt {
    constructor(t) {
        super(),
        this.reviver = t
    }
    add(t) {
        let n;
        if (typeof t == "string") {
            if (this.reconstructor)
                throw new Error("got plaintext data when reconstructing a packet");
            n = this.decodeString(t);
            const a = n.type === gt.BINARY_EVENT;
            a || n.type === gt.BINARY_ACK ? (n.type = a ? gt.EVENT : gt.ACK,
            this.reconstructor = new kD(n),
            n.attachments === 0 && super.emitReserved("decoded", n)) : super.emitReserved("decoded", n)
        } else if (ld(t) || t.base64)
            if (this.reconstructor)
                n = this.reconstructor.takeBinaryData(t),
                n && (this.reconstructor = null,
                super.emitReserved("decoded", n));
            else
                throw new Error("got binary data when not reconstructing a packet");
        else
            throw new Error("Unknown type: " + t)
    }
    decodeString(t) {
        let n = 0;
        const a = {
            type: Number(t.charAt(0))
        };
        if (gt[a.type] === void 0)
            throw new Error("unknown packet type " + a.type);
        if (a.type === gt.BINARY_EVENT || a.type === gt.BINARY_ACK) {
            const o = n + 1;
            for (; t.charAt(++n) !== "-" && n != t.length; )
                ;
            const i = t.substring(o, n);
            if (i != Number(i) || t.charAt(n) !== "-")
                throw new Error("Illegal attachments");
            a.attachments = Number(i)
        }
        if (t.charAt(n + 1) === "/") {
            const o = n + 1;
            for (; ++n && !(t.charAt(n) === "," || n === t.length); )
                ;
            a.nsp = t.substring(o, n)
        } else
            a.nsp = "/";
        const r = t.charAt(n + 1);
        if (r !== "" && Number(r) == r) {
            const o = n + 1;
            for (; ++n; ) {
                const i = t.charAt(n);
                if (i == null || Number(i) != i) {
                    --n;
                    break
                }
                if (n === t.length)
                    break
            }
            a.id = Number(t.substring(o, n + 1))
        }
        if (t.charAt(++n)) {
            const o = this.tryParse(t.substr(n));
            if (cd.isPayloadValid(a.type, o))
                a.data = o;
            else
                throw new Error("invalid payload")
        }
        return a
    }
    tryParse(t) {
        try {
            return JSON.parse(t, this.reviver)
        } catch {
            return !1
        }
    }
    static isPayloadValid(t, n) {
        switch (t) {
        case gt.CONNECT:
            return typeof n == "object";
        case gt.DISCONNECT:
            return n === void 0;
        case gt.CONNECT_ERROR:
            return typeof n == "string" || typeof n == "object";
        case gt.EVENT:
        case gt.BINARY_EVENT:
            return Array.isArray(n) && n.length > 0;
        case gt.ACK:
        case gt.BINARY_ACK:
            return Array.isArray(n)
        }
    }
    destroy() {
        this.reconstructor && (this.reconstructor.finishedReconstruction(),
        this.reconstructor = null)
    }
}
class kD {
    constructor(t) {
        this.packet = t,
        this.buffers = [],
        this.reconPack = t
    }
    takeBinaryData(t) {
        if (this.buffers.push(t),
        this.buffers.length === this.reconPack.attachments) {
            const n = CD(this.reconPack, this.buffers);
            return this.finishedReconstruction(),
            n
        }
        return null
    }
    finishedReconstruction() {
        this.reconPack = null,
        this.buffers = []
    }
}
const SD = Object.freeze(Object.defineProperty({
    __proto__: null,
    Decoder: cd,
    Encoder: _D,
    get PacketType() {
        return gt
    },
    protocol: wD
}, Symbol.toStringTag, {
    value: "Module"
}));
function fa(e, t, n) {
    return e.on(t, n),
    function() {
        e.off(t, n)
    }
}
const $D = Object.freeze({
    connect: 1,
    connect_error: 1,
    disconnect: 1,
    disconnecting: 1,
    newListener: 1,
    removeListener: 1
});
class Ih extends Jt {
    constructor(t, n, a) {
        super(),
        this.connected = !1,
        this.recovered = !1,
        this.receiveBuffer = [],
        this.sendBuffer = [],
        this._queue = [],
        this._queueSeq = 0,
        this.ids = 0,
        this.acks = {},
        this.flags = {},
        this.io = t,
        this.nsp = n,
        a && a.auth && (this.auth = a.auth),
        this._opts = Object.assign({}, a),
        this.io._autoConnect && this.open()
    }
    get disconnected() {
        return !this.connected
    }
    subEvents() {
        if (this.subs)
            return;
        const t = this.io;
        this.subs = [fa(t, "open", this.onopen.bind(this)), fa(t, "packet", this.onpacket.bind(this)), fa(t, "error", this.onerror.bind(this)), fa(t, "close", this.onclose.bind(this))]
    }
    get active() {
        return !!this.subs
    }
    connect() {
        return this.connected ? this : (this.subEvents(),
        this.io._reconnecting || this.io.open(),
        this.io._readyState === "open" && this.onopen(),
        this)
    }
    open() {
        return this.connect()
    }
    send(...t) {
        return t.unshift("message"),
        this.emit.apply(this, t),
        this
    }
    emit(t, ...n) {
        if ($D.hasOwnProperty(t))
            throw new Error('"' + t.toString() + '" is a reserved event name');
        if (n.unshift(t),
        this._opts.retries && !this.flags.fromQueue && !this.flags.volatile)
            return this._addToQueue(n),
            this;
        const a = {
            type: gt.EVENT,
            data: n
        };
        if (a.options = {},
        a.options.compress = this.flags.compress !== !1,
        typeof n[n.length - 1] == "function") {
            const i = this.ids++
              , s = n.pop();
            this._registerAckCallback(i, s),
            a.id = i
        }
        const r = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
        return this.flags.volatile && (!r || !this.connected) || (this.connected ? (this.notifyOutgoingListeners(a),
        this.packet(a)) : this.sendBuffer.push(a)),
        this.flags = {},
        this
    }
    _registerAckCallback(t, n) {
        var a;
        const r = (a = this.flags.timeout) !== null && a !== void 0 ? a : this._opts.ackTimeout;
        if (r === void 0) {
            this.acks[t] = n;
            return
        }
        const o = this.io.setTimeoutFn( () => {
            delete this.acks[t];
            for (let i = 0; i < this.sendBuffer.length; i++)
                this.sendBuffer[i].id === t && this.sendBuffer.splice(i, 1);
            n.call(this, new Error("operation has timed out"))
        }
        , r);
        this.acks[t] = (...i) => {
            this.io.clearTimeoutFn(o),
            n.apply(this, [null, ...i])
        }
    }
    emitWithAck(t, ...n) {
        const a = this.flags.timeout !== void 0 || this._opts.ackTimeout !== void 0;
        return new Promise( (r, o) => {
            n.push( (i, s) => a ? i ? o(i) : r(s) : r(i)),
            this.emit(t, ...n)
        }
        )
    }
    _addToQueue(t) {
        let n;
        typeof t[t.length - 1] == "function" && (n = t.pop());
        const a = {
            id: this._queueSeq++,
            tryCount: 0,
            pending: !1,
            args: t,
            flags: Object.assign({
                fromQueue: !0
            }, this.flags)
        };
        t.push( (r, ...o) => a !== this._queue[0] ? void 0 : (r !== null ? a.tryCount > this._opts.retries && (this._queue.shift(),
        n && n(r)) : (this._queue.shift(),
        n && n(null, ...o)),
        a.pending = !1,
        this._drainQueue())),
        this._queue.push(a),
        this._drainQueue()
    }
    _drainQueue(t=!1) {
        if (!this.connected || this._queue.length === 0)
            return;
        const n = this._queue[0];
        n.pending && !t || (n.pending = !0,
        n.tryCount++,
        this.flags = n.flags,
        this.emit.apply(this, n.args))
    }
    packet(t) {
        t.nsp = this.nsp,
        this.io._packet(t)
    }
    onopen() {
        typeof this.auth == "function" ? this.auth(t => {
            this._sendConnectPacket(t)
        }
        ) : this._sendConnectPacket(this.auth)
    }
    _sendConnectPacket(t) {
        this.packet({
            type: gt.CONNECT,
            data: this._pid ? Object.assign({
                pid: this._pid,
                offset: this._lastOffset
            }, t) : t
        })
    }
    onerror(t) {
        this.connected || this.emitReserved("connect_error", t)
    }
    onclose(t, n) {
        this.connected = !1,
        delete this.id,
        this.emitReserved("disconnect", t, n)
    }
    onpacket(t) {
        if (t.nsp === this.nsp)
            switch (t.type) {
            case gt.CONNECT:
                t.data && t.data.sid ? this.onconnect(t.data.sid, t.data.pid) : this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
                break;
            case gt.EVENT:
            case gt.BINARY_EVENT:
                this.onevent(t);
                break;
            case gt.ACK:
            case gt.BINARY_ACK:
                this.onack(t);
                break;
            case gt.DISCONNECT:
                this.ondisconnect();
                break;
            case gt.CONNECT_ERROR:
                this.destroy();
                const a = new Error(t.data.message);
                a.data = t.data.data,
                this.emitReserved("connect_error", a);
                break
            }
    }
    onevent(t) {
        const n = t.data || [];
        t.id != null && n.push(this.ack(t.id)),
        this.connected ? this.emitEvent(n) : this.receiveBuffer.push(Object.freeze(n))
    }
    emitEvent(t) {
        if (this._anyListeners && this._anyListeners.length) {
            const n = this._anyListeners.slice();
            for (const a of n)
                a.apply(this, t)
        }
        super.emit.apply(this, t),
        this._pid && t.length && typeof t[t.length - 1] == "string" && (this._lastOffset = t[t.length - 1])
    }
    ack(t) {
        const n = this;
        let a = !1;
        return function(...r) {
            a || (a = !0,
            n.packet({
                type: gt.ACK,
                id: t,
                data: r
            }))
        }
    }
    onack(t) {
        const n = this.acks[t.id];
        typeof n == "function" && (n.apply(this, t.data),
        delete this.acks[t.id])
    }
    onconnect(t, n) {
        this.id = t,
        this.recovered = n && this._pid === n,
        this._pid = n,
        this.connected = !0,
        this.emitBuffered(),
        this.emitReserved("connect"),
        this._drainQueue(!0)
    }
    emitBuffered() {
        this.receiveBuffer.forEach(t => this.emitEvent(t)),
        this.receiveBuffer = [],
        this.sendBuffer.forEach(t => {
            this.notifyOutgoingListeners(t),
            this.packet(t)
        }
        ),
        this.sendBuffer = []
    }
    ondisconnect() {
        this.destroy(),
        this.onclose("io server disconnect")
    }
    destroy() {
        this.subs && (this.subs.forEach(t => t()),
        this.subs = void 0),
        this.io._destroy(this)
    }
    disconnect() {
        return this.connected && this.packet({
            type: gt.DISCONNECT
        }),
        this.destroy(),
        this.connected && this.onclose("io client disconnect"),
        this
    }
    close() {
        return this.disconnect()
    }
    compress(t) {
        return this.flags.compress = t,
        this
    }
    get volatile() {
        return this.flags.volatile = !0,
        this
    }
    timeout(t) {
        return this.flags.timeout = t,
        this
    }
    onAny(t) {
        return this._anyListeners = this._anyListeners || [],
        this._anyListeners.push(t),
        this
    }
    prependAny(t) {
        return this._anyListeners = this._anyListeners || [],
        this._anyListeners.unshift(t),
        this
    }
    offAny(t) {
        if (!this._anyListeners)
            return this;
        if (t) {
            const n = this._anyListeners;
            for (let a = 0; a < n.length; a++)
                if (t === n[a])
                    return n.splice(a, 1),
                    this
        } else
            this._anyListeners = [];
        return this
    }
    listenersAny() {
        return this._anyListeners || []
    }
    onAnyOutgoing(t) {
        return this._anyOutgoingListeners = this._anyOutgoingListeners || [],
        this._anyOutgoingListeners.push(t),
        this
    }
    prependAnyOutgoing(t) {
        return this._anyOutgoingListeners = this._anyOutgoingListeners || [],
        this._anyOutgoingListeners.unshift(t),
        this
    }
    offAnyOutgoing(t) {
        if (!this._anyOutgoingListeners)
            return this;
        if (t) {
            const n = this._anyOutgoingListeners;
            for (let a = 0; a < n.length; a++)
                if (t === n[a])
                    return n.splice(a, 1),
                    this
        } else
            this._anyOutgoingListeners = [];
        return this
    }
    listenersAnyOutgoing() {
        return this._anyOutgoingListeners || []
    }
    notifyOutgoingListeners(t) {
        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
            const n = this._anyOutgoingListeners.slice();
            for (const a of n)
                a.apply(this, t.data)
        }
    }
}
function zi(e) {
    e = e || {},
    this.ms = e.min || 100,
    this.max = e.max || 1e4,
    this.factor = e.factor || 2,
    this.jitter = e.jitter > 0 && e.jitter <= 1 ? e.jitter : 0,
    this.attempts = 0
}
zi.prototype.duration = function() {
    var e = this.ms * Math.pow(this.factor, this.attempts++);
    if (this.jitter) {
        var t = Math.random()
          , n = Math.floor(t * this.jitter * e);
        e = Math.floor(t * 10) & 1 ? e + n : e - n
    }
    return Math.min(e, this.max) | 0
}
;
zi.prototype.reset = function() {
    this.attempts = 0
}
;
zi.prototype.setMin = function(e) {
    this.ms = e
}
;
zi.prototype.setMax = function(e) {
    this.max = e
}
;
zi.prototype.setJitter = function(e) {
    this.jitter = e
}
;
class Vu extends Jt {
    constructor(t, n) {
        var a;
        super(),
        this.nsps = {},
        this.subs = [],
        t && typeof t == "object" && (n = t,
        t = void 0),
        n = n || {},
        n.path = n.path || "/socket.io",
        this.opts = n,
        _c(this, n),
        this.reconnection(n.reconnection !== !1),
        this.reconnectionAttempts(n.reconnectionAttempts || 1 / 0),
        this.reconnectionDelay(n.reconnectionDelay || 1e3),
        this.reconnectionDelayMax(n.reconnectionDelayMax || 5e3),
        this.randomizationFactor((a = n.randomizationFactor) !== null && a !== void 0 ? a : .5),
        this.backoff = new zi({
            min: this.reconnectionDelay(),
            max: this.reconnectionDelayMax(),
            jitter: this.randomizationFactor()
        }),
        this.timeout(n.timeout == null ? 2e4 : n.timeout),
        this._readyState = "closed",
        this.uri = t;
        const r = n.parser || SD;
        this.encoder = new r.Encoder,
        this.decoder = new r.Decoder,
        this._autoConnect = n.autoConnect !== !1,
        this._autoConnect && this.open()
    }
    reconnection(t) {
        return arguments.length ? (this._reconnection = !!t,
        this) : this._reconnection
    }
    reconnectionAttempts(t) {
        return t === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = t,
        this)
    }
    reconnectionDelay(t) {
        var n;
        return t === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = t,
        (n = this.backoff) === null || n === void 0 || n.setMin(t),
        this)
    }
    randomizationFactor(t) {
        var n;
        return t === void 0 ? this._randomizationFactor : (this._randomizationFactor = t,
        (n = this.backoff) === null || n === void 0 || n.setJitter(t),
        this)
    }
    reconnectionDelayMax(t) {
        var n;
        return t === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = t,
        (n = this.backoff) === null || n === void 0 || n.setMax(t),
        this)
    }
    timeout(t) {
        return arguments.length ? (this._timeout = t,
        this) : this._timeout
    }
    maybeReconnectOnOpen() {
        !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect()
    }
    open(t) {
        if (~this._readyState.indexOf("open"))
            return this;
        this.engine = new sd(this.uri,this.opts);
        const n = this.engine
          , a = this;
        this._readyState = "opening",
        this.skipReconnect = !1;
        const r = fa(n, "open", function() {
            a.onopen(),
            t && t()
        })
          , o = fa(n, "error", i => {
            a.cleanup(),
            a._readyState = "closed",
            this.emitReserved("error", i),
            t ? t(i) : a.maybeReconnectOnOpen()
        }
        );
        if (this._timeout !== !1) {
            const i = this._timeout;
            i === 0 && r();
            const s = this.setTimeoutFn( () => {
                r(),
                n.close(),
                n.emit("error", new Error("timeout"))
            }
            , i);
            this.opts.autoUnref && s.unref(),
            this.subs.push(function() {
                clearTimeout(s)
            })
        }
        return this.subs.push(r),
        this.subs.push(o),
        this
    }
    connect(t) {
        return this.open(t)
    }
    onopen() {
        this.cleanup(),
        this._readyState = "open",
        this.emitReserved("open");
        const t = this.engine;
        this.subs.push(fa(t, "ping", this.onping.bind(this)), fa(t, "data", this.ondata.bind(this)), fa(t, "error", this.onerror.bind(this)), fa(t, "close", this.onclose.bind(this)), fa(this.decoder, "decoded", this.ondecoded.bind(this)))
    }
    onping() {
        this.emitReserved("ping")
    }
    ondata(t) {
        try {
            this.decoder.add(t)
        } catch (n) {
            this.onclose("parse error", n)
        }
    }
    ondecoded(t) {
        Ph( () => {
            this.emitReserved("packet", t)
        }
        , this.setTimeoutFn)
    }
    onerror(t) {
        this.emitReserved("error", t)
    }
    socket(t, n) {
        let a = this.nsps[t];
        return a ? this._autoConnect && !a.active && a.connect() : (a = new Ih(this,t,n),
        this.nsps[t] = a),
        a
    }
    _destroy(t) {
        const n = Object.keys(this.nsps);
        for (const a of n)
            if (this.nsps[a].active)
                return;
        this._close()
    }
    _packet(t) {
        const n = this.encoder.encode(t);
        for (let a = 0; a < n.length; a++)
            this.engine.write(n[a], t.options)
    }
    cleanup() {
        this.subs.forEach(t => t()),
        this.subs.length = 0,
        this.decoder.destroy()
    }
    _close() {
        this.skipReconnect = !0,
        this._reconnecting = !1,
        this.onclose("forced close"),
        this.engine && this.engine.close()
    }
    disconnect() {
        return this._close()
    }
    onclose(t, n) {
        this.cleanup(),
        this.backoff.reset(),
        this._readyState = "closed",
        this.emitReserved("close", t, n),
        this._reconnection && !this.skipReconnect && this.reconnect()
    }
    reconnect() {
        if (this._reconnecting || this.skipReconnect)
            return this;
        const t = this;
        if (this.backoff.attempts >= this._reconnectionAttempts)
            this.backoff.reset(),
            this.emitReserved("reconnect_failed"),
            this._reconnecting = !1;
        else {
            const n = this.backoff.duration();
            this._reconnecting = !0;
            const a = this.setTimeoutFn( () => {
                t.skipReconnect || (this.emitReserved("reconnect_attempt", t.backoff.attempts),
                !t.skipReconnect && t.open(r => {
                    r ? (t._reconnecting = !1,
                    t.reconnect(),
                    this.emitReserved("reconnect_error", r)) : t.onreconnect()
                }
                ))
            }
            , n);
            this.opts.autoUnref && a.unref(),
            this.subs.push(function() {
                clearTimeout(a)
            })
        }
    }
    onreconnect() {
        const t = this.backoff.attempts;
        this._reconnecting = !1,
        this.backoff.reset(),
        this.emitReserved("reconnect", t)
    }
}
const Ui = {};
function r1(e, t) {
    typeof e == "object" && (t = e,
    e = void 0),
    t = t || {};
    const n = hD(e, t.path || "/socket.io")
      , a = n.source
      , r = n.id
      , o = n.path
      , i = Ui[r] && o in Ui[r].nsps
      , s = t.forceNew || t["force new connection"] || t.multiplex === !1 || i;
    let l;
    return s ? l = new Vu(a,t) : (Ui[r] || (Ui[r] = new Vu(a,t)),
    l = Ui[r]),
    n.query && !t.query && (t.query = n.queryKey),
    l.socket(n.path, t)
}
Object.assign(r1, {
    Manager: Vu,
    Socket: Ih,
    io: r1,
    connect: r1
});
class ED {
    constructor(t, n, a, r) {
        this.host = t,
        this.deviceId = n,
        this.stateApi = a,
        this.afterSign = r,
        this.readyPromise = new Promise(o => {
            this.resolveReady = o
        }
        ),
        this.socket = this.initSocket()
    }
    initSocket() {
        const t = r1(this.host, {
            transports: ["websocket"],
            query: {
                device_id: this.deviceId
            }
        });
        return t.on("connect", () => {
            console.log("SOCKET CONNECTED!"),
            this.resolveReady()
        }
        ),
        t.on("callback", n => {
            if (!this.stateApi.getSigningStageKey) {
                this.disconnect();
                return
            }
            switch (n.status) {
            case "process":
                this.stateApi.setSigningStageKey("sign_process"),
                this.stateApi.setSigningStageData(n.message);
                break;
            case !0:
                this.disconnect(),
                this.stateApi.setSigningStageKey("ready_to_install"),
                this.afterSign(n);
                break;
            default:
                this.disconnect(),
                console.error("SIGNING ERROR", n.message),
                D.dialog.alert(n.message, "Error")
            }
        }
        ),
        t.on("connect_error", () => {
            console.error("SOCKET ERROR!"),
            D.dialog.alert("Connection failed. Try again or contact technical support.", "Error"),
            this.resetState(),
            this.destroy()
        }
        ),
        t.on("disconnect", n => {
            console.log("SOCKET DISCONNECTED!", n),
            this.resetState(),
            this.destroy()
        }
        ),
        t
    }
    async startSign(t) {
        await this.readyPromise,
        this.socket.emit("start_sign", t)
    }
    resetState() {
        this.stateApi.setSigningStageKey(null),
        this.stateApi.setSigningStageData(null)
    }
    disconnect() {
        this.socket.disconnect()
    }
    destroy() {
        this.socket.destroy()
    }
}
var I1 = {}
  , xD = {
    get exports() {
        return I1
    },
    set exports(e) {
        I1 = e
    }
};
(function(e, t) {
    "use strict";
    (function() {
        var n = 0;
        function a() {
            return n++
        }
        function r(s, l) {
            l = l || {};
            var c = this
              , u = this.socket
              , f = this.chunkSize
              , d = this.transmissionDelay
              , p = s.uploadId
              , h = l.uploadTo || ""
              , m = l.data || {}
              , g = {
                id: p,
                name: s.name,
                size: s.size,
                chunkSize: f,
                sent: 0,
                data: m
            };
            h && (g.uploadTo = h);
            var b = new FileReader;
            b.onloadstart = function() {
                c.emit("loadstart")
            }
            ,
            b.onprogress = function(v) {
                c.emit("progress", {
                    loaded: v.loaded,
                    total: v.total
                })
            }
            ,
            b.onloadend = function() {
                var v = b.result;
                if (c.accepts && c.accepts.length > 0) {
                    for (var y = !1, w = 0; w < c.accepts.length; w++) {
                        var C = c.accepts[w];
                        if (s.type === C) {
                            y = !0;
                            break
                        }
                    }
                    if (!y)
                        return c.emit("error", new Error("Not Acceptable file type " + s.type + " of " + s.name + ". Type must be one of these: " + c.accepts.join(", ")), {
                            uploadId: g.id,
                            name: g.name,
                            size: g.size,
                            type: s.type,
                            uploadTo: h,
                            data: m
                        })
                }
                if (c.maxFileSize && c.maxFileSize > 0 && s.size > +c.maxFileSize)
                    return c.emit("error", new Error("Max Uploading File size must be under " + c.maxFileSize + " byte(s)."), {
                        uploadId: g.id,
                        name: g.name,
                        size: g.size,
                        uploadTo: h,
                        data: m
                    });
                c.uploadingFiles[p] = g,
                c.emit("start", {
                    uploadId: g.id,
                    name: g.name,
                    size: g.size,
                    uploadTo: h,
                    data: m
                }),
                u.emit("socket.io-file::createFile", g);
                function _() {
                    if (!g.aborted) {
                        if (g.sent >= v.byteLength) {
                            u.emit("socket.io-file::done::" + p);
                            return
                        }
                        var E = v.slice(g.sent, g.sent + f);
                        c.emit("stream", {
                            uploadId: g.id,
                            name: g.name,
                            size: g.size,
                            sent: g.sent,
                            uploadTo: h,
                            data: m
                        }),
                        u.once("socket.io-file::request::" + p, _),
                        u.emit("socket.io-file::stream::" + p, E),
                        g.sent += E.byteLength,
                        c.uploadingFiles[p] = g
                    }
                }
                u.once("socket.io-file::request::" + p, _),
                u.on("socket.io-file::complete::" + p, function(E) {
                    E.uploadId = g.id,
                    E.data = g.data,
                    u.removeAllListeners("socket.io-file::abort::" + p),
                    u.removeAllListeners("socket.io-file::error::" + p),
                    u.removeAllListeners("socket.io-file::complete::" + p),
                    delete c.uploadingFiles[p],
                    c.emit("complete", E)
                }),
                u.on("socket.io-file::abort::" + p, function(E) {
                    g.aborted = !0,
                    c.emit("abort", {
                        uploadId: g.id,
                        name: g.name,
                        size: g.size,
                        sent: g.sent,
                        wrote: E.wrote,
                        uploadTo: h,
                        data: m
                    })
                }),
                u.on("socket.io-file::error::" + p, function(E) {
                    c.emit("error", new Error(E.message), {
                        uploadId: g.id,
                        name: g.name,
                        size: g.size,
                        uploadTo: h,
                        data: m
                    })
                })
            }
            ,
            b.readAsArrayBuffer(s)
        }
        function o(s, l) {
            if (!s)
                return this.emit("error", new Error("SocketIOFile requires Socket."));
            this.instanceId = a(),
            this.uploadId = 0,
            this.ev = {},
            this.options = l || {},
            this.accepts = [],
            this.maxFileSize = void 0,
            this.socket = s,
            this.uploadingFiles = {},
            this.isDestroyed = !1;
            var c = this;
            s.on("socket.io-file::recvSync", function(u) {
                c.maxFileSize = u.maxFileSize || void 0,
                c.accepts = u.accepts || [],
                c.chunkSize = u.chunkSize || 10240,
                c.transmissionDelay = u.transmissionDelay || 0,
                c.emit("ready")
            }),
            s.emit("socket.io-file::reqSync"),
            s.on("socket.io-file::disconnectByServer", function() {
                c.emit("disconnected"),
                c.destroy()
            })
        }
        if (o.prototype.getUploadId = function() {
            return "u_" + this.uploadId++
        }
        ,
        o.prototype.upload = function(s, l) {
            if (this.isDestroyed)
                throw new Error("SocketIOFileClient is closed.");
            if (!s || s.files && s.files.length <= 0 || s.length <= 0)
                return this.emit("error", new Error("No file(s) to upload.")),
                [];
            for (var c = this, u = [], f = s.files ? s.files : s, d = 0, p = 0; p < f.length; p++) {
                var h = f[p]
                  , m = this.getUploadId();
                u.push(m),
                h.uploadId = m,
                r.call(c, h, l)
            }
            return u
        }
        ,
        o.prototype.on = function(s, l) {
            if (this.isDestroyed)
                throw new Error("SocketIOFileClient is closed.");
            return this.ev[s] || (this.ev[s] = []),
            this.ev[s].push(l),
            this
        }
        ,
        o.prototype.off = function(s, l) {
            if (this.isDestroyed)
                throw new Error("SocketIOFileClient is closed.");
            if (typeof s > "u")
                this.ev = [];
            else if (typeof l > "u")
                this.ev[s] && delete this.ev[s];
            else
                for (var c = this.ev[s] || [], u = 0; u < c.length; u++)
                    if (c[u] === l) {
                        c = c.splice(u, 1);
                        break
                    }
            return this
        }
        ,
        o.prototype.emit = function(s) {
            if (this.isDestroyed)
                throw new Error("SocketIOFileClient is closed.");
            var l = this.ev[s] || []
              , c = Array.from(arguments);
            c.splice(0, 1);
            for (var u = 0; u < l.length; u++)
                l[u].apply(null, c);
            return this
        }
        ,
        o.prototype.abort = function(s) {
            if (this.isDestroyed)
                throw new Error("SocketIOFileClient is closed.");
            var l = this.socket;
            l.emit("socket.io-file::abort::" + s)
        }
        ,
        o.prototype.destroy = function() {
            if (this.isDestroyed)
                throw new Error("SocketIOFileClient is closed.");
            var s = this.uploadingFiles;
            for (var l in s)
                this.abort(l);
            this.socket = null,
            this.uploadingFiles = null,
            this.ev = null,
            this.isDestroyed = !0
        }
        ,
        o.prototype.getUploadInfo = function() {
            return JSON.parse(JSON.stringify(this.uploadingFiles))
        }
        ,
        !0)
            e.exports = o;
        else
            var i
    }
    )()
}
)(xD, I1);
const TD = I1;
class MD {
    constructor(t, n) {
        this.socket = t,
        this.stateApi = n,
        this.uploader = new TD(t),
        this.uploaderId = null,
        this.init()
    }
    init() {
        this.readyPromise = this.initializeUploader(),
        this.setupEventListeners()
    }
    initializeUploader() {
        return new Promise( (t, n) => {
            this.uploader.on("ready", () => {
                console.log("Uploader is ready"),
                t()
            }
            ).on("error", a => {
                console.error("Error initializing uploader:", a),
                n(a)
            }
            )
        }
        )
    }
    setupEventListeners() {
        this.uploader.on("start", this.handleStart.bind(this)).on("stream", this.handleStream.bind(this))
    }
    handleStart(t) {
        console.log("Start uploading", t),
        this.updateState("uploading", "Uploaded 0%", 0)
    }
    handleStream(t) {
        if (console.log("Stream uploading", t),
        !this.stateApi.getSigningStageKey()) {
            this.abort();
            return
        }
        const n = (t.sent / t.size * 100).toFixed(0);
        this.updateState("uploading", `Uploaded ${n}%`, n)
    }
    handleComplete(t) {
        console.log("Upload Complete", t)
    }
    handleError(t) {
        console.error("Upload error:", t),
        this.destroy(),
        this.showAlert(t)
    }
    handleAbort(t) {
        console.log("Upload aborted:", t),
        this.destroy()
    }
    async upload(t) {
        if (!t)
            return !1;
        try {
            return await this.readyPromise,
            new Promise( (n, a) => {
                this.uploaderId = this.uploader.upload(t),
                this.once("complete", r => {
                    this.handleComplete(r),
                    n(r)
                }
                , a),
                this.once("error", r => {
                    this.handleError(r),
                    a(r)
                }
                , a),
                this.once("abort", r => {
                    this.handleAbort(r),
                    a(new Error("Upload aborted"))
                }
                , a)
            }
            )
        } catch (n) {
            throw this.handleError(n),
            n
        }
    }
    once(t, n, a) {
        const r = (...o) => {
            try {
                n(...o)
            } catch (i) {
                a(i)
            } finally {
                this.uploader.off(t, r)
            }
        }
        ;
        this.uploader.on(t, r)
    }
    abort() {
        this.uploaderId && this.uploader.abort(this.uploaderId)
    }
    destroy() {
        var t, n;
        (t = this.uploader) == null || t.destroy(),
        (n = this.socket) == null || n.disconnect()
    }
    updateState(t, n, a) {
        this.stateApi.setSigningStageKey(t),
        this.stateApi.setSigningStageData({
            message: n,
            uploadingPercent: a
        })
    }
    showAlert(t) {
        const n = t.toString().includes("Max Uploading File") ? `Max Uploading File size must be under: ${mc(this.uploader.maxFileSize)}` : String(t);
        D.dialog.alert(n, "Error")
    }
}
class kc {
    constructor({host: t="https://syka.flekstore.com", deviceId: n, streamId: a, appId: r=null}={}) {
        if (!n || !a)
            throw new Error(`Missing required parameters: ${n ? "" : "deviceId"} ${a ? "" : "streamId"}`);
        Object.assign(this, {
            host: t,
            deviceId: n,
            streamId: a,
            appId: r,
            signingStage: Jn({
                key: null,
                data: null
            }),
            appGeneralSettings: Jn({
                name: null,
                ipaExternalUrl: null,
                ipaFileName: null,
                ipaFileContent: null,
                removeProfile: !1
            }),
            appCustomSettings: Jn({
                enabled: !0,
                name: null,
                bundleId: null,
                iconFileContent: null,
                iconFilePreview: null,
                dylibFileContent: null,
                removeProfile: !1
            }),
            stateApi: {
                getSigningStageKey: () => this.signingStage.key,
                setSigningStageKey: o => this.signingStage.key = o,
                setSigningStageData: o => this.signingStage.data = o
            },
            socketObject: null
        }),
        console.log("IpaSigner initialized")
    }
    resetAppSigningStages() {
        var t;
        this.signingStage.key = null,
        this.signingStage.data = null,
        (t = this.socketObject) == null || t.disconnect()
    }
    resetAppSettingsForm() {
        this.appCustomSettings.name = this.appGeneralSettings.name,
        this.appCustomSettings.bundleId = null,
        this.appCustomSettings.dylibFileContent = null,
        this.appCustomSettings.iconFileContent = null,
        this.appCustomSettings.iconFilePreview = null,
        this.appCustomSettings.removeProfile = !1
    }
    buildObjectForStartSign({ipaFileName: t, ipaExternalUrl: n, iconFileName: a, dylibFileName: r, bundleId: o}) {
        const i = {
            device_id: this.deviceId,
            stream: this.streamId,
            app_name: this.appGeneralSettings.name !== this.appCustomSettings.name && this.appCustomSettings.name,
            bundle_id: o || this.appCustomSettings.bundleId || "",
            removeProfile: this.appCustomSettings.removeProfile
        };
        r && (i.dylib = r),
        a && (i.iconFileName = a);
        const s = n ? {
            ipaUrl: `${n}`
        } : {
            file: t
        };
        return {
            ...i,
            ...s
        }
    }
    createSocket() {
        return new ED(this.host,this.deviceId,this.stateApi,t => {
            const n = this.appId ? `https://flekstore.com/install_ipa/${this.appId}/${this.streamId}/app.plist?filename=${t.message}&bundle_id=${t.bundle_id}` : `https://flekstore.com/signer/install_ipa/${this.streamId}/signer_app.plist?filename=${t.message}&bundle_id=${t.bundle_id}&app_name=${encodeURIComponent(this.appCustomSettings.name)}`;
            this.signingStage.data = encodeURIComponent(n),
            this.installApp()
        }
        )
    }
    async sign() {
        var l, c;
        this.signingStage.key = "connecting",
        this.signingStage.data = "Connecting...";
        const t = h2(this.appGeneralSettings.ipaFileContent, `${Gf("xxxx-xxxx-xxxx-xxxx")}.ipa`)
          , n = h2(this.appCustomSettings.iconFileContent, (l = this.appCustomSettings.iconFileContent) == null ? void 0 : l.name)
          , a = h2(this.appCustomSettings.dylibFileContent, (c = this.appCustomSettings.dylibFileContent) == null ? void 0 : c.name);
        this.socketObject = this.createSocket();
        const r = new MD(this.socketObject.socket,this.stateApi)
          , o = await r.upload(t)
          , i = await r.upload(n)
          , s = await r.upload(a);
        await this.socketObject.startSign(this.buildObjectForStartSign({
            ipaFileName: o.name || this.appGeneralSettings.ipaFileName,
            ipaExternalUrl: this.appGeneralSettings.ipaExternalUrl,
            iconFileName: i.name,
            dylibFileName: s.name
        }))
    }
    async signDuplicate() {
        this.signingStage.key = "connecting",
        this.signingStage.data = "Connecting...",
        this.socketObject = this.createSocket(),
        await this.socketObject.startSign(this.buildObjectForStartSign({
            ipaFileName: this.appGeneralSettings.ipaFileName,
            ipaExternalUrl: this.appGeneralSettings.ipaExternalUrl,
            iconFileName: !1,
            dylibFileName: !1,
            removeProfile: !1,
            bundleId: Cz()
        }))
    }
    installApp() {
        console.log(`itms-services://?action=download-manifest&url=${this.signingStage.data}`),
        window.open(`itms-services://?action=download-manifest&url=${this.signingStage.data}`, "_self")
    }
    destroy() {
        this.resetAppSigningStages(),
        this.resetAppSettingsForm(),
        this.socketObject && this.socketObject.socket && this.socketObject.disconnect(),
        console.log("IpaSigner resources have been freed.")
    }
}
const zD = {
    __name: "ui",
    props: {
        deviceId: {
            type: [Number, Boolean],
            required: !0
        },
        streamId: {
            type: [Number, Boolean],
            required: !0
        }
    },
    setup(e) {
        const t = e
          , n = id()
          , a = oe(null)
          , r = oe(null)
          , o = oe(null)
          , i = s => {
            if (o.value || (o.value = new kc({
                host: "https://syka.flekstore.com",
                deviceId: t.deviceId,
                streamId: t.streamId
            })),
            o.value.appGeneralSettings.name = n.app.name,
            o.value.appGeneralSettings.ipaFileContent = s,
            o.value.appCustomSettings.enabled = !n.app.nameChangingDisabled,
            o.value.appCustomSettings.name = n.app.name,
            n.signerOpened) {
                o.value.appCustomSettings.iconFileContent = null,
                o.value.appCustomSettings.iconFilePreview = null,
                o.value.appCustomSettings.dylibFileContent = null;
                return
            }
            setTimeout( () => {
                D.accordion.close(a.value.$el),
                D.accordion.open(r.value.$el),
                n.signerOpened = !0
            }
            ),
            st( () => [t.deviceId, t.streamId], ([l,c]) => {
                o.value && (o.value.deviceId = l,
                o.value.streamId = c)
            }
            )
        }
        ;
        return (s, l) => {
            const c = P("f7-accordion-content")
              , u = P("f7-accordion-item")
              , f = P("f7-button")
              , d = P("f7-block");
            return O(),
            K(d, {
                "accordion-list": "",
                class: "margin-top",
                inner: ""
            }, {
                default: k( () => [S(u, {
                    ref_key: "beforeSignerAccordion",
                    ref: a,
                    opened: ""
                }, {
                    default: k( () => [S(c, null, {
                        default: k( () => [S(B(yp), {
                            fill: "",
                            large: "",
                            round: "",
                            onOnSelect: i
                        })]),
                        _: 1
                    })]),
                    _: 1
                }, 512), S(u, {
                    ref_key: "signerAccordion",
                    ref: r
                }, {
                    default: k( () => [S(c, null, {
                        default: k( () => [o.value ? (O(),
                        K(B(DR), {
                            key: 0,
                            "signer-object": o.value
                        }, {
                            accordionContent: k( () => [ce(s.$slots, "signerSettings", {
                                signerObject: o.value
                            })]),
                            beforeSigningActions: k( () => [S(B(ll), {
                                class: "margin-bottom",
                                fill: "",
                                large: "",
                                round: "",
                                "signer-object": o.value
                            }, {
                                default: k( () => [J(" Sign app ")]),
                                _: 1
                            }, 8, ["signer-object"]), S(B(yp), {
                                large: "",
                                lite: "",
                                round: "",
                                onOnSelect: i
                            })]),
                            afterStartSigning: k( () => [S(f, {
                                class: "button-lite",
                                "icon-f7": "arrow_left_circle_fill",
                                large: "",
                                round: "",
                                onClick: l[0] || (l[0] = p => o.value.resetAppSigningStages())
                            }, {
                                default: k( () => [J(" Back ")]),
                                _: 1
                            })]),
                            afterSigningActions: k( () => [S(f, {
                                class: "margin-bottom",
                                fill: "",
                                "icon-f7": "cloud_download",
                                large: "",
                                round: "",
                                onClick: l[1] || (l[1] = p => o.value.installApp())
                            }, {
                                default: k( () => [J(" Install ")]),
                                _: 1
                            })]),
                            _: 3
                        }, 8, ["signer-object"])) : pe("", !0)]),
                        _: 3
                    })]),
                    _: 3
                }, 512)]),
                _: 3
            })
        }
    }
}
  , AD = V("p", {
    class: "text-align-center"
}, " App signing completed successfully  ", -1)
  , OD = {
    __name: "ui",
    props: {
        deviceId: {
            type: [Number, Boolean],
            required: !0
        },
        streamId: {
            type: [Number, Boolean],
            required: !0
        }
    },
    setup(e) {
        const t = e
          , n = oe(!1)
          , a = new kc({
            host: "https://syka.flekstore.com",
            deviceId: t.deviceId,
            streamId: t.streamId
        });
        a.appGeneralSettings.name = "External App",
        a.appCustomSettings.name = "External App",
        st( () => [t.deviceId, t.streamId], ([o,i]) => {
            a.deviceId = o,
            a.streamId = i
        }
        );
        const r = o => {
            n.value = o
        }
        ;
        return (o, i) => {
            const s = P("f7-list-input")
              , l = P("f7-list")
              , c = P("f7-icon")
              , u = P("f7-accordion-content")
              , f = P("f7-list-item")
              , d = P("f7-button")
              , p = P("f7-card-content")
              , h = P("f7-card");
            return O(),
            K(h, null, {
                default: k( () => [S(p, null, {
                    default: k( () => [B(a).signingStage.key ? pe("", !0) : (O(),
                    G(Be, {
                        key: 0
                    }, [S(l, {
                        class: "padding-top-half margin-bottom-half",
                        "no-hairlines": ""
                    }, {
                        default: k( () => [S(s, {
                            value: B(a).appGeneralSettings.ipaExternalUrl,
                            "onUpdate:value": i[0] || (i[0] = m => B(a).appGeneralSettings.ipaExternalUrl = m),
                            "clear-button": "",
                            "on-validate": r,
                            outline: "",
                            placeholder: "Link to download .ipa file",
                            type: "url",
                            validate: ""
                        }, null, 8, ["value"])]),
                        _: 1
                    }), S(l, {
                        class: "no-margin-vertical"
                    }, {
                        default: k( () => [V("ul", null, [S(f, {
                            "accordion-item": "",
                            title: "Customize"
                        }, {
                            media: k( () => [S(c, {
                                f7: "gear"
                            })]),
                            default: k( () => [S(u, null, {
                                default: k( () => [ce(o.$slots, "signerSettings", {
                                    signerObject: B(a)
                                })]),
                                _: 3
                            })]),
                            _: 3
                        })])]),
                        _: 3
                    }), S(B(ll), {
                        class: "margin-top",
                        disabled: !B(a).appGeneralSettings.ipaExternalUrl || !n.value,
                        fill: "",
                        large: "",
                        "only-for-premium": !0,
                        round: "",
                        "signer-object": B(a)
                    }, {
                        default: k( () => [J(" Sign app ")]),
                        _: 1
                    }, 8, ["disabled", "signer-object"])], 64)), B(a).signingStage.key && B(a).signingStage.key !== "ready_to_install" ? (O(),
                    G(Be, {
                        key: 1
                    }, [S(B(wc), {
                        "signer-object": B(a)
                    }, null, 8, ["signer-object"]), S(d, {
                        class: "button-lite margin-top",
                        "icon-f7": "arrow_left_circle_fill",
                        large: "",
                        onClick: i[1] || (i[1] = m => B(a).resetAppSigningStages())
                    }, {
                        default: k( () => [J(" Back ")]),
                        _: 1
                    })], 64)) : pe("", !0), B(a).signingStage.key === "ready_to_install" ? (O(),
                    G(Be, {
                        key: 2
                    }, [AD, S(d, {
                        class: "margin-bottom",
                        fill: "",
                        "icon-f7": "cloud_download",
                        large: "",
                        onClick: i[2] || (i[2] = m => B(a).installApp())
                    }, {
                        default: k( () => [J(" Install ")]),
                        _: 1
                    }), S(d, {
                        class: "button-lite",
                        "icon-f7": "arrow_left_circle_fill",
                        large: "",
                        onClick: i[3] || (i[3] = m => B(a).resetAppSigningStages())
                    }, {
                        default: k( () => [J(" Back ")]),
                        _: 1
                    })], 64)) : pe("", !0)]),
                    _: 3
                })]),
                _: 3
            })
        }
    }
}
  , PD = {
    style: {
        padding: "10px 15px"
    }
}
  , LD = {
    __name: "ui",
    setup(e) {
        const t = sl()
          , n = ht()
          , a = oe(null)
          , r = oe({
            device_id: localStorage.device_id,
            api_key_id: "",
            issuer_id: "",
            p8_file: {}
        })
          , o = () => {
            if (!(a.value.checkValidity() && r.value.p8_file !== {})) {
                D.dialog.alert("Please fill in all fields of the form correctly.", "Error");
                return
            }
            t.createStreamWithApiKeys(r.value, n.getDevice)
        }
        ;
        return (i, s) => {
            const l = P("f7-list-input")
              , c = P("f7-button")
              , u = P("f7-list");
            return O(),
            K(B(gI), null, {
                form: k( () => [V("form", {
                    ref_key: "formRef",
                    ref: a
                }, [S(u, {
                    class: "padding-top-half padding-bottom-half",
                    "no-hairlines": ""
                }, {
                    default: k( () => [S(l, {
                        value: r.value.api_key_id,
                        "onUpdate:value": s[0] || (s[0] = f => r.value.api_key_id = f),
                        "clear-button": "",
                        label: "API Key ID",
                        outline: "",
                        pattern: "[A-Z0-9]{10}",
                        placeholder: "M2R9WE7H8Z",
                        required: "",
                        type: "text",
                        validate: ""
                    }, null, 8, ["value"]), S(l, {
                        value: r.value.issuer_id,
                        "onUpdate:value": s[1] || (s[1] = f => r.value.issuer_id = f),
                        "clear-button": "",
                        label: "Issuer ID",
                        outline: "",
                        pattern: "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}",
                        placeholder: "03e91973-bb21-4e6f-21c0-420a7651c4ea",
                        required: "",
                        type: "text",
                        validate: ""
                    }, null, 8, ["value"]), V("li", PD, [S(B(_u), {
                        modelValue: r.value.p8_file,
                        "onUpdate:modelValue": s[2] || (s[2] = f => r.value.p8_file = f),
                        "accepted-extensions": ["p8"],
                        label: "Private Key File",
                        placeholder: ".p8 file"
                    }, {
                        button: k( ({handleClick: f}) => [S(c, {
                            class: "button-lite",
                            large: "",
                            onClick: f
                        }, {
                            default: k( () => [J(" Browse ")]),
                            _: 2
                        }, 1032, ["onClick"])]),
                        _: 1
                    }, 8, ["modelValue"])])]),
                    _: 1
                })], 512)]),
                formActions: k( () => [S(c, {
                    fill: "",
                    large: "",
                    round: "",
                    onClick: o
                }, {
                    default: k( () => [J(" Connect ")]),
                    _: 1
                })]),
                _: 1
            })
        }
    }
}
  , ID = {
    style: {
        padding: "10px 15px"
    }
}
  , BD = {
    style: {
        padding: "10px 15px"
    }
}
  , RD = {
    __name: "ui",
    setup(e) {
        const t = sl()
          , n = ht()
          , a = oe(null)
          , r = oe({
            device_id: localStorage.device_id,
            mobileprovision_file: {},
            p12_file: {},
            p12_password: ""
        })
          , o = () => {
            if (!(a.value.checkValidity() && r.value.mobileprovision_file !== {} && r.value.p12_file !== {})) {
                D.dialog.alert("Please fill in all fields of the form correctly.", "Error");
                return
            }
            t.createStreamWithCertificate(r.value, n.getDevice)
        }
        ;
        return (i, s) => {
            const l = P("f7-button")
              , c = P("f7-list-input")
              , u = P("f7-list");
            return O(),
            K(B(kI), null, {
                form: k( () => [V("form", {
                    ref_key: "formRef",
                    ref: a
                }, [S(u, {
                    class: "padding-top-half padding-bottom-half",
                    "no-hairlines": ""
                }, {
                    default: k( () => [V("li", ID, [S(B(_u), {
                        modelValue: r.value.mobileprovision_file,
                        "onUpdate:modelValue": s[0] || (s[0] = f => r.value.mobileprovision_file = f),
                        "accepted-extensions": ["mobileprovision"],
                        label: "Mobileprovision",
                        placeholder: ".mobileprovision file"
                    }, {
                        button: k( ({handleClick: f}) => [S(l, {
                            class: "button-lite",
                            large: "",
                            onClick: f
                        }, {
                            default: k( () => [J(" Browse ")]),
                            _: 2
                        }, 1032, ["onClick"])]),
                        _: 1
                    }, 8, ["modelValue"])]), V("li", BD, [S(B(_u), {
                        modelValue: r.value.p12_file,
                        "onUpdate:modelValue": s[1] || (s[1] = f => r.value.p12_file = f),
                        "accepted-extensions": ["p12"],
                        label: "Certificate",
                        placeholder: ".p12 file"
                    }, {
                        button: k( ({handleClick: f}) => [S(l, {
                            class: "button-lite",
                            large: "",
                            onClick: f
                        }, {
                            default: k( () => [J(" Browse ")]),
                            _: 2
                        }, 1032, ["onClick"])]),
                        _: 1
                    }, 8, ["modelValue"])]), S(c, {
                        value: r.value.p12_password,
                        "onUpdate:value": s[2] || (s[2] = f => r.value.p12_password = f),
                        "clear-button": "",
                        label: "p12 password",
                        outline: "",
                        placeholder: "Password",
                        type: "password"
                    }, null, 8, ["value"])]),
                    _: 1
                })], 512)]),
                formActions: k( () => [S(l, {
                    fill: "",
                    large: "",
                    round: "",
                    onClick: o
                }, {
                    default: k( () => [J(" Confirm ")]),
                    _: 1
                })]),
                _: 1
            })
        }
    }
};
const DD = {
    style: {
        "text-align": "center",
        display: "flex",
        gap: "8px"
    }
}
  , ND = {
    __name: "ui",
    props: {
        signerObject: {
            type: Object,
            required: !0
        },
        ipaUrl: {
            type: String,
            default: ""
        },
        appId: {
            type: Number,
            required: !0
        },
        appName: {
            type: String,
            default: null
        },
        appDeveloper: {
            type: String,
            default: null
        },
        appIcon: {
            type: String,
            default: null
        },
        oldSignerUi: {
            type: Boolean,
            default: !1
        }
    },
    setup(e) {
        const t = e
          , n = oe(!1)
          , a = ae( () => t.oldSignerUi || ra.LC_APP_ID === t.appId);
        return (r, o) => {
            const i = P("f7-icon")
              , s = P("f7-accordion-toggle");
            return O(),
            K(B(OB), {
                "app-developer": e.appDeveloper,
                "app-icon": e.appIcon,
                "app-name": e.appName,
                "signer-object": e.signerObject
            }, lr({
                button: k( () => [V("div", DD, [a.value ? (O(),
                K(B(ll), {
                    key: 0,
                    fill: "",
                    round: "",
                    "signer-object": e.signerObject
                }, {
                    default: k( () => [J(" SIGN APP ")]),
                    _: 1
                }, 8, ["signer-object"])) : (O(),
                K(B(gh), {
                    key: 1,
                    fill: "",
                    "ipa-url": e.ipaUrl,
                    round: ""
                }, {
                    default: k( () => [J(" INSTALL ")]),
                    _: 1
                }, 8, ["ipa-url"]))])]),
                "signing-info": k( () => [S(B(wc), {
                    "signer-object": e.signerObject
                }, null, 8, ["signer-object"])]),
                "accordion-content": k( () => [ce(r.$slots, "accordion-content", {}, void 0, !0)]),
                _: 2
            }, [e.oldSignerUi ? {
                name: "accordion-toggle",
                fn: k( () => [S(s, null, {
                    default: k( () => [S(B(F8), {
                        class: "source-app-view-header-ui__sign-settings-button bounce-tap",
                        "is-active": n.value,
                        onSwitchMode: o[0] || (o[0] = l => n.value = !n.value)
                    }, {
                        "not-active": k( () => [S(i, {
                            f7: "gear",
                            size: "26"
                        })]),
                        active: k( () => [S(i, {
                            f7: "chevron_up",
                            size: "24"
                        })]),
                        _: 1
                    }, 8, ["is-active"])]),
                    _: 1
                })]),
                key: "0"
            } : void 0, B(ra).LC_APP_ID !== e.appId ? {
                name: "download-button",
                fn: k( () => [S(B(vh), {
                    "from-source": "",
                    "ipa-url": e.ipaUrl,
                    "signer-object": e.signerObject
                }, null, 8, ["ipa-url", "signer-object"])]),
                key: "1"
            } : void 0]), 1032, ["app-developer", "app-icon", "app-name", "signer-object"])
        }
    }
}
  , HD = it(ND, [["__scopeId", "data-v-36ccd913"]]);
const VD = "/warning";
var N1;
class FD {
    constructor() {
        mn(this, N1, Ur)
    }
    getWarning(t) {
        return pt(this, N1).get(`${VD}/${t}`)
    }
}
N1 = new WeakMap;
const jD = new FD;
const Bh = e => (qt("data-v-0cd2c3bd"),
e = e(),
Wt(),
e)
  , UD = {
    class: "swiper-block"
}
  , qD = {
    class: "catalog__toolbar-sticky"
}
  , WD = Bh( () => V("div", {
    class: "catalog__toolbar-sticky__bg"
}, null, -1))
  , YD = Bh( () => V("div", {
    class: "catalog__toolbar-sticky__gradient-bg"
}, null, -1))
  , GD = {
    __name: "catalog",
    setup(e) {
        const t = Ti()
          , n = od()
          , a = ph()
          , r = ht()
          , o = oe("")
          , i = () => {
            t.filters.page !== 0 && (t.apps.length < t.pageItemsLimit * t.filters.page || t.allowInfinite && (t.allowInfinite = !0,
            t.getApps()))
        }
          , s = () => {
            D.view.current.router.refreshPage()
        }
          , l = async () => {
            var c;
            try {
                return (c = (await jD.getWarning(1)).data) == null ? void 0 : c.message
            } catch (u) {
                return console.log(u),
                ""
            }
        }
        ;
        return Xe( () => {
            ut(async () => {
                await a.getCategories(),
                t.resetCatalog(),
                await t.getApps(),
                o.value = await l(),
                n.articles = null,
                await n.getArticles()
            }
            )
        }
        ),
        (c, u) => {
            const f = P("f7-navbar")
              , d = P("f7-page");
            return O(),
            K(d, {
                infinite: "",
                "infinite-distance": 50,
                "infinite-preloader": B(t).showPreloader,
                ptr: "",
                onInfinite: i,
                "onPtr:refresh": s
            }, {
                default: k( () => [S(f, {
                    class: "no-blur",
                    hidden: "",
                    "no-hairline": ""
                }), S(B(An), null, {
                    default: k( () => {
                        var p;
                        return [V("div", UD, [S(B(XI))]), V("div", qD, [WD, YD, S(B(HB)), B(t).filters.search ? pe("", !0) : (O(),
                        K(B(xB), {
                            key: 0
                        }))]), B(r).currentIosIsBeta ? (O(),
                        K(B(j8), {
                            key: 0,
                            class: "margin-top-half",
                            "ios-version": B(r).deviceIosVersion
                        }, null, 8, ["ios-version"])) : (p = B(r)) != null && p.device && o.value.length ? (O(),
                        K(B(ol), {
                            key: 1,
                            class: "margin-top-half",
                            text: o.value
                        }, null, 8, ["text"])) : pe("", !0), S(B(yB))]
                    }
                    ),
                    _: 1
                })]),
                _: 1
            }, 8, ["infinite-preloader"])
        }
    }
}
  , XD = it(GD, [["__scopeId", "data-v-0cd2c3bd"]]);
class KD extends ed {
    constructor() {
        super("https://translate.flekstore.com")
    }
}
const ZD = new KD
  , xp = "/";
var Is;
class JD {
    constructor() {
        mn(this, Is, ZD)
    }
    translate(t) {
        return pt(this, Is).post(`${xp}translate`, t)
    }
    getItem() {
        return pt(this, Is).get(`${xp}languages`)
    }
}
Is = new WeakMap;
const QD = new JD
  , eN = bf('<path d="m5 8 6 6"></path><path d="m4 14 6-6 2-3"></path><path d="M2 5h12"></path><path d="M7 2h1"></path><path d="m22 22-5-10-5 10"></path><path d="M14 18h6"></path>', 6)
  , tN = [eN]
  , nN = {
    __name: "LanguagesIcon",
    props: {
        size: {
            type: [String, Number],
            default: "28"
        }
    },
    setup(e) {
        const t = e;
        return (n, a) => (O(),
        G("div", {
            style: Rt({
                width: `${t.size}px`,
                height: `${t.size}px`
            })
        }, [(O(),
        G("svg", {
            class: "lucide lucide-languages",
            display: "block",
            fill: "none",
            stroke: "currentColor",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            "stroke-width": "2",
            style: Rt({
                width: `${t.size}px`,
                height: `${t.size}px`
            }),
            viewBox: "0 0 24 24",
            xmlns: "http://www.w3.org/2000/svg"
        }, tN, 4))], 4))
    }
};
const cl = {
    __name: "ui",
    props: {
        content: {
            type: [String, Array],
            required: !0
        },
        hideIcon: {
            type: Boolean,
            default: !1
        },
        beforeTranslateText: {
            type: String,
            default: ""
        },
        afterTranslateText: {
            type: String,
            default: ""
        },
        translationFormat: {
            type: String,
            default: "text"
        },
        fill: {
            type: Boolean,
            default: !1
        },
        large: {
            type: Boolean,
            default: !1
        },
        lite: {
            type: Boolean,
            default: !1
        },
        disabled: {
            type: [Boolean, Number],
            default: !1
        },
        hairlines: {
            type: Boolean,
            default: !1
        }
    },
    emits: ["onComplete"],
    setup(e, {expose: t, emit: n}) {
        const a = wz()
          , r = oe(!1)
          , o = oe(null)
          , i = oe(!1)
          , s = e
          , l = n
          , c = async p => {
            try {
                return r.value = !0,
                (await QD.translate({
                    q: p,
                    source: "en",
                    target: a,
                    format: s.translationFormat
                })).data.translatedText
            } catch {
                hc("Translation error. Please try again later.")
            }
        }
          , u = async () => {
            if (i.value) {
                i.value = !1,
                l("onComplete", s.content);
                return
            }
            if (o.value) {
                i.value = !0,
                l("onComplete", o.value);
                return
            }
            const p = await c(s.content);
            r.value = !1,
            i.value = !0,
            o.value = p,
            l("onComplete", o.value)
        }
        ;
        return t({
            translate: () => u(),
            textIsTranslated: () => i.value
        }),
        (p, h) => {
            const m = P("f7-button");
            return B(a) !== "en" ? (O(),
            K(m, {
                key: 0,
                class: Ae(["translate-button button-glass", {
                    "button-lite": e.lite,
                    hairlines: e.hairlines
                }]),
                disabled: e.disabled,
                fill: e.fill,
                large: e.large,
                loading: r.value,
                preloader: "",
                style: {},
                onClick: u
            }, {
                default: k( () => {
                    var g;
                    return [e.hideIcon ? pe("", !0) : (O(),
                    K(nN, {
                        key: 0,
                        class: "padding-right-half",
                        size: 20
                    })), i.value ? (O(),
                    G(Be, {
                        key: 2
                    }, [e.afterTranslateText ? (O(),
                    G(Be, {
                        key: 1
                    }, [J(Me(e.afterTranslateText), 1)], 64)) : (O(),
                    G(Be, {
                        key: 0
                    }, [J(" Original ")], 64))], 64)) : (O(),
                    G(Be, {
                        key: 1
                    }, [J(Me(e.beforeTranslateText) + " " + Me((g = B(a)) == null ? void 0 : g.toUpperCase()), 1)], 64))]
                }
                ),
                _: 1
            }, 8, ["class", "disabled", "fill", "large", "loading"])) : pe("", !0)
        }
    }
}
  , aN = {
    __name: "viewPopup",
    props: {
        appItem: {
            type: Object,
            default: null
        }
    },
    setup(e) {
        var u, f;
        const t = e
          , n = Ti()
          , a = ht()
          , r = oe("")
          , o = oe(null)
          , i = oe(null);
        i.value = t.appItem;
        const s = new kc({
            host: "wss://sign.flekstore.com",
            deviceId: ((u = a == null ? void 0 : a.device) == null ? void 0 : u.id) || !0,
            streamId: ((f = a == null ? void 0 : a.device) == null ? void 0 : f.stream.id) || !0,
            appId: t.appItem.id
        });
        (async () => {
            var d, p, h, m, g, b;
            try {
                i.value = await n.getApp(t.appItem.id),
                o.value = (d = i.value) == null ? void 0 : d.warning,
                r.value = (p = i.value) == null ? void 0 : p.description,
                s.appGeneralSettings.name = (h = i.value) == null ? void 0 : h.name,
                s.appGeneralSettings.ipaFileName = (m = i.value) == null ? void 0 : m.install_url,
                s.appCustomSettings.enabled = !((g = i.value) != null && g.nameChangingDisabled),
                s.appCustomSettings.name = (b = i.value) == null ? void 0 : b.name
            } catch {}
        }
        )();
        const c = d => {
            o.value = d[0],
            r.value = d[1]
        }
        ;
        return Ca( () => {
            s && s.destroy()
        }
        ),
        (d, p) => {
            const h = P("f7-page")
              , m = P("f7-popup");
            return O(),
            K(m, {
                push: "",
                "swipe-to-close": "to-bottom"
            }, {
                default: k( () => [S(B(ia)), S(h, null, {
                    default: k( () => {
                        var g, b, v, y, w, C, _, E, z, T, A, x;
                        return [S(B(JB), {
                            "app-developer": (g = i.value) == null ? void 0 : g.developer,
                            "app-icon": (b = i.value) == null ? void 0 : b.icon,
                            "app-id": (v = i.value) == null ? void 0 : v.id,
                            "app-name": (y = i.value) == null ? void 0 : y.name,
                            "ipa-url": `https://s3.flekstore.com/ipa-library/${(w = i.value) == null ? void 0 : w.install_url}`,
                            "old-signer-ui": B(a).oldSignerUI,
                            "signer-object": B(s)
                        }, {
                            "accordion-content": k( () => {
                                var M, L, U;
                                return [S(B(L1), {
                                    "has-device": Boolean((M = B(a)) == null ? void 0 : M.device),
                                    "has-premium": !((U = (L = B(a)) == null ? void 0 : L.getServiceByName("premium")) != null && U.isExpired),
                                    "signer-object": B(s)
                                }, null, 8, ["has-device", "has-premium", "signer-object"])]
                            }
                            ),
                            _: 1
                        }, 8, ["app-developer", "app-icon", "app-id", "app-name", "ipa-url", "old-signer-ui", "signer-object"]), i.value.id !== B(ra).LC_APP_ID && !B(a).oldSignerUI ? (O(),
                        K(B(fh), {
                            key: 0
                        })) : pe("", !0), (C = i.value) != null && C.warning ? (O(),
                        K(B(ol), {
                            key: 1,
                            class: "margin-top-half",
                            text: o.value
                        }, null, 8, ["text"])) : pe("", !0), S(B(cB), {
                            "app-downloads": (_ = i.value) == null ? void 0 : _.downloads,
                            "app-size": (E = i.value) == null ? void 0 : E.size,
                            "app-updated-at": (z = i.value) == null ? void 0 : z.date,
                            "app-version": (T = i.value) == null ? void 0 : T.version
                        }, null, 8, ["app-downloads", "app-size", "app-updated-at", "app-version"]), (A = i.value) != null && A.photos ? (O(),
                        K(B(yh), {
                            key: 2,
                            images: (x = i.value) == null ? void 0 : x.photos
                        }, null, 8, ["images"])) : pe("", !0), S(B(sB), {
                            description: r.value
                        }, {
                            titleRight: k( () => {
                                var M, L;
                                return [S(B(cl), {
                                    "after-translate-text": "EN",
                                    content: [(M = i.value) == null ? void 0 : M.warning, (L = i.value) == null ? void 0 : L.description],
                                    lite: "",
                                    "translation-format": "html",
                                    onOnComplete: p[0] || (p[0] = U => c(U))
                                }, null, 8, ["content"])]
                            }
                            ),
                            _: 1
                        }, 8, ["description"])]
                    }
                    ),
                    _: 1
                })]),
                _: 1
            })
        }
    }
};
const ud = e => (qt("data-v-e885db42"),
e = e(),
Wt(),
e)
  , rN = {
    class: "page-col-navbar"
}
  , oN = {
    key: 0,
    class: "article-header"
}
  , iN = ["src"]
  , sN = ud( () => V("div", {
    class: "backout"
}, null, -1))
  , lN = {
    class: "title"
}
  , cN = {
    key: 1,
    class: "article-header"
}
  , uN = ["src"]
  , fN = ud( () => V("div", {
    class: "backout"
}, null, -1))
  , dN = {
    class: "title"
}
  , pN = {
    class: "article-info text-color-gray"
}
  , hN = {
    class: "display-flex align-items-center"
}
  , mN = {
    key: 3,
    style: {
        "text-align": "center"
    }
}
  , gN = ud( () => V("br", null, null, -1))
  , vN = {
    __name: "article",
    props: {
        articleItem: {
            type: Object,
            default: Object
        },
        articleId: {
            type: Number,
            default: 0
        }
    },
    setup(e) {
        const t = e
          , n = t.articleId ? t.articleId : t.articleItem.id
          , a = od()
          , r = oe("")
          , o = i => {
            r.value = i[0]
        }
        ;
        return Xe(async () => {
            await a.getArticle({
                id: n
            }),
            r.value = a.article.text
        }
        ),
        (i, s) => {
            const l = P("f7-icon")
              , c = P("f7-link")
              , u = P("f7-block")
              , f = P("f7-preloader")
              , d = P("f7-page");
            return O(),
            K(d, null, {
                default: k( () => [V("div", rN, [S(B(An), null, {
                    default: k( () => [S(c, {
                        back: "",
                        class: "top-left-bubble"
                    }, {
                        default: k( () => [S(l, {
                            f7: "chevron_left"
                        })]),
                        _: 1
                    })]),
                    _: 1
                })]), S(B(An), null, {
                    default: k( () => [t.articleItem.title ? (O(),
                    G("div", oN, [V("img", {
                        alt: "header",
                        src: t.articleItem.image
                    }, null, 8, iN), sN, V("div", lN, Me(t.articleItem.title), 1)])) : B(a).article ? (O(),
                    G("div", cN, [V("img", {
                        alt: "header",
                        src: B(a).article.image
                    }, null, 8, uN), fN, V("div", dN, Me(B(a).article.title), 1)])) : pe("", !0), B(a).article ? (O(),
                    G(Be, {
                        key: 2
                    }, [V("div", pN, [V("div", null, Me(B(Si).format(Date.parse(B(a).article.date.replace(/-/g, "/")))), 1), V("div", hN, [S(l, {
                        f7: "eye",
                        style: {
                            "font-size": "inherit"
                        }
                    }), J(" " + Me(B(a).article.views) + " ", 1), S(B(cl), {
                        "after-translate-text": "EN",
                        class: "margin-left",
                        content: [B(a).article.text],
                        lite: "",
                        "translation-format": "html",
                        onOnComplete: s[0] || (s[0] = p => o(p))
                    }, null, 8, ["content"])])]), S(u, {
                        class: "article-text",
                        innerHTML: r.value
                    }, null, 8, ["innerHTML"])], 64)) : (O(),
                    G("div", mN, [gN, S(f, {
                        size: "30"
                    })]))]),
                    _: 1
                })]),
                _: 1
            })
        }
    }
}
  , bN = it(vN, [["__scopeId", "data-v-e885db42"]]);
const yN = {}
  , CN = {
    style: {
        "text-align": "center"
    }
};
function wN(e, t) {
    const n = P("f7-icon")
      , a = P("f7-link");
    return O(),
    G("div", CN, [S(a, {
        class: "single-link-font",
        color: "blue",
        href: "/docs/"
    }, {
        default: k( () => [S(n, {
            f7: "question_diamond_fill",
            style: {
                "font-size": "large"
            }
        }), J("  Help and Support ")]),
        _: 1
    })])
}
const _N = it(yN, [["render", wN]]);
const kN = {
    key: 0,
    style: {
        "white-space": "normal"
    }
}
  , SN = {
    style: {
        display: "flex",
        padding: "0 15px",
        "margin-top": "20px"
    }
}
  , $N = {
    class: "width-100"
}
  , EN = {
    __name: "main",
    setup(e) {
        const t = ht()
          , n = sl()
          , a = _a()
          , r = async o => {
            var i, s, l, c, u, f;
            if (!t.hasDeviceId) {
                o();
                return
            }
            ((i = t.device) == null ? void 0 : i.hasActivation) === !1 && (await t.getTariff(),
            await t.getOffers()),
            ((s = t.device) == null ? void 0 : s.queue) > 1 && ((l = t.device) != null && l.stream) && ((c = t.device) != null && c.stream.connected_via_api) && await t.checkActivation(),
            (u = t == null ? void 0 : t.device) != null && u.isUserStream && await n.checkUserCertificate((f = t == null ? void 0 : t.device) == null ? void 0 : f.stream.id, localStorage.device_id),
            await t.getDevice(),
            await a.getReferralCode(),
            await a.getBalance(),
            o()
        }
        ;
        return Xe(async () => {
            t.iosReleaseVersion = await vz()
        }
        ),
        (o, i) => {
            const s = P("f7-nav-left")
              , l = P("f7-nav-title")
              , c = P("f7-nav-right")
              , u = P("f7-nav-title-large")
              , f = P("f7-navbar")
              , d = P("f7-button")
              , p = P("f7-block-title")
              , h = P("f7-block-header")
              , m = P("f7-link")
              , g = P("f7-block")
              , b = P("f7-page");
            return O(),
            K(b, {
                class: "device-main",
                ptr: "",
                "onPtr:refresh": r
            }, {
                default: k( () => [S(f, {
                    class: "navbar-glass-blur",
                    large: "",
                    "no-hairline": "",
                    sliding: !0,
                    transparent: ""
                }, {
                    default: k( () => [S(s), S(l, {
                        sliding: ""
                    }, {
                        default: k( () => [J(" Device ")]),
                        _: 1
                    }), S(c), S(u, null, {
                        default: k( () => [J("Device")]),
                        _: 1
                    })]),
                    _: 1
                }), S(B(An), null, {
                    default: k( () => [B(t).loadingError ? (O(),
                    K(B(bc), {
                        key: 0,
                        "icon-name": "wifi_exclamationmark",
                        text: "Loading error! Pull down to try again."
                    })) : pe("", !0), B(t).hasDeviceId ? (O(),
                    G(Be, {
                        key: 1
                    }, [S(B(iI)), B(t).canContactSupport ? (O(),
                    K(d, {
                        key: 0,
                        class: "device-main__help-button margin-top button-lite margin-horizontal",
                        href: "/docs/",
                        "icon-f7": "question_diamond",
                        large: "",
                        round: ""
                    }, {
                        default: k( () => [J(" Help and Support ")]),
                        _: 1
                    })) : pe("", !0), B(t).currentIosIsBeta ? (O(),
                    K(B(j8), {
                        key: 1,
                        class: "margin-top",
                        "ios-version": B(t).deviceIosVersion
                    }, null, 8, ["ios-version"])) : pe("", !0), B(t).device ? (O(),
                    G(Be, {
                        key: 2
                    }, [B(t).device.streamRevoked ? (O(),
                    K(B(ol), {
                        key: 0,
                        class: "margin-top"
                    }, {
                        default: k( () => {
                            var v, y;
                            return [B(t).device.isUserStream ? (O(),
                            G("span", kN, ' To use the new certificate, unlink the current one by clicking on "Unlink" in the widget below. ')) : (O(),
                            G(Be, {
                                key: 1
                            }, [J(Me(((v = B(t).tariff) == null ? void 0 : v.tariff) === 4 || ((y = B(t).tariff) == null ? void 0 : y.tariff) === 2 ? "Unfortunately, your certificate has been revoked prematurely by Apple." : "Your last certificate expired."), 1)], 64))]
                        }
                        ),
                        _: 1
                    })) : pe("", !0), V("div", SN, [V("div", $N, [S(p, {
                        class: "no-margin",
                        medium: ""
                    }, {
                        default: k( () => [J(" Certificate ")]),
                        _: 1
                    }), B(t).device.hasActivation === !1 && !B(t).device.isUserStream ? (O(),
                    K(h, {
                        key: 0,
                        class: "no-padding no-margin"
                    }, {
                        default: k( () => [J(" Select one of the options to access apps. ")]),
                        _: 1
                    })) : pe("", !0)]), S(m, {
                        color: "blue",
                        href: "/docs/40/",
                        "icon-f7": "info_circle"
                    })]), B(t).device.hasActivation === !1 && !B(t).device.isUserStream ? (O(),
                    K(B(NO), {
                        key: 1
                    })) : pe("", !0), B(t).device.hasActivation === null ? (O(),
                    K(B(SI), {
                        key: 2
                    })) : pe("", !0), B(t).device.hasActivation || B(t).device.isUserStream && B(t).device.streamRevoked ? (O(),
                    K(B(xI), {
                        key: 3
                    })) : pe("", !0), B(t).device.hasActivation || B(t).device.service ? (O(),
                    G(Be, {
                        key: 4
                    }, [S(p, {
                        class: "margin-top",
                        medium: ""
                    }, {
                        default: k( () => [J(" Services ")]),
                        _: 1
                    }), S(B(eP)), S(B(sP))], 64)) : pe("", !0), B(t).canContactSupport ? (O(),
                    K(g, {
                        key: 5
                    }, {
                        default: k( () => [S(B(_N))]),
                        _: 1
                    })) : pe("", !0)], 64)) : pe("", !0)], 64)) : (O(),
                    K(B(TO), {
                        key: 2
                    }))]),
                    _: 1
                })]),
                _: 1
            })
        }
    }
}
  , xN = {}
  , TN = V("img", {
    height: "55",
    src: "https://i.imgur.com/T9Qvjh0.png",
    style: {
        "border-radius": "23%"
    }
}, null, -1);
function MN(e, t) {
    const n = P("f7-list-item")
      , a = P("f7-list");
    return O(),
    K(a, {
        class: "margin-15",
        inset: ""
    }, {
        default: k( () => [S(n, {
            footer: "You can link more devices to your certificate. New devices will also have access to install apps.",
            link: "/dd/",
            title: "Add new UDID"
        }, {
            media: k( () => [TN]),
            _: 1
        })]),
        _: 1
    })
}
const zN = it(xN, [["render", MN]])
  , AN = {
    __name: "manageOwnStream",
    setup(e) {
        const t = ht();
        return (n, a) => {
            const r = P("f7-navbar")
              , o = P("f7-page");
            return O(),
            K(o, null, {
                default: k( () => [S(r, {
                    "back-link": "",
                    sliding: !1,
                    title: "Account manager"
                }), B(t).device.isStreamOwner ? (O(),
                K(B(zN), {
                    key: 0
                })) : pe("", !0)]),
                _: 1
            })
        }
    }
}
  , ON = {
    key: 0,
    style: {
        "text-align": "center"
    }
}
  , PN = V("p", null, [J(" Maximum file size - "), V("span", {
    class: "text-color-orange"
}, "120 MB")], -1)
  , LN = V("b", null, "Upgrade to 3500 MB", -1)
  , IN = {
    key: 1,
    style: {
        "text-align": "center"
    }
}
  , BN = V("p", null, [J(" Maximum file size - "), V("b", null, "3500 MB")], -1)
  , RN = [BN]
  , DN = {
    __name: "ui",
    props: {
        hasPremium: {
            type: Boolean,
            required: !0
        },
        hasDevice: {
            type: Boolean,
            required: !0
        }
    },
    setup(e) {
        const t = e
          , n = () => {
            if (!t.hasDevice) {
                D.tab.show("#view-device");
                return
            }
            D.view.current.router.navigate("/device/service-offer-details/", {
                props: {
                    offerId: 1
                }
            })
        }
        ;
        return (a, r) => {
            const o = P("f7-link");
            return e.hasPremium ? (O(),
            G("div", IN, RN)) : (O(),
            G("div", ON, [PN, V("p", null, [S(o, {
                color: "blue",
                onClick: n
            }, {
                default: k( () => [LN]),
                _: 1
            })])]))
        }
    }
}
  , NN = [{
    icon: "doc_fill",
    color: "blue",
    text: "Signing IPA files <b>on your device</b>"
}, {
    icon: "link",
    color: "blue",
    text: "Signing apps using <b>external links</b>"
}, {
    icon: "shippingbox_fill",
    color: "blue",
    text: "Inject <b>.dylib tweaks</b>"
}, {
    icon: "gear",
    color: "blue",
    text: "Changing the app <b>Bundle ID</b>"
}, {
    icon: "square_split_1x2_fill",
    color: "blue",
    text: "Launching apps in <b>split-screen mode</b>"
}, {
    icon: "square_fill_on_square_fill",
    color: "blue",
    text: "Install <b>duplicates</b>"
}];
const HN = ["innerHTML"]
  , VN = {
    class: "signer-main__buttons-col"
}
  , FN = V("b", null, "How it works", -1)
  , jN = {
    class: "text-align-center"
}
  , UN = V("b", null, "5x times faster", -1)
  , qN = {
    __name: "main",
    setup(e) {
        const t = ht()
          , n = ra.LC_APP_ID
          , a = ae( () => {
            var o;
            return ((o = t == null ? void 0 : t.device) == null ? void 0 : o.id) || !0
        }
        )
          , r = ae( () => {
            var o;
            return ((o = t == null ? void 0 : t.device) == null ? void 0 : o.stream.id) || !0
        }
        );
        return (o, i) => {
            const s = P("f7-nav-left")
              , l = P("f7-nav-title")
              , c = P("f7-nav-right")
              , u = P("f7-nav-title-large")
              , f = P("f7-navbar")
              , d = P("f7-icon")
              , p = P("f7-list-item")
              , h = P("f7-list")
              , m = P("f7-button")
              , g = P("f7-link")
              , b = P("f7-segmented")
              , v = P("f7-block")
              , y = P("f7-tab")
              , w = P("f7-tabs")
              , C = P("f7-page");
            return O(),
            K(C, {
                name: "home"
            }, {
                default: k( () => [S(f, {
                    class: "navbar-glass-blur",
                    large: "",
                    "no-hairline": "",
                    sliding: !1,
                    transparent: ""
                }, {
                    default: k( () => [S(s), S(l, {
                        sliding: ""
                    }, {
                        default: k( () => [J(" Signer ")]),
                        _: 1
                    }), S(c), S(u, null, {
                        default: k( () => [J("Signer")]),
                        _: 1
                    })]),
                    _: 1
                }), S(B(An), null, {
                    default: k( () => [B(t).oldSignerUI ? pe("", !0) : (O(),
                    K(B(PR), {
                        key: 0
                    }, {
                        default: k( () => [S(h, {
                            class: "signer-main__lc-features-list no-margin-horizontal no-margin-top margin-bottom",
                            "no-hairlines": "",
                            "no-hairlines-between": ""
                        }, {
                            default: k( () => [(O(!0),
                            G(Be, null, vt(B(NN), _ => (O(),
                            K(p, {
                                key: _
                            }, {
                                title: k( () => [V("span", {
                                    innerHTML: _.text
                                }, null, 8, HN)]),
                                media: k( () => [S(d, {
                                    f7: _.icon,
                                    "text-color": _.color || "green"
                                }, null, 8, ["f7", "text-color"])]),
                                _: 2
                            }, 1024))), 128))]),
                            _: 1
                        }), V("div", VN, [S(m, {
                            fill: "",
                            href: "/app/",
                            "icon-f7": "cloud_download",
                            large: "",
                            round: "",
                            "route-props": {
                                appItem: {
                                    id: B(n)
                                }
                            }
                        }, {
                            default: k( () => [J(" Install ")]),
                            _: 1
                        }, 8, ["route-props"]), S(m, {
                            class: "button-lite",
                            href: "/docs/76/",
                            large: "",
                            round: ""
                        }, {
                            default: k( () => [J(" How to use? ")]),
                            _: 1
                        })])]),
                        _: 1
                    })), B(t).oldSignerUI ? (O(),
                    G(Be, {
                        key: 1
                    }, [S(B(MR), null, {
                        default: k( () => [S(g, {
                            external: "",
                            href: "https://youtu.be/5NRGq2R0HK4"
                        }, {
                            default: k( () => [S(d, {
                                f7: "play_rectangle_fill",
                                style: {
                                    "font-size": "large"
                                }
                            }), J("  "), FN]),
                            _: 1
                        })]),
                        _: 1
                    }), S(v, {
                        class: "no-margin no-padding"
                    }, {
                        default: k( () => [S(b, {
                            class: "signer__main__segmented-button margin-horizontal",
                            round: "",
                            strong: "",
                            style: {
                                "margin-top": "40px"
                            },
                            tag: "div"
                        }, {
                            default: k( () => [S(m, {
                                "tab-link": "#tab-sign-by-file"
                            }, {
                                default: k( () => [J(" File ")]),
                                _: 1
                            }), S(m, {
                                "icon-f7": "bolt_fill",
                                "tab-link": "#tab-sign-by-url"
                            }, {
                                default: k( () => [J(" Link ")]),
                                _: 1
                            })]),
                            _: 1
                        })]),
                        _: 1
                    }), S(w, {
                        animated: "",
                        swipeable: ""
                    }, {
                        default: k( () => [S(y, {
                            id: "tab-sign-by-file",
                            style: {
                                "min-height": "40vh"
                            },
                            "tab-active": ""
                        }, {
                            default: k( () => {
                                var _, E, z;
                                return [S(B(zD), {
                                    "device-id": a.value,
                                    "stream-id": r.value
                                }, {
                                    signerSettings: k(T => {
                                        var A, x, M;
                                        return [S(B(L1), {
                                            class: "signer-page-settings",
                                            "has-device": Boolean((A = B(t)) == null ? void 0 : A.device),
                                            "has-premium": Boolean((M = (x = B(t)) == null ? void 0 : x.device) == null ? void 0 : M.hasPremium),
                                            "no-sign-app-button": "",
                                            "signer-object": T.signerObject
                                        }, null, 8, ["has-device", "has-premium", "signer-object"])]
                                    }
                                    ),
                                    _: 1
                                }, 8, ["device-id", "stream-id"]), S(B(DN), {
                                    "has-device": Boolean((_ = B(t)) == null ? void 0 : _.device),
                                    "has-premium": Boolean(!((z = (E = B(t)) == null ? void 0 : E.getServiceByName("premium")) != null && z.isExpired))
                                }, null, 8, ["has-device", "has-premium"])]
                            }
                            ),
                            _: 1
                        }), S(y, {
                            id: "tab-sign-by-url",
                            style: {
                                "min-height": "40vh"
                            }
                        }, {
                            default: k( () => [S(B(OD), {
                                "device-id": a.value,
                                "stream-id": r.value
                            }, {
                                signerSettings: k(_ => {
                                    var E, z, T;
                                    return [S(B(L1), {
                                        class: "signer-page-settings",
                                        "has-device": Boolean((E = B(t)) == null ? void 0 : E.device),
                                        "has-premium": Boolean(!((T = (z = B(t)) == null ? void 0 : z.getServiceByName("premium")) != null && T.isExpired)),
                                        "no-sign-app-button": "",
                                        "signer-object": _.signerObject
                                    }, null, 8, ["has-device", "has-premium", "signer-object"])]
                                }
                                ),
                                _: 1
                            }, 8, ["device-id", "stream-id"]), V("p", jN, [S(d, {
                                f7: "bolt_fill",
                                size: "20"
                            }), J(), UN, J(" than file uploading ")])]),
                            _: 1
                        })]),
                        _: 1
                    })], 64)) : pe("", !0)]),
                    _: 1
                })]),
                _: 1
            })
        }
    }
};
const Rh = e => (qt("data-v-b79527ff"),
e = e(),
Wt(),
e)
  , WN = Rh( () => V("p", null, "Manage sources to control which apps are available to download through FlekSt0re.", -1))
  , YN = Rh( () => V("img", {
    alt: "flekstore icon",
    src: Bu,
    width: "40"
}, null, -1))
  , GN = ["src"]
  , XN = {
    __name: "main",
    setup(e) {
        const t = Fa()
          , n = Cc()
          , a = oe(!1)
          , r = oe(0)
          , o = d => {
            d.target.src = "./icons/tweakicon.png"
        }
        ;
        st(n.sourcesList, d => {
            localStorage.sources = JSON.stringify(d)
        }
        );
        const i = d => {
            d(),
            s()
        }
          , s = () => {
            n.sourcesList.map(p => {
                p.isLoading = !0,
                n.fetchRepoData(p.sourceURL, h => {
                    p.isLoading = !0,
                    Array.isArray(h.data.apps) && (p.subtitle = h.data.subtitle,
                    p.iconURL = h.data.iconURL,
                    p.count = h.data.apps.length)
                }
                , () => {
                    p.isLoading = !1
                }
                )
            }
            )
        }
          , l = () => {
            D.dialog.prompt("Paste source URL. <br><br> We support AltSources.", "Add source", d => {
                D.dialog.preloader(),
                n.fetchRepoData(d, p => {
                    if (n.sourcesList.some(m => m.sourceURL === d))
                        return;
                    const h = {
                        name: p.data.name,
                        subtitle: p.data.subtitle,
                        iconURL: p.data.iconURL,
                        sourceURL: d,
                        count: p.data.apps.length
                    };
                    n.sourcesList.push(h)
                }
                , () => {
                    D.dialog.close()
                }
                )
            }
            )
        }
          , c = d => {
            const {from: p, to: h} = d;
            if (p === h)
                return;
            const m = n.sourcesList.splice(p, 1)[0];
            n.sourcesList.splice(h, 0, m),
            r.value++
        }
          , u = d => {
            D.dialog.confirm("Are you sure you want to delete this source?", "Delete source", () => {
                n.sourcesList.splice(d, 1)
            }
            )
        }
          , f = () => {
            a.value = !a.value,
            setTimeout( () => {
                window.dispatchEvent(new Event("resize"))
            }
            , 1)
        }
        ;
        return Xe( () => {
            s()
        }
        ),
        (d, p) => {
            const h = P("f7-link")
              , m = P("f7-nav-left")
              , g = P("f7-nav-title")
              , b = P("f7-nav-right")
              , v = P("f7-nav-title-large")
              , y = P("f7-navbar")
              , w = P("f7-block-footer")
              , C = P("f7-list-item")
              , _ = P("f7-list")
              , E = P("f7-preloader")
              , z = P("f7-icon")
              , T = P("f7-block")
              , A = P("f7-page");
            return O(),
            K(A, {
                ptr: "",
                "onPtr:refresh": i
            }, {
                default: k( () => [S(y, {
                    class: "navbar-glass-blur",
                    large: "",
                    "no-hairline": "",
                    sliding: !1,
                    transparent: ""
                }, {
                    default: k( () => [S(m, null, {
                        default: k( () => [S(h, {
                            "sortable-toggle": ".sortable",
                            onClick: f
                        }, {
                            default: k( () => [J(Me(a.value ? "Done" : "Edit"), 1)]),
                            _: 1
                        })]),
                        _: 1
                    }), S(g, {
                        sliding: ""
                    }, {
                        default: k( () => [J(" Sources ")]),
                        _: 1
                    }), S(b, null, {
                        default: k( () => [S(h, {
                            "icon-ios": "f7:plus",
                            "icon-only": "",
                            onClick: l
                        })]),
                        _: 1
                    }), S(v, null, {
                        default: k( () => [J("Sources")]),
                        _: 1
                    })]),
                    _: 1
                }), S(An, null, {
                    default: k( () => [S(w, null, {
                        default: k( () => [WN]),
                        _: 1
                    }), S(_, {
                        class: "rounded-items no-margin-bottom",
                        inset: "",
                        "media-list": ""
                    }, {
                        default: k( () => [S(C, {
                            after: "353",
                            footer: "default app catalog",
                            link: "",
                            title: "FlekSt0re Lib",
                            onClick: p[0] || (p[0] = x => B(t).setActiveTab("view-apps"))
                        }, {
                            media: k( () => [YN]),
                            _: 1
                        })]),
                        _: 1
                    }), S(_, {
                        class: "rounded-items margin-top-half",
                        inset: "",
                        "media-list": "",
                        sortable: "",
                        "sortable-opposite": "",
                        "onSortable:sort": c
                    }, {
                        default: k( () => [(O(!0),
                        G(Be, null, vt(B(n).sourcesList, (x, M) => (O(),
                        K(C, {
                            key: `${M}-${r.value}`,
                            footer: x.sourceURL,
                            link: a.value ? !1 : `/source/catalog/${M}/`,
                            title: x.name
                        }, lr({
                            media: k( () => [V("img", {
                                alt: "source icon",
                                src: x.iconURL,
                                width: "40",
                                onError: o
                            }, null, 40, GN)]),
                            "content-end": k( () => [a.value ? (O(),
                            K(h, {
                                key: 0,
                                class: "margin-right",
                                "icon-color": "red",
                                "icon-ios": "f7:minus_circle_fill",
                                "icon-only": "",
                                onClick: L => u(M)
                            }, null, 8, ["onClick"])) : pe("", !0)]),
                            _: 2
                        }, [a.value ? void 0 : {
                            name: "after",
                            fn: k( () => [x.isLoading ? (O(),
                            K(E, {
                                key: 1
                            })) : (O(),
                            G(Be, {
                                key: 0
                            }, [J(Me(x.count), 1)], 64))]),
                            key: "0"
                        }]), 1032, ["footer", "link", "title"]))), 128))]),
                        _: 1
                    }), S(T, {
                        style: {
                            "text-align": "center"
                        }
                    }, {
                        default: k( () => [S(h, {
                            color: "blue",
                            target: "_blank",
                            onClick: p[1] || (p[1] = x => B(D).view.current.router.navigate("/article/", {
                                props: {
                                    articleId: 49
                                }
                            }))
                        }, {
                            default: k( () => [J(" How to make your own app source "), S(z, {
                                f7: "arrow_right_circle_fill",
                                size: "16",
                                style: {
                                    "margin-left": "5px"
                                }
                            })]),
                            _: 1
                        })]),
                        _: 1
                    })]),
                    _: 1
                })]),
                _: 1
            })
        }
    }
}
  , KN = it(XN, [["__scopeId", "data-v-b79527ff"]])
  , ZN = e => e.map(t => {
    let n = [];
    return t.screenshots ? Array.isArray(t.screenshots) && (n = t.screenshots.map(a => typeof a == "string" ? a : a.imageURL)) : t.screenshotURLs && Array.isArray(t.screenshotURLs) && (n = t.screenshotURLs.map(a => typeof a == "string" ? a : a.imageURL)),
    {
        ...t,
        screenshots: n
    }
}
);
const fd = e => (qt("data-v-10287231"),
e = e(),
Wt(),
e)
  , JN = fd( () => V("div", {
    style: {
        height: "var(--f7-navbar-large-title-height)"
    }
}, null, -1))
  , QN = {
    class: "source-catalog__toolbar-sticky"
}
  , eH = fd( () => V("div", {
    class: "source-catalog__toolbar-sticky__bg"
}, null, -1))
  , tH = fd( () => V("div", {
    class: "source-catalog__toolbar-sticky__gradient-bg"
}, null, -1))
  , nH = {
    __name: "catalog",
    props: {
        sourceIndex: {
            type: String,
            default: null
        }
    },
    setup(e) {
        const t = e
          , n = Cc()
          , a = oe(null)
          , r = n.sourcesList[Number(t.sourceIndex)]
          , o = oe(!1)
          , i = oe([])
          , s = oe([])
          , l = oe("")
          , c = oe(0)
          , u = oe(0)
          , f = oe(1)
          , d = () => {
            f.value = window.innerWidth >= 768 ? 2 : 1,
            u.value = a.value.$el.clientWidth / f.value
        }
          , p = () => {
            l.value.trim() || (s.value = i.value),
            s.value = i.value.filter(b => b.name.toLowerCase().includes(l.value.toLowerCase()))
        }
          , h = (b= () => {}
        ) => {
            n.fetchRepoData(r.sourceURL, v => {
                v.data.apps = v.data.apps.map( (y, w) => ({
                    ...y,
                    id: w
                })),
                i.value = ZN(v.data.apps),
                o.value = v.data.website,
                p()
            }
            , () => {
                b()
            }
            )
        }
          , m = () => {
            p(),
            c.value++
        }
          , g = b => {
            i.value = [],
            h(b())
        }
        ;
        return Xe( () => {
            h()
        }
        ),
        (b, v) => {
            const y = P("f7-nav-title")
              , w = P("f7-badge")
              , C = P("f7-preloader")
              , _ = P("f7-nav-right")
              , E = P("f7-nav-title-large")
              , z = P("f7-navbar")
              , T = P("f7-icon")
              , A = P("f7-list-input")
              , x = P("f7-list")
              , M = P("f7-link")
              , L = P("f7-block-footer")
              , U = P("f7-list-item")
              , Y = P("RecycleScroller")
              , H = P("f7-page");
            return O(),
            K(H, {
                ptr: "",
                "onPtr:refresh": g
            }, {
                default: k( () => [S(z, {
                    "back-link": "",
                    large: "",
                    "no-hairline": "",
                    sliding: !1,
                    transparent: ""
                }, {
                    default: k( () => [S(y, {
                        sliding: ""
                    }, {
                        default: k( () => [J(Me(B(r).name), 1)]),
                        _: 1
                    }), S(_, null, {
                        default: k( () => [i.value ? (O(),
                        K(w, {
                            key: 0
                        }, {
                            default: k( () => [J(Me(i.value.length), 1)]),
                            _: 1
                        })) : (O(),
                        K(C, {
                            key: 1
                        }))]),
                        _: 1
                    }), S(E, null, {
                        default: k( () => [J(Me(B(r).name), 1)]),
                        _: 1
                    })]),
                    _: 1
                }), S(An, null, {
                    default: k( () => [JN, V("div", QN, [eH, tH, S(x, {
                        class: "fs-search-input no-margin-top no-margin-bottom",
                        inset: ""
                    }, {
                        default: k( () => [S(A, {
                            value: l.value,
                            "onUpdate:value": [v[0] || (v[0] = W => l.value = W), m],
                            "clear-button": "",
                            placeholder: "Search by app name",
                            type: "text"
                        }, {
                            media: k( () => [S(T, {
                                f7: "search"
                            })]),
                            _: 1
                        }, 8, ["value"])]),
                        _: 1
                    })]), S(L, {
                        class: "margin-bottom"
                    }, {
                        default: k( () => [V("p", null, Me(B(r).subtitle), 1), o.value ? (O(),
                        K(M, {
                            key: 0,
                            color: "blue",
                            external: "",
                            href: o.value,
                            target: "_blank"
                        }, {
                            default: k( () => [J(" Source website "), S(T, {
                                f7: "arrow_right_circle_fill",
                                size: "16",
                                style: {
                                    "margin-left": "5px"
                                }
                            })]),
                            _: 1
                        }, 8, ["href"])) : pe("", !0)]),
                        _: 1
                    }), !i.value || i.value.length === 0 ? (O(),
                    K(B(zB), {
                        key: 0
                    })) : pe("", !0), S(x, {
                        class: "searchbar-not-found",
                        inset: ""
                    }, {
                        default: k( () => [S(U, {
                            title: "Nothing found"
                        })]),
                        _: 1
                    }), i.value.length ? (O(),
                    K(Y, {
                        key: 1,
                        ref_key: "appsListEl",
                        ref: a,
                        class: "scroller list inset rounded-items margin-top-half media-list search-list searchbar-found margin-top",
                        "emit-update": "",
                        "grid-items": f.value,
                        "item-secondary-size": u.value,
                        "item-size": 105,
                        "item-tag": "div",
                        items: s.value,
                        "key-field": "id",
                        "page-mode": "",
                        prerender: 30,
                        onResize: d
                    }, {
                        default: k( ({item: W, index: j}) => {
                            var Q, ne;
                            return [(O(),
                            K(U, {
                                key: `${j}-${c.value}`,
                                footer: (W == null ? void 0 : W.subtitle) ?? (W == null ? void 0 : W.localizedDescription) ?? (W == null ? void 0 : W.bundleID) ?? "",
                                link: "/source/app/",
                                "media-item": "",
                                "route-props": {
                                    appItem: W
                                },
                                subtitle: `v${(W == null ? void 0 : W.version) ?? ((ne = (Q = W == null ? void 0 : W.versions) == null ? void 0 : Q[0]) == null ? void 0 : ne.version) ?? ""}`,
                                title: W.name
                            }, {
                                media: k( () => [S(Mi, {
                                    size: 75,
                                    src: W.iconURL
                                }, null, 8, ["src"])]),
                                _: 2
                            }, 1032, ["footer", "route-props", "subtitle", "title"]))]
                        }
                        ),
                        _: 1
                    }, 8, ["grid-items", "item-secondary-size", "items"])) : pe("", !0)]),
                    _: 1
                })]),
                _: 1
            })
        }
    }
}
  , aH = it(nH, [["__scopeId", "data-v-10287231"]])
  , rH = {
    __name: "viewPopup",
    props: {
        appItem: {
            type: Object,
            default: null
        }
    },
    setup(e) {
        var s, l, c;
        const t = e
          , n = oe(null);
        n.value = t.appItem,
        n.value.ipaUrl = n.value.downloadURL || n.value.versions[0].downloadURL;
        const a = ht()
          , r = oe((s = n.value) == null ? void 0 : s.localizedDescription)
          , o = new kc({
            host: "https://syka.flekstore.com",
            deviceId: ((l = a == null ? void 0 : a.device) == null ? void 0 : l.id) || !0,
            streamId: ((c = a == null ? void 0 : a.device) == null ? void 0 : c.stream.id) || !0
        });
        o.appGeneralSettings.name = n.value.name,
        o.appGeneralSettings.ipaExternalUrl = n.value.downloadURL || n.value.versions[0].downloadURL,
        o.appCustomSettings.name = n.value.name;
        const i = u => {
            r.value = u[0]
        }
        ;
        return Ca( () => {
            o.destroy()
        }
        ),
        (u, f) => {
            const d = P("f7-page")
              , p = P("f7-popup");
            return O(),
            K(p, {
                push: "",
                "swipe-to-close": "to-bottom"
            }, {
                default: k( () => [S(B(ia)), S(d, null, {
                    default: k( () => {
                        var h, m, g, b, v, y, w;
                        return [S(B(HD), {
                            "app-developer": (h = n.value) == null ? void 0 : h.developerName,
                            "app-icon": (m = n.value) == null ? void 0 : m.iconURL,
                            "app-id": (g = n.value) == null ? void 0 : g.id,
                            "app-name": (b = n.value) == null ? void 0 : b.name,
                            "ipa-url": (v = n.value) == null ? void 0 : v.ipaUrl,
                            "old-signer-ui": B(a).oldSignerUI,
                            "signer-object": B(o)
                        }, {
                            "accordion-content": k( () => {
                                var C, _, E;
                                return [S(B(L1), {
                                    "has-device": Boolean((C = B(a)) == null ? void 0 : C.device),
                                    "has-premium": !((E = (_ = B(a)) == null ? void 0 : _.getServiceByName("premium")) != null && E.isExpired),
                                    "signer-object": B(o)
                                }, null, 8, ["has-device", "has-premium", "signer-object"])]
                            }
                            ),
                            _: 1
                        }, 8, ["app-developer", "app-icon", "app-id", "app-name", "ipa-url", "old-signer-ui", "signer-object"]), n.value.id !== B(ra).LC_APP_ID ? (O(),
                        K(B(fh), {
                            key: 0
                        })) : pe("", !0), S(B(BB), {
                            size: n.value.size || n.value.versions[0].size,
                            "updated-date": n.value.versionDate || n.value.versions[0].date,
                            version: n.value.version || n.value.versions[0].version
                        }, null, 8, ["size", "updated-date", "version"]), S(B(yh), {
                            images: (y = n.value) == null ? void 0 : y.screenshots
                        }, null, 8, ["images"]), (w = n.value) != null && w.localizedDescription ? (O(),
                        K(B(LB), {
                            key: 1,
                            text: r.value
                        }, {
                            titleRight: k( () => [S(B(cl), {
                                "after-translate-text": "EN",
                                content: [n.value.localizedDescription],
                                lite: "",
                                "translation-format": "html",
                                onOnComplete: f[0] || (f[0] = C => i(C))
                            }, null, 8, ["content"])]),
                            _: 1
                        }, 8, ["text"])) : pe("", !0)]
                    }
                    ),
                    _: 1
                })]),
                _: 1
            })
        }
    }
};
const Ai = e => (qt("data-v-5a2b0795"),
e = e(),
Wt(),
e)
  , oH = Ai( () => V("br", null, null, -1))
  , iH = ["src"]
  , sH = Ai( () => V("img", {
    alt: "Apple pay and cards",
    src: "https://flekstore.com/client/img/device/stripe_usd_methods.png?2",
    style: {
        width: "100%",
        "max-width": "250px",
        padding: "5px 0 0"
    }
}, null, -1))
  , lH = ["src"]
  , cH = Ai( () => V("div", {
    class: "display-flex align-items-center"
}, [V("div", null, [V("img", {
    src: "https://ipax.pw/ipax_app/icons/ipax_site_logo.png?1",
    width: "60"
})]), V("div", {
    class: "margin-left"
}, " Payment is made through the website of our partners - IPAX code sign. ")], -1))
  , uH = {
    class: "display-flex align-items-center"
}
  , fH = Ai( () => V("div", {
    class: "margin-left"
}, " Cryptocurrency transactions can be delayed by several minutes. Don't worry, this is normal. ", -1))
  , dH = Ai( () => V("div", {
    class: "text-color-red"
}, " Please complete this field. ", -1))
  , pH = {
    style: {
        "text-align": "center"
    }
}
  , hH = Ai( () => V("b", null, "Terms of service", -1))
  , mH = {
    __name: "mainPopup",
    props: {
        offerId: {
            type: String,
            default: "1"
        }
    },
    setup(e) {
        const t = e
          , n = ht()
          , a = n.offers.find(d => d.id === parseInt(t.offerId, 10))
          , r = a.trial_price / 100
          , o = `${Math.random().toString(36).substr(2, 9)}`
          , i = oe(null)
          , s = ae( () => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(i.value))
          , l = {
            stripe: {
                name: "stripe",
                url: `https://api.ipax.pw/stripe/createCheck?id=${n.device.id}&offer=${t.offerId}&p=${o}`
            },
            oldStripe: {
                name: "oldStripe",
                url: `https://ipax.pw/index/createStripeCheckout?id=${n.device.id}&offer=${t.offerId}&p=${o}`
            },
            paypal: {
                name: "paypal",
                url: `https://flekstore.com/rest/device/paypalRedirect?id=${n.device.id}&p=${o}`
            },
            cryptoCloud: {
                name: "cryptoCloud",
                get url() {
                    return `https://api.ipax.pw/cryptocloud/invoice?device_id=${n.device.id}&email=${i.value}&offerId=${t.offerId}&p=${o}`
                }
            },
            centAppUSD: {
                name: "centAppUSD",
                url: `https://ipax.pw/index/createCentAppInvoice?id=${n.device.id}&p=${o}`
            },
            freeKassa: {
                name: "freeKassa",
                url: `https://flekstore.com/rest/device/freekassaRedirect?id=${n.device.id}&p=${o}`
            }
        }
          , c = oe(t.offerId !== "5" ? l.stripe : l.cryptoCloud)
          , u = () => {
            if (n.currentIosIsBeta && (t.offerId === "2" || t.offerId === "3" || t.offerId === "4")) {
                D.dialog.alert("Your device is running a beta version of iOS. To reduce the risk of certificate revocations, we do not allow certificates to be purchased for devices running beta versions of iOS. Please roll back to the release version.");
                return
            }
            localStorage.triedToPurchase = 1,
            n.triedToPurchase = !0,
            window.open(c.value.url, "_blank")
        }
          , f = () => {
            n.getDevice()
        }
        ;
        return (d, p) => {
            const h = P("f7-badge")
              , m = P("f7-list-item")
              , g = P("f7-list")
              , b = P("f7-icon")
              , v = P("f7-card-content")
              , y = P("f7-card")
              , w = P("f7-list-input")
              , C = P("f7-button")
              , _ = P("f7-block")
              , E = P("f7-link")
              , z = P("f7-page")
              , T = P("f7-popup");
            return O(),
            K(T, {
                push: "",
                "swipe-to-close": "to-bottom",
                "onPopup:close": f
            }, {
                default: k( () => [S(B(ia)), S(z, null, {
                    default: k( () => [oH, S(g, {
                        class: "outline",
                        inset: "",
                        "media-list": ""
                    }, {
                        default: k( () => [S(m, {
                            "no-chevron": "",
                            title: B(a).name
                        }, {
                            after: k( () => [S(h, {
                                color: "yellow",
                                "text-color": "black"
                            }, {
                                default: k( () => [J(" $" + Me(r))]),
                                _: 1
                            })]),
                            media: k( () => [V("img", {
                                alt: "Offer logo",
                                height: "60",
                                src: `./icons/${B(a).logo}`,
                                style: {
                                    "border-radius": "23%",
                                    border: "1px solid rgb(221 221 221 / 50%)"
                                }
                            }, null, 8, iH)]),
                            _: 1
                        }, 8, ["title"])]),
                        _: 1
                    }), S(g, {
                        class: "outline-list",
                        inset: ""
                    }, {
                        default: k( () => [S(m, {
                            link: "",
                            "popup-close": "",
                            title: "What do you need to know before paying",
                            onClick: p[0] || (p[0] = A => B(D).view.current.router.navigate("/article/", {
                                props: {
                                    articleId: 6
                                }
                            }))
                        }, {
                            media: k( () => [S(b, {
                                f7: "question_diamond",
                                "text-color": "yellow"
                            })]),
                            _: 1
                        })]),
                        _: 1
                    }), S(g, {
                        class: "rounded-items md",
                        inset: ""
                    }, {
                        default: k( () => [S(m, {
                            checked: c.value.name === l.stripe.name,
                            name: "demo-radio-start",
                            radio: "",
                            "radio-icon": "start",
                            onClick: p[1] || (p[1] = A => c.value = l.stripe)
                        }, {
                            title: k( () => [sH]),
                            _: 1
                        }, 8, ["checked"]), B(a).id === 5 || B(a).id === 7 ? (O(),
                        K(m, {
                            key: 0,
                            checked: c.value.name === l.cryptoCloud.name,
                            name: "demo-radio-start",
                            radio: "",
                            "radio-icon": "start",
                            onClick: p[2] || (p[2] = A => c.value = l.cryptoCloud)
                        }, {
                            title: k( () => [V("img", {
                                alt: "Crypto USDT and Bitcoin",
                                src: "./icons/Crypto.svg",
                                style: {
                                    width: "100%",
                                    height: "36px",
                                    "max-width": "250px",
                                    padding: "5px 0 0"
                                }
                            }, null, 8, lH)]),
                            _: 1
                        }, 8, ["checked"])) : pe("", !0)]),
                        _: 1
                    }), c.value.name === l.stripe.name ? (O(),
                    K(y, {
                        key: 0
                    }, {
                        default: k( () => [S(v, null, {
                            default: k( () => [cH]),
                            _: 1
                        })]),
                        _: 1
                    })) : pe("", !0), c.value.name === l.cryptoCloud.name ? (O(),
                    G(Be, {
                        key: 1
                    }, [S(y, null, {
                        default: k( () => [S(v, null, {
                            default: k( () => [V("div", uH, [V("div", null, [S(b, {
                                color: "orange",
                                f7: "hourglass",
                                size: "36"
                            })]), fH])]),
                            _: 1
                        })]),
                        _: 1
                    }), S(g, {
                        inset: "",
                        "media-list": ""
                    }, {
                        default: k( () => [S(w, {
                            value: i.value,
                            "onUpdate:value": p[3] || (p[3] = A => i.value = A),
                            "clear-button": "",
                            placeholder: "someemail@example.com",
                            required: "",
                            type: "email",
                            validate: ""
                        }, lr({
                            media: k( () => [S(b, {
                                f7: "envelope"
                            })]),
                            _: 2
                        }, [i.value ? void 0 : {
                            name: "info",
                            fn: k( () => [dH]),
                            key: "0"
                        }]), 1032, ["value"])]),
                        _: 1
                    })], 64)) : pe("", !0), S(_, null, {
                        default: k( () => [S(C, {
                            disabled: c.value.name === l.cryptoCloud.name && !s.value,
                            fill: "",
                            large: "",
                            round: "",
                            onClick: u
                        }, {
                            default: k( () => [S(b, {
                                f7: "arrow_right_circle_fill",
                                style: {
                                    "font-size": "inherit"
                                }
                            }), J(" Purchase ")]),
                            _: 1
                        }, 8, ["disabled"])]),
                        _: 1
                    }), S(_, null, {
                        default: k( () => [V("div", pH, [V("p", null, [J(" By paying, you confirm that you accept the "), S(E, {
                            color: "blue",
                            href: "/docs/3/"
                        }, {
                            default: k( () => [hH]),
                            _: 1
                        })])])]),
                        _: 1
                    })]),
                    _: 1
                })]),
                _: 1
            })
        }
    }
}
  , gH = it(mH, [["__scopeId", "data-v-5a2b0795"]])
  , vH = "/docs-category";
var H1;
class bH {
    constructor() {
        mn(this, H1, Ur)
    }
    getDocsCategories(t) {
        return pt(this, H1).get(`${vH}`, t)
    }
}
H1 = new WeakMap;
const yH = new bH
  , CH = oa("docsCategory", {
    state: () => ({
        isLoading: !1,
        loadingError: !1,
        listItems: []
    }),
    getters: {},
    actions: {
        resetLoadingState() {
            this.isLoading = !0,
            this.loadingError = !1
        },
        async getList() {
            this.resetLoadingState();
            try {
                const e = await yH.getDocsCategories();
                return this.listItems = e.data,
                e.data
            } catch {
                return this.loadingError = !0,
                null
            } finally {
                this.isLoading = !1
            }
        }
    }
})
  , Tp = "/docs";
var Bs;
class wH {
    constructor() {
        mn(this, Bs, Ur)
    }
    getList(t) {
        return pt(this, Bs).get(`${Tp}`, t)
    }
    getItem(t) {
        return pt(this, Bs).get(`${Tp}/${t}`)
    }
}
Bs = new WeakMap;
const Mp = new wH
  , Dh = oa("docs", {
    state: () => ({
        isLoading: !1,
        loadingError: !1,
        listItems: []
    }),
    getters: {
        getCategoriesWithDocuments: e => t => t.map(n => ({
            name: n.name,
            documents: e.listItems.filter(a => a.categories.includes(n.id)).map(a => ({
                id: a.id,
                title: a.title
            }))
        })),
        searchDocumentsByTitle: e => t => {
            const n = t.toLowerCase();
            return e.listItems.filter(a => a.title.toLowerCase().includes(n))
        }
    },
    actions: {
        resetLoadingState() {
            this.isLoading = !0,
            this.loadingError = !1
        },
        async getList(e) {
            this.resetLoadingState();
            try {
                const t = await Mp.getList(e);
                return this.listItems = t.data,
                t.data
            } catch {
                return this.loadingError = !0,
                null
            } finally {
                this.isLoading = !1
            }
        },
        async getItem(e) {
            this.resetLoadingState();
            try {
                return (await Mp.getItem(e)).data
            } catch {
                return this.loadingError = !0,
                null
            } finally {
                this.isLoading = !1
            }
        }
    }
});
const _H = {};
function kH(e, t) {
    const n = P("f7-skeleton-block")
      , a = P("f7-list-item")
      , r = P("f7-list");
    return O(),
    K(r, {
        class: "help-center-list-skeleton__list skeleton-text skeleton-effect-wave large-items-list",
        "medium-inset": "",
        "no-hairlines": "",
        "no-hairlines-between": ""
    }, {
        default: k( () => [(O(),
        G(Be, null, vt(15, o => S(a, {
            key: o,
            title: "Lorem dsakjljkasjd sadj"
        }, {
            "inner-end": k( () => [S(n, {
                style: {
                    height: "120px",
                    "border-radius": "16px",
                    margin: "16px 0"
                }
            })]),
            _: 2
        }, 1024)), 64))]),
        _: 1
    })
}
const SH = it(_H, [["render", kH]]);
const $H = {
    class: "display-flex align-items-center justify-content-space-between margin-top"
}
  , EH = {
    class: "padding-horizontal"
}
  , xH = V("div", {
    class: "docs-list__group-title-sticky__bg"
}, null, -1)
  , TH = V("div", {
    class: "docs-list__group-title-sticky__gradient-bg"
}, null, -1)
  , MH = {
    class: "docs-list__group-title-sticky__content"
}
  , zH = {
    class: "history-popup__transactions-group"
}
  , AH = V("b", null, "Nothing found", -1)
  , OH = V("br", null, null, -1)
  , PH = V("br", null, null, -1)
  , LH = V("div", {
    style: {
        "max-width": "240px",
        margin: "0 auto"
    }
}, " Try rephrasing the question or just looking through the list of issues. ", -1)
  , IH = V("br", null, null, -1)
  , BH = V("br", null, null, -1)
  , RH = {
    __name: "list",
    setup(e) {
        const t = Dh()
          , n = CH()
          , a = ht()
          , r = oe([])
          , o = oe([])
          , i = oe(null)
          , s = oe([])
          , l = oe(null)
          , c = [{
            text: "Contact Support",
            bold: !0,
            onClick: () => {
                window.open(`mailto:premium@flekstore.com?subject=UDID: ${a == null ? void 0 : a.device.udid} iOS: ${a == null ? void 0 : a.deviceIosVersion}`, "_blank")
            }
        }, {
            text: "Close",
            onClick: () => {
                localStorage.canCopySupportEmail = !0
            }
        }]
          , u = [{
            text: "Contact Support",
            bold: !0,
            onClick: () => {
                window.open(`mailto:premium@flekstore.com?subject=UDID: ${a == null ? void 0 : a.device.udid} iOS: ${a == null ? void 0 : a.deviceIosVersion}`, "_blank")
            }
        }, {
            text: "Copy Support Email",
            bold: !0,
            onClick: () => {
                tl("premium@flekstore.com"),
                hc("Email was copied")
            }
        }, {
            text: "Close"
        }]
          , f = g => {
            if (g === "") {
                s.value = [];
                return
            }
            const b = [];
            r.value.forEach(v => {
                v.documents.forEach(y => {
                    y.title.toLowerCase().includes(g.toLowerCase()) && b.push(y)
                }
                )
            }
            ),
            s.value = b
        }
          , d = g => {
            D.view.current.router.navigate(`/docs/${g}/`, {
                props: {
                    initTranslate: l.value.textIsTranslated()
                }
            })
        }
          , p = () => {
            D.dialog.create({
                title: "",
                text: "In 80% of requests, users could usually find the answer in the Help Center catalog. <br><br> Please, before contacting a technical support specialist, make sure that you have not found the answer in the list of questions. ",
                verticalButtons: !0,
                buttons: localStorage.canCopySupportEmail ? u : c
            }).open()
        }
          , h = g => {
            let b = 0;
            r.value = r.value.map(v => {
                const y = {
                    name: g[b],
                    documents: v.documents.map(w => ({
                        id: w.id,
                        title: g[++b]
                    }))
                };
                return b++,
                y
            }
            )
        }
          , m = g => {
            const b = [];
            return g.forEach(v => {
                b.push(v.name),
                v.documents.forEach(y => {
                    b.push(y.title)
                }
                )
            }
            ),
            b
        }
        ;
        return Xe(async () => {
            await n.getList(),
            await t.getList({
                page: 0,
                search: !1,
                filter: "faq"
            }),
            o.value = t.getCategoriesWithDocuments(n.listItems),
            r.value = o.value
        }
        ),
        (g, b) => {
            const v = P("f7-link")
              , y = P("f7-nav-right")
              , w = P("f7-navbar")
              , C = P("f7-block-header")
              , _ = P("f7-icon")
              , E = P("f7-list-input")
              , z = P("f7-list")
              , T = P("f7-list-item")
              , A = P("f7-list-group")
              , x = P("f7-chip")
              , M = P("f7-block")
              , L = P("f7-page");
            return O(),
            K(L, null, {
                default: k( () => [S(w, {
                    "back-link": "",
                    large: "",
                    "large-transparent": "",
                    "no-hairline": "",
                    sliding: !1,
                    title: " Help Center"
                }, {
                    default: k( () => [B(a).canContactSupport ? (O(),
                    K(y, {
                        key: 0
                    }, {
                        default: k( () => [S(v, {
                            "icon-f7": "bubble_left_bubble_right",
                            "icon-size": "24",
                            onClick: p
                        })]),
                        _: 1
                    })) : pe("", !0)]),
                    _: 1
                }), S(B(An), null, {
                    default: k( () => {
                        var U;
                        return [V("div", $H, [S(C, {
                            class: "no-margin"
                        }, {
                            default: k( () => [J(" Most likely your question already has an answer. ")]),
                            _: 1
                        }), V("div", EH, [S(B(cl), {
                            ref_key: "translateButtonRef",
                            ref: l,
                            "after-translate-text": "EN",
                            content: m(o.value),
                            disabled: (U = i.value) == null ? void 0 : U.length,
                            lite: "",
                            onOnComplete: b[0] || (b[0] = Y => h(Y))
                        }, null, 8, ["content", "disabled"])])]), S(z, {
                            class: "fs-search-input margin-top no-margin-bottom",
                            inset: ""
                        }, {
                            default: k( () => [S(E, {
                                value: i.value,
                                "onUpdate:value": [b[1] || (b[1] = Y => i.value = Y), f],
                                "clear-button": "",
                                placeholder: "Search by issue title",
                                type: "text"
                            }, {
                                media: k( () => [S(_, {
                                    f7: "search"
                                })]),
                                _: 1
                            }, 8, ["value"])]),
                            _: 1
                        }), r.value.length ? (O(),
                        G(Be, {
                            key: 1
                        }, [i.value ? (O(),
                        K(z, {
                            key: 1,
                            class: "faq-list__search-list",
                            inset: "",
                            "media-list": ""
                        }, {
                            default: k( () => [(O(!0),
                            G(Be, null, vt(s.value, (Y, H) => (O(),
                            K(T, {
                                key: H,
                                "no-chevron": "",
                                text: Y.title,
                                onClick: W => d(Y.id)
                            }, null, 8, ["text", "onClick"]))), 128))]),
                            _: 1
                        })) : (O(),
                        K(z, {
                            key: 0,
                            class: "faq-list__list",
                            inset: "",
                            "media-list": ""
                        }, {
                            default: k( () => [(O(!0),
                            G(Be, null, vt(r.value, (Y, H) => (O(),
                            K(A, {
                                key: H
                            }, {
                                default: k( () => [S(T, {
                                    "group-title": ""
                                }, {
                                    default: k( () => [xH, TH, V("div", MH, Me(Y.name), 1)]),
                                    _: 2
                                }, 1024), V("div", zH, [(O(!0),
                                G(Be, null, vt(Y.documents, (W, j) => (O(),
                                K(T, {
                                    key: j,
                                    "no-chevron": "",
                                    text: W.title,
                                    onClick: Q => d(W.id)
                                }, null, 8, ["text", "onClick"]))), 128))])]),
                                _: 2
                            }, 1024))), 128))]),
                            _: 1
                        })), i.value && !s.value.length ? (O(),
                        K(M, {
                            key: 2,
                            style: {
                                "text-align": "center"
                            }
                        }, {
                            default: k( () => [AH, OH, PH, LH, IH, BH, S(v, {
                                onClick: p
                            }, {
                                default: k( () => [S(x, {
                                    color: "blue",
                                    outline: ""
                                }, {
                                    default: k( () => [S(_, {
                                        class: "margin-right-half",
                                        f7: "bubble_left_bubble_right_fill",
                                        size: "18"
                                    }), J(" Contact support ")]),
                                    _: 1
                                })]),
                                _: 1
                            })]),
                            _: 1
                        })) : pe("", !0)], 64)) : (O(),
                        K(B(SH), {
                            key: 0
                        }))]
                    }
                    ),
                    _: 1
                })]),
                _: 1
            })
        }
    }
};
const DH = {
    key: 0,
    class: "docs__view-popup__toolbar"
}
  , NH = V("div", {
    class: "docs__view-popup__toolbar-layout-wrapper toolbar-menu"
}, [V("div", {
    class: "docs__view-popup__toolbar-sticky__gradient-bg"
})], -1)
  , HH = {
    key: 0,
    class: "skeleton-text"
}
  , VH = V("p", null, "Lorem asdnjjkasd jsadsak sadkjasd Lorem asdnjjkasd jsadsak sadkjasd Lorem asdnjjkasd jsadsak sadkjasd", -1)
  , FH = {
    key: 1
}
  , jH = ["innerHTML"]
  , UH = {
    key: 0,
    class: "no-margin-top"
}
  , qH = V("b", {
    class: "block-title no-margin-left"
}, "10. Bonus for Attentive Users", -1)
  , WH = V("br", null, null, -1)
  , YH = V("br", null, null, -1)
  , GH = {
    __name: "viewPopup",
    props: {
        itemId: {
            type: String,
            default: null
        },
        initTranslate: {
            type: Boolean,
            default: !1
        }
    },
    setup(e) {
        const t = e
          , n = Dh()
          , a = ht()
          , r = oe(null)
          , o = oe(null)
          , i = oe(null)
          , s = oe(null)
          , l = c => {
            i.value = c[0],
            s.value = c[1]
        }
        ;
        return Xe(async () => {
            o.value = await n.getItem(t.itemId),
            i.value = o.value.title,
            s.value = o.value.text,
            setTimeout( () => {
                t.initTranslate && r.value.translate()
            }
            )
        }
        ),
        (c, u) => {
            const f = P("f7-block-title")
              , d = P("f7-block")
              , p = P("f7-link")
              , h = P("f7-icon")
              , m = P("f7-button")
              , g = P("f7-page")
              , b = P("f7-popup");
            return O(),
            K(b, {
                push: "",
                "swipe-to-close": "to-bottom"
            }, {
                default: k( () => [S(B(ia)), i.value ? (O(),
                G("div", DH, [S(B(cl), {
                    ref_key: "translateButtonRef",
                    ref: r,
                    "after-translate-text": "Return to English",
                    "before-translate-text": "Translate to",
                    class: "docs__view-popup__translation-button button-glass button-fit button-center",
                    content: [o.value.title, o.value.text],
                    "translation-format": "html",
                    onOnComplete: u[0] || (u[0] = v => l(v))
                }, null, 8, ["content"]), NH])) : pe("", !0), S(g, null, {
                    default: k( () => [i.value ? (O(),
                    G("div", FH, [S(f, {
                        medium: ""
                    }, {
                        default: k( () => [J(Me(i.value), 1)]),
                        _: 1
                    }), S(d, {
                        class: "text-document-content"
                    }, {
                        default: k( () => {
                            var v, y;
                            return [V("p", {
                                innerHTML: s.value
                            }, null, 8, jH), e.itemId === "3" && (((v = B(a).device) == null ? void 0 : v.hasActivation) === !1 || (y = B(a).device) != null && y.isUserStream) ? (O(),
                            G("p", UH, [qH, WH, YH, J(" 10.1 We value careful and informed users. If youve read this far, we have a small surprise for you. "), S(p, {
                                href: "/device/certificate-offer-details/",
                                "route-props": {
                                    offerAlias: "certificateByFlekStore1399"
                                },
                                "text-color": "blue"
                            }, {
                                default: k( () => [J(" Claim Your Discount. ")]),
                                _: 1
                            })])) : pe("", !0)]
                        }
                        ),
                        _: 1
                    }), B(a).canContactSupport ? (O(),
                    K(d, {
                        key: 0,
                        style: {
                            "text-align": "center"
                        }
                    }, {
                        default: k( () => {
                            var v, y, w, C;
                            return [e.itemId === "66" ? (O(),
                            K(m, {
                                key: 0,
                                class: "button-lite margin-vertical",
                                external: "",
                                href: `mailto:premium@flekstore.com?subject=Refund request | UDID: ${(y = (v = B(a)) == null ? void 0 : v.device) == null ? void 0 : y.udid}`,
                                large: "",
                                round: ""
                            }, {
                                default: k( () => [J(" Request a Refund "), S(h, {
                                    class: "margin-left-half",
                                    f7: "arrow_right_circle_fill"
                                })]),
                                _: 1
                            }, 8, ["href"])) : pe("", !0), S(p, {
                                class: "single-link-font",
                                color: "blue",
                                external: "",
                                href: `mailto:premium@flekstore.com?subject=UDID: ${(C = (w = B(a)) == null ? void 0 : w.device) == null ? void 0 : C.udid} iOS: ${B(a).deviceIosVersion}`
                            }, {
                                default: k( () => [S(h, {
                                    f7: "envelope_fill",
                                    style: {
                                        "font-size": "large"
                                    }
                                }), J("  I still need help ")]),
                                _: 1
                            }, 8, ["href"])]
                        }
                        ),
                        _: 1
                    })) : pe("", !0)])) : (O(),
                    G("div", HH, [S(f, {
                        medium: ""
                    }, {
                        default: k( () => [J(" Lorem asdnjjkasd jsadsak sadkjasd ")]),
                        _: 1
                    }), S(d, null, {
                        default: k( () => [VH]),
                        _: 1
                    })]))]),
                    _: 1
                })]),
                _: 1
            })
        }
    }
}
  , XH = {}
  , KH = V("p", null, "Sorry", -1)
  , ZH = V("p", null, "Requested content not found.", -1);
function JH(e, t, n, a, r, o) {
    const i = P("f7-navbar")
      , s = P("f7-block")
      , l = P("f7-page");
    return O(),
    K(l, null, {
        default: k( () => [S(i, {
            "back-link": "",
            title: "Not found"
        }), S(s, {
            strong: ""
        }, {
            default: k( () => [KH, ZH]),
            _: 1
        })]),
        _: 1
    })
}
const QH = it(XH, [["render", JH]])
  , eV = {
    dispute: {
        description: `Your device's access to the service has been limited due to a chargeback through
                a bank or contacting a merchant.
                

                In accordance with the service rules, all claims and refunds are made through our support 
                service by mutual agreement.
                Other user behavior is regarded as suspicious activity causing damage to the service.
                In accordance with this, the provision of services for this device has been unilaterally suspended.`
    },
    terms_of_service: {
        description: "Your device's access to the service has been restricted due to activity that is contrary to the service rules."
    }
};
const tV = V("br", null, null, -1)
  , nV = V("b", null, "Reason:", -1)
  , aV = {
    style: {
        "font-size": "14px",
        "white-space": "pre-line"
    }
}
  , rV = {
    __name: "banned",
    props: {
        banReason: {
            type: String,
            default: "terms_of_service"
        }
    },
    setup(e) {
        const t = ht();
        return (n, a) => {
            const r = P("f7-icon")
              , o = P("f7-login-screen-title")
              , i = P("f7-card-content")
              , s = P("f7-card")
              , l = P("f7-link")
              , c = P("f7-block-footer")
              , u = P("f7-list")
              , f = P("f7-page")
              , d = P("f7-login-screen");
            return O(),
            K(d, {
                class: "demo-login-screen"
            }, {
                default: k( () => [S(f, {
                    "login-screen": ""
                }, {
                    default: k( () => [S(o, null, {
                        default: k( () => [S(r, {
                            color: "red",
                            f7: "exclamationmark_octagon",
                            size: "56"
                        }), tV, J(" Access blocked ")]),
                        _: 1
                    }), S(u, null, {
                        default: k( () => [S(s, null, {
                            default: k( () => [S(i, null, {
                                default: k( () => [nV, V("p", aV, Me(B(eV)[e.banReason].description), 1)]),
                                _: 1
                            })]),
                            _: 1
                        }), S(c, {
                            class: "margin-top"
                        }, {
                            default: k( () => {
                                var p, h;
                                return [J(" To restore access, you can "), S(l, {
                                    class: "text-color-blue",
                                    external: "",
                                    href: `mailto:premium@flekstore.com?subject=Unban request | UDID: ${(h = (p = B(t)) == null ? void 0 : p.device) == null ? void 0 : h.udid}`
                                }, {
                                    default: k( () => [J(" contact support. ")]),
                                    _: 1
                                }, 8, ["href"])]
                            }
                            ),
                            _: 1
                        })]),
                        _: 1
                    })]),
                    _: 1
                })]),
                _: 1
            })
        }
    }
};
const oV = {
    __name: "main",
    setup(e) {
        const t = _a()
          , n = oe(!1)
          , a = async r => {
            n.value = !0;
            try {
                await t.getBalance(),
                await t.getReferralCode(),
                await t.getTasks()
            } catch (o) {
                console.error("Error loading data:", o)
            } finally {
                n.value = !1,
                r()
            }
        }
        ;
        return Xe(async () => {
            await t.getBalance(),
            await t.getReferralCode()
        }
        ),
        (r, o) => {
            const i = P("f7-icon")
              , s = P("f7-link")
              , l = P("f7-navbar")
              , c = P("f7-page");
            return O(),
            K(c, {
                ptr: "",
                "onPtr:refresh": a
            }, {
                default: k( () => [S(l, {
                    "back-link": "",
                    class: "navbar-glass-blur",
                    "no-hairline": "",
                    sliding: !1,
                    title: "Hi, partner!"
                }, {
                    right: k( () => [S(s, {
                        "icon-only": "",
                        onClick: o[0] || (o[0] = u => a( () => {}
                        ))
                    }, {
                        default: k( () => [S(i, {
                            class: Ae({
                                spinner: n.value
                            }),
                            f7: "arrow_2_circlepath"
                        }, null, 8, ["class"])]),
                        _: 1
                    })]),
                    _: 1
                }), S(B(An), null, {
                    default: k( () => [B(t).loadingError ? (O(),
                    K(B(bc), {
                        key: 0,
                        "icon-name": "wifi_exclamationmark",
                        text: "Loading error! Pull down to try again."
                    })) : pe("", !0), S(B(HI)), S(B(II))]),
                    _: 1
                })]),
                _: 1
            })
        }
    }
}
  , iV = "" + new URL("../icons/PremiumPartnerIcon.png?1",import.meta.url).href;
const dd = e => (qt("data-v-ca4c4f27"),
e = e(),
Wt(),
e)
  , sV = dd( () => V("div", {
    style: {
        "text-align": "center"
    }
}, [V("img", {
    class: "partner-program-description-popup___header-icon",
    src: iV
}), V("h2", {
    class: "partner-program-description-popup___header-title no-margin"
}, " Join our Partner Program  "), V("p", null, "You boost us, we boost your premium!")], -1))
  , lV = dd( () => V("div", {
    class: "colored-bg"
}, null, -1))
  , cV = dd( () => V("b", null, "Premium Access for FREE!", -1))
  , uV = {
    __name: "partnerProgramDescriptionPopup",
    setup(e) {
        const t = _a()
          , n = () => {
            t.startPartnerProgramForDevice( () => {
                D.popup.close(),
                D.view.current.router.navigate("/partner/main/")
            }
            )
        }
        ;
        return (a, r) => {
            const o = P("f7-icon")
              , i = P("f7-list-item")
              , s = P("f7-list")
              , l = P("f7-button")
              , c = P("f7-block")
              , u = P("f7-link")
              , f = P("f7-block-footer")
              , d = P("f7-page")
              , p = P("f7-popup");
            return O(),
            K(p, {
                push: "",
                "swipe-to-close": "to-bottom"
            }, {
                default: k( () => [S(B(ia)), S(d, null, {
                    default: k( () => [sV, S(s, {
                        class: "features-list premium-only-offer",
                        inset: "",
                        "no-hairlines": "",
                        "no-hairlines-between": ""
                    }, {
                        default: k( () => [lV, S(i, null, {
                            title: k( () => [J(" Invite friends ")]),
                            media: k( () => [S(o, {
                                f7: "person_badge_plus_fill",
                                "text-color": "yellow"
                            })]),
                            _: 1
                        }), S(i, null, {
                            title: k( () => [J(" omplete tasks ")]),
                            media: k( () => [S(o, {
                                f7: "checkmark_seal_fill",
                                "text-color": "yellow"
                            })]),
                            _: 1
                        }), S(i, null, {
                            title: k( () => [J(" Earn extra days of "), cV]),
                            media: k( () => [S(o, {
                                f7: "gift_alt_fill",
                                "text-color": "yellow"
                            })]),
                            _: 1
                        })]),
                        _: 1
                    }), S(c, null, {
                        default: k( () => [S(l, {
                            fill: "",
                            large: "",
                            round: "",
                            onClick: n
                        }, {
                            default: k( () => [J(" Get started ")]),
                            _: 1
                        })]),
                        _: 1
                    }), S(f, {
                        class: "text-align-center margin-top",
                        style: {
                            "font-size": "12px"
                        }
                    }, {
                        default: k( () => [J(" By participating in the partner program, you agree to the terms and conditions of the partner program described in the "), S(u, {
                            href: "/docs/3/"
                        }, {
                            default: k( () => [J(" Terms of Services ")]),
                            _: 1
                        }), J(". ")]),
                        _: 1
                    })]),
                    _: 1
                })]),
                _: 1
            })
        }
    }
}
  , fV = it(uV, [["__scopeId", "data-v-ca4c4f27"]]);
const Nh = e => (qt("data-v-99889346"),
e = e(),
Wt(),
e)
  , dV = {
    style: {
        "text-align": "center"
    }
}
  , pV = ["src"]
  , hV = {
    class: "partner-program-description-popup___header-title no-margin-bottom"
}
  , mV = Nh( () => V("p", null, [J(" Share your referral link on social networks and receive a reward for every purchase made through your link. "), V("br"), V("br"), J(" The number of rewards is unlimited, so the more people you refer, the more you will receive. ")], -1))
  , gV = Nh( () => V("div", null, " Referral Link ", -1))
  , vV = {
    __name: "referralTaskDescriptionPopup",
    props: {
        taskId: {
            type: Number,
            required: !0
        }
    },
    setup(e) {
        const t = e
          , n = _a()
          , a = "https://flekstore.com"
          , r = oe(null)
          , o = n.getTaskById(t.taskId);
        return (i, s) => {
            const l = P("f7-badge")
              , c = P("f7-card-content")
              , u = P("f7-link")
              , f = P("f7-row")
              , d = P("f7-card-footer")
              , p = P("f7-card")
              , h = P("f7-button")
              , m = P("f7-block")
              , g = P("f7-page")
              , b = P("f7-popup");
            return O(),
            K(b, {
                push: "",
                "swipe-to-close": "to-bottom"
            }, {
                default: k( () => [S(B(ia)), S(g, null, {
                    default: k( () => [V("div", dV, [V("img", {
                        class: "referral-task-description-popup___header-icon",
                        src: `./icons/${B(o).icon}?3`
                    }, null, 8, pV), V("h2", hV, Me(B(o).title), 1), V("p", null, [S(l, {
                        color: "blue"
                    }, {
                        default: k( () => [J(" +" + Me(B(o).bonus_amount) + " coins ", 1)]),
                        _: 1
                    }), J(" " + Me(B(o).bonus_reason), 1)])]), S(p, {
                        inset: "",
                        strong: ""
                    }, {
                        default: k( () => [S(c, null, {
                            default: k( () => [mV]),
                            _: 1
                        }), S(d, null, {
                            default: k( () => [V("div", null, [gV, S(f, {
                                class: "padding-bottom-half align-items-center"
                            }, {
                                default: k( () => [S(u, {
                                    class: "partner-main___referral-url",
                                    onClick: s[0] || (s[0] = v => {
                                        var y;
                                        return (y = r.value) == null ? void 0 : y.handleCopyClick(` ${B(a)}/${B(n).referralCode}`)
                                    }
                                    )
                                }, {
                                    default: k( () => [J(Me(B(a)) + "/" + Me(B(n).referralCode), 1)]),
                                    _: 1
                                }), S(B(uh), {
                                    ref_key: "shareLinkRef",
                                    ref: r,
                                    code: B(n).referralCode
                                }, null, 8, ["code"])]),
                                _: 1
                            })])]),
                            _: 1
                        })]),
                        _: 1
                    }), S(m, {
                        class: "margin-top"
                    }, {
                        default: k( () => [S(h, {
                            fill: "",
                            "icon-f7": "square_on_square",
                            large: "",
                            round: "",
                            onClick: s[1] || (s[1] = v => {
                                var y;
                                return (y = r.value) == null ? void 0 : y.handleCopyClick(` ${B(a)}/${B(n).referralCode}`)
                            }
                            )
                        }, {
                            default: k( () => [J(" Copy Link ")]),
                            _: 1
                        })]),
                        _: 1
                    })]),
                    _: 1
                })]),
                _: 1
            })
        }
    }
}
  , bV = it(vV, [["__scopeId", "data-v-99889346"]]);
const pd = e => (qt("data-v-0b38fcbd"),
e = e(),
Wt(),
e)
  , yV = {
    style: {
        "text-align": "center"
    }
}
  , CV = ["src"]
  , wV = {
    class: "partner-program-description-popup___header-title no-margin-bottom"
}
  , _V = {
    class: "display-flex margin-vertical"
}
  , kV = pd( () => V("div", null, [J("Head over to the bloggers YouTube channel and press "), V("b", null, "Subscribe"), J(".")], -1))
  , SV = {
    class: "display-flex margin-vertical"
}
  , $V = pd( () => V("div", null, [J("When you're done, come back to FlekSt0re and tap "), V("b", null, "Ive subscribed"), J(" to get your bonus.")], -1))
  , EV = pd( () => V("br", null, null, -1))
  , xV = {
    __name: "youtubeTaskDescriptionPopup",
    props: {
        taskId: {
            type: Number,
            required: !0
        },
        youTubeLink: {
            type: String,
            required: !0
        }
    },
    setup(e) {
        const t = e
          , n = _a()
          , a = n.getTaskById(t.taskId)
          , r = oe(!1)
          , o = oe(!1)
          , i = oe(!0)
          , s = async () => {
            if (o.value = !0,
            i.value) {
                setTimeout( () => {
                    D.dialog.alert("Subscription verification failed. <br><br> Make sure you are subscribed to the specified channel and try again.", "Something went wrong"),
                    i.value = !1,
                    o.value = !1
                }
                , 800);
                return
            }
            try {
                await eo.completeTask({
                    device_id: Number(localStorage.device_id),
                    task_id: t.taskId
                }),
                D.dialog.alert(`Balance successfully replenished by ${a.bonus_amount} FlekCoins! <br><br> Thanks for subscribing `, "Success "),
                await n.getBalance(),
                await n.getTasks(),
                D.popup.close()
            } catch (l) {
                D.dialog.alert(l.response.data.message, "Something went wrong")
            } finally {
                o.value = !1
            }
        }
        ;
        return (l, c) => {
            const u = P("f7-badge")
              , f = P("f7-card-content")
              , d = P("f7-card")
              , p = P("f7-button")
              , h = P("f7-block")
              , m = P("f7-page")
              , g = P("f7-popup");
            return O(),
            K(g, {
                push: "",
                "swipe-to-close": "to-bottom"
            }, {
                default: k( () => [S(B(ia)), S(m, null, {
                    default: k( () => [V("div", yV, [V("img", {
                        class: "referral-task-description-popup___header-icon",
                        src: `./icons/${B(a).icon}?3`
                    }, null, 8, CV), V("h2", wV, Me(B(a).title), 1), V("p", null, [S(u, {
                        color: "blue"
                    }, {
                        default: k( () => [J(" +" + Me(B(a).bonus_amount) + " coins ", 1)]),
                        _: 1
                    }), J(" " + Me(B(a).bonus_reason), 1)])]), S(d, {
                        inset: "",
                        strong: ""
                    }, {
                        default: k( () => [S(f, null, {
                            default: k( () => [V("div", _V, [S(u, {
                                class: "vertical-align-bottom margin-right-half"
                            }, {
                                default: k( () => [J(" 1 ")]),
                                _: 1
                            }), kV]), V("div", SV, [S(u, {
                                class: "vertical-align-bottom margin-right-half"
                            }, {
                                default: k( () => [J(" 2 ")]),
                                _: 1
                            }), $V])]),
                            _: 1
                        })]),
                        _: 1
                    }), S(h, {
                        class: "margin-top"
                    }, {
                        default: k( () => [S(p, {
                            external: "",
                            fill: "",
                            href: e.youTubeLink,
                            "icon-f7": "play_rectangle_fill",
                            large: "",
                            target: "_blank",
                            onClick: c[0] || (c[0] = b => r.value = !0)
                        }, {
                            default: k( () => [J(" Go to Channel ")]),
                            _: 1
                        }, 8, ["href"]), EV, r.value ? (O(),
                        K(p, {
                            key: 0,
                            class: "button-lite",
                            "icon-f7": "checkmark_alt_circle_fill",
                            large: "",
                            loading: o.value,
                            preloader: "",
                            onClick: s
                        }, {
                            default: k( () => [J(" Ive subscribed ")]),
                            _: 1
                        }, 8, ["loading"])) : pe("", !0)]),
                        _: 1
                    })]),
                    _: 1
                })]),
                _: 1
            })
        }
    }
}
  , TV = it(xV, [["__scopeId", "data-v-0b38fcbd"]]);
const MV = {
    class: "history-popup__transactions-group"
}
  , zV = ["src"]
  , AV = {
    key: 1,
    style: {
        "text-align": "center"
    }
}
  , OV = V("h2", {
    class: "text-color-gray"
}, " Loading ", -1)
  , PV = {
    __name: "historyPopup",
    setup(e) {
        const t = r => Si.format(new Date(Date.parse(r)))
          , n = _a()
          , a = oe(null);
        return Xe(async () => {
            a.value = await n.getInvoiceList()
        }
        ),
        (r, o) => {
            const i = P("f7-list-item")
              , s = P("f7-badge")
              , l = P("f7-list-group")
              , c = P("f7-list")
              , u = P("f7-preloader")
              , f = P("f7-page")
              , d = P("f7-popup");
            return O(),
            K(d, {
                push: "",
                "swipe-to-close": "to-bottom"
            }, {
                default: k( () => [S(B(ia)), S(f, {
                    class: "history-popup__page"
                }, {
                    default: k( () => [a.value ? (O(),
                    K(c, {
                        key: 0,
                        class: "history-popup__list",
                        inset: ""
                    }, {
                        default: k( () => [(O(!0),
                        G(Be, null, vt(a.value, (p, h) => (O(),
                        K(l, {
                            key: h
                        }, {
                            default: k( () => [S(i, {
                                "group-title": "",
                                title: t(h)
                            }, null, 8, ["title"]), V("div", MV, [(O(!0),
                            G(Be, null, vt(p, (m, g) => (O(),
                            K(i, {
                                key: g,
                                title: m.partners_task.title
                            }, {
                                media: k( () => [V("img", {
                                    class: "history-popup__transaction-icon",
                                    src: `./icons/${m.partners_task.icon}`
                                }, null, 8, zV)]),
                                after: k( () => [S(s, {
                                    color: m.partners_task.transaction_type === "income" ? "blue" : "orange"
                                }, {
                                    default: k( () => [V("b", null, Me(m.bonus_amount > 0 ? `+${m.bonus_amount}` : m.bonus_amount), 1)]),
                                    _: 2
                                }, 1032, ["color"])]),
                                _: 2
                            }, 1032, ["title"]))), 128))])]),
                            _: 2
                        }, 1024))), 128))]),
                        _: 1
                    })) : a.value === null ? (O(),
                    G("div", AV, [S(u, {
                        size: "28",
                        style: {
                            "padding-top": "10vh"
                        }
                    }), OV])) : (O(),
                    K(B(bc), {
                        key: 2,
                        "icon-name": "wifi_exclamationmark",
                        text: "Loading error! Reopen page to ty again."
                    }))]),
                    _: 1
                })]),
                _: 1
            })
        }
    }
};
const LV = {
    class: "block-footer no-padding no-margin"
}
  , IV = V("img", {
    class: "to-spend-popup__service-icon",
    src: ch
}, null, -1)
  , BV = {
    class: "to-spend-popup__amount-text"
}
  , RV = V("div", {
    class: "to-spend-popup__currency-text"
}, " coins ", -1)
  , DV = {
    class: "to-spend-popup__arrow-between-cards"
}
  , NV = {
    class: "to-spend-popup__arrow-between-cards__inner"
}
  , HV = {
    key: 0,
    class: "text-color-red"
}
  , VV = V("img", {
    class: "to-spend-popup__service-icon",
    src: Y8
}, null, -1)
  , FV = {
    class: "to-spend-popup__amount-text"
}
  , jV = V("div", {
    class: "to-spend-popup__currency-text"
}, " days of premium ", -1)
  , g2 = 10
  , UV = {
    __name: "toSpendPopup",
    setup(e) {
        const t = _a()
          , n = ht()
          , a = ~~(t.balance / g2)
          , r = oe(a)
          , o = ae( () => r.value * g2)
          , i = ae( () => r.value - 1 <= 10 ? r.value - 1 : 1)
          , s = c => {
            r.value = c
        }
          , l = () => {
            D.dialog.confirm('Click "OK" to confirm the operation.', "Are you sure?", async () => {
                D.dialog.preloader();
                const c = await t.boostService(o.value, 18);
                if (D.dialog.close(),
                !c) {
                    D.dialog.alert(`Something went wrong. Make sure you have enough funds in your balance and try again.<br><br>
If the problem is not resolved, contact technical support.`, "Error");
                    return
                }
                await t.getBalance(),
                await n.getDevice(),
                D.dialog.alert("Transaction completed", '<i class="f7-icons text-color-green" style="font-size: inherit">checkmark_circle_fill</i> Success'),
                D.popup.close()
            }
            )
        }
        ;
        return (c, u) => {
            const f = P("f7-row")
              , d = P("f7-icon")
              , p = P("f7-card-content")
              , h = P("f7-card")
              , m = P("f7-range")
              , g = P("f7-button")
              , b = P("f7-block")
              , v = P("f7-page")
              , y = P("f7-popup");
            return O(),
            K(y, {
                push: "",
                "swipe-to-close": "to-bottom"
            }, {
                default: k( () => [S(B(ia)), S(v, {
                    class: "to-spend-popup__page"
                }, {
                    default: k( () => [S(h, {
                        class: "margin-bottom-half"
                    }, {
                        default: k( () => [S(p, null, {
                            default: k( () => [S(f, {
                                class: "align-items-center"
                            }, {
                                default: k( () => [V("div", null, [V("div", LV, [J(" Available: "), V("span", {
                                    class: Ae({
                                        "text-color-red": r.value < 1
                                    })
                                }, Me(B(t).balance), 3)]), J(" You pay: ")]), IV]),
                                _: 1
                            }), S(f, {
                                class: "align-items-flex-end"
                            }, {
                                default: k( () => [V("div", BV, Me(o.value), 1), RV]),
                                _: 1
                            }), V("div", DV, [V("div", NV, [S(d, {
                                class: "margin-right-half",
                                f7: "arrow_up_arrow_down_circle_fill",
                                size: "26"
                            }), V("span", {
                                style: {
                                    "padding-right": "5px"
                                }
                            }, Me(g2) + " coins = 1 day")])])]),
                            _: 1
                        })]),
                        _: 1
                    }), S(h, {
                        class: "margin-bottom-half no-margin-top"
                    }, {
                        default: k( () => [S(p, null, {
                            default: k( () => [S(f, {
                                class: "align-items-center"
                            }, {
                                default: k( () => [V("div", null, [r.value < 1 ? (O(),
                                G("div", HV, " Not enough coins to convert. ")) : pe("", !0), J(" You receive: ")]), VV]),
                                _: 1
                            }), S(f, {
                                class: "align-items-flex-end"
                            }, {
                                default: k( () => [V("div", FV, Me(r.value), 1), jV]),
                                _: 1
                            }), r.value >= 1 ? (O(),
                            K(m, {
                                key: 0,
                                label: !0,
                                max: a,
                                min: 1,
                                scale: !0,
                                "scale-steps": i.value,
                                step: 1,
                                value: r.value,
                                "onRange:change": s
                            }, null, 8, ["scale-steps", "value"])) : pe("", !0)]),
                            _: 1
                        })]),
                        _: 1
                    }), S(b, {
                        class: "margin-top"
                    }, {
                        default: k( () => [S(g, {
                            disabled: r.value < 1,
                            fill: "",
                            large: "",
                            round: "",
                            onClick: l
                        }, {
                            default: k( () => [J(" Convert ")]),
                            _: 1
                        }, 8, ["disabled"])]),
                        _: 1
                    })]),
                    _: 1
                })]),
                _: 1
            })
        }
    }
};
const qV = {
    style: {
        "font-size": "15px",
        "font-weight": "400"
    }
}
  , WV = {
    __name: "linkCertificate",
    setup(e) {
        return (t, n) => {
            const a = P("f7-navbar")
              , r = P("f7-link")
              , o = P("f7-block-title")
              , i = P("f7-page");
            return O(),
            K(i, null, {
                default: k( () => [S(a, {
                    "back-link": "",
                    class: "navbar-glass-blur",
                    "no-hairline": "",
                    sliding: !1,
                    title: "Add Certificate"
                }), S(An, null, {
                    default: k( () => [S(o, {
                        medium: ""
                    }, {
                        default: k( () => [J(" Provide certificate "), V("div", qV, [S(r, {
                            color: "blue",
                            onClick: n[0] || (n[0] = s => B(D).view.current.router.navigate("/article/", {
                                props: {
                                    articleId: 12
                                }
                            }))
                        }, {
                            default: k( () => [J(" How get certificate with developer account? ")]),
                            _: 1
                        })])]),
                        _: 1
                    }), S(B(RD))]),
                    _: 1
                })]),
                _: 1
            })
        }
    }
}
  , YV = it(WV, [["__scopeId", "data-v-dfb3f605"]]);
const GV = e => (qt("data-v-74829286"),
e = e(),
Wt(),
e)
  , XV = GV( () => V("img", {
    alt: "Apple Developer Icon",
    src: U8
}, null, -1))
  , KV = {
    __name: "linkDeveloperAccount",
    setup(e) {
        return (t, n) => {
            const a = P("f7-navbar")
              , r = P("f7-block-title")
              , o = P("f7-list-item")
              , i = P("f7-list")
              , s = P("f7-page");
            return O(),
            K(s, null, {
                default: k( () => [S(a, {
                    "back-link": "",
                    class: "navbar-glass-blur",
                    "no-hairline": "",
                    sliding: !1,
                    title: "Link Developer Account"
                }), S(An, null, {
                    default: k( () => [S(r, {
                        medium: ""
                    }, {
                        default: k( () => [J(" Step 1 ")]),
                        _: 1
                    }), S(i, {
                        class: "rounded-items margin-top margin-bottom",
                        inset: "",
                        "media-list": ""
                    }, {
                        default: k( () => [S(o, {
                            class: "item-premium",
                            link: "",
                            text: "Click to view instruction",
                            title: "Purchase Apple Developer Membership",
                            onClick: n[0] || (n[0] = l => B(D).view.current.router.navigate("/article/", {
                                props: {
                                    articleId: 10
                                }
                            }))
                        }, {
                            media: k( () => [XV]),
                            _: 1
                        })]),
                        _: 1
                    }), S(r, {
                        medium: ""
                    }, {
                        default: k( () => [J(" Step 2 ")]),
                        _: 1
                    }), S(B(LD))]),
                    _: 1
                })]),
                _: 1
            })
        }
    }
}
  , ZV = it(KV, [["__scopeId", "data-v-74829286"]]);
const JV = {
    __name: "serviceOfferDetailsPopup",
    props: {
        offerId: {
            type: Number,
            default: 1
        }
    },
    setup(e) {
        const t = e
          , n = ht()
          , a = n.offers.find(o => o.id === t.offerId)
          , r = n.tariff.buy_premium_service ? a.subscription_price / 100 : a.trial_price / 100;
        return (o, i) => {
            const s = P("f7-button")
              , l = P("f7-page")
              , c = P("f7-popup");
            return O(),
            K(c, {
                push: "",
                "swipe-to-close": "to-bottom"
            }, {
                default: k( () => [S(B(ia)), S(l, null, {
                    default: k( () => [t.offerId === 1 ? (O(),
                    K(pa, {
                        key: 0,
                        "card-class": B(ct).premiumOnly.cardClass,
                        features: B(ct).premiumOnly.features,
                        footer: `after $${B(a).subscription_price / 100} per month`,
                        logo: B(a).logo,
                        price: `$${B(r)}`,
                        title: B(a).name
                    }, {
                        default: k( () => [S(s, {
                            fill: "",
                            href: "/purchase/1/",
                            large: "",
                            "popup-close": "",
                            round: "",
                            "route-props": {
                                price: B(r)
                            }
                        }, {
                            default: k( () => [J(" Get it ")]),
                            _: 1
                        }, 8, ["route-props"])]),
                        _: 1
                    }, 8, ["card-class", "features", "footer", "logo", "price", "title"])) : pe("", !0)]),
                    _: 1
                })]),
                _: 1
            })
        }
    }
}
  , QV = it(JV, [["__scopeId", "data-v-14767d1d"]])
  , eF = {
    __name: "ui",
    setup(e) {
        const t = ht();
        return (n, a) => {
            const r = P("f7-button");
            return O(),
            K(r, {
                large: "",
                outline: "",
                "popup-close": "",
                round: "",
                onClick: a[0] || (a[0] = o => B(t).restoreCertificateForFree())
            }, {
                default: k( () => [J(" Restore ")]),
                _: 1
            })
        }
    }
};
const tF = {
    style: {
        margin: "0 0 25px"
    }
}
  , nF = {
    key: 1,
    style: {
        margin: "25px 0 25px"
    }
}
  , aF = {
    __name: "certificateOfferDetailsPopup",
    props: {
        offerAlias: {
            type: String,
            default: null
        }
    },
    setup(e) {
        const t = e
          , n = ht()
          , a = n.offers.find(r => r.id === ct[t.offerAlias].offerId);
        return Xe(async () => {
            var r, o, i;
            if (t.offerAlias === "priorityRecovery")
                try {
                    const s = await W8.getDeviceHasFreeRecovery((r = n == null ? void 0 : n.device) == null ? void 0 : r.id);
                    n.device.hasFreeRecovery = ((o = s.data) == null ? void 0 : o.isFreeRestoreAvailable) && !((i = n.device) != null && i.isUserStream)
                } catch {
                    n.device.hasFreeRecovery = !1
                }
        }
        ),
        (r, o) => {
            const i = P("f7-button")
              , s = P("f7-page")
              , l = P("f7-popup");
            return O(),
            K(l, {
                push: "",
                "swipe-to-close": "to-bottom"
            }, {
                default: k( () => [S(B(ia)), S(s, null, {
                    default: k( () => [e.offerAlias === "certificateByFlekStore" ? (O(),
                    K(B(pp), {
                        key: 0,
                        "offer-alias": e.offerAlias
                    }, null, 8, ["offer-alias"])) : pe("", !0), e.offerAlias === "certificateByFlekStore1399" ? (O(),
                    K(B(pp), {
                        key: 1,
                        "offer-alias": e.offerAlias
                    }, null, 8, ["offer-alias"])) : pe("", !0), e.offerAlias === "certificateByFlekStore12" ? (O(),
                    G(Be, {
                        key: 2
                    }, [S(pa, {
                        "card-class": B(ct).certificateByFlekStore.cardClass,
                        features: B(ct).certificateByFlekStore.features,
                        logo: B(a).logo,
                        price: `$${B(a).trial_price / 100}`,
                        text: "up to 12 months",
                        title: B(ct).certificateByFlekStore.name
                    }, null, 8, ["card-class", "features", "logo", "price", "title"]), V("div", tF, [S(B(M1), {
                        colored: "",
                        title: "PLUS"
                    })]), S(pa, {
                        "card-class": B(ct).premiumOnly.cardClass,
                        features: B(ct).premiumOnly.features,
                        footer: `after $${B(a).subscription_price / 100} per month`,
                        logo: B(ct).premiumOnly.logo,
                        price: `${B(a).trial_months} months FREE`,
                        title: B(ct).premiumOnly.name
                    }, null, 8, ["card-class", "features", "footer", "logo", "price", "title"])], 64)) : pe("", !0), e.offerAlias === "priorityRecovery" ? (O(),
                    G(Be, {
                        key: 3
                    }, [B(n).device.hasFreeRecovery ? (O(),
                    K(pa, {
                        key: 0,
                        "card-class": B(ct).freeRecovery.cardClass,
                        description: B(ct).freeRecovery.description,
                        features: null,
                        logo: B(ct).freeRecovery.logo,
                        price: "FREE",
                        "price-color": "gray",
                        title: B(ct).freeRecovery.name
                    }, {
                        default: k( () => [S(B(eF))]),
                        _: 1
                    }, 8, ["card-class", "description", "logo", "title"])) : pe("", !0), B(n).device.hasFreeRecovery ? (O(),
                    G("div", nF, [S(B(M1), {
                        title: "OR"
                    })])) : pe("", !0), S(pa, {
                        "card-class": B(ct).certificateByFSPlusPremiumDiscount.cardClass,
                        description: B(ct).certificateByFSPlusPremiumDiscount.description,
                        features: null,
                        footer: "up to 12 months",
                        logo: B(ct).certificateByFSPlusPremiumDiscount.logo,
                        price: "13.99",
                        strikethrough: "$15.99",
                        title: B(ct).certificateByFSPlusPremiumDiscount.name
                    }, {
                        default: k( () => [S(i, {
                            fill: "",
                            href: `/purchase/${B(ct).certificateByFlekStore1399.offerId}/`,
                            large: "",
                            "popup-close": "",
                            round: ""
                        }, {
                            default: k( () => [J(" Get it ")]),
                            _: 1
                        }, 8, ["href"])]),
                        _: 1
                    }, 8, ["card-class", "description", "logo", "title"])], 64)) : pe("", !0), e.offerAlias === "linkDeveloperAccount" ? (O(),
                    K(pa, {
                        key: 4,
                        "card-class": B(ct).linkDeveloperAccount.cardClass,
                        description: B(ct).linkDeveloperAccount.description,
                        features: B(ct).linkDeveloperAccount.features,
                        logo: B(ct).linkDeveloperAccount.logo,
                        subtitle: "Recommended",
                        title: B(ct).linkDeveloperAccount.name
                    }, {
                        default: k( () => [S(i, {
                            fill: "",
                            large: "",
                            "popup-close": "",
                            round: "",
                            onClick: o[0] || (o[0] = c => B(D).view.current.router.navigate("/device/link-dev-acc/"))
                        }, {
                            default: k( () => [J(" Get started ")]),
                            _: 1
                        })]),
                        _: 1
                    }, 8, ["card-class", "description", "features", "logo", "title"])) : pe("", !0), e.offerAlias === "ownCertificate" ? (O(),
                    K(pa, {
                        key: 5,
                        "card-class": B(ct).ownCertificate.cardClass,
                        description: B(ct).ownCertificate.description,
                        features: B(ct).ownCertificate.features,
                        logo: B(ct).ownCertificate.logo,
                        title: B(ct).ownCertificate.name
                    }, {
                        default: k( () => [S(i, {
                            fill: "",
                            large: "",
                            "popup-close": "",
                            round: "",
                            onClick: o[1] || (o[1] = c => B(D).view.current.router.navigate("/device/link-certificate/"))
                        }, {
                            default: k( () => [J(" Get started ")]),
                            _: 1
                        })]),
                        _: 1
                    }, 8, ["card-class", "description", "features", "logo", "title"])) : pe("", !0)]),
                    _: 1
                })]),
                _: 1
            })
        }
    }
}
  , rF = it(aF, [["__scopeId", "data-v-6336d01b"]])
  , oF = {
    style: {
        "text-align": "center"
    }
}
  , iF = {
    __name: "list",
    setup(e) {
        return (t, n) => {
            const a = P("f7-nav-left")
              , r = P("f7-nav-title")
              , o = P("f7-nav-right")
              , i = P("f7-nav-title-large")
              , s = P("f7-navbar")
              , l = P("f7-block-title")
              , c = P("f7-block-header")
              , u = P("f7-page");
            return O(),
            K(u, {
                name: "home"
            }, {
                default: k( () => [S(s, {
                    class: "navbar-glass-blur",
                    large: "",
                    "no-hairline": "",
                    sliding: !1,
                    transparent: ""
                }, {
                    default: k( () => [S(a), S(r, {
                        sliding: ""
                    }, {
                        default: k( () => [J(" Settings ")]),
                        _: 1
                    }), S(o), S(i, null, {
                        default: k( () => [J("Settings")]),
                        _: 1
                    })]),
                    _: 1
                }), S(B(An), null, {
                    default: k( () => [S(l, {
                        class: "padding-left"
                    }, {
                        default: k( () => [J(" Appearance ")]),
                        _: 1
                    }), S(B(Az)), S(l, {
                        class: "padding-left"
                    }, {
                        default: k( () => [J(" General ")]),
                        _: 1
                    }), S(B(uz)), S(l, {
                        class: "padding-left"
                    }, {
                        default: k( () => [J(" Follow us ")]),
                        _: 1
                    }), S(B(iz)), S(l, {
                        class: "padding-left"
                    }, {
                        default: k( () => [J(" Documentation ")]),
                        _: 1
                    }), S(B(ez)), V("div", oF, [S(c, null, {
                        default: k( () => [J(" flekstore.com  2015-" + Me(new Date().getFullYear()), 1)]),
                        _: 1
                    })])]),
                    _: 1
                })]),
                _: 1
            })
        }
    }
};
const Sc = e => (qt("data-v-6068141e"),
e = e(),
Wt(),
e)
  , sF = {
    style: {
        "text-align": "center"
    }
}
  , lF = Sc( () => V("div", {
    class: "red-point"
}, null, -1))
  , cF = Sc( () => V("br", null, null, -1))
  , uF = Sc( () => V("br", null, null, -1))
  , fF = Sc( () => V("p", null, "We will notify you about:", -1))
  , dF = {
    class: "margin",
    style: {
        "text-align": "center"
    }
}
  , pF = {
    __name: "allowNotificationsPopup",
    setup(e) {
        const t = async () => {
            await g8() ? console.log("Notification subscription successful.") : console.warn("Notification subscription failed.")
        }
          , n = async () => {
            await v8() ? console.log("Notifications disabled.") : console.warn("Failed to disable notifications.")
        }
        ;
        return (a, r) => {
            const o = P("f7-navbar")
              , i = P("f7-icon")
              , s = P("f7-block-title")
              , l = P("f7-list-item")
              , c = P("f7-list")
              , u = P("f7-button")
              , f = P("f7-link")
              , d = P("f7-block")
              , p = P("f7-page")
              , h = P("f7-popup");
            return O(),
            K(h, {
                "tablet-fullscreen": ""
            }, {
                default: k( () => [S(p, null, {
                    default: k( () => [S(o, {
                        class: "no-blur",
                        hidden: "",
                        "no-hairline": ""
                    }), S(B(An), null, {
                        default: k( () => [V("div", sF, [S(s, {
                            medium: ""
                        }, {
                            default: k( () => [lF, S(i, {
                                color: "yellow",
                                f7: "bell_fill",
                                size: "60"
                            }), cF, uF, J(" Notifications ")]),
                            _: 1
                        }), fF]), S(c, {
                            class: "rounded-items",
                            inset: ""
                        }, {
                            default: k( () => [S(l, {
                                title: "Changing device statuses"
                            }, {
                                media: k( () => [S(i, {
                                    color: "green",
                                    f7: "device_phone_portrait"
                                })]),
                                _: 1
                            }), S(l, {
                                title: "Application updates"
                            }, {
                                media: k( () => [S(i, {
                                    color: "blue",
                                    f7: "capslock_fill"
                                })]),
                                _: 1
                            }), S(l, {
                                title: "Interesting events"
                            }, {
                                media: k( () => [S(i, {
                                    color: "orange",
                                    f7: "flame_fill"
                                })]),
                                _: 1
                            }), S(l, {
                                title: "Other service updates"
                            }, {
                                media: k( () => [S(i, {
                                    color: "pink",
                                    f7: "arrow_2_circlepath_circle_fill"
                                })]),
                                _: 1
                            })]),
                            _: 1
                        }), S(d, null, {
                            default: k( () => [S(u, {
                                color: "white",
                                fill: "",
                                large: "",
                                "popup-close": "",
                                round: "",
                                "text-color": "black",
                                onClick: t
                            }, {
                                default: k( () => [J(" Allow Notifications ")]),
                                _: 1
                            }), V("div", dF, [S(f, {
                                "popup-close": "",
                                onClick: n
                            }, {
                                default: k( () => [J(" Disable notifications ")]),
                                _: 1
                            })])]),
                            _: 1
                        })]),
                        _: 1
                    })]),
                    _: 1
                })]),
                _: 1
            })
        }
    }
}
  , hF = it(pF, [["__scopeId", "data-v-6068141e"]]);
const mF = V("div", {
    style: {
        "margin-top": "10px"
    }
}, [V("p", {
    style: {
        margin: "0",
        "font-size": "14px"
    }
}, " Please confirm you are an adult by selecting your birth year below. "), V("div", {
    id: "picker-year",
    style: {
        "margin-top": "10px",
        "min-height": "200px"
    }
})], -1)
  , gF = {
    style: {
        "margin-top": "10px",
        "font-size": "14px"
    }
}
  , vF = {
    __name: "ui",
    emits: ["onResult"],
    setup(e, {expose: t, emit: n}) {
        const a = oe(!1)
          , r = new Date().getFullYear()
          , o = oe(r)
          , i = oe(!1);
        let s = null;
        const l = n
          , c = () => {
            a.value || (i.value = !1,
            a.value = !0)
        }
          , u = () => {
            a.value && (a.value = !1,
            l("onResult", i.value))
        }
          , f = () => {
            r - o.value >= 18 ? i.value = !0 : (i.value = !1,
            D.dialog.alert("Access denied due to age restrictions.", "Warning")),
            D.popup.close()
        }
          , d = () => {
            s ? s.setValue(s.getValue()) : s = D.picker.create({
                containerEl: "#picker-year",
                toolbar: !1,
                rotateEffect: !0,
                cols: [{
                    values: Array.from({
                        length: 101
                    }, (p, h) => r - h),
                    textAlign: "center"
                }],
                on: {
                    change: (p, h) => {
                        o.value = h[0]
                    }
                }
            })
        }
        ;
        return t({
            popupOpened: a,
            open: c,
            close: u
        }),
        (p, h) => {
            const m = P("f7-block-title")
              , g = P("f7-link")
              , b = P("f7-button")
              , v = P("f7-col")
              , y = P("f7-row")
              , w = P("f7-block")
              , C = P("f7-page")
              , _ = P("f7-popup");
            return O(),
            K(_, {
                opened: a.value,
                "onUpdate:opened": h[1] || (h[1] = E => a.value = E),
                class: "adult-confirm-popup__age-confirm-popup",
                "onPopup:close": h[2] || (h[2] = E => {
                    u()
                }
                ),
                "onPopup:opened": h[3] || (h[3] = E => d())
            }, {
                default: k( () => [S(C, {
                    class: "adult-confirm-popup__page"
                }, {
                    default: k( () => [S(w, {
                        class: "no-margin-bottom",
                        style: {
                            "text-align": "center"
                        }
                    }, {
                        default: k( () => [S(m, {
                            medium: ""
                        }, {
                            default: k( () => [J(" Age Confirmation ")]),
                            _: 1
                        }), mF, V("div", gF, [J(" By confirming, you agree to our "), S(g, {
                            class: "text-color-blue",
                            href: "/docs/3/"
                        }, {
                            default: k( () => [J(" Terms of Service ")]),
                            _: 1
                        }), J(" and "), S(g, {
                            class: "text-color-blue",
                            href: "/docs/4/"
                        }, {
                            default: k( () => [J(" Privacy Policy ")]),
                            _: 1
                        })]), S(y, {
                            class: "margin-top"
                        }, {
                            default: k( () => [S(v, null, {
                                default: k( () => [S(b, {
                                    class: "button-lite",
                                    large: "",
                                    "popup-close": "",
                                    round: ""
                                }, {
                                    default: k( () => [J(" Cancel ")]),
                                    _: 1
                                })]),
                                _: 1
                            }), S(v, null, {
                                default: k( () => [S(b, {
                                    fill: "",
                                    large: "",
                                    round: "",
                                    onClick: h[0] || (h[0] = E => f())
                                }, {
                                    default: k( () => [J(" Confirm ")]),
                                    _: 1
                                })]),
                                _: 1
                            })]),
                            _: 1
                        })]),
                        _: 1
                    })]),
                    _: 1
                })]),
                _: 1
            }, 8, ["opened"])
        }
    }
}
  , bF = {
    __name: "privacyAndSecurity",
    setup(e) {
        const t = nl()
          , n = oe(null)
          , a = oe(null)
          , r = oe(t.isAdultUser)
          , o = () => {
            n.value.popupOpened || (t.isAdultUser ? (t.setAccessToAdultContent(!1),
            r.value = !1) : n.value.open())
        }
          , i = s => {
            t.setAccessToAdultContent(s),
            r.value = s
        }
        ;
        return (s, l) => {
            const c = P("f7-nav-left")
              , u = P("f7-nav-title")
              , f = P("f7-nav-right")
              , d = P("f7-nav-title-large")
              , p = P("f7-navbar")
              , h = P("f7-block-header")
              , m = P("f7-icon")
              , g = P("f7-toggle")
              , b = P("f7-list-item")
              , v = P("f7-block-footer")
              , y = P("f7-list")
              , w = P("f7-page");
            return O(),
            K(w, {
                name: "home"
            }, {
                default: k( () => [S(p, {
                    "back-link": "",
                    large: "",
                    "no-hairline": "",
                    sliding: !1,
                    transparent: ""
                }, {
                    default: k( () => [S(c), S(u, {
                        sliding: ""
                    }, {
                        default: k( () => [J(" Privacy and Security ")]),
                        _: 1
                    }), S(f), S(d, null, {
                        default: k( () => [J("Privacy and Security")]),
                        _: 1
                    })]),
                    _: 1
                }), S(B(An), null, {
                    default: k( () => [S(y, {
                        class: "rounded-items",
                        inset: ""
                    }, {
                        default: k( () => [S(h, {
                            style: {
                                "text-transform": "uppercase"
                            }
                        }, {
                            default: k( () => [J(" Sensitive Content ")]),
                            _: 1
                        }), S(b, {
                            title: "Disable filtering"
                        }, {
                            media: k( () => [S(m, {
                                f7: "exclamationmark_triangle_fill"
                            })]),
                            after: k( () => [S(g, {
                                ref_key: "sensitiveContentToggle",
                                ref: a,
                                checked: r.value,
                                "onUpdate:checked": l[0] || (l[0] = C => r.value = C),
                                onChange: l[1] || (l[1] = C => o())
                            }, null, 8, ["checked"])]),
                            _: 1
                        }), S(v, null, {
                            default: k( () => [J(' Enabling this option will grant access to applications with strict age restrictions and the "Adult" category. ')]),
                            _: 1
                        })]),
                        _: 1
                    })]),
                    _: 1
                }), S(B(vF), {
                    ref_key: "AdultConfirm",
                    ref: n,
                    onOnResult: l[2] || (l[2] = C => i(C))
                }, null, 512)]),
                _: 1
            })
        }
    }
}
  , yF = [{
    path: "/",
    component: XD
}, {
    path: "/app/",
    popup: {
        push: !0,
        swipeToClose: "to-bottom",
        component: aN
    }
}, {
    path: "/article/",
    component: bN
}, {
    path: "/device/",
    component: EN
}, {
    path: "/device/certificate-offer-details/",
    popup: {
        push: !0,
        swipeToClose: "to-bottom",
        component: rF
    }
}, {
    path: "/device/service-offer-details/",
    popup: {
        push: !0,
        swipeToClose: "to-bottom",
        component: QV
    }
}, {
    path: "/device/link-dev-acc/",
    component: ZV
}, {
    path: "/device/link-certificate/",
    component: YV
}, {
    path: "/partner/description-popup/",
    popup: {
        push: !0,
        swipeToClose: "to-bottom",
        component: fV
    }
}, {
    path: "/partner/history-popup/",
    popup: {
        push: !0,
        swipeToClose: "to-bottom",
        component: PV
    }
}, {
    path: "/partner/to-spend-popup/",
    popup: {
        push: !0,
        swipeToClose: "to-bottom",
        component: UV
    }
}, {
    path: "/partner/youtube-task-description-popup/",
    popup: {
        push: !0,
        swipeToClose: "to-bottom",
        component: TV
    }
}, {
    path: "/partner/referral-task-description-popup/",
    popup: {
        push: !0,
        swipeToClose: "to-bottom",
        component: bV
    }
}, {
    path: "/partner/main/",
    component: oV
}, {
    path: "/manage-own-stream/",
    component: AN
}, {
    path: "/signer/",
    component: qN
}, {
    path: "/source/",
    component: KN
}, {
    path: "/source/catalog/:sourceIndex/",
    component: aH
}, {
    path: "/source/app/",
    popup: {
        push: !0,
        swipeToClose: "to-bottom",
        component: rH
    }
}, {
    path: "/settings/",
    component: iF
}, {
    path: "/settings/allow-notifications/",
    popup: {
        component: hF
    }
}, {
    path: "/settings/privacy-and-security/",
    component: bF
}, {
    path: "/purchase/:offerId/",
    popup: {
        push: !0,
        swipeToClose: "to-bottom",
        component: gH
    }
}, {
    path: "/docs/",
    component: RH
}, {
    path: "/docs/:itemId/",
    popup: {
        push: !0,
        swipeToClose: "to-bottom",
        component: GH
    }
}, {
    path: "/bannedPopup/",
    loginScreen: {
        component: rV
    }
}, {
    path: "(.*)",
    component: QH
}];
const CF = V("div", {
    class: "panel-logo",
    style: {
        "padding-top": "8vh",
        "text-align": "center"
    }
}, [V("i", {
    class: "fs-icon",
    style: {
        "font-size": "45px"
    }
}, "")], -1)
  , wF = {
    __name: "app",
    setup(e) {
        const t = nl()
          , n = Fa()
          , a = ht()
          , r = sl();
        t.init(),
        localStorage.deal_id || a.getDealId();
        const o = {
            name: "FlekSt0re",
            theme: "ios",
            routes: yF,
            serviceWorker: {
                path: "./service-worker.js"
            }
        }
          , i = async () => {
            var s, l;
            await a.getDevice(),
            await a.checkBanned(),
            (s = a == null ? void 0 : a.device) != null && s.isUserStream && await r.checkUserCertificate((l = a == null ? void 0 : a.device) == null ? void 0 : l.stream.id, localStorage.device_id, () => {
                n.setActiveTab("view-device")
            }
            )
        }
        ;
        return Xe( () => {
            st( () => t.darkMode, () => {
                t.updateBodyDarkThemeClass()
            }
            ),
            ut( () => {
                i(),
                "serviceWorker"in navigator && navigator.serviceWorker.register(o.serviceWorker.path).then(l => {
                    l.update(),
                    setInterval( () => {
                        l.update()
                    }
                    , 5 * 60 * 1e3)
                }
                ),
                pc && !ms.value && Notification.permission === "default" && setTimeout( () => D.view.current.router.navigate("/settings/allow-notifications/"), 1e3);
                let s = document.getElementById("install-screen");
                if (s)
                    if (D.device.standalone || localStorage.in_browser || localStorage.dev_mode)
                        s.remove();
                    else {
                        let l = document.getElementById("use-in-browser-button")
                          , c = document.getElementById("dev-mode-button")
                          , u = 0;
                        s.querySelector(".install-screen-page").style.display = "block";
                        const f = () => {
                            localStorage.in_browser = 1,
                            s.remove(),
                            l.removeEventListener("click", f),
                            s = null,
                            l = null
                        }
                          , d = () => {
                            u++,
                            u === 10 && (localStorage.dev_mode = !0,
                            s.remove(),
                            c.removeEventListener("click", d),
                            c = null)
                        }
                        ;
                        c.addEventListener("click", d),
                        l.addEventListener("click", f)
                    }
            }
            )
        }
        ),
        (s, l) => {
            const c = P("f7-page")
              , u = P("f7-view")
              , f = P("f7-panel")
              , d = P("f7-views")
              , p = P("f7-app");
            return O(),
            K(p, Un(o, {
                dark: B(t).darkMode
            }), {
                default: k( () => [S(f, {
                    cover: "",
                    left: "",
                    "visible-breakpoint": 960
                }, {
                    default: k( () => [S(u, null, {
                        default: k( () => [S(c, null, {
                            default: k( () => [CF, S(B(ZM))]),
                            _: 1
                        })]),
                        _: 1
                    })]),
                    _: 1
                }), S(d, {
                    class: "safe-areas",
                    tabs: ""
                }, {
                    default: k( () => [S(B(XM)), S(B(WM))]),
                    _: 1
                })]),
                _: 1
            }, 16, ["dark"])
        }
    }
}
  , _F = {
    name: "appbar"
};
let Wa = class extends Va {
    constructor(t, n) {
        const a = se({
            title: t.params.dialog.title,
            text: void 0,
            content: "",
            buttons: [],
            verticalButtons: !1,
            onClick: void 0,
            cssClass: void 0,
            destroyOnClose: !1,
            on: {}
        }, n);
        typeof a.closeByBackdropClick > "u" && (a.closeByBackdropClick = t.params.dialog.closeByBackdropClick),
        typeof a.backdrop > "u" && (a.backdrop = t.params.dialog.backdrop),
        super(t, a);
        const r = this
          , o = yt()
          , i = Qe()
          , {title: s, text: l, content: c, buttons: u, verticalButtons: f, cssClass: d, backdrop: p} = a;
        r.params = a;
        let h;
        if (r.params.el)
            h = $(r.params.el);
        else {
            const w = ["dialog"];
            u.length === 0 && w.push("dialog-no-buttons"),
            u.length > 0 && w.push(`dialog-buttons-${u.length}`),
            f && w.push("dialog-buttons-vertical"),
            d && w.push(d);
            let C = "";
            u.length > 0 && (C = R("div", {
                class: "dialog-buttons"
            }, u.map(E => R("span", {
                class: `dialog-button${E.bold ? " dialog-button-bold" : ""}${E.color ? ` color-${E.color}` : ""}${E.cssClass ? ` ${E.cssClass}` : ""}`
            }, E.text))));
            const _ = R("div", {
                class: w.join(" ")
            }, R("div", {
                class: "dialog-inner"
            }, s && R("div", {
                class: "dialog-title"
            }, s), l && R("div", {
                class: "dialog-text"
            }, l), c), C);
            h = $(_)
        }
        if (h && h.length > 0 && h[0].f7Modal)
            return h[0].f7Modal;
        if (h.length === 0)
            return r.destroy();
        let m;
        p && (m = t.$el.children(".dialog-backdrop"),
        m.length === 0 && (m = $('<div class="dialog-backdrop"></div>'),
        t.$el.append(m)));
        function g(w) {
            const _ = $(this).index()
              , E = u[_];
            E.onClick && E.onClick(r, w),
            r.params.onClick && r.params.onClick(r, _),
            E.close !== !1 && r.close()
        }
        let b;
        function v(w) {
            const C = w.keyCode;
            u.forEach( (_, E) => {
                _.keyCodes && _.keyCodes.indexOf(C) >= 0 && (i.activeElement && i.activeElement.blur(),
                _.onClick && _.onClick(r, w),
                r.params.onClick && r.params.onClick(r, E),
                _.close !== !1 && r.close())
            }
            )
        }
        u && u.length > 0 && (r.on("open", () => {
            h.find(".dialog-button").each( (w, C) => {
                u[C].keyCodes && (b = !0),
                $(w).on("click", g)
            }
            ),
            b && !o.ios && !o.android && !o.cordova && !o.capacitor && $(i).on("keydown", v)
        }
        ),
        r.on("close", () => {
            h.find(".dialog-button").each(w => {
                $(w).off("click", g)
            }
            ),
            b && !o.ios && !o.android && !o.cordova && !o.capacitor && $(i).off("keydown", v),
            b = !1
        }
        )),
        se(r, {
            app: t,
            $el: h,
            el: h[0],
            $backdropEl: m,
            backdropEl: m && m[0],
            type: "dialog",
            setProgress(w, C) {
                return t.progressbar.set(h.find(".progressbar"), w, C),
                r
            },
            setText(w) {
                let C = h.find(".dialog-text");
                return C.length === 0 && (C = $('<div class="dialog-text"></div>'),
                typeof s < "u" ? C.insertAfter(h.find(".dialog-title")) : h.find(".dialog-inner").prepend(C)),
                C.html(w),
                r.params.text = w,
                r
            },
            setTitle(w) {
                let C = h.find(".dialog-title");
                return C.length === 0 && (C = $('<div class="dialog-title"></div>'),
                h.find(".dialog-inner").prepend(C)),
                C.html(w),
                r.params.title = w,
                r
            }
        });
        function y(w) {
            const C = w.target;
            $(C).closest(r.el).length === 0 && r.params.closeByBackdropClick && r.backdropEl && r.backdropEl === C && r.close()
        }
        return r.on("opened", () => {
            r.params.closeByBackdropClick && t.on("click", y)
        }
        ),
        r.on("close", () => {
            r.params.closeByBackdropClick && t.off("click", y)
        }
        ),
        h[0].f7Modal = r,
        r.params.destroyOnClose && r.once("closed", () => {
            setTimeout( () => {
                r.destroy()
            }
            , 0)
        }
        ),
        r
    }
}
;
const kF = {
    name: "dialog",
    params: {
        dialog: {
            title: void 0,
            buttonOk: "OK",
            buttonCancel: "Cancel",
            usernamePlaceholder: "Username",
            passwordPlaceholder: "Password",
            preloaderTitle: "Loading... ",
            progressTitle: "Loading... ",
            backdrop: !0,
            closeByBackdropClick: !1,
            destroyPredefinedDialogs: !0,
            keyboardActions: !0,
            autoFocus: !0
        }
    },
    static: {
        Dialog: Wa
    },
    create() {
        const e = this;
        function t() {
            return e.params.dialog.title || e.name
        }
        const n = e.params.dialog.destroyPredefinedDialogs
          , a = e.params.dialog.keyboardActions
          , o = e.params.dialog.autoFocus ? {
            on: {
                opened(i) {
                    i.$el.find("input").eq(0).focus()
                }
            }
        } : {};
        e.dialog = se(cr({
            app: e,
            constructor: Wa,
            defaultSelector: ".dialog.modal-in"
        }), {
            alert() {
                for (var i = arguments.length, s = new Array(i), l = 0; l < i; l++)
                    s[l] = arguments[l];
                let[c,u,f] = s;
                return s.length === 2 && typeof s[1] == "function" && ([c,f,u] = s),
                new Wa(e,{
                    title: typeof u > "u" ? t() : u,
                    text: c,
                    buttons: [{
                        text: e.params.dialog.buttonOk,
                        bold: !0,
                        onClick: f,
                        keyCodes: a ? [13, 27] : null
                    }],
                    destroyOnClose: n
                }).open()
            },
            prompt() {
                for (var i = arguments.length, s = new Array(i), l = 0; l < i; l++)
                    s[l] = arguments[l];
                let[c,u,f,d,p] = s;
                return typeof s[1] == "function" && ([c,f,d,p,u] = s),
                p = typeof p > "u" || p === null ? "" : p,
                new Wa(e,{
                    title: typeof u > "u" ? t() : u,
                    text: c,
                    content: `<div class="dialog-input-field input"><input type="text" class="dialog-input" value="${p}"></div>`,
                    buttons: [{
                        text: e.params.dialog.buttonCancel,
                        keyCodes: a ? [27] : null,
                        color: e.theme === "aurora" ? "gray" : null
                    }, {
                        text: e.params.dialog.buttonOk,
                        bold: !0,
                        keyCodes: a ? [13] : null
                    }],
                    onClick(h, m) {
                        const g = h.$el.find(".dialog-input").val();
                        m === 0 && d && d(g),
                        m === 1 && f && f(g)
                    },
                    destroyOnClose: n,
                    ...o
                }).open()
            },
            confirm() {
                for (var i = arguments.length, s = new Array(i), l = 0; l < i; l++)
                    s[l] = arguments[l];
                let[c,u,f,d] = s;
                return typeof s[1] == "function" && ([c,f,d,u] = s),
                new Wa(e,{
                    title: typeof u > "u" ? t() : u,
                    text: c,
                    buttons: [{
                        text: e.params.dialog.buttonCancel,
                        onClick: d,
                        keyCodes: a ? [27] : null,
                        color: e.theme === "aurora" ? "gray" : null
                    }, {
                        text: e.params.dialog.buttonOk,
                        bold: !0,
                        onClick: f,
                        keyCodes: a ? [13] : null
                    }],
                    destroyOnClose: n
                }).open()
            },
            login() {
                for (var i = arguments.length, s = new Array(i), l = 0; l < i; l++)
                    s[l] = arguments[l];
                let[c,u,f,d] = s;
                return typeof s[1] == "function" && ([c,f,d,u] = s),
                new Wa(e,{
                    title: typeof u > "u" ? t() : u,
                    text: c,
                    content: `
              <div class="dialog-input-field dialog-input-double input">
                <input type="text" name="dialog-username" placeholder="${e.params.dialog.usernamePlaceholder}" class="dialog-input">
              </div>
              <div class="dialog-input-field dialog-input-double input">
                <input type="password" name="dialog-password" placeholder="${e.params.dialog.passwordPlaceholder}" class="dialog-input">
              </div>`,
                    buttons: [{
                        text: e.params.dialog.buttonCancel,
                        keyCodes: a ? [27] : null,
                        color: e.theme === "aurora" ? "gray" : null
                    }, {
                        text: e.params.dialog.buttonOk,
                        bold: !0,
                        keyCodes: a ? [13] : null
                    }],
                    onClick(p, h) {
                        const m = p.$el.find('[name="dialog-username"]').val()
                          , g = p.$el.find('[name="dialog-password"]').val();
                        h === 0 && d && d(m, g),
                        h === 1 && f && f(m, g)
                    },
                    destroyOnClose: n,
                    ...o
                }).open()
            },
            password() {
                for (var i = arguments.length, s = new Array(i), l = 0; l < i; l++)
                    s[l] = arguments[l];
                let[c,u,f,d] = s;
                return typeof s[1] == "function" && ([c,f,d,u] = s),
                new Wa(e,{
                    title: typeof u > "u" ? t() : u,
                    text: c,
                    content: `
              <div class="dialog-input-field input">
                <input type="password" name="dialog-password" placeholder="${e.params.dialog.passwordPlaceholder}" class="dialog-input">
              </div>`,
                    buttons: [{
                        text: e.params.dialog.buttonCancel,
                        keyCodes: a ? [27] : null,
                        color: e.theme === "aurora" ? "gray" : null
                    }, {
                        text: e.params.dialog.buttonOk,
                        bold: !0,
                        keyCodes: a ? [13] : null
                    }],
                    onClick(p, h) {
                        const m = p.$el.find('[name="dialog-password"]').val();
                        h === 0 && d && d(m),
                        h === 1 && f && f(m)
                    },
                    destroyOnClose: n,
                    ...o
                }).open()
            },
            preloader(i, s) {
                const c = {
                    iosPreloaderContent: ho,
                    mdPreloaderContent: po,
                    auroraPreloaderContent: mo
                }[`${e.theme}PreloaderContent`] || "";
                return new Wa(e,{
                    title: typeof i > "u" || i === null ? e.params.dialog.preloaderTitle : i,
                    content: `<div class="preloader${s ? ` color-${s}` : ""}">${c}</div>`,
                    cssClass: "dialog-preloader",
                    destroyOnClose: n
                }).open()
            },
            progress() {
                for (var i = arguments.length, s = new Array(i), l = 0; l < i; l++)
                    s[l] = arguments[l];
                let[c,u,f] = s;
                s.length === 2 ? typeof s[0] == "number" ? [u,f,c] = s : typeof s[0] == "string" && typeof s[1] == "string" && ([c,f,u] = s) : s.length === 1 && typeof s[0] == "number" && ([u,c,f] = s);
                const d = typeof u > "u"
                  , p = new Wa(e,{
                    title: typeof c > "u" ? e.params.dialog.progressTitle : c,
                    cssClass: "dialog-progress",
                    content: `
              <div class="progressbar${d ? "-infinite" : ""}${f ? ` color-${f}` : ""}">
                ${d ? "" : "<span></span>"}
              </div>
            `,
                    destroyOnClose: n
                });
                return d || p.setProgress(u),
                p.open()
            }
        })
    }
};
let zp = class extends Va {
    constructor(t, n) {
        const a = se({
            on: {}
        }, t.params.popup, n);
        super(t, a);
        const r = this
          , o = He()
          , i = Qe()
          , s = Mt()
          , l = yt();
        r.params = a;
        let c;
        if (r.params.el ? c = $(r.params.el).eq(0) : c = $(r.params.content).filter(re => re.nodeType === 1).eq(0),
        c && c.length > 0 && c[0].f7Modal)
            return c[0].f7Modal;
        if (c.length === 0)
            return r.destroy();
        let u;
        r.params.backdrop && r.params.backdropEl ? u = $(r.params.backdropEl) : r.params.backdrop && (r.params.backdropUnique ? (u = $('<div class="popup-backdrop popup-backdrop-unique"></div>'),
        r.$containerEl.append(u)) : u = r.$containerEl.children(".popup-backdrop"),
        u.length === 0 && (u = $('<div class="popup-backdrop"></div>'),
        r.$containerEl.append(u))),
        se(r, {
            app: t,
            push: c.hasClass("popup-push") || r.params.push,
            $el: c,
            el: c[0],
            $backdropEl: u,
            backdropEl: u && u[0],
            type: "popup",
            $htmlEl: $("html")
        }),
        r.params.push && c.addClass("popup-push");
        function f(re) {
            const ve = re.target
              , Ne = $(ve);
            if (!(!l.desktop && l.cordova && (o.Keyboard && o.Keyboard.isVisible || o.cordova.plugins && o.cordova.plugins.Keyboard && o.cordova.plugins.Keyboard.isVisible)) && Ne.closest(r.el).length === 0 && r.params && r.params.closeByBackdropClick && r.params.backdrop && r.backdropEl && r.backdropEl === ve) {
                let Ye = !0;
                r.$el.nextAll(".popup.modal-in").each(tt => {
                    const ee = tt.f7Modal;
                    ee && ee.params.closeByBackdropClick && ee.params.backdrop && ee.backdropEl === r.backdropEl && (Ye = !1)
                }
                ),
                Ye && r.close()
            }
        }
        function d(re) {
            re.keyCode === 27 && r.params.closeOnEscape && r.close()
        }
        let p, h;
        function m(re) {
            return (t.height - re * 2) / t.height
        }
        let g = !0, b = !1, v, y, w, C, _, E = !1, z, T, A, x, M, L;
        function U(re) {
            b || !g || !r.params.swipeToClose || r.params.swipeHandler && $(re.target).closest(r.params.swipeHandler).length === 0 || (b = !0,
            E = !1,
            v = {
                x: re.type === "touchstart" ? re.targetTouches[0].pageX : re.pageX,
                y: re.type === "touchstart" ? re.targetTouches[0].pageY : re.pageY
            },
            C = zn(),
            w = void 0,
            !r.params.swipeHandler && re.type === "touchstart" && (z = $(re.target).closest(".page-content")[0]))
        }
        function Y(re) {
            if (!b)
                return;
            if (y = {
                x: re.type === "touchmove" ? re.targetTouches[0].pageX : re.pageX,
                y: re.type === "touchmove" ? re.targetTouches[0].pageY : re.pageY
            },
            typeof w > "u" && (w = !!(w || Math.abs(y.x - v.x) > Math.abs(y.y - v.y))),
            w) {
                b = !1,
                E = !1;
                return
            }
            _ = v.y - y.y,
            h && p && _ > 0 && (_ = 0);
            const ve = _ < 0 ? "to-bottom" : "to-top";
            if (c.transition(0),
            typeof r.params.swipeToClose == "string" && ve !== r.params.swipeToClose) {
                c.transform(""),
                c.transition("");
                return
            }
            if (E)
                r.emit("local::swipeMove popupSwipeMove", r),
                r.$el.trigger("popup:swipemove");
            else {
                if (h && p && (M = c[0].offsetHeight,
                L = c.prevAll(".popup.modal-in").eq(0),
                L.length === 0 && (L = t.$el.children(".view, .views"))),
                z && (T = z.scrollTop,
                x = z.scrollHeight,
                A = z.offsetHeight,
                x !== A && !(ve === "to-bottom" && T === 0) && !(ve === "to-top" && T === x - A))) {
                    c.transform(""),
                    c.transition(""),
                    b = !1,
                    E = !1;
                    return
                }
                E = !0,
                r.emit("local::swipeStart popupSwipeStart", r),
                r.$el.trigger("popup:swipestart")
            }
            if (re.preventDefault(),
            h && p) {
                const Ne = 1 - Math.abs(_ / M)
                  , Ge = 1 - (1 - m(p)) * Ne;
                L.hasClass("popup") ? L.hasClass("popup-push") ? L.transition(0).forEach(Ye => {
                    Ye.style.setProperty("transform", `translate3d(0, calc(-1 * ${Ne} * (var(--f7-popup-push-offset) + 10px)) , 0px) scale(${Ge})`, "important")
                }
                ) : L.transition(0).forEach(Ye => {
                    Ye.style.setProperty("transform", `translate3d(0, 0px , 0px) scale(${Ge})`, "important")
                }
                ) : L.transition(0).forEach(Ye => {
                    Ye.style.setProperty("transform", `translate3d(0,0,0) scale(${Ge})`, "important")
                }
                )
            }
            c.transition(0).transform(`translate3d(0,${-_}px,0)`)
        }
        function H() {
            if (b = !1,
            !E)
                return;
            r.emit("local::swipeEnd popupSwipeEnd", r),
            r.$el.trigger("popup:swipeend"),
            E = !1,
            g = !1,
            c.transition(""),
            h && p && L.transition("").transform("");
            const re = _ <= 0 ? "to-bottom" : "to-top";
            if (typeof r.params.swipeToClose == "string" && re !== r.params.swipeToClose) {
                c.transform(""),
                g = !0;
                return
            }
            const ve = Math.abs(_)
              , Ne = new Date().getTime() - C;
            if (Ne < 300 && ve > 20 || Ne >= 300 && ve > 100) {
                un( () => {
                    re === "to-bottom" ? c.addClass("swipe-close-to-bottom") : c.addClass("swipe-close-to-top"),
                    c.transform(""),
                    r.emit("local::swipeclose popupSwipeClose", r),
                    r.$el.trigger("popup:swipeclose"),
                    r.close(),
                    g = !0
                }
                );
                return
            }
            g = !0,
            c.transform("")
        }
        const W = s.passiveListener ? {
            passive: !0
        } : !1;
        r.params.swipeToClose && (c.on(t.touchEvents.start, U, W),
        t.on("touchmove", Y),
        t.on("touchend:passive", H),
        r.once("popupDestroy", () => {
            c.off(t.touchEvents.start, U, W),
            t.off("touchmove", Y),
            t.off("touchend:passive", H)
        }
        ));
        let j;
        const Q = () => {
            const re = h;
            r.push && (h = r.push && (t.width < 630 || t.height < 630 || c.hasClass("popup-tablet-fullscreen"))),
            h && !re ? ne() : h && re ? r.$htmlEl[0].style.setProperty("--f7-popup-push-scale", m(p)) : !h && re && (r.$htmlEl.removeClass("with-modal-popup-push"),
            r.$htmlEl[0].style.removeProperty("--f7-popup-push-scale"))
        }
          , ne = () => {
            t.off("resize", Q),
            r.push && (h = r.push && (t.width < 630 || t.height < 630 || c.hasClass("popup-tablet-fullscreen"))),
            h && (p = parseInt(c.css("--f7-popup-push-offset"), 10),
            Number.isNaN(p) && (p = 0),
            p && (c.addClass("popup-push"),
            r.$htmlEl.addClass("with-modal-popup-push"),
            r.$htmlEl[0].style.setProperty("--f7-popup-push-scale", m(p)))),
            t.on("resize", Q)
        }
        ;
        return r.on("open", () => {
            j = !1,
            r.params.closeOnEscape && $(i).on("keydown", d),
            c.prevAll(".popup.modal-in").addClass("popup-behind"),
            ne()
        }
        ),
        r.on("opened", () => {
            c.removeClass("swipe-close-to-bottom swipe-close-to-top"),
            r.params.closeByBackdropClick && t.on("click", f)
        }
        ),
        r.on("close", () => {
            j = r.$el.prevAll(".popup-push.modal-in").length > 0,
            r.params.closeOnEscape && $(i).off("keydown", d),
            r.params.closeByBackdropClick && t.off("click", f),
            c.prevAll(".popup.modal-in").eq(0).removeClass("popup-behind"),
            h && p && !j && (r.$htmlEl.removeClass("with-modal-popup-push"),
            r.$htmlEl.addClass("with-modal-popup-push-closing")),
            t.off("resize", Q)
        }
        ),
        r.on("closed", () => {
            c.removeClass("popup-behind"),
            h && p && !j && (r.$htmlEl.removeClass("with-modal-popup-push-closing"),
            r.$htmlEl[0].style.removeProperty("--f7-popup-push-scale"))
        }
        ),
        c[0].f7Modal = r,
        r
    }
}
;
const SF = {
    name: "popup",
    params: {
        popup: {
            backdrop: !0,
            backdropEl: void 0,
            backdropUnique: !1,
            closeByBackdropClick: !0,
            closeOnEscape: !1,
            swipeToClose: !1,
            swipeHandler: null,
            push: !1,
            containerEl: null
        }
    },
    static: {
        Popup: zp
    },
    create() {
        const e = this;
        e.popup = cr({
            app: e,
            constructor: zp,
            defaultSelector: ".popup.modal-in",
            parentSelector: ".popup"
        })
    },
    clicks: {
        ".popup-open": function(t, n) {
            n === void 0 && (n = {}),
            this.popup.open(n.popup, n.animate, t)
        },
        ".popup-close": function(t, n) {
            n === void 0 && (n = {}),
            this.popup.close(n.popup, n.animate, t)
        }
    }
};
let Ap = class extends Va {
    constructor(t, n) {
        const a = se({
            on: {}
        }, n);
        super(t, a);
        const r = this;
        r.params = a;
        let o;
        return r.params.el ? o = $(r.params.el).eq(0) : o = $(r.params.content).filter(i => i.nodeType === 1).eq(0),
        o && o.length > 0 && o[0].f7Modal ? o[0].f7Modal : o.length === 0 ? r.destroy() : (se(r, {
            app: t,
            $el: o,
            el: o[0],
            type: "loginScreen"
        }),
        o[0].f7Modal = r,
        r)
    }
}
;
const $F = {
    name: "loginScreen",
    static: {
        LoginScreen: Ap
    },
    create() {
        const e = this;
        e.loginScreen = cr({
            app: e,
            constructor: Ap,
            defaultSelector: ".login-screen.modal-in"
        })
    },
    clicks: {
        ".login-screen-open": function(t, n) {
            n === void 0 && (n = {}),
            this.loginScreen.open(n.loginScreen, n.animate, t)
        },
        ".login-screen-close": function(t, n) {
            n === void 0 && (n = {}),
            this.loginScreen.close(n.loginScreen, n.animate, t)
        }
    }
};
let v2 = class extends Va {
    constructor(t, n) {
        const a = se({
            on: {}
        }, t.params.popover, n);
        super(t, a);
        const r = this
          , o = yt()
          , i = He()
          , s = Qe();
        r.params = a;
        let l;
        if (r.params.el ? l = $(r.params.el).eq(0) : l = $(r.params.content).filter(y => y.nodeType === 1).eq(0),
        l && l.length > 0 && l[0].f7Modal)
            return l[0].f7Modal;
        const c = $(r.params.targetEl).eq(0);
        if (l.length === 0)
            return r.destroy();
        let u;
        const f = r.params.backdrop && t.$el.find(".popover.modal-in").filter(y => y !== l[0]).length > 0;
        r.params.backdrop && r.params.backdropEl ? u = $(r.params.backdropEl) : r.params.backdrop && (r.params.backdropUnique || f ? (u = $('<div class="popover-backdrop popover-backdrop-unique"></div>'),
        u[0].f7PopoverRef = r,
        r.$containerEl.append(u)) : u = r.$containerEl.children(".popover-backdrop"),
        u.length === 0 && (u = $('<div class="popover-backdrop"></div>'),
        r.$containerEl.append(u)));
        let d;
        l.find(".popover-angle").length === 0 ? (d = $('<div class="popover-angle"></div>'),
        l.prepend(d)) : d = l.find(".popover-angle");
        const p = r.open;
        se(r, {
            app: t,
            $el: l,
            el: l[0],
            $targetEl: c,
            targetEl: c[0],
            $angleEl: d,
            angleEl: d[0],
            $backdropEl: u,
            backdropEl: u && u[0],
            type: "popover",
            forceBackdropUnique: f,
            open() {
                for (var y = arguments.length, w = new Array(y), C = 0; C < y; C++)
                    w[C] = arguments[C];
                let[_,E] = w;
                return typeof w[0] == "boolean" && ([E,_] = w),
                _ && (r.$targetEl = $(_),
                r.targetEl = r.$targetEl[0]),
                p.call(r, E)
            }
        });
        function h() {
            r.resize()
        }
        r.on("popoverOpen", () => {
            r.resize(),
            t.on("resize", h),
            $(i).on("keyboardDidShow keyboardDidHide", h),
            r.on("popoverClose popoverBeforeDestroy", () => {
                t.off("resize", h),
                $(i).off("keyboardDidShow keyboardDidHide", h)
            }
            )
        }
        );
        let m = null;
        function g(y) {
            m = y.target
        }
        function b(y) {
            const w = y.target
              , C = $(w);
            if (!(!o.desktop && o.cordova && (i.Keyboard && i.Keyboard.isVisible || i.cordova.plugins && i.cordova.plugins.Keyboard && i.cordova.plugins.Keyboard.isVisible)) && C.closest(r.el).length === 0) {
                if (r.params.closeByBackdropClick && r.params.backdrop && r.backdropEl && r.backdropEl === w && m === w)
                    r.close();
                else if (r.params.closeByOutsideClick && m === w) {
                    const E = C.hasClass("popover-backdrop-unique") && w.f7PopoverRef !== r || C.hasClass("popover-backdrop") && w !== r.backdropEl
                      , z = w.closest(".popover") && w.closest(".popover") !== r.$el[0];
                    !E && !z && r.close()
                }
            }
        }
        function v(y) {
            y.keyCode === 27 && r.params.closeOnEscape && r.close()
        }
        return r.params.closeOnEscape && (r.on("popoverOpen", () => {
            $(s).on("keydown", v)
        }
        ),
        r.on("popoverClose", () => {
            $(s).off("keydown", v)
        }
        )),
        r.on("popoverOpened", () => {
            (r.params.closeByOutsideClick || r.params.closeByBackdropClick) && (t.on("touchstart", g),
            t.on("click", b))
        }
        ),
        r.on("popoverClose", () => {
            (r.params.closeByOutsideClick || r.params.closeByBackdropClick) && (t.off("touchstart", g),
            t.off("click", b))
        }
        ),
        l[0].f7Modal = r,
        r
    }
    resize() {
        const t = this
          , {app: n, $el: a, $targetEl: r, $angleEl: o} = t
          , {targetX: i, targetY: s, verticalPosition: l} = t.params;
        a.css({
            left: "",
            top: ""
        });
        const [c,u] = [a.width(), a.height()];
        let f = 0, d, p;
        n.theme === "ios" || n.theme === "aurora" ? (o.removeClass("on-left on-right on-top on-bottom").css({
            left: "",
            top: ""
        }),
        f = o.width() / 2) : a.removeClass("popover-on-left popover-on-right popover-on-top popover-on-bottom popover-on-middle").css({
            left: "",
            top: ""
        });
        let h, m, g, b, v = parseInt($("html").css("--f7-safe-area-top"), 10), y = parseInt($("html").css("--f7-safe-area-left"), 10), w = parseInt($("html").css("--f7-safe-area-right"), 10);
        if (Number.isNaN(v) && (v = 0),
        Number.isNaN(y) && (y = 0),
        Number.isNaN(w) && (w = 0),
        r && r.length > 0) {
            h = r.outerWidth(),
            m = r.outerHeight();
            const A = r.offset();
            g = A.left - n.left,
            b = A.top - n.top;
            const x = r.parents(".page");
            x.length > 0 && (b -= x[0].scrollTop)
        } else
            typeof i < "u" && s !== "undefined" && (g = i,
            b = s,
            h = t.params.targetWidth || 0,
            m = t.params.targetHeight || 0);
        let[C,_,E] = [0, 0, 0];
        const z = l === "auto" ? !1 : l;
        let T = z || (n.theme === "md" ? "bottom" : "top");
        if (n.theme === "md") {
            z === "bottom" || !z && u < n.height - b - m ? (T = "bottom",
            _ = b + m) : z === "top" || !z && u < b - v ? (_ = b - u,
            T = "top") : (T = "middle",
            _ = m / 2 + b - u / 2),
            _ = Math.max(8, Math.min(_, n.height - u - 8));
            let A;
            g < n.width / 2 ? (A = "right",
            C = T === "middle" ? g + h : g) : (A = "left",
            C = T === "middle" ? g - c : g + h - c),
            C = Math.max(8, Math.min(C, n.width - c - 8 - w), y),
            a.addClass(`popover-on-${T} popover-on-${A}`)
        } else
            z === "top" || !z && u + f < b - v ? _ = b - u - f : z === "bottom" || !z && u + f < n.height - b - m ? (T = "bottom",
            _ = b + m + f) : (T = "middle",
            _ = m / 2 + b - u / 2,
            E = _,
            _ = Math.max(5, Math.min(_, n.height - u - 5)),
            E -= _),
            T === "top" || T === "bottom" ? (C = h / 2 + g - c / 2,
            E = C,
            C = Math.max(5, Math.min(C, n.width - c - 5)),
            y && (C = Math.max(C, y)),
            w && C + c > n.width - 5 - w && (C = n.width - 5 - w - c),
            T === "top" && o.addClass("on-bottom"),
            T === "bottom" && o.addClass("on-top"),
            E -= C,
            d = c / 2 - f + E,
            d = Math.max(Math.min(d, c - f * 2 - 13), 13),
            o.css({
                left: `${d}px`
            })) : T === "middle" && (C = g - c - f,
            o.addClass("on-right"),
            (C < 5 || C + c + w > n.width || C < y) && (C < 5 && (C = g + h + f),
            C + c + w > n.width && (C = n.width - c - 5 - w),
            C < y && (C = y),
            o.removeClass("on-right").addClass("on-left")),
            p = u / 2 - f + E,
            p = Math.max(Math.min(p, u - f * 2 - 13), 13),
            o.css({
                top: `${p}px`
            }));
        a.css({
            top: `${_}px`,
            left: `${C}px`
        })
    }
}
;
const EF = {
    name: "popover",
    params: {
        popover: {
            verticalPosition: "auto",
            backdrop: !0,
            backdropEl: void 0,
            backdropUnique: !1,
            closeByBackdropClick: !0,
            closeByOutsideClick: !0,
            closeOnEscape: !1,
            containerEl: null
        }
    },
    static: {
        Popover: v2
    },
    create() {
        const e = this;
        e.popover = se(cr({
            app: e,
            constructor: v2,
            defaultSelector: ".popover.modal-in"
        }), {
            open(t, n, a) {
                let r = $(t);
                if (r.length > 1) {
                    const s = $(n).parents(".page");
                    s.length && r.each(l => {
                        const c = $(l);
                        c.parents(s)[0] === s[0] && (r = c)
                    }
                    )
                }
                r.length > 1 && (r = r.eq(r.length - 1));
                let o = r[0].f7Modal;
                const i = r.dataset();
                return o || (o = new v2(e,Object.assign({
                    el: r,
                    targetEl: n
                }, i))),
                o.open(n, a)
            }
        })
    },
    clicks: {
        ".popover-open": function(t, n) {
            n === void 0 && (n = {}),
            this.popover.open(n.popover, t, n.animate)
        },
        ".popover-close": function(t, n) {
            n === void 0 && (n = {}),
            this.popover.close(n.popover, n.animate, t)
        }
    }
};
let Op = class extends Va {
    constructor(t, n) {
        const a = se({
            on: {}
        }, t.params.actions, n);
        super(t, a);
        const r = this
          , o = yt()
          , i = He()
          , s = Qe();
        r.params = a;
        let l;
        r.params.buttons && (l = r.params.buttons,
        Array.isArray(l[0]) || (l = [l])),
        r.groups = l;
        let c;
        if (r.params.el ? c = $(r.params.el).eq(0) : r.params.content ? c = $(r.params.content).filter(b => b.nodeType === 1).eq(0) : r.params.buttons && (r.params.convertToPopover && (r.popoverHtml = r.renderPopover()),
        r.actionsHtml = r.render()),
        c && c.length > 0 && c[0].f7Modal)
            return c[0].f7Modal;
        if (c && c.length === 0 && !(r.actionsHtml || r.popoverHtml))
            return r.destroy();
        let u;
        r.params.backdrop && r.params.backdropEl ? u = $(r.params.backdropEl) : r.params.backdrop && (r.params.backdropUnique ? (u = $('<div class="popup-backdrop popup-backdrop-unique"></div>'),
        r.$containerEl.append(u)) : u = r.$containerEl.children(".actions-backdrop"),
        u.length === 0 && (u = $('<div class="actions-backdrop"></div>'),
        r.$containerEl.append(u)));
        const f = r.open
          , d = r.close;
        let p;
        function h(b) {
            const v = $(this);
            let y, w;
            if (v.hasClass("list-button") || v.hasClass("item-link") ? (y = v.parents("li").index(),
            w = v.parents(".list").index()) : (y = v.index(),
            w = v.parents(".actions-group").index()),
            typeof l < "u") {
                const C = l[w][y];
                C.onClick && C.onClick(r, b),
                r.params.onClick && r.params.onClick(r, b),
                C.close !== !1 && r.close()
            }
        }
        r.open = function(v) {
            let y = !1;
            const {targetEl: w, targetX: C, targetY: _, targetWidth: E, targetHeight: z} = r.params;
            return r.params.convertToPopover && (w || C !== void 0 && _ !== void 0) && (r.params.forceToPopover || o.ios && o.ipad || t.width >= 768 || o.desktop && t.theme === "aurora") && (y = !0),
            y && r.popoverHtml ? (p = t.popover.create({
                containerEl: r.params.containerEl,
                content: r.popoverHtml,
                backdrop: r.params.backdrop,
                targetEl: w,
                targetX: C,
                targetY: _,
                targetWidth: E,
                targetHeight: z,
                on: {
                    open() {
                        r.$el || (r.$el = p.$el),
                        r.$el.trigger(`modal:open ${r.type.toLowerCase()}:open`),
                        r.emit(`local::open modalOpen ${r.type}Open`, r)
                    },
                    opened() {
                        r.$el || (r.$el = p.$el),
                        r.$el.trigger(`modal:opened ${r.type.toLowerCase()}:opened`),
                        r.emit(`local::opened modalOpened ${r.type}Opened`, r)
                    },
                    close() {
                        r.$el || (r.$el = p.$el),
                        r.$el.trigger(`modal:close ${r.type.toLowerCase()}:close`),
                        r.emit(`local::close modalClose ${r.type}Close`, r)
                    },
                    closed() {
                        r.$el || (r.$el = p.$el),
                        r.$el.trigger(`modal:closed ${r.type.toLowerCase()}:closed`),
                        r.emit(`local::closed modalClosed ${r.type}Closed`, r)
                    }
                }
            }),
            p.open(v),
            p.once("popoverOpened", () => {
                p.$el.find(".list-button, .item-link").each(T => {
                    $(T).on("click", h)
                }
                )
            }
            ),
            p.once("popoverClosed", () => {
                p.$el.find(".list-button, .item-link").each(T => {
                    $(T).off("click", h)
                }
                ),
                un( () => {
                    p.destroy(),
                    p = void 0
                }
                )
            }
            )) : (r.$el = r.actionsHtml ? $(r.actionsHtml) : r.$el,
            r.$el[0].f7Modal = r,
            r.groups && (r.$el.find(".actions-button").each(T => {
                $(T).on("click", h)
            }
            ),
            r.once("actionsClosed", () => {
                r.$el.find(".actions-button").each(T => {
                    $(T).off("click", h)
                }
                )
            }
            )),
            r.el = r.$el[0],
            f.call(r, v)),
            r
        }
        ,
        r.close = function(v) {
            return p ? p.close(v) : d.call(r, v),
            r
        }
        ,
        se(r, {
            app: t,
            $el: c,
            el: c ? c[0] : void 0,
            $backdropEl: u,
            backdropEl: u && u[0],
            type: "actions"
        });
        function m(b) {
            const v = b.target
              , y = $(v);
            !o.desktop && o.cordova && (i.Keyboard && i.Keyboard.isVisible || i.cordova.plugins && i.cordova.plugins.Keyboard && i.cordova.plugins.Keyboard.isVisible) || y.closest(r.el).length === 0 && (r.params.closeByBackdropClick && r.params.backdrop && r.backdropEl && r.backdropEl === v || r.params.closeByOutsideClick) && r.close()
        }
        function g(b) {
            b.keyCode === 27 && r.params.closeOnEscape && r.close()
        }
        return r.params.closeOnEscape && (r.on("open", () => {
            $(s).on("keydown", g)
        }
        ),
        r.on("close", () => {
            $(s).off("keydown", g)
        }
        )),
        r.on("opened", () => {
            (r.params.closeByBackdropClick || r.params.closeByOutsideClick) && t.on("click", m)
        }
        ),
        r.on("close", () => {
            (r.params.closeByBackdropClick || r.params.closeByOutsideClick) && t.off("click", m)
        }
        ),
        c && (c[0].f7Modal = r),
        r
    }
    render() {
        const t = this;
        if (t.params.render)
            return t.params.render.call(t, t);
        const {groups: n} = t
          , a = t.params.cssClass;
        return R("div", {
            class: `actions-modal${t.params.grid ? " actions-grid" : ""} ${a || ""}`
        }, n.map(r => R("div", {
            class: "actions-group"
        }, r.map(o => {
            const i = [`actions-${o.label ? "label" : "button"}`]
              , {color: s, bg: l, bold: c, disabled: u, label: f, text: d, icon: p} = o;
            return s && i.push(`color-${s}`),
            l && i.push(`bg-color-${l}`),
            c && i.push("actions-button-bold"),
            u && i.push("disabled"),
            f ? R("div", {
                class: i.join(" ")
            }, d) : R("div", {
                class: i.join(" ")
            }, p && R("div", {
                class: "actions-button-media"
            }, p), R("div", {
                class: "actions-button-text"
            }, d))
        }
        ))))
    }
    renderPopover() {
        const t = this;
        if (t.params.renderPopover)
            return t.params.renderPopover.call(t, t);
        const {groups: n} = t
          , a = t.params.cssClass;
        return R("div", {
            class: `popover popover-from-actions ${a || ""}`
        }, R("div", {
            class: "popover-inner"
        }, n.map(r => R("div", {
            class: "list"
        }, R("ul", null, r.map(o => {
            const i = []
              , {color: s, bg: l, bold: c, disabled: u, label: f, text: d, icon: p} = o;
            return s && i.push(`color-${s}`),
            l && i.push(`bg-color-${l}`),
            c && i.push("popover-from-actions-bold"),
            u && i.push("disabled"),
            f ? (i.push("popover-from-actions-label"),
            `<li class="${i.join(" ")}">${d}</li>`) : p ? (i.push("item-link item-content"),
            R("li", null, R("a", {
                class: i.join(" ")
            }, R("div", {
                class: "item-media"
            }, p), R("div", {
                class: "item-inner"
            }, R("div", {
                class: "item-title"
            }, d))))) : (i.push("list-button"),
            R("li", null, R("a", {
                class: i.join(" ")
            }, d)))
        }
        ))))))
    }
}
;
const xF = {
    name: "actions",
    params: {
        actions: {
            convertToPopover: !0,
            forceToPopover: !1,
            backdrop: !0,
            backdropEl: void 0,
            backdropUnique: !1,
            cssClass: null,
            closeByBackdropClick: !0,
            closeOnEscape: !1,
            render: null,
            renderPopover: null,
            containerEl: null
        }
    },
    static: {
        Actions: Op
    },
    create() {
        const e = this;
        e.actions = cr({
            app: e,
            constructor: Op,
            defaultSelector: ".actions-modal.modal-in"
        })
    },
    clicks: {
        ".actions-open": function(t, n) {
            n === void 0 && (n = {}),
            this.actions.open(n.actions, n.animate, t)
        },
        ".actions-close": function(t, n) {
            n === void 0 && (n = {}),
            this.actions.close(n.actions, n.animate, t)
        }
    }
};
let Pp = class extends Va {
    constructor(t, n) {
        const a = se({
            on: {}
        }, t.params.sheet, n);
        super(t, a);
        const r = this
          , o = He()
          , i = Qe()
          , s = Mt()
          , l = yt();
        r.params = a,
        typeof r.params.backdrop > "u" && (r.params.backdrop = t.theme !== "ios");
        let c;
        if (r.params.el ? c = $(r.params.el).eq(0) : c = $(r.params.content).filter(ee => ee.nodeType === 1).eq(0),
        c && c.length > 0 && c[0].f7Modal)
            return c[0].f7Modal;
        if (c.length === 0)
            return r.destroy();
        let u;
        r.params.backdrop && r.params.backdropEl ? u = $(r.params.backdropEl) : r.params.backdrop && (r.params.backdropUnique ? (u = $('<div class="sheet-backdrop sheet-backdrop-unique"></div>'),
        r.$containerEl.append(u)) : u = r.$containerEl.children(".sheet-backdrop"),
        u.length === 0 && (u = $('<div class="sheet-backdrop"></div>'),
        r.$containerEl.append(u))),
        se(r, {
            app: t,
            push: c.hasClass("sheet-modal-push") || r.params.push,
            $el: c,
            el: c[0],
            $backdropEl: u,
            backdropEl: u && u[0],
            type: "sheet",
            $htmlEl: $("html")
        }),
        r.params.push && c.addClass("sheet-modal-push");
        let f;
        function d() {
            const ee = $(r.params.scrollToEl).eq(0);
            if (ee.length === 0 || (f = ee.parents(".page-content"),
            f.length === 0))
                return;
            const ye = parseInt(f.css("padding-top"), 10)
              , Le = parseInt(f.css("padding-bottom"), 10)
              , Se = f[0].offsetHeight - ye - c.height()
              , Re = f[0].scrollHeight - ye - c.height()
              , Ve = f.scrollTop();
            let Ze;
            const q = ee.offset().top - ye + ee[0].offsetHeight;
            if (q > Se) {
                const Z = Ve + q - Se;
                Z + Se > Re && (Ze = Z + Se - Re + Le,
                Se === Re && (Ze = c.height()),
                f.css({
                    "padding-bottom": `${Ze}px`
                })),
                f.scrollTop(Z, 300)
            }
        }
        function p() {
            f && f.length > 0 && f.css({
                "padding-bottom": ""
            })
        }
        function h(ee) {
            const ye = ee.target
              , Le = $(ye);
            !l.desktop && l.cordova && (o.Keyboard && o.Keyboard.isVisible || o.cordova.plugins && o.cordova.plugins.Keyboard && o.cordova.plugins.Keyboard.isVisible) || Le.closest(r.el).length === 0 && (r.params.closeByBackdropClick && r.params.backdrop && r.backdropEl && r.backdropEl === ye || r.params.closeByOutsideClick) && r.close()
        }
        function m(ee) {
            ee.keyCode === 27 && r.params.closeOnEscape && r.close()
        }
        let g;
        function b(ee) {
            return (t.height - ee * 2) / t.height
        }
        let v = !1, y, w, C, _, E, z = !1, T, A, x, M, L, U, Y, H, W, j, Q, ne, re;
        function ve(ee) {
            v || !(r.params.swipeToClose || r.params.swipeToStep) || r.params.swipeHandler && $(ee.target).closest(r.params.swipeHandler).length === 0 || (v = !0,
            z = !1,
            y = {
                x: ee.type === "touchstart" ? ee.targetTouches[0].pageX : ee.pageX,
                y: ee.type === "touchstart" ? ee.targetTouches[0].pageY : ee.pageY
            },
            _ = zn(),
            C = void 0,
            T = c.hasClass("sheet-modal-top"),
            !r.params.swipeHandler && ee.type === "touchstart" && (j = $(ee.target).closest(".page-content")[0]))
        }
        function Ne(ee) {
            if (!v)
                return;
            if (w = {
                x: ee.type === "touchmove" ? ee.targetTouches[0].pageX : ee.pageX,
                y: ee.type === "touchmove" ? ee.targetTouches[0].pageY : ee.pageY
            },
            typeof C > "u" && (C = !!(C || Math.abs(w.x - y.x) > Math.abs(w.y - y.y))),
            C) {
                v = !1,
                z = !1;
                return
            }
            E = y.y - w.y;
            const ye = E < 0 ? "to-bottom" : "to-top";
            if (!z) {
                if (j && !c.hasClass("modal-in-swipe-step") && (Q = j.scrollTop,
                ne = j.scrollHeight,
                re = j.offsetHeight,
                ne !== re && !(ye === "to-bottom" && Q === 0) && !(ye === "to-top" && Q === ne - re))) {
                    c.transform(""),
                    v = !1,
                    z = !1;
                    return
                }
                r.push && g && (H = t.$el.children(".view, .views")),
                L = c[0].offsetHeight,
                x = w1(c[0], "y"),
                T ? (U = r.params.swipeToClose ? -L : -A,
                Y = 0) : (U = 0,
                Y = r.params.swipeToClose ? L : A),
                z = !0
            }
            if (M = x - E,
            M = Math.min(Math.max(M, U), Y),
            ee.preventDefault(),
            r.push && g) {
                let Le = (M - x) / L;
                r.params.swipeToStep && (T ? Le = M / A : Le = 1 - (A - M) / A),
                Le = Math.abs(Le),
                Le = Math.min(Math.max(Le, 0), 1);
                const Se = 1 - Le
                  , Re = 1 - (1 - b(g)) * Se;
                H.transition(0).forEach(Ve => {
                    Ve.style.setProperty("transform", `translate3d(0,0,0) scale(${Re})`, "important")
                }
                ),
                r.params.swipeToStep && H.css("border-radius", `${W * Se}px`)
            }
            if (c.transition(0).transform(`translate3d(0,${M}px,0)`),
            r.params.swipeToStep) {
                let Le;
                T ? Le = 1 - M / A : Le = (A - M) / A,
                Le = Math.min(Math.max(Le, 0), 1),
                c.trigger("sheet:stepprogress", Le),
                r.emit("local::stepProgress sheetStepProgress", r, Le)
            }
        }
        function Ge() {
            if (v = !1,
            !z)
                return;
            z = !1,
            c.transform("").transition(""),
            r.push && g && (H.transition("").transform(""),
            H.css("border-radius", ""));
            const ee = E < 0 ? "to-bottom" : "to-top"
              , ye = Math.abs(E);
            if (ye === 0 || M === x)
                return;
            const Le = new Date().getTime() - _;
            if (!r.params.swipeToStep) {
                if (ee !== (T ? "to-top" : "to-bottom"))
                    return;
                (Le < 300 && ye > 20 || Le >= 300 && ye > L / 2) && r.close();
                return
            }
            const Se = T ? "to-bottom" : "to-top"
              , Re = T ? "to-top" : "to-bottom"
              , Ve = Math.abs(M)
              , Ze = Math.abs(A);
            if (Le < 300 && ye > 10) {
                ee === Se && Ve < Ze && (c.removeClass("modal-in-swipe-step"),
                c.trigger("sheet:stepprogress", 1),
                r.emit("local::stepProgress sheetStepProgress", r, 1),
                r.emit("local::_swipeStep", !1),
                c.trigger("sheet:stepopen"),
                r.emit("local::stepOpen sheetStepOpen", r),
                r.push && g && (r.$htmlEl[0].style.setProperty("--f7-sheet-push-scale", b(g)),
                H.css("border-radius", ""))),
                ee === Re && Ve > Ze && (r.params.swipeToClose ? r.close() : (c.addClass("modal-in-swipe-step"),
                c.trigger("sheet:stepprogress", 0),
                r.emit("local::stepProgress sheetStepProgress", r, 0),
                r.emit("local::_swipeStep", !0),
                c.trigger("sheet:stepclose"),
                r.emit("local::stepClose sheetStepClose", r),
                r.push && g && (r.$htmlEl[0].style.removeProperty("--f7-sheet-push-scale"),
                H.css("border-radius", "0px")))),
                ee === Re && Ve <= Ze && (c.addClass("modal-in-swipe-step"),
                c.trigger("sheet:stepprogress", 0),
                r.emit("local::stepProgress sheetStepProgress", r, 0),
                r.emit("local::_swipeStep", !0),
                c.trigger("sheet:stepclose"),
                r.emit("local::stepClose sheetStepClose", r),
                r.push && g && (r.$htmlEl[0].style.removeProperty("--f7-sheet-push-scale"),
                H.css("border-radius", "0px")));
                return
            }
            if (Le >= 300) {
                const q = !c.hasClass("modal-in-swipe-step");
                q ? q && (Ve > Ze + (L - Ze) / 2 ? r.params.swipeToClose && r.close() : Ve > Ze / 2 && (c.addClass("modal-in-swipe-step"),
                c.trigger("sheet:stepprogress", 0),
                r.emit("local::stepProgress sheetStepProgress", r, 0),
                r.emit("local::_swipeStep", !0),
                c.trigger("sheet:stepclose"),
                r.emit("local::stepClose sheetStepClose", r),
                r.push && g && (r.$htmlEl[0].style.removeProperty("--f7-sheet-push-scale"),
                H.css("border-radius", "0px")))) : Ve < Ze / 2 ? (c.removeClass("modal-in-swipe-step"),
                c.trigger("sheet:stepprogress", 1),
                r.emit("local::stepProgress sheetStepProgress", r, 1),
                r.emit("local::_swipeStep", !1),
                c.trigger("sheet:stepopen"),
                r.emit("local::stepOpen sheetStepOpen", r),
                r.push && g && (r.$htmlEl[0].style.setProperty("--f7-sheet-push-scale", b(g)),
                H.css("border-radius", ""))) : Ve - Ze > (L - Ze) / 2 && r.params.swipeToClose && r.close()
            }
        }
        r.setSwipeStep = function(ye) {
            ye === void 0 && (ye = !0);
            const Le = c.find(".sheet-modal-swipe-step").eq(0);
            Le.length && (c.hasClass("sheet-modal-top") ? A = -(Le.offset().top - c.offset().top + Le[0].offsetHeight) : A = c[0].offsetHeight - (Le.offset().top - c.offset().top + Le[0].offsetHeight),
            c[0].style.setProperty("--f7-sheet-swipe-step", `${A}px`),
            ye || (c.addClass("modal-in-swipe-step"),
            r.emit("local::_swipeStep", !0)))
        }
        ;
        function Ye() {
            r.setSwipeStep(!0)
        }
        const tt = s.passiveListener ? {
            passive: !0
        } : !1;
        return (r.params.swipeToClose || r.params.swipeToStep) && (c.on(t.touchEvents.start, ve, tt),
        t.on("touchmove", Ne),
        t.on("touchend:passive", Ge),
        r.once("sheetDestroy", () => {
            c.off(t.touchEvents.start, ve, tt),
            t.off("touchmove", Ne),
            t.off("touchend:passive", Ge)
        }
        )),
        r.on("open", () => {
            r.params.closeOnEscape && $(i).on("keydown", m),
            c.prevAll(".popup.modal-in").addClass("popup-behind"),
            r.params.swipeToStep && (r.setSwipeStep(!1),
            t.on("resize", Ye)),
            r.params.scrollToEl && d(),
            r.push && (g = parseInt(c.css("--f7-sheet-push-offset"), 10),
            Number.isNaN(g) && (g = 0),
            g && (c.addClass("sheet-modal-push"),
            r.$htmlEl.addClass("with-modal-sheet-push"),
            r.params.swipeToStep ? (H = t.$el.children(".view, .views"),
            W = parseFloat(c.css(`border-${T ? "bottom" : "top"}-left-radius`)),
            H.css("border-radius", "0px")) : r.$htmlEl[0].style.setProperty("--f7-sheet-push-scale", b(g))))
        }
        ),
        r.on("opened", () => {
            (r.params.closeByOutsideClick || r.params.closeByBackdropClick) && t.on("click", h)
        }
        ),
        r.on("close", () => {
            r.params.swipeToStep && (c.removeClass("modal-in-swipe-step"),
            r.emit("local::_swipeStep", !1),
            t.off("resize", Ye)),
            r.params.closeOnEscape && $(i).off("keydown", m),
            r.params.scrollToEl && p(),
            (r.params.closeByOutsideClick || r.params.closeByBackdropClick) && t.off("click", h),
            c.prevAll(".popup.modal-in").eq(0).removeClass("popup-behind"),
            r.push && g && (r.$htmlEl.removeClass("with-modal-sheet-push"),
            r.$htmlEl.addClass("with-modal-sheet-push-closing"))
        }
        ),
        r.on("closed", () => {
            r.push && g && (r.$htmlEl.removeClass("with-modal-sheet-push-closing"),
            r.$htmlEl[0].style.removeProperty("--f7-sheet-push-scale"))
        }
        ),
        r.stepOpen = function() {
            c.removeClass("modal-in-swipe-step"),
            r.emit("local::_swipeStep", !1),
            r.push && (g || (g = parseInt(c.css("--f7-sheet-push-offset"), 10),
            Number.isNaN(g) && (g = 0)),
            g && r.$htmlEl[0].style.setProperty("--f7-sheet-push-scale", b(g)))
        }
        ,
        r.stepClose = function() {
            c.addClass("modal-in-swipe-step"),
            r.emit("local::_swipeStep", !0),
            r.push && r.$htmlEl[0].style.removeProperty("--f7-sheet-push-scale")
        }
        ,
        r.stepToggle = function() {
            c.toggleClass("modal-in-swipe-step"),
            r.emit("local::_swipeStep", c.hasClass("modal-in-swipe-step"))
        }
        ,
        c[0].f7Modal = r,
        r
    }
}
;
const TF = {
    name: "sheet",
    params: {
        sheet: {
            push: !1,
            backdrop: void 0,
            backdropEl: void 0,
            backdropUnique: !1,
            closeByBackdropClick: !0,
            closeByOutsideClick: !1,
            closeOnEscape: !1,
            swipeToClose: !1,
            swipeToStep: !1,
            swipeHandler: null,
            containerEl: null
        }
    },
    static: {
        Sheet: Pp
    },
    create() {
        const e = this;
        e.sheet = se({}, cr({
            app: e,
            constructor: Pp,
            defaultSelector: ".sheet-modal.modal-in"
        }), {
            stepOpen(t) {
                const n = e.sheet.get(t);
                if (n && n.stepOpen)
                    return n.stepOpen()
            },
            stepClose(t) {
                const n = e.sheet.get(t);
                if (n && n.stepClose)
                    return n.stepClose()
            },
            stepToggle(t) {
                const n = e.sheet.get(t);
                if (n && n.stepToggle)
                    return n.stepToggle()
            }
        })
    },
    clicks: {
        ".sheet-open": function(t, n) {
            n === void 0 && (n = {});
            const a = this;
            $(".sheet-modal.modal-in").length > 0 && n.sheet && $(n.sheet)[0] !== $(".sheet-modal.modal-in")[0] && a.sheet.close(".sheet-modal.modal-in"),
            a.sheet.open(n.sheet, n.animate, t)
        },
        ".sheet-close": function(t, n) {
            n === void 0 && (n = {}),
            this.sheet.close(n.sheet, n.animate, t)
        }
    }
};
let b2 = class extends Va {
    constructor(t, n) {
        const a = se({
            on: {}
        }, t.params.toast, n);
        super(t, a);
        const r = this
          , o = He();
        r.app = t,
        r.params = a;
        const {closeButton: i, closeTimeout: s} = r.params;
        let l;
        if (r.params.el)
            l = $(r.params.el);
        else {
            const u = r.render();
            l = $(u)
        }
        if (l && l.length > 0 && l[0].f7Modal)
            return l[0].f7Modal;
        if (l.length === 0)
            return r.destroy();
        se(r, {
            $el: l,
            el: l[0],
            type: "toast"
        }),
        l[0].f7Modal = r,
        i && (l.find(".toast-button").on("click", () => {
            r.emit("local::closeButtonClick toastCloseButtonClick", r),
            r.close()
        }
        ),
        r.on("beforeDestroy", () => {
            l.find(".toast-button").off("click")
        }
        ));
        let c;
        return r.on("open", () => {
            $(".toast.modal-in").each(u => {
                const f = t.toast.get(u);
                u !== r.el && f && f.close()
            }
            ),
            s && (c = un( () => {
                r.close()
            }
            , s))
        }
        ),
        r.on("close", () => {
            o.clearTimeout(c)
        }
        ),
        r.params.destroyOnClose && r.once("closed", () => {
            setTimeout( () => {
                r.destroy()
            }
            , 0)
        }
        ),
        r
    }
    render() {
        const t = this;
        if (t.params.render)
            return t.params.render.call(t, t);
        const {position: n, horizontalPosition: a, cssClass: r, icon: o, text: i, closeButton: s, closeButtonColor: l, closeButtonText: c} = t.params
          , u = n === "top" || n === "bottom" ? `toast-horizontal-${a}` : "";
        return R("div", {
            class: `toast toast-${n} ${u} ${r || ""} ${o ? "toast-with-icon" : ""}`
        }, R("div", {
            class: "toast-content"
        }, o && R("div", {
            class: "toast-icon"
        }, o), R("div", {
            class: "toast-text"
        }, i), s && !o && R("a", {
            class: `toast-button button ${l ? `color-${l}` : ""}`
        }, c)))
    }
}
;
const MF = {
    name: "toast",
    static: {
        Toast: b2
    },
    create() {
        const e = this;
        e.toast = se({}, cr({
            app: e,
            constructor: b2,
            defaultSelector: ".toast.modal-in"
        }), {
            show(t) {
                return se(t, {
                    destroyOnClose: !0
                }),
                new b2(e,t).open()
            }
        })
    },
    params: {
        toast: {
            icon: null,
            text: null,
            position: "bottom",
            horizontalPosition: "left",
            closeButton: !1,
            closeButtonColor: null,
            closeButtonText: "Ok",
            closeTimeout: null,
            cssClass: null,
            render: null,
            containerEl: null
        }
    }
}
  , ns = {
    init(e) {
        const t = this
          , n = {
            iosPreloaderContent: ho,
            mdPreloaderContent: po,
            auroraPreloaderContent: mo
        }
          , a = $(e);
        a.length === 0 || a.children(".preloader-inner").length > 0 || a.children(".preloader-inner-line").length > 0 || a.append(n[`${t.theme}PreloaderContent`])
    },
    visible: !1,
    show(e) {
        e === void 0 && (e = "white");
        const t = this;
        if (ns.visible)
            return;
        const a = {
            iosPreloaderContent: ho,
            mdPreloaderContent: po,
            auroraPreloaderContent: mo
        }[`${t.theme}PreloaderContent`] || "";
        $("html").addClass("with-modal-preloader"),
        t.$el.append(`
      <div class="preloader-backdrop"></div>
      <div class="preloader-modal">
        <div class="preloader color-${e}">${a}</div>
      </div>
    `),
        ns.visible = !0
    },
    showIn(e, t) {
        t === void 0 && (t = "white");
        const n = this
          , r = {
            iosPreloaderContent: ho,
            mdPreloaderContent: po,
            auroraPreloaderContent: mo
        }[`${n.theme}PreloaderContent`] || "";
        $(e || "html").addClass("with-modal-preloader"),
        $(e || n.$el).append(`
      <div class="preloader-backdrop"></div>
      <div class="preloader-modal">
        <div class="preloader color-${t}">${r}</div>
      </div>
    `)
    },
    hide() {
        const e = this;
        ns.visible && ($("html").removeClass("with-modal-preloader"),
        e.$el.find(".preloader-backdrop, .preloader-modal").remove(),
        ns.visible = !1)
    },
    hideIn(e) {
        const t = this;
        $(e || "html").removeClass("with-modal-preloader"),
        $(e || t.$el).find(".preloader-backdrop, .preloader-modal").remove()
    }
}
  , zF = {
    name: "preloader",
    create() {
        hn(this, {
            preloader: ns
        })
    },
    on: {
        photoBrowserOpen(e) {
            const t = this;
            e.$el.find(".preloader").each(n => {
                t.preloader.init(n)
            }
            )
        },
        tabMounted(e) {
            const t = this;
            $(e).find(".preloader").each(n => {
                t.preloader.init(n)
            }
            )
        },
        pageInit(e) {
            const t = this;
            e.$el.find(".preloader").each(n => {
                t.preloader.init(n)
            }
            )
        }
    },
    vnode: {
        preloader: {
            insert(e) {
                const t = this
                  , n = e.elm;
                t.preloader.init(n)
            }
        }
    }
}
  , AF = {
    set() {
        const e = this;
        for (var t = arguments.length, n = new Array(t), a = 0; a < t; a++)
            n[a] = arguments[a];
        let[r,o,i] = n;
        if (typeof n[0] == "number" && ([o,i] = n,
        r = e.$el),
        typeof o > "u" || o === null)
            return r;
        o || (o = 0);
        const s = $(r || e.$el);
        if (s.length === 0)
            return r;
        const l = Math.min(Math.max(o, 0), 100);
        let c;
        if (s.hasClass("progressbar") ? c = s.eq(0) : c = s.children(".progressbar"),
        c.length === 0 || c.hasClass("progressbar-infinite"))
            return c;
        let u = c.children("span");
        return u.length === 0 && (u = $("<span></span>"),
        c.append(u)),
        u.transition(typeof i < "u" ? i : "").transform(`translate3d(${(-100 + l) * (e.rtl ? -1 : 1)}%,0,0)`),
        c[0]
    },
    show() {
        const e = this;
        for (var t = arguments.length, n = new Array(t), a = 0; a < t; a++)
            n[a] = arguments[a];
        let[r,o,i] = n
          , s = "determined";
        n.length === 2 ? (typeof n[0] == "string" || typeof n[0] == "object") && typeof n[1] == "string" ? ([r,i,o] = n,
        s = "infinite") : typeof n[0] == "number" && typeof n[1] == "string" && ([o,i] = n,
        r = e.$el) : n.length === 1 ? typeof n[0] == "number" ? (r = e.$el,
        o = n[0]) : typeof n[0] == "string" && (s = "infinite",
        r = e.$el,
        i = n[0]) : n.length === 0 && (s = "infinite",
        r = e.$el);
        const l = $(r);
        if (l.length === 0)
            return;
        let c;
        return l.hasClass("progressbar") || l.hasClass("progressbar-infinite") ? c = l : (c = l.children(".progressbar:not(.progressbar-out), .progressbar-infinite:not(.progressbar-out)"),
        c.length === 0 && (c = $(`
          <span class="progressbar${s === "infinite" ? "-infinite" : ""}${i ? ` color-${i}` : ""} progressbar-in">
            ${s === "infinite" ? "" : "<span></span>"}
          </span>`),
        l.append(c))),
        typeof o < "u" && e.progressbar.set(c, o),
        c[0]
    },
    hide(e, t) {
        t === void 0 && (t = !0);
        const a = $(e || this.$el);
        if (a.length === 0)
            return;
        let r;
        return a.hasClass("progressbar") || a.hasClass("progressbar-infinite") ? r = a : r = a.children(".progressbar, .progressbar-infinite"),
        r.length === 0 || !r.hasClass("progressbar-in") || r.hasClass("progressbar-out") || r.removeClass("progressbar-in").addClass("progressbar-out").animationEnd( () => {
            t && r.remove()
        }
        ),
        r
    }
}
  , OF = {
    name: "progressbar",
    create() {
        hn(this, {
            progressbar: AF
        })
    },
    on: {
        tabMounted(e) {
            const t = this;
            $(e).find(".progressbar").each(n => {
                const a = $(n);
                t.progressbar.set(a, a.attr("data-progress"))
            }
            )
        },
        pageInit(e) {
            const t = this;
            e.$el.find(".progressbar").each(n => {
                const a = $(n);
                t.progressbar.set(a, a.attr("data-progress"))
            }
            )
        }
    },
    vnode: {
        progressbar: {
            insert(e) {
                const t = this
                  , n = e.elm;
                t.progressbar.set(n, n.getAttribute("data-progress"))
            },
            update(e) {
                const t = this
                  , n = e.elm;
                t.progressbar.set(n, n.getAttribute("data-progress"))
            }
        }
    }
}
  , PF = {
    init() {
        const e = this
          , t = Qe();
        let n, a, r, o, i, s, l, c, u, f, d, p, h, m, g, b, v, y, w, C, _;
        function E(x, M) {
            a = !1,
            n = !0,
            _ = !1,
            r = x.type === "touchstart" ? x.targetTouches[0].pageY : x.pageY,
            i = $(x.target).closest("li").eq(0),
            h = i.index(),
            l = i.parents(".sortable");
            const L = i.parents(".list-group");
            L.length && L.parents(l).length && (l = L),
            s = l.children("ul").children("li:not(.disallow-sorting):not(.no-sorting)"),
            e.panel && (e.panel.allowOpen = !1),
            e.swipeout && (e.swipeout.allow = !1),
            M && (i.addClass("sorting"),
            l.addClass("sortable-sorting"),
            _ = !0)
        }
        function z(x) {
            if (!n || !i)
                return;
            const M = x.type === "touchmove" ? x.targetTouches[0].pageY : x.pageY;
            if (!a) {
                m = i.parents(".page"),
                g = i.parents(".page-content");
                const j = parseInt(g.css("padding-top"), 10)
                  , Q = parseInt(g.css("padding-bottom"), 10);
                C = g[0].scrollTop,
                v = m.offset().top + j,
                b = m.height() - j - Q,
                i.addClass("sorting"),
                l.addClass("sortable-sorting"),
                y = i[0].offsetTop,
                u = i[0].offsetTop,
                f = i.parent().height() - y - i.height(),
                c = i[0].offsetHeight,
                w = i.offset().top
            }
            a = !0,
            x.preventDefault(),
            x.f7PreventSwipePanel = !0,
            o = M - r;
            const L = g[0].scrollTop - C
              , U = Math.min(Math.max(o + L, -u), f);
            i.transform(`translate3d(0,${U}px,0)`);
            const Y = 44;
            let H = !0;
            o + L + Y < -u && (H = !1),
            o + L - Y > f && (H = !1),
            p = void 0,
            d = void 0;
            let W;
            H && (w + o + c + Y > v + b && (W = w + o + c + Y - (v + b)),
            w + o < v + Y && (W = w + o - v - Y),
            W && (g[0].scrollTop += W)),
            s.each(j => {
                const Q = $(j);
                if (Q[0] === i[0])
                    return;
                const ne = Q[0].offsetTop
                  , re = Q.height()
                  , ve = y + U;
                let Ne;
                const Ge = Q[0].f7Translate;
                ve >= ne - re / 2 && i.index() < Q.index() ? (Ne = -c,
                Q.transform(`translate3d(0, ${Ne}px,0)`),
                d = Q,
                p = void 0) : ve <= ne + re / 2 && i.index() > Q.index() ? (Ne = c,
                Q[0].f7Translate = Ne,
                Q.transform(`translate3d(0, ${Ne}px,0)`),
                d = void 0,
                p || (p = Q)) : (Ne = void 0,
                Q.transform("translate3d(0, 0%,0)")),
                Ge !== Ne && (Q.trigger("sortable:move"),
                e.emit("sortableMove", Q[0], l[0])),
                Q[0].f7Translate = Ne
            }
            )
        }
        function T() {
            if (!n || !a) {
                n && !a && (e.panel && (e.panel.allowOpen = !0),
                e.swipeout && (e.swipeout.allow = !0),
                _ && (i.removeClass("sorting"),
                l.removeClass("sortable-sorting"))),
                n = !1,
                a = !1;
                return
            }
            e.panel && (e.panel.allowOpen = !0),
            e.swipeout && (e.swipeout.allow = !0),
            s.transform(""),
            i.removeClass("sorting"),
            l.removeClass("sortable-sorting");
            let x;
            d ? x = d.index() : p && (x = p.index());
            let M = l.dataset().sortableMoveElements;
            if (typeof M > "u" && (M = e.params.sortable.moveElements),
            M && (d && i.insertAfter(d),
            p && i.insertBefore(p)),
            (d || p) && l.hasClass("virtual-list")) {
                h = i[0].f7VirtualListIndex,
                typeof h > "u" && (h = i.attr("data-virtual-list-index")),
                p ? (x = p[0].f7VirtualListIndex,
                typeof x > "u" && (x = p.attr("data-virtual-list-index"))) : (x = d[0].f7VirtualListIndex,
                typeof x > "u" && (x = d.attr("data-virtual-list-index"))),
                x !== null ? x = parseInt(x, 10) : x = void 0;
                const L = l[0].f7VirtualList;
                h && (h = parseInt(h, 10)),
                x && (x = parseInt(x, 10)),
                L && L.moveItem(h, x)
            }
            typeof x < "u" && !Number.isNaN(x) && x !== h && (i.trigger("sortable:sort", {
                from: h,
                to: x
            }),
            e.emit("sortableSort", i[0], {
                from: h,
                to: x,
                el: i[0]
            }, l[0])),
            p = void 0,
            d = void 0,
            n = !1,
            a = !1
        }
        const A = Mt().passiveListener ? {
            passive: !1,
            capture: !1
        } : !1;
        $(t).on(e.touchEvents.start, ".list.sortable .sortable-handler", E, A),
        e.on("touchmove:active", z),
        e.on("touchend:passive", T),
        $(t).on("taphold", ".sortable-tap-hold", (x, M) => {
            E(M, !0)
        }
        )
    },
    enable(e) {
        e === void 0 && (e = ".list.sortable");
        const t = this
          , n = $(e);
        n.length !== 0 && (n.addClass("sortable-enabled"),
        n.trigger("sortable:enable"),
        t.emit("sortableEnable", n[0]))
    },
    disable(e) {
        e === void 0 && (e = ".list.sortable");
        const t = this
          , n = $(e);
        n.length !== 0 && (n.removeClass("sortable-enabled"),
        n.trigger("sortable:disable"),
        t.emit("sortableDisable", n[0]))
    },
    toggle(e) {
        e === void 0 && (e = ".list.sortable");
        const t = this
          , n = $(e);
        n.length !== 0 && (n.hasClass("sortable-enabled") ? t.sortable.disable(n) : t.sortable.enable(n))
    }
}
  , LF = {
    name: "sortable",
    params: {
        sortable: {
            moveElements: !0
        }
    },
    create() {
        hn(this, {
            sortable: PF
        })
    },
    on: {
        init() {
            const e = this;
            e.params.sortable && e.sortable.init()
        }
    },
    clicks: {
        ".sortable-enable": function(t, n) {
            n === void 0 && (n = {}),
            this.sortable.enable(n.sortable)
        },
        ".sortable-disable": function(t, n) {
            n === void 0 && (n = {}),
            this.sortable.disable(n.sortable)
        },
        ".sortable-toggle": function(t, n) {
            n === void 0 && (n = {}),
            this.sortable.toggle(n.sortable)
        }
    }
}
  , Xn = {
    init() {
        const e = this
          , t = Qe()
          , n = {};
        let a, r, o, i, s, l, c, u, f, d, p, h, m, g, b, v, y, w, C, _, E;
        function z(M) {
            e.swipeout.allow && (r = !1,
            a = !0,
            o = void 0,
            n.x = M.type === "touchstart" ? M.targetTouches[0].pageX : M.pageX,
            n.y = M.type === "touchstart" ? M.targetTouches[0].pageY : M.pageY,
            i = new Date().getTime(),
            l = $(this))
        }
        function T(M) {
            if (!a)
                return;
            const L = M.type === "touchmove" ? M.targetTouches[0].pageX : M.pageX
              , U = M.type === "touchmove" ? M.targetTouches[0].pageY : M.pageY;
            if (typeof o > "u" && (o = !!(o || Math.abs(U - n.y) > Math.abs(L - n.x))),
            o) {
                a = !1;
                return
            }
            if (!r) {
                if ($(".list.sortable-opened").length > 0)
                    return;
                c = l.find(".swipeout-content"),
                u = l.find(".swipeout-actions-right"),
                f = l.find(".swipeout-actions-left"),
                d = null,
                p = null,
                b = null,
                v = null,
                C = null,
                w = null,
                f.length > 0 && (d = f.outerWidth(),
                b = f.children("a"),
                w = f.find(".swipeout-overswipe")),
                u.length > 0 && (p = u.outerWidth(),
                v = u.children("a"),
                C = u.find(".swipeout-overswipe")),
                m = l.hasClass("swipeout-opened"),
                m && (g = l.find(".swipeout-actions-left.swipeout-actions-opened").length > 0 ? "left" : "right"),
                l.removeClass("swipeout-transitioning"),
                e.params.swipeout.noFollow || (l.find(".swipeout-actions-opened").removeClass("swipeout-actions-opened"),
                l.removeClass("swipeout-opened"))
            }
            if (r = !0,
            M.cancelable && M.preventDefault(),
            s = L - n.x,
            h = s,
            m && (g === "right" ? h -= p : h += d),
            h > 0 && f.length === 0 || h < 0 && u.length === 0) {
                if (!m) {
                    a = !1,
                    r = !1,
                    c.transform(""),
                    v && v.length > 0 && v.transform(""),
                    b && b.length > 0 && b.transform("");
                    return
                }
                h = 0
            }
            h < 0 ? y = "to-left" : h > 0 ? y = "to-right" : y || (y = "to-left");
            let Y, H;
            if (M.f7PreventSwipePanel = !0,
            e.params.swipeout.noFollow) {
                m ? (g === "right" && s > 0 && e.swipeout.close(l),
                g === "left" && s < 0 && e.swipeout.close(l)) : (s < 0 && u.length > 0 && e.swipeout.open(l, "right"),
                s > 0 && f.length > 0 && e.swipeout.open(l, "left")),
                a = !1,
                r = !1;
                return
            }
            if (_ = !1,
            E = !1,
            u.length > 0) {
                let W = h;
                if (H = W / p,
                W < -p) {
                    const j = W / -p;
                    W = -p - (-W - p) ** .8,
                    h = W,
                    C.length > 0 && j > e.params.swipeout.overswipeRatio && (E = !0)
                }
                y !== "to-left" && (H = 0,
                W = 0),
                v.each(j => {
                    const Q = $(j);
                    typeof j.f7SwipeoutButtonOffset > "u" && (Q[0].f7SwipeoutButtonOffset = j.offsetLeft),
                    Y = j.f7SwipeoutButtonOffset,
                    C.length > 0 && Q.hasClass("swipeout-overswipe") && y === "to-left" && (Q.css({
                        left: `${E ? -Y : 0}px`
                    }),
                    E ? (Q.hasClass("swipeout-overswipe-active") || (l.trigger("swipeout:overswipeenter"),
                    e.emit("swipeoutOverswipeEnter", l[0])),
                    Q.addClass("swipeout-overswipe-active")) : (Q.hasClass("swipeout-overswipe-active") && (l.trigger("swipeout:overswipeexit"),
                    e.emit("swipeoutOverswipeExit", l[0])),
                    Q.removeClass("swipeout-overswipe-active"))),
                    Q.transform(`translate3d(${W - Y * (1 + Math.max(H, -1))}px,0,0)`)
                }
                )
            }
            if (f.length > 0) {
                let W = h;
                if (H = W / d,
                W > d) {
                    const j = W / p;
                    W = d + (W - d) ** .8,
                    h = W,
                    w.length > 0 && j > e.params.swipeout.overswipeRatio && (_ = !0)
                }
                y !== "to-right" && (W = 0,
                H = 0),
                b.each( (j, Q) => {
                    const ne = $(j);
                    typeof j.f7SwipeoutButtonOffset > "u" && (ne[0].f7SwipeoutButtonOffset = d - j.offsetLeft - j.offsetWidth),
                    Y = j.f7SwipeoutButtonOffset,
                    w.length > 0 && ne.hasClass("swipeout-overswipe") && y === "to-right" && (ne.css({
                        left: `${_ ? Y : 0}px`
                    }),
                    _ ? (ne.hasClass("swipeout-overswipe-active") || (l.trigger("swipeout:overswipeenter"),
                    e.emit("swipeoutOverswipeEnter", l[0])),
                    ne.addClass("swipeout-overswipe-active")) : (ne.hasClass("swipeout-overswipe-active") && (l.trigger("swipeout:overswipeexit"),
                    e.emit("swipeoutOverswipeExit", l[0])),
                    ne.removeClass("swipeout-overswipe-active"))),
                    b.length > 1 && ne.css("z-index", b.length - Q),
                    ne.transform(`translate3d(${W + Y * (1 - Math.min(H, 1))}px,0,0)`)
                }
                )
            }
            l.trigger("swipeout", H),
            e.emit("swipeout", l[0], H),
            c.transform(`translate3d(${h}px,0,0)`)
        }
        function A() {
            if (!a || !r) {
                a = !1,
                r = !1;
                return
            }
            a = !1,
            r = !1;
            const M = new Date().getTime() - i
              , L = y === "to-left" ? u : f
              , U = y === "to-left" ? p : d;
            let Y, H, W;
            if (M < 300 && (s < -10 && y === "to-left" || s > 10 && y === "to-right") || M >= 300 && Math.abs(h) > U / 2 ? Y = "open" : Y = "close",
            M < 300 && (Math.abs(h) === 0 && (Y = "close"),
            Math.abs(h) === U && (Y = "open")),
            Y === "open") {
                Xn.el = l[0],
                l.trigger("swipeout:open"),
                e.emit("swipeoutOpen", l[0]),
                l.addClass("swipeout-opened swipeout-transitioning");
                const Q = y === "to-left" ? -U : U;
                if (c.transform(`translate3d(${Q}px,0,0)`),
                L.addClass("swipeout-actions-opened"),
                H = y === "to-left" ? v : b,
                H)
                    for (W = 0; W < H.length; W += 1)
                        $(H[W]).transform(`translate3d(${Q}px,0,0)`);
                E && u.find(".swipeout-overswipe").trigger("click", "f7Overswipe"),
                _ && f.find(".swipeout-overswipe").trigger("click", "f7Overswipe")
            } else
                l.trigger("swipeout:close"),
                e.emit("swipeoutClose", l[0]),
                Xn.el = void 0,
                l.addClass("swipeout-transitioning").removeClass("swipeout-opened"),
                c.transform(""),
                L.removeClass("swipeout-actions-opened");
            let j;
            b && b.length > 0 && b !== H && b.each(Q => {
                const ne = $(Q);
                j = Q.f7SwipeoutButtonOffset,
                typeof j > "u" && (ne[0].f7SwipeoutButtonOffset = d - Q.offsetLeft - Q.offsetWidth),
                ne.transform(`translate3d(${j}px,0,0)`)
            }
            ),
            v && v.length > 0 && v !== H && v.each(Q => {
                const ne = $(Q);
                j = Q.f7SwipeoutButtonOffset,
                typeof j > "u" && (ne[0].f7SwipeoutButtonOffset = Q.offsetLeft),
                ne.transform(`translate3d(${-j}px,0,0)`)
            }
            ),
            c.transitionEnd( () => {
                m && Y === "open" || !m && Y === "close" || (l.trigger(Y === "open" ? "swipeout:opened" : "swipeout:closed"),
                e.emit(Y === "open" ? "swipeoutOpened" : "swipeoutClosed", l[0]),
                l.removeClass("swipeout-transitioning"),
                m && Y === "close" && (u.length > 0 && v.transform(""),
                f.length > 0 && b.transform("")))
            }
            )
        }
        const x = Mt().passiveListener ? {
            passive: !0
        } : !1;
        e.on("touchstart", M => {
            if (Xn.el) {
                const L = $(M.target);
                $(Xn.el).is(L[0]) || L.parents(".swipeout").is(Xn.el) || L.hasClass("modal-in") || (L.attr("class") || "").indexOf("-backdrop") > 0 || L.hasClass("actions-modal") || L.parents(".actions-modal.modal-in, .dialog.modal-in").length > 0 || e.swipeout.close(Xn.el)
            }
        }
        ),
        $(t).on(e.touchEvents.start, "li.swipeout", z, x),
        e.on("touchmove:active", T),
        e.on("touchend:passive", A)
    },
    allow: !0,
    el: void 0,
    open() {
        const e = this;
        for (var t = arguments.length, n = new Array(t), a = 0; a < t; a++)
            n[a] = arguments[a];
        let[r,o,i] = n;
        typeof n[1] == "function" && ([r,i,o] = n);
        const s = $(r).eq(0);
        if (s.length === 0 || !s.hasClass("swipeout") || s.hasClass("swipeout-opened"))
            return;
        o || (s.find(".swipeout-actions-right").length > 0 ? o = "right" : o = "left");
        const l = s.find(`.swipeout-actions-${o}`)
          , c = s.find(".swipeout-content");
        if (l.length === 0)
            return;
        s.trigger("swipeout:open").addClass("swipeout-opened").removeClass("swipeout-transitioning"),
        e.emit("swipeoutOpen", s[0]),
        l.addClass("swipeout-actions-opened");
        const u = l.children("a")
          , f = l.outerWidth()
          , d = o === "right" ? -f : f;
        u.length > 1 && u.each( (p, h) => {
            const m = $(p);
            o === "right" ? m.transform(`translate3d(${-p.offsetLeft}px,0,0)`) : m.css("z-index", u.length - h).transform(`translate3d(${f - p.offsetWidth - p.offsetLeft}px,0,0)`)
        }
        ),
        s.addClass("swipeout-transitioning"),
        c.transitionEnd( () => {
            s.trigger("swipeout:opened"),
            e.emit("swipeoutOpened", s[0]),
            i && i.call(s[0])
        }
        ),
        xn( () => {
            u.transform(`translate3d(${d}px,0,0)`),
            c.transform(`translate3d(${d}px,0,0)`)
        }
        ),
        Xn.el = s[0]
    },
    close(e, t) {
        const n = this
          , a = $(e).eq(0);
        if (a.length === 0 || !a.hasClass("swipeout-opened"))
            return;
        const r = a.find(".swipeout-actions-opened").hasClass("swipeout-actions-right") ? "right" : "left"
          , o = a.find(".swipeout-actions-opened").removeClass("swipeout-actions-opened")
          , i = o.children("a")
          , s = o.outerWidth();
        n.swipeout.allow = !1,
        a.trigger("swipeout:close"),
        n.emit("swipeoutClose", a[0]),
        a.removeClass("swipeout-opened").addClass("swipeout-transitioning");
        let l;
        function c() {
            n.swipeout.allow = !0,
            !a.hasClass("swipeout-opened") && (a.removeClass("swipeout-transitioning"),
            i.transform(""),
            a.trigger("swipeout:closed"),
            n.emit("swipeoutClosed", a[0]),
            t && t.call(a[0]),
            l && clearTimeout(l))
        }
        a.find(".swipeout-content").transform("").transitionEnd(c),
        l = setTimeout(c, 500),
        i.each(u => {
            const f = $(u);
            r === "right" ? f.transform(`translate3d(${-u.offsetLeft}px,0,0)`) : f.transform(`translate3d(${s - u.offsetWidth - u.offsetLeft}px,0,0)`),
            f.css({
                left: "0px"
            }).removeClass("swipeout-overswipe-active")
        }
        ),
        Xn.el && Xn.el === a[0] && (Xn.el = void 0)
    },
    delete(e, t) {
        const n = this
          , a = $(e).eq(0);
        a.length !== 0 && (Xn.el = void 0,
        a.trigger("swipeout:delete"),
        n.emit("swipeoutDelete", a[0]),
        a.css({
            height: `${a.outerHeight()}px`
        }),
        a.transitionEnd( () => {
            if (a.trigger("swipeout:deleted"),
            n.emit("swipeoutDeleted", a[0]),
            t && t.call(a[0]),
            a.parents(".virtual-list").length > 0) {
                const r = a.parents(".virtual-list")[0].f7VirtualList
                  , o = a[0].f7VirtualListIndex;
                r && typeof o < "u" && r.deleteItem(o)
            } else
                n.params.swipeout.removeElements ? n.params.swipeout.removeElementsWithTimeout ? setTimeout( () => {
                    a.remove()
                }
                , n.params.swipeout.removeElementsTimeout) : a.remove() : a.removeClass("swipeout-deleting swipeout-transitioning")
        }
        ),
        xn( () => {
            a.addClass("swipeout-deleting swipeout-transitioning").css({
                height: "0px"
            }).find(".swipeout-content").transform("translate3d(-100%,0,0)")
        }
        ))
    }
}
  , IF = {
    name: "swipeout",
    params: {
        swipeout: {
            actionsNoFold: !1,
            noFollow: !1,
            removeElements: !0,
            removeElementsWithTimeout: !1,
            removeElementsTimeout: 0,
            overswipeRatio: 1.2
        }
    },
    create() {
        hn(this, {
            swipeout: Xn
        })
    },
    clicks: {
        ".swipeout-open": function(t, n) {
            n === void 0 && (n = {}),
            this.swipeout.open(n.swipeout, n.side)
        },
        ".swipeout-close": function(t) {
            const n = this
              , a = t.closest(".swipeout");
            a.length !== 0 && n.swipeout.close(a)
        },
        ".swipeout-delete": function(t, n) {
            n === void 0 && (n = {});
            const a = this
              , r = t.closest(".swipeout");
            if (r.length === 0)
                return;
            const {confirm: o, confirmTitle: i} = n;
            n.confirm ? a.dialog.confirm(o, i, () => {
                a.swipeout.delete(r)
            }
            ) : a.swipeout.delete(r)
        }
    },
    on: {
        init() {
            const e = this;
            e.params.swipeout && e.swipeout.init()
        }
    }
}
  , Lp = {
    toggleClicked(e) {
        const t = this;
        let n = e.closest(".accordion-item").eq(0);
        n.length || (n = e.parents("li").eq(0));
        const a = e.parents(".accordion-item-content").eq(0);
        a.length && a.parents(n).length || e.parents("li").length > 1 && e.parents("li")[0] !== n[0] || t.accordion.toggle(n)
    },
    open(e) {
        const t = this
          , n = $(e);
        let a = !1;
        function r() {
            a = !0
        }
        if (n.trigger("accordion:beforeopen", {
            prevent: r
        }, r),
        t.emit("accordionBeforeOpen", n[0], r),
        a)
            return;
        const o = n.parents(".accordion-list").eq(0);
        let i = n.children(".accordion-item-content");
        if (i.removeAttr("aria-hidden"),
        i.length === 0 && (i = n.find(".accordion-item-content")),
        i.length === 0)
            return;
        const s = o.length > 0 && n.parent().children(".accordion-item-opened");
        s.length > 0 && t.accordion.close(s),
        i.transitionEnd( () => {
            n.hasClass("accordion-item-opened") ? (i.transition(0),
            i.css("height", "auto"),
            xn( () => {
                i.transition(""),
                n.trigger("accordion:opened"),
                t.emit("accordionOpened", n[0])
            }
            )) : (i.css("height", ""),
            n.trigger("accordion:closed"),
            t.emit("accordionClosed", n[0]))
        }
        ),
        i.css("height", `${i[0].scrollHeight}px`),
        n.trigger("accordion:open"),
        n.addClass("accordion-item-opened"),
        t.emit("accordionOpen", n[0])
    },
    close(e) {
        const t = this
          , n = $(e);
        let a = !1;
        function r() {
            a = !0
        }
        if (n.trigger("accordion:beforeclose", {
            prevent: r
        }, r),
        t.emit("accordionBeforeClose", n[0], r),
        a)
            return;
        let o = n.children(".accordion-item-content");
        o.length === 0 && (o = n.find(".accordion-item-content")),
        n.removeClass("accordion-item-opened"),
        o.attr("aria-hidden", !0),
        o.transition(0),
        o.css("height", `${o[0].scrollHeight}px`),
        o.transitionEnd( () => {
            n.hasClass("accordion-item-opened") ? (o.transition(0),
            o.css("height", "auto"),
            xn( () => {
                o.transition(""),
                n.trigger("accordion:opened"),
                t.emit("accordionOpened", n[0])
            }
            )) : (o.css("height", ""),
            n.trigger("accordion:closed"),
            t.emit("accordionClosed", n[0]))
        }
        ),
        xn( () => {
            o.transition(""),
            o.css("height", ""),
            n.trigger("accordion:close"),
            t.emit("accordionClose", n[0])
        }
        )
    },
    toggle(e) {
        const t = this
          , n = $(e);
        n.length !== 0 && (n.hasClass("accordion-item-opened") ? t.accordion.close(e) : t.accordion.open(e))
    }
}
  , BF = {
    name: "accordion",
    create() {
        hn(this, {
            accordion: Lp
        })
    },
    clicks: {
        ".accordion-item .item-link, .accordion-item-toggle, .links-list.accordion-list > ul > li > a": function(t) {
            const n = this;
            Lp.toggleClicked.call(n, t)
        }
    }
}
  , RF = {
    name: "contactsList"
};
let Ip = class extends Bt {
    constructor(t, n) {
        n === void 0 && (n = {}),
        super(n, [t]);
        const a = this
          , r = yt()
          , o = Qe();
        let i;
        t.theme === "md" ? i = 48 : t.theme === "ios" ? i = 44 : t.theme === "aurora" && (i = 38);
        const s = {
            cols: 1,
            height: i,
            cache: !0,
            dynamicHeightBufferSize: 1,
            showFilteredItemsOnly: !1,
            renderExternal: void 0,
            setListHeight: !0,
            searchByItem: void 0,
            searchAll: void 0,
            ul: null,
            createUl: !0,
            scrollableParentEl: void 0,
            renderItem(g) {
                return `
          <li>
            <div class="item-content">
              <div class="item-inner">
                <div class="item-title">${g}</div>
              </div>
            </div>
          </li>
        `.trim()
            },
            on: {}
        };
        if (a.useModulesParams(s),
        a.params = se(s, n),
        (a.params.height === void 0 || !a.params.height) && (a.params.height = i),
        a.$el = $(n.el),
        a.el = a.$el[0],
        a.$el.length === 0)
            return;
        a.$el[0].f7VirtualList = a,
        a.items = a.params.items,
        a.params.showFilteredItemsOnly && (a.filteredItems = []),
        a.params.renderItem && (a.renderItem = a.params.renderItem),
        a.$pageContentEl = a.$el.parents(".page-content"),
        a.pageContentEl = a.$pageContentEl[0],
        a.$scrollableParentEl = a.params.scrollableParentEl ? $(a.params.scrollableParentEl).eq(0) : a.$pageContentEl,
        !a.$scrollableParentEl.length && a.$pageContentEl.length && (a.$scrollableParentEl = a.$pageContentEl),
        a.scrollableParentEl = a.$scrollableParentEl[0],
        typeof a.params.updatableScroll < "u" ? a.updatableScroll = a.params.updatableScroll : (a.updatableScroll = !0,
        r.ios && r.osVersion.split(".")[0] < 8 && (a.updatableScroll = !1));
        const l = a.params.ul;
        a.$ul = l ? $(a.params.ul) : a.$el.children("ul"),
        a.$ul.length === 0 && a.params.createUl && (a.$el.append("<ul></ul>"),
        a.$ul = a.$el.children("ul")),
        a.ul = a.$ul[0];
        let c;
        !a.ul && !a.params.createUl ? c = a.$el : c = a.$ul,
        se(a, {
            $itemsWrapEl: c,
            itemsWrapEl: c[0],
            domCache: {},
            displayDomCache: {},
            tempDomElement: o.createElement("ul"),
            lastRepaintY: null,
            fragment: o.createDocumentFragment(),
            pageHeight: void 0,
            rowsPerScreen: void 0,
            rowsBefore: void 0,
            rowsAfter: void 0,
            rowsToRender: void 0,
            maxBufferHeight: 0,
            listHeight: void 0,
            dynamicHeight: typeof a.params.height == "function",
            autoHeight: a.params.height === "auto"
        }),
        a.useModules();
        const u = a.handleScroll.bind(a)
          , f = a.handleResize.bind(a);
        let d, p, h, m;
        return a.attachEvents = function() {
            d = a.$el.parents(".page").eq(0),
            p = a.$el.parents(".tab").filter(b => $(b).parent(".tabs").parent(".tabs-animated-wrap, .tabs-swipeable-wrap").length === 0).eq(0),
            h = a.$el.parents(".panel").eq(0),
            m = a.$el.parents(".popup").eq(0),
            a.$scrollableParentEl.on("scroll", u),
            d.length && d.on("page:reinit", f),
            p.length && p.on("tab:show", f),
            h.length && h.on("panel:open", f),
            m.length && m.on("popup:open", f),
            t.on("resize", f)
        }
        ,
        a.detachEvents = function() {
            a.$scrollableParentEl.off("scroll", u),
            d.length && d.off("page:reinit", f),
            p.length && p.off("tab:show", f),
            h.length && h.off("panel:open", f),
            m.length && m.off("popup:open", f),
            t.off("resize", f)
        }
        ,
        a.init(),
        a
    }
    setListSize(t) {
        const n = this
          , a = n.filteredItems || n.items;
        if (t || (n.pageHeight = n.$scrollableParentEl[0].offsetHeight),
        n.dynamicHeight) {
            n.listHeight = 0,
            n.heights = [];
            for (let r = 0; r < a.length; r += 1) {
                const o = n.params.height(a[r]);
                n.listHeight += o,
                n.heights.push(o)
            }
        } else if (n.autoHeight) {
            n.listHeight = 0,
            n.heights || (n.heights = []),
            n.heightsCalculated || (n.heightsCalculated = []);
            const r = {};
            n.$itemsWrapEl.find("[data-virtual-list-index]").forEach(o => {
                r[parseInt(o.getAttribute("data-virtual-list-index"), 10)] = o
            }
            );
            for (let o = 0; o < a.length; o += 1) {
                const i = r[o];
                i && (n.heightsCalculated.includes(o) || (n.heights[o] = i.offsetHeight,
                n.heightsCalculated.push(o))),
                typeof n.heights[o] > "u" && (n.heights[o] = 40),
                n.listHeight += n.heights[o]
            }
        } else
            n.listHeight = Math.ceil(a.length / n.params.cols) * n.params.height,
            n.rowsPerScreen = Math.ceil(n.pageHeight / n.params.height),
            n.rowsBefore = n.params.rowsBefore || n.rowsPerScreen * 2,
            n.rowsAfter = n.params.rowsAfter || n.rowsPerScreen,
            n.rowsToRender = n.rowsPerScreen + n.rowsBefore + n.rowsAfter,
            n.maxBufferHeight = n.rowsBefore / 2 * n.params.height;
        (n.updatableScroll || n.params.setListHeight) && n.$itemsWrapEl.css({
            height: `${n.listHeight}px`
        })
    }
    render(t, n) {
        const a = this;
        t && (a.lastRepaintY = null);
        let r = -(a.$el[0].getBoundingClientRect().top - a.$scrollableParentEl[0].getBoundingClientRect().top);
        if (typeof n < "u" && (r = n),
        a.lastRepaintY === null || Math.abs(r - a.lastRepaintY) > a.maxBufferHeight || !a.updatableScroll && a.$scrollableParentEl[0].scrollTop + a.pageHeight >= a.$scrollableParentEl[0].scrollHeight)
            a.lastRepaintY = r;
        else
            return;
        const o = a.filteredItems || a.items;
        let i, s, l = 0, c = 0;
        if (a.dynamicHeight || a.autoHeight) {
            let p = 0, h;
            a.maxBufferHeight = a.pageHeight;
            for (let m = 0; m < a.heights.length; m += 1)
                h = a.heights[m],
                typeof i > "u" && (p + h >= r - a.pageHeight * 2 * a.params.dynamicHeightBufferSize ? i = m : l += h),
                typeof s > "u" && ((p + h >= r + a.pageHeight * 2 * a.params.dynamicHeightBufferSize || m === a.heights.length - 1) && (s = m + 1),
                c += h),
                p += h;
            s = Math.min(s, o.length)
        } else
            i = (parseInt(r / a.params.height, 10) - a.rowsBefore) * a.params.cols,
            i < 0 && (i = 0),
            s = Math.min(i + a.rowsToRender * a.params.cols, o.length);
        let u;
        const f = [];
        a.reachEnd = !1;
        let d;
        for (d = i; d < s; d += 1) {
            let p;
            const h = a.items.indexOf(o[d]);
            d === i && (a.currentFromIndex = h),
            d === s - 1 && (a.currentToIndex = h),
            a.filteredItems ? a.items[h] === a.filteredItems[a.filteredItems.length - 1] && (a.reachEnd = !0) : h === a.items.length - 1 && (a.reachEnd = !0),
            a.params.renderExternal ? f.push(o[d]) : a.domCache[h] ? (p = a.domCache[h],
            p.f7VirtualListIndex = h) : (a.renderItem ? a.tempDomElement.innerHTML = a.renderItem(o[d], h).trim() : a.tempDomElement.innerHTML = o[d].toString().trim(),
            p = a.tempDomElement.childNodes[0],
            a.params.cache && (a.domCache[h] = p),
            p.f7VirtualListIndex = h),
            d === i && (a.dynamicHeight || a.autoHeight ? u = l : u = d * a.params.height / a.params.cols),
            a.params.renderExternal || (p.style.top = `${u}px`,
            a.emit("local::itemBeforeInsert vlItemBeforeInsert", a, p, o[d]),
            a.fragment.appendChild(p))
        }
        a.updatableScroll || (a.dynamicHeight || a.autoHeight ? a.itemsWrapEl.style.height = `${c}px` : a.itemsWrapEl.style.height = `${d * a.params.height / a.params.cols}px`),
        a.params.renderExternal ? o && o.length === 0 && (a.reachEnd = !0) : (a.emit("local::beforeClear vlBeforeClear", a, a.fragment),
        a.itemsWrapEl.innerHTML = "",
        a.emit("local::itemsBeforeInsert vlItemsBeforeInsert", a, a.fragment),
        o && o.length === 0 ? (a.reachEnd = !0,
        a.params.emptyTemplate && (a.itemsWrapEl.innerHTML = a.params.emptyTemplate)) : a.itemsWrapEl.appendChild(a.fragment),
        a.emit("local::itemsAfterInsert vlItemsAfterInsert", a, a.fragment)),
        typeof n < "u" && t && a.$scrollableParentEl.scrollTop(n, 0),
        a.params.renderExternal && a.params.renderExternal(a, {
            fromIndex: i,
            toIndex: s,
            listHeight: a.listHeight,
            topPosition: u,
            items: f
        }),
        a.autoHeight && requestAnimationFrame( () => {
            a.setListSize(!0)
        }
        )
    }
    filterItems(t, n) {
        n === void 0 && (n = !0);
        const a = this;
        a.filteredItems = [];
        for (let r = 0; r < t.length; r += 1)
            a.filteredItems.push(a.items[t[r]]);
        n && (a.$scrollableParentEl[0].scrollTop = 0),
        a.update()
    }
    resetFilter() {
        const t = this;
        t.params.showFilteredItemsOnly ? t.filteredItems = [] : (t.filteredItems = null,
        delete t.filteredItems),
        t.update()
    }
    scrollToItem(t) {
        const n = this;
        if (t > n.items.length)
            return !1;
        let a = 0;
        if (n.dynamicHeight || n.autoHeight)
            for (let o = 0; o < t; o += 1)
                a += n.heights[o];
        else
            a = t * n.params.height;
        const r = n.$el[0].offsetTop;
        return n.render(!0, r + a - parseInt(n.$scrollableParentEl.css("padding-top"), 10)),
        !0
    }
    handleScroll() {
        this.render()
    }
    isVisible() {
        const t = this;
        return !!(t.el.offsetWidth || t.el.offsetHeight || t.el.getClientRects().length)
    }
    handleResize() {
        const t = this;
        t.isVisible() && (t.heightsCalculated = [],
        t.setListSize(),
        t.render(!0))
    }
    appendItems(t) {
        const n = this;
        for (let a = 0; a < t.length; a += 1)
            n.items.push(t[a]);
        n.update()
    }
    appendItem(t) {
        this.appendItems([t])
    }
    replaceAllItems(t) {
        const n = this;
        n.items = t,
        delete n.filteredItems,
        n.domCache = {},
        n.update()
    }
    replaceItem(t, n) {
        const a = this;
        a.items[t] = n,
        a.params.cache && delete a.domCache[t],
        a.update()
    }
    prependItems(t) {
        const n = this;
        for (let a = t.length - 1; a >= 0; a -= 1)
            n.items.unshift(t[a]);
        if (n.params.cache) {
            const a = {};
            Object.keys(n.domCache).forEach(r => {
                a[parseInt(r, 10) + t.length] = n.domCache[r]
            }
            ),
            n.domCache = a
        }
        n.update()
    }
    prependItem(t) {
        this.prependItems([t])
    }
    moveItem(t, n) {
        const a = this
          , r = t;
        let o = n;
        if (r === o)
            return;
        const i = a.items.splice(r, 1)[0];
        if (o >= a.items.length ? (a.items.push(i),
        o = a.items.length - 1) : a.items.splice(o, 0, i),
        a.params.cache) {
            const s = {};
            Object.keys(a.domCache).forEach(l => {
                const c = parseInt(l, 10)
                  , u = r < o ? r : o
                  , f = r < o ? o : r
                  , d = r < o ? -1 : 1;
                (c < u || c > f) && (s[c] = a.domCache[c]),
                c === u && (s[f] = a.domCache[c]),
                c > u && c <= f && (s[c + d] = a.domCache[c])
            }
            ),
            a.domCache = s
        }
        a.update()
    }
    insertItemBefore(t, n) {
        const a = this;
        if (t === 0) {
            a.prependItem(n);
            return
        }
        if (t >= a.items.length) {
            a.appendItem(n);
            return
        }
        if (a.items.splice(t, 0, n),
        a.params.cache) {
            const r = {};
            Object.keys(a.domCache).forEach(o => {
                const i = parseInt(o, 10);
                i >= t && (r[i + 1] = a.domCache[i])
            }
            ),
            a.domCache = r
        }
        a.update()
    }
    deleteItems(t) {
        const n = this;
        let a, r = 0;
        for (let o = 0; o < t.length; o += 1) {
            let i = t[o];
            typeof a < "u" && i > a && (r = -o),
            i += r,
            a = t[o];
            const s = n.items.splice(i, 1)[0];
            if (n.filteredItems && n.filteredItems.indexOf(s) >= 0 && n.filteredItems.splice(n.filteredItems.indexOf(s), 1),
            n.params.cache) {
                const l = {};
                Object.keys(n.domCache).forEach(c => {
                    const u = parseInt(c, 10);
                    u === i ? delete n.domCache[i] : parseInt(c, 10) > i ? l[u - 1] = n.domCache[c] : l[u] = n.domCache[c]
                }
                ),
                n.domCache = l
            }
        }
        n.update()
    }
    deleteAllItems() {
        const t = this;
        t.items = [],
        delete t.filteredItems,
        t.params.cache && (t.domCache = {}),
        t.update()
    }
    deleteItem(t) {
        this.deleteItems([t])
    }
    clearCache() {
        const t = this;
        t.domCache = {}
    }
    update(t) {
        const n = this;
        t && n.params.cache && (n.domCache = {}),
        n.heightsCalculated = [],
        n.setListSize(),
        n.render(!0)
    }
    init() {
        const t = this;
        t.attachEvents(),
        t.setListSize(),
        t.render()
    }
    destroy() {
        let t = this;
        t.detachEvents(),
        t.$el[0].f7VirtualList = null,
        delete t.$el[0].f7VirtualList,
        Yt(t),
        t = null
    }
}
;
const DF = {
    name: "virtualList",
    static: {
        VirtualList: Ip
    },
    create() {
        const e = this;
        e.virtualList = Gt({
            defaultSelector: ".virtual-list",
            constructor: Ip,
            app: e,
            domProp: "f7VirtualList"
        })
    }
};
let Bp = class extends Bt {
    constructor(t, n) {
        n === void 0 && (n = {}),
        super(n, [t]);
        const a = this
          , r = {
            el: null,
            listEl: null,
            indexes: "auto",
            iosItemHeight: 14,
            mdItemHeight: 14,
            auroraItemHeight: 14,
            scrollList: !0,
            label: !1,
            renderItem(_, E) {
                return `
          <li>${_}</li>
        `.trim()
            },
            renderSkipPlaceholder() {
                return '<li class="list-index-skip-placeholder"></li>'
            },
            on: {}
        };
        a.useModulesParams(r),
        a.params = se(r, n);
        let o, i, s, l;
        if (a.params.el)
            o = $(a.params.el);
        else
            return a;
        if (o[0].f7ListIndex)
            return o[0].f7ListIndex;
        if (l = o.find("ul"),
        l.length === 0 && (l = $("<ul></ul>"),
        o.append(l)),
        a.params.listEl && (i = $(a.params.listEl)),
        a.params.indexes === "auto" && !i)
            return a;
        i ? s = i.parents(".page-content").eq(0) : (s = o.siblings(".page-content").eq(0),
        s.length === 0 && (s = o.parents(".page").eq(0).find(".page-content").eq(0))),
        o[0].f7ListIndex = a,
        se(a, {
            app: t,
            $el: o,
            el: o && o[0],
            $ul: l,
            ul: l && l[0],
            $listEl: i,
            listEl: i && i[0],
            $pageContentEl: s,
            pageContentEl: s && s[0],
            indexes: n.indexes,
            height: 0,
            skipRate: 0
        }),
        a.useModules();
        function c() {
            const _ = {
                index: a
            };
            a.calcSize(),
            _ !== a.height && a.render()
        }
        function u(_) {
            const E = $(_.target).closest("li");
            if (!E.length)
                return;
            let z = E.index();
            if (a.skipRate > 0) {
                const A = z / (E.siblings("li").length - 1);
                z = Math.round((a.indexes.length - 1) * A)
            }
            const T = a.indexes[z];
            a.$el.trigger("listindex:click", {
                content: T,
                index: z
            }),
            a.emit("local::click listIndexClick", a, T, z),
            a.$el.trigger("listindex:select", {
                content: T,
                index: z
            }),
            a.emit("local::select listIndexSelect", a, T, z),
            a.$listEl && a.params.scrollList && a.scrollListToIndex(T, z)
        }
        const f = {};
        let d, p, h, m, g, b = null;
        function v(_) {
            const E = l.children();
            E.length && (h = E[0].getBoundingClientRect().top,
            m = E[E.length - 1].getBoundingClientRect().top + E[0].offsetHeight,
            f.x = _.type === "touchstart" ? _.targetTouches[0].pageX : _.pageX,
            f.y = _.type === "touchstart" ? _.targetTouches[0].pageY : _.pageY,
            d = !0,
            p = !1,
            b = null)
        }
        function y(_) {
            if (!d)
                return;
            !p && a.params.label && (g = $('<span class="list-index-label"></span>'),
            o.append(g)),
            p = !0;
            const E = _.type === "touchmove" ? _.targetTouches[0].pageY : _.pageY;
            _.preventDefault();
            let z = (E - h) / (m - h);
            z = Math.min(Math.max(z, 0), 1);
            const T = Math.round((a.indexes.length - 1) * z)
              , A = a.indexes[T]
              , x = m - h
              , M = (a.height - x) / 2 + (1 - z) * x;
            T !== b && (a.params.label && g.html(A).transform(`translateY(-${M}px)`),
            a.$listEl && a.params.scrollList && a.scrollListToIndex(A, T)),
            b = T,
            a.$el.trigger("listindex:select"),
            a.emit("local::select listIndexSelect", a, A, T)
        }
        function w() {
            d && (d = !1,
            p = !1,
            a.params.label && (g && g.remove(),
            g = void 0))
        }
        const C = Mt().passiveListener ? {
            passive: !0
        } : !1;
        return a.attachEvents = function() {
            o.parents(".tab").on("tab:show", c),
            o.parents(".page").on("page:reinit", c),
            o.parents(".panel").on("panel:open", c),
            o.parents(".sheet-modal, .actions-modal, .popup, .popover, .login-screen, .dialog, .toast").on("modal:open", c),
            t.on("resize", c),
            o.on("click", u),
            o.on(t.touchEvents.start, v, C),
            t.on("touchmove:active", y),
            t.on("touchend:passive", w)
        }
        ,
        a.detachEvents = function() {
            o.parents(".tab").off("tab:show", c),
            o.parents(".page").off("page:reinit", c),
            o.parents(".panel").off("panel:open", c),
            o.parents(".sheet-modal, .actions-modal, .popup, .popover, .login-screen, .dialog, .toast").off("modal:open", c),
            t.off("resize", c),
            o.off("click", u),
            o.off(t.touchEvents.start, v, C),
            t.off("touchmove:active", y),
            t.off("touchend:passive", w)
        }
        ,
        a.init(),
        a
    }
    scrollListToIndex(t, n) {
        const a = this
          , {$listEl: r, $pageContentEl: o, app: i} = a;
        if (!r || !o || o.length === 0)
            return a;
        let s;
        if (r.find(".list-group-title, .item-divider").each(d => {
            if (s)
                return;
            const p = $(d);
            p.text() === t && (s = p)
        }
        ),
        !s || s.length === 0)
            return a;
        const l = s.parent().offset().top;
        let c = parseInt(o.css("padding-top"), 10);
        const u = o[0].scrollTop
          , f = s.offset().top;
        if (o.parents(".page-with-navbar-large").length) {
            const d = i.navbar.getElByPage(o.parents(".page-with-navbar-large").eq(0))
              , p = $(d).find(".title-large");
            p.length && (c -= p[0].offsetHeight || 0)
        }
        return l <= c ? o.scrollTop(l + u - c) : o.scrollTop(f + u - c),
        a
    }
    renderSkipPlaceholder() {
        const t = this;
        return t.params.renderSkipPlaceholder.call(t)
    }
    renderItem(t, n) {
        const a = this;
        return a.params.renderItem.call(a, t, n)
    }
    render() {
        const t = this
          , {$ul: n, indexes: a, skipRate: r} = t;
        let o;
        const i = a.map( (s, l) => {
            if (l % r !== 0 && r > 0)
                return o = !0,
                "";
            let c = t.renderItem(s, l);
            return o && (c = t.renderSkipPlaceholder() + c),
            o = !1,
            c
        }
        ).join("");
        return n.html(i),
        t
    }
    calcSize() {
        const t = this
          , {app: n, params: a, el: r, indexes: o} = t
          , i = r.offsetHeight
          , s = a[`${n.theme}ItemHeight`]
          , l = Math.floor(i / s)
          , c = o.length;
        let u = 0;
        return c > l && (u = Math.ceil((c * 2 - 1) / l)),
        t.height = i,
        t.skipRate = u,
        t
    }
    calcIndexes() {
        const t = this;
        return t.params.indexes === "auto" ? (t.indexes = [],
        t.$listEl.find(".list-group-title, .item-divider").each(n => {
            const a = $(n).text();
            t.indexes.indexOf(a) < 0 && t.indexes.push(a)
        }
        )) : t.indexes = t.params.indexes,
        t
    }
    update() {
        const t = this;
        return t.calcIndexes(),
        t.calcSize(),
        t.render(),
        t
    }
    init() {
        const t = this;
        t.calcIndexes(),
        t.calcSize(),
        t.render(),
        t.attachEvents()
    }
    destroy() {
        let t = this;
        t.$el.trigger("listindex:beforedestroy", t),
        t.emit("local::beforeDestroy listIndexBeforeDestroy"),
        t.detachEvents(),
        t.$el[0] && (t.$el[0].f7ListIndex = null,
        delete t.$el[0].f7ListIndex),
        Yt(t),
        t = null
    }
}
;
const NF = {
    name: "listIndex",
    static: {
        ListIndex: Bp
    },
    create() {
        const e = this;
        e.listIndex = Gt({
            defaultSelector: ".list-index",
            constructor: Bp,
            app: e,
            domProp: "f7ListIndex"
        })
    },
    on: {
        tabMounted(e) {
            const t = this;
            $(e).find(".list-index-init").each(n => {
                const a = se($(n).dataset(), {
                    el: n
                });
                t.listIndex.create(a)
            }
            )
        },
        tabBeforeRemove(e) {
            $(e).find(".list-index-init").each(t => {
                t.f7ListIndex && t.f7ListIndex.destroy()
            }
            )
        },
        pageInit(e) {
            const t = this;
            e.$el.find(".list-index-init").each(n => {
                const a = se($(n).dataset(), {
                    el: n
                });
                t.listIndex.create(a)
            }
            )
        },
        pageBeforeRemove(e) {
            e.$el.find(".list-index-init").each(t => {
                t.f7ListIndex && t.f7ListIndex.destroy()
            }
            )
        }
    },
    vnode: {
        "list-index-init": {
            insert(e) {
                const t = this
                  , n = e.elm
                  , a = se($(n).dataset(), {
                    el: n
                });
                t.listIndex.create(a)
            },
            destroy(e) {
                const t = e.elm;
                t.f7ListIndex && t.f7ListIndex.destroy()
            }
        }
    }
}
  , HF = {
    name: "timeline"
}
  , VF = {
    show() {
        const e = this;
        let t, n, a, r, o;
        for (var i = arguments.length, s = new Array(i), l = 0; l < i; l++)
            s[l] = arguments[l];
        s.length === 1 && s[0] && s[0].constructor === Object ? (t = s[0].tabEl,
        n = s[0].tabLinkEl,
        a = s[0].animate,
        r = s[0].tabRoute,
        o = s[0].animatedInit) : ([t,n,a,r] = s,
        typeof s[1] == "boolean" && ([t,a,n,r] = s,
        s.length > 2 && n.constructor === Object && ([t,a,r,n] = s))),
        typeof a > "u" && (a = !0);
        const c = $(t);
        if (r && c[0] && (c[0].f7TabRoute = r),
        !o && (c.length === 0 || c.hasClass("tab-active")))
            return {
                $newTabEl: c,
                newTabEl: c[0]
            };
        let u;
        n && (u = $(n));
        const f = c.parent(".tabs");
        if (f.length === 0)
            return {
                $newTabEl: c,
                newTabEl: c[0]
            };
        e.swipeout && (e.swipeout.allowOpen = !0);
        const d = [];
        function p(v) {
            d.push(v)
        }
        function h() {
            d.forEach(v => {
                v()
            }
            )
        }
        let m = !1;
        if (f.parent().hasClass("tabs-animated-wrap")) {
            f.parent()[a ? "removeClass" : "addClass"]("not-animated");
            const v = parseFloat(f.css("transition-duration").replace(",", "."));
            a && v && (f.transitionEnd(h),
            m = !0);
            const y = (e.rtl ? c.index() : -c.index()) * 100;
            f.transform(`translate3d(${y}%,0,0)`)
        }
        let g;
        f.parent().hasClass("tabs-swipeable-wrap") && e.swiper && (g = f.parent()[0].swiper,
        g && g.activeIndex !== c.index() ? (m = !0,
        g.once("slideChangeTransitionEnd", () => {
            h()
        }
        ).slideTo(c.index(), a ? void 0 : 0)) : g && g.animating && (m = !0,
        g.once("slideChangeTransitionEnd", () => {
            h()
        }
        )));
        const b = f.children(".tab-active");
        if (b.removeClass("tab-active"),
        !o && (!g || g && !g.animating || g && r) && (b.hasClass("view") && b.children(".page").length && b.children(".page").each(v => {
            $(v).trigger("page:tabhide"),
            e.emit("pageTabHide", v)
        }
        ),
        b.trigger("tab:hide"),
        e.emit("tabHide", b[0])),
        c.addClass("tab-active"),
        !o && (!g || g && !g.animating || g && r) && (c.hasClass("view") && c.children(".page").length && c.children(".page").each(v => {
            $(v).trigger("page:tabshow"),
            e.emit("pageTabShow", v)
        }
        ),
        c.trigger("tab:show"),
        e.emit("tabShow", c[0])),
        !u && (typeof t == "string" ? u = $(`.tab-link[href="${t}"]`) : u = $(`.tab-link[href="#${c.attr("id")}"]`),
        (!u || u && u.length === 0) && $("[data-tab]").each(v => {
            c.is($(v).attr("data-tab")) && (u = $(v))
        }
        ),
        r && (!u || u && u.length === 0) && (u = $(`[data-route-tab-id="${r.route.tab.id}"]`),
        u.length === 0 && (u = $(`.tab-link[href="${r.url}"]`))),
        u.length > 1 && c.parents(".page").length && (u = u.filter(v => $(v).parents(".page")[0] === c.parents(".page")[0]),
        e.theme === "ios" && u.length === 0 && r))) {
            const v = c.parents(".page")
              , y = $(e.navbar.getElByPage(v));
            u = y.find(`[data-route-tab-id="${r.route.tab.id}"]`),
            u.length === 0 && (u = y.find(`.tab-link[href="${r.url}"]`))
        }
        if (u.length > 0) {
            let v;
            if (b && b.length > 0) {
                const y = b.attr("id");
                y && (v = $(`.tab-link[href="#${y}"]`),
                (!v || v && v.length === 0) && (v = $(`.tab-link[data-route-tab-id="${y}"]`))),
                (!v || v && v.length === 0) && $("[data-tab]").each(w => {
                    b.is($(w).attr("data-tab")) && (v = $(w))
                }
                ),
                (!v || v && v.length === 0) && (v = u.siblings(".tab-link-active"))
            } else
                r && (v = u.siblings(".tab-link-active"));
            if (v && v.length > 1 && b && b.parents(".page").length && (v = v.filter(y => $(y).parents(".page")[0] === b.parents(".page")[0])),
            v && v.length > 0 && v.removeClass("tab-link-active"),
            u && u.length > 0) {
                u.addClass("tab-link-active");
                const y = u.parents(".tabbar, .tabbar-labels");
                e.toolbar && y.length > 0 && (y.hasClass("tabbar-highlight") || e.theme !== "ios") && e.toolbar.setHighlight(y)
            }
        }
        return {
            $newTabEl: c,
            newTabEl: c[0],
            $oldTabEl: b,
            oldTabEl: b[0],
            onTabsChanged: p,
            animated: m
        }
    }
}
  , FF = {
    name: "tabs",
    create() {
        const e = this;
        se(e, {
            tab: {
                show: VF.show.bind(e)
            }
        })
    },
    on: {
        "pageInit tabMounted": function(t) {
            const a = $(t.el || t).find(".tabs-animated-wrap > .tabs > .tab-active")[0];
            if (!a)
                return;
            this.tab.show({
                tabEl: a,
                animatedInit: !0,
                animate: !1
            })
        }
    },
    clicks: {
        ".tab-link": function(t, n) {
            n === void 0 && (n = {}),
            (t.attr("href") && t.attr("href").indexOf("#") === 0 || t.attr("data-tab")) && this.tab.show({
                tabEl: n.tab || t.attr("href"),
                tabLinkEl: t,
                animate: n.animate
            })
        }
    }
};
function jF(e) {
    const t = e.app;
    if (e.swipeInitialized)
        return;
    se(e, {
        swipeable: !0,
        swipeInitialized: !0
    });
    const n = e.params
      , {$el: a, $backdropEl: r, side: o, effect: i} = e;
    let s, l, c, u, f, d;
    const p = {};
    let h, m, g, b, v, y, w, C = 0;
    function _(x) {
        if (!e.swipeable || c || !t.panel.allowOpen || !n.swipe && !n.swipeOnlyClose || l || $(".modal-in:not(.toast):not(.notification), .photo-browser-in").length > 0)
            return;
        s = t.panel.get(o === "left" ? "right" : "left") || {};
        const M = s.opened && s.$el && !s.$el.hasClass("panel-in-breakpoint");
        !e.opened && M || !n.swipeOnlyClose && M || x.target && x.target.nodeName.toLowerCase() === "input" && x.target.type === "range" || $(x.target).closest(".range-slider, .tabs-swipeable-wrap, .calendar-months, .no-swipe-panel, .card-opened").length > 0 || (p.x = x.type === "touchstart" ? x.targetTouches[0].pageX : x.pageX,
        p.y = x.type === "touchstart" ? x.targetTouches[0].pageY : x.pageY,
        !(n.swipeOnlyClose && !e.opened) && (n.swipeActiveArea && !e.opened && (o === "left" && p.x > n.swipeActiveArea || o === "right" && p.x < t.width - n.swipeActiveArea) || (C = 0,
        w = $(e.getViewEl()),
        u = !1,
        l = !0,
        f = void 0,
        d = !1,
        h = zn(),
        y = void 0)))
    }
    function E(x) {
        if (!l || c || d || (C += 1,
        C < 2))
            return;
        if (x.f7PreventSwipePanel || t.preventSwipePanelBySwipeBack || t.preventSwipePanel) {
            l = !1;
            return
        }
        const M = x.type === "touchmove" ? x.targetTouches[0].pageX : x.pageX
          , L = x.type === "touchmove" ? x.targetTouches[0].pageY : x.pageY;
        if (typeof f > "u" && (f = !!(f || Math.abs(L - p.y) > Math.abs(M - p.x))),
        f) {
            l = !1;
            return
        }
        if (!y) {
            if (M > p.x ? y = "to-right" : y = "to-left",
            n.swipeActiveArea > 0 && !e.opened) {
                if (o === "left" && p.x > n.swipeActiveArea) {
                    l = !1;
                    return
                }
                if (o === "right" && p.x < t.width - n.swipeActiveArea) {
                    l = !1;
                    return
                }
            }
            if (a.hasClass("panel-in-breakpoint")) {
                l = !1;
                return
            }
            if (o === "left" && y === "to-left" && !a.hasClass("panel-in") || o === "right" && y === "to-right" && !a.hasClass("panel-in")) {
                l = !1;
                return
            }
        }
        let U = e.opened ? 0 : -n.swipeThreshold;
        o === "right" && (U = -U),
        u || (e.opened || (e.insertToRoot(),
        a.addClass("panel-in-swipe"),
        r && r.css("visibility", "visible"),
        a.trigger("panel:swipeopen"),
        e.emit("local::swipeOpen panelSwipeOpen", e)),
        v = a[0].offsetWidth,
        i === "reveal" && a.hasClass("panel-in-collapsed") && (v -= parseFloat(w.css(`margin-${o}`))),
        a.transition(0)),
        u = !0,
        x.cancelable && x.preventDefault(),
        m = M - p.x + U,
        o === "right" ? i === "cover" || i === "push" ? (g = m + (e.opened ? 0 : v),
        g < 0 && (g = 0),
        g > v && (g = v)) : (g = m - (e.opened ? v : 0),
        g > 0 && (g = 0),
        g < -v && (g = -v)) : (g = m + (e.opened ? v : 0),
        g < 0 && (g = 0),
        g > v && (g = v));
        const Y = Math.abs(g / v);
        if (i === "reveal")
            n.swipeNoFollow || (w.transform(`translate3d(${g}px,0,0)`).transition(0),
            r && r.transform(`translate3d(${g}px,0,0)`).transition(0)),
            a.trigger("panel:swipe", Math.abs(g / v)),
            e.emit("local::swipe panelSwipe", e, Math.abs(g / v));
        else {
            if (o === "left" && (g -= v),
            !n.swipeNoFollow && (b = 1 - Math.abs(g / v),
            r && (r.transition(0),
            r.css({
                opacity: b
            })),
            a.transform(`translate3d(${g}px,0,0)`).transition(0),
            i === "push")) {
                const H = o === "left" ? g + v : g - v;
                w.transform(`translate3d(${H}px,0,0)`).transition(0),
                r && r.transform(`translate3d(${H}px,0,0)`).transition(0)
            }
            a.trigger("panel:swipe", Math.abs(g / v)),
            e.emit("local::swipe panelSwipe", e, Math.abs(g / v))
        }
        n.swipeNoFollow && (e.opened && Y === 0 || !e.opened && Y === 1) && (d = !0,
        z(x))
    }
    function z(x) {
        if (!l || !u) {
            l = !1,
            u = !1;
            return
        }
        const M = x.type === "gesturestart" || c;
        l = !1,
        u = !1;
        const L = new Date().getTime() - h;
        let U;
        const Y = (g === 0 || Math.abs(g) === v) && !n.swipeNoFollow
          , H = n.swipeThreshold || 0;
        M ? U = "reset" : e.opened ? i === "cover" || i === "push" ? g === 0 ? U = "reset" : L < 300 && Math.abs(g) > 0 ? U = "swap" : L >= 300 && Math.abs(g) < v / 2 ? U = "reset" : U = "swap" : g === -v ? U = "reset" : L < 300 && Math.abs(g) >= 0 || L >= 300 && Math.abs(g) <= v / 2 ? o === "left" && g === v ? U = "reset" : U = "swap" : U = "reset" : Math.abs(m) < H ? U = "reset" : i === "cover" || i === "push" ? g === 0 || L < 300 && Math.abs(g) > 0 || L >= 300 && Math.abs(g) < v / 2 ? U = "swap" : U = "reset" : g === 0 ? U = "reset" : L < 300 && Math.abs(g) > 0 || L >= 300 && Math.abs(g) >= v / 2 ? U = "swap" : U = "reset",
        U === "swap" && (e.opened ? e.close(!Y) : e.open(!Y));
        let W = !0;
        if (U === "reset" && !e.opened)
            if (Y)
                a.removeClass("panel-in-swipe");
            else {
                W = !1;
                const j = i === "reveal" ? w : a;
                e.setStateClasses("before-closing"),
                j.transitionEnd( () => {
                    a.hasClass("panel-in") || (a.removeClass("panel-in-swipe"),
                    e.setStateClasses("after-closing"))
                }
                )
            }
        (i === "reveal" || i === "push") && xn( () => {
            w.transition(""),
            w.transform("")
        }
        ),
        W && a.removeClass("panel-in-swipe"),
        a.transition("").transform(""),
        r && r.transform("").transition("").css({
            opacity: "",
            visibility: ""
        })
    }
    function T(x) {
        c = !0,
        z(x)
    }
    function A() {
        c = !1
    }
    t.on("touchstart:passive", _),
    t.on("touchmove:active", E),
    t.on("touchend:passive", z),
    t.on("gesturestart", T),
    t.on("gestureend", A),
    e.on("panelDestroy", () => {
        t.off("touchstart:passive", _),
        t.off("touchmove:active", E),
        t.off("touchend:passive", z),
        t.off("gesturestart", T),
        t.off("gestureend", A)
    }
    )
}
function UF(e) {
    const t = e.app
      , n = Mt();
    if (e.resizableInitialized)
        return;
    se(e, {
        resizable: !0,
        resizableWidth: null,
        resizableInitialized: !0
    });
    const a = $("html")
      , {$el: r, $backdropEl: o, side: i, effect: s} = e;
    if (!r)
        return;
    let l, c;
    const u = {};
    let f, d, p, h, m, g;
    function b(z) {
        if (!z)
            return null;
        if (z.indexOf("%") >= 0 || z.indexOf("vw") >= 0)
            return parseInt(z, 10) / 100 * t.width;
        const T = parseInt(z, 10);
        return Number.isNaN(T) ? null : T
    }
    function v() {
        return e.resizable && r.hasClass("panel-resizable")
    }
    function y(z) {
        v() && (u.x = z.type === "touchstart" ? z.targetTouches[0].pageX : z.pageX,
        u.y = z.type === "touchstart" ? z.targetTouches[0].pageY : z.pageY,
        c = !1,
        l = !0,
        h = b(r.css("min-width")),
        m = b(r.css("max-width")),
        g = r.hasClass("panel-in-breakpoint"))
    }
    function w(z) {
        if (!l)
            return;
        const T = z.type === "touchmove" ? z.targetTouches[0].pageX : z.pageX;
        c || (d = r[0].offsetWidth,
        r.transition(0),
        r.addClass("panel-resizing"),
        a.css("cursor", "col-resize"),
        (s !== "cover" || g) && (p = $(e.getViewEl()),
        e.$containerEl && e.$containerEl.hasClass("page") && p.add(e.$containerEl.children(".page-content, .tabs, .fab"))),
        s !== "cover" && !g && (o.transition(0),
        p.transition(0))),
        c = !0,
        z.preventDefault(),
        f = T - u.x;
        let A = i === "left" ? d + f : d - f;
        h && !Number.isNaN(h) && (A = Math.max(A, h)),
        m && !Number.isNaN(m) && (A = Math.min(A, m)),
        A = Math.min(Math.max(A, 0), t.width),
        e.resizableWidth = A,
        r[0].style.width = `${A}px`,
        s !== "cover" && !g ? (p && p.transform(`translate3d(${i === "left" ? A : -A}px, 0, 0)`),
        o && o.transform(`translate3d(${i === "left" ? A : -A}px, 0, 0)`)) : g && p && p.css(`margin-${i}`, `${A}px`),
        r.trigger("panel:resize", A),
        e.emit("local::resize panelResize", e, A)
    }
    function C() {
        if ($("html").css("cursor", ""),
        !l || !c) {
            l = !1,
            c = !1;
            return
        }
        l = !1,
        c = !1,
        a[0].style.setProperty(`--f7-panel-${i}-width`, `${e.resizableWidth}px`),
        r[0].style.width = "",
        s !== "cover" && !g && (p.transform(""),
        o.transform("")),
        r.removeClass("panel-resizing"),
        xn( () => {
            r.transition(""),
            s !== "cover" && (o.transition(""),
            p && p.transition(""))
        }
        )
    }
    function _() {
        !e.opened || !e.resizableWidth || (h = b(r.css("min-width")),
        m = b(r.css("max-width")),
        h && !Number.isNaN(h) && e.resizableWidth < h && (e.resizableWidth = Math.max(e.resizableWidth, h)),
        m && !Number.isNaN(m) && e.resizableWidth > m && (e.resizableWidth = Math.min(e.resizableWidth, m)),
        e.resizableWidth = Math.min(Math.max(e.resizableWidth, 0), t.width),
        a[0].style.setProperty(`--f7-panel-${i}-width`, `${e.resizableWidth}px`))
    }
    e.$el.find(".panel-resize-handler").length === 0 && e.$el.append('<div class="panel-resize-handler"></div>'),
    e.$resizeHandlerEl = e.$el.children(".panel-resize-handler"),
    r.addClass("panel-resizable");
    const E = n.passiveListener ? {
        passive: !0
    } : !1;
    e.$el.on(t.touchEvents.start, ".panel-resize-handler", y, E),
    t.on("touchmove:active", w),
    t.on("touchend:passive", C),
    t.on("resize", _),
    e.on("beforeOpen", _),
    e.once("panelDestroy", () => {
        r.removeClass("panel-resizable"),
        e.$resizeHandlerEl.remove(),
        e.$el.off(t.touchEvents.start, ".panel-resize-handler", y, E),
        t.off("touchmove:active", w),
        t.off("touchend:passive", C),
        t.off("resize", _),
        e.off("beforeOpen", _)
    }
    )
}
let y2 = class extends Bt {
    constructor(t, n) {
        n === void 0 && (n = {});
        const a = se({
            on: {}
        }, t.params.panel, n);
        super(a, [t]);
        const r = this;
        r.params = a,
        r.$containerEl = r.params.containerEl ? $(r.params.containerEl).eq(0) : t.$el,
        r.containerEl = r.$containerEl[0],
        r.containerEl || (r.$containerEl = t.$el,
        r.containerEl = t.$el[0]);
        let o;
        if (r.params.el ? o = $(r.params.el).eq(0) : r.params.content && (o = $(r.params.content).filter(u => u.nodeType === 1).eq(0)),
        o.length === 0)
            return r;
        if (o[0].f7Panel)
            return o[0].f7Panel;
        o[0].f7Panel = r;
        let {side: i, effect: s, resizable: l} = r.params;
        typeof i > "u" && (i = o.hasClass("panel-left") ? "left" : "right"),
        typeof s > "u" && (s = o.hasClass("panel-cover") ? "cover" : o.hasClass("panel-push") ? "push" : "reveal"),
        typeof l > "u" && (l = o.hasClass("panel-resizable"));
        let c;
        return r.params.backdrop && r.params.backdropEl ? c = $(r.params.backdropEl) : r.params.backdrop && (c = r.$containerEl.children(".panel-backdrop"),
        c.length === 0 && (c = $('<div class="panel-backdrop"></div>'),
        r.$containerEl.prepend(c))),
        se(r, {
            app: t,
            side: i,
            effect: s,
            resizable: l,
            $el: o,
            el: o[0],
            opened: !1,
            $backdropEl: c,
            backdropEl: c && c[0]
        }),
        r.useModules(),
        r.init(),
        r
    }
    getViewEl() {
        const t = this;
        let n;
        return t.$containerEl.children(".views").length > 0 ? n = t.$containerEl.children(".views")[0] : n = t.$containerEl.children(".view")[0],
        n
    }
    setStateClasses(t) {
        const n = this
          , {side: a, el: r} = n
          , o = n.getViewEl()
          , i = o && o.contains(r)
          , s = !o || i ? n.$containerEl : $("html");
        t === "open" && s.addClass(`with-panel with-panel-${n.side}-${n.effect}`),
        t === "before-closing" && s.addClass("with-panel-closing"),
        t === "closing" && (s.addClass("with-panel-closing"),
        s.removeClass(`with-panel with-panel-${n.side}-${n.effect}`)),
        t === "after-closing" && s.removeClass("with-panel-closing"),
        t === "closed" && s.removeClass(`with-panel-${a}-reveal with-panel-${a}-cover with-panel-${a}-push with-panel`)
    }
    enableVisibleBreakpoint() {
        const t = this;
        return t.visibleBreakpointDisabled = !1,
        t.setVisibleBreakpoint(),
        t
    }
    disableVisibleBreakpoint() {
        const t = this;
        return t.visibleBreakpointDisabled = !0,
        t.setVisibleBreakpoint(),
        t
    }
    toggleVisibleBreakpoint() {
        const t = this;
        return t.visibleBreakpointDisabled = !t.visibleBreakpointDisabled,
        t.setVisibleBreakpoint(),
        t
    }
    setVisibleBreakpoint(t) {
        t === void 0 && (t = !0);
        const n = this
          , a = n.app;
        n.visibleBreakpointResizeHandler || (n.visibleBreakpointResizeHandler = function() {
            n.setVisibleBreakpoint()
        }
        ,
        a.on("resize", n.visibleBreakpointResizeHandler));
        const {side: r, $el: o, $containerEl: i, params: s, visibleBreakpointDisabled: l} = n
          , c = s.visibleBreakpoint
          , u = $(n.getViewEl())
          , f = o.hasClass("panel-in-breakpoint");
        i && i.hasClass("page") && u.add(i.children(".page-content, .tabs, .fab")),
        a.width >= c && typeof c < "u" && c !== null && !l ? f ? u.css({
            [`margin-${r}`]: `${o.width()}px`
        }) : (n.setStateClasses("closed"),
        o.addClass("panel-in-breakpoint").removeClass("panel-in panel-in-collapsed"),
        n.onOpen(!1),
        n.onOpened(),
        u.css({
            [`margin-${r}`]: `${o.width()}px`
        }),
        a.allowPanelOpen = !0,
        t && (n.emit("local::breakpoint panelBreakpoint", n),
        n.$el.trigger("panel:breakpoint"))) : f && (o.removeClass("panel-in-breakpoint panel-in"),
        n.onClose(),
        n.onClosed(),
        u.css({
            [`margin-${r}`]: ""
        }),
        t && (n.emit("local::breakpoint panelBreakpoint", n),
        n.$el.trigger("panel:breakpoint")))
    }
    enableCollapsedBreakpoint() {
        const t = this;
        return t.collapsedBreakpointDisabled = !1,
        t.setCollapsedBreakpoint(),
        t
    }
    disableCollapsedBreakpoint() {
        const t = this;
        return t.collapsedBreakpointDisabled = !0,
        t.setCollapsedBreakpoint(),
        t
    }
    toggleCollapsedBreakpoint() {
        const t = this;
        return t.collapsedBreakpointDisabled = !t.collapsedBreakpointDisabled,
        t.setCollapsedBreakpoint(),
        t
    }
    setCollapsedBreakpoint(t) {
        t === void 0 && (t = !0);
        const n = this
          , a = n.app;
        n.collapsedBreakpointResizeHandler || (n.collapsedBreakpointResizeHandler = function() {
            n.setCollapsedBreakpoint()
        }
        ,
        a.on("resize", n.collapsedBreakpointResizeHandler));
        const {$el: r, params: o, collapsedBreakpointDisabled: i} = n;
        if (r.hasClass("panel-in-breakpoint"))
            return;
        const s = o.collapsedBreakpoint
          , l = r.hasClass("panel-in-collapsed");
        a.width >= s && typeof s < "u" && s !== null && !i ? l || (n.setStateClasses("closed"),
        r.addClass("panel-in-collapsed").removeClass("panel-in"),
        n.collapsed = !0,
        a.allowPanelOpen = !0,
        t && (n.emit("local::collapsedBreakpoint panelCollapsedBreakpoint", n),
        n.$el.trigger("panel:collapsedbreakpoint"))) : l && (r.removeClass("panel-in-collapsed panel-in"),
        n.collapsed = !1,
        t && (n.emit("local::collapsedBreakpoint panelCollapsedBreakpoint", n),
        n.$el.trigger("panel:collapsedbreakpoint")))
    }
    enableResizable() {
        const t = this;
        return t.resizableInitialized ? (t.resizable = !0,
        t.$el.addClass("panel-resizable")) : UF(t),
        t
    }
    disableResizable() {
        const t = this;
        return t.resizable = !1,
        t.$el.removeClass("panel-resizable"),
        t
    }
    enableSwipe() {
        const t = this;
        return t.swipeInitialized ? t.swipeable = !0 : jF(t),
        t
    }
    disableSwipe() {
        const t = this;
        return t.swipeable = !1,
        t
    }
    onOpen(t) {
        t === void 0 && (t = !0);
        const n = this;
        n._openTransitionStarted = !1;
        const a = n.app;
        n.opened = !0,
        a.panel.allowOpen = !1,
        n.$el.trigger("panel:beforeopen"),
        n.emit("local::beforeOpen panelBeforeOpen", n),
        t && n.setStateClasses("open"),
        n.$el.trigger("panel:open"),
        n.emit("local::open panelOpen", n)
    }
    onOpened() {
        const t = this
          , n = t.app;
        n.panel.allowOpen = !0,
        t.$el.trigger("panel:opened"),
        t.emit("local::opened panelOpened", t)
    }
    onClose() {
        const t = this
          , n = t.app;
        t.opened = !1,
        n.panel.allowOpen = !1,
        t.$el.trigger("panel:beforeclose"),
        t.emit("local::beforeClose panelBeforeClose", t),
        t.setStateClasses("closing"),
        t.$el.trigger("panel:close"),
        t.emit("local::close panelClose", t)
    }
    onClosed() {
        const t = this
          , n = t.app;
        if (n.panel.allowOpen = !0,
        t.setStateClasses("after-closing"),
        t.$el.removeClass("panel-out"),
        t.$backdropEl) {
            const a = n.panel.get(".panel-in");
            (!a || a && !a.$backdropEl) && t.$backdropEl.removeClass("panel-backdrop-in")
        }
        t.$el.trigger("panel:closed"),
        t.emit("local::closed panelClosed", t)
    }
    toggle(t) {
        t === void 0 && (t = !0);
        const n = this
          , a = n.params.visibleBreakpoint;
        return n.app.width >= a && typeof a < "u" && a !== null ? n.toggleVisibleBreakpoint() : (n.opened ? n.close(t) : n.open(t),
        n)
    }
    insertToRoot() {
        const t = this
          , n = Qe()
          , {$el: a, $backdropEl: r, $containerEl: o} = t
          , i = a.parent()
          , s = a.parents(n).length > 0;
        if (!i.is(o) || a.prevAll(".views, .view").length) {
            const l = o.children(".panel, .views, .view").eq(0)
              , c = o.children(".panel-backdrop").eq(0);
            l.length ? a.insertBefore(l) : c ? a.insertBefore(c) : o.prepend(a),
            r && r.length && (!r.parent().is(o) && r.nextAll(".panel").length === 0 || r.parent().is(o) && r.nextAll(".panel").length === 0) && r.insertBefore(a),
            t.once("panelClosed", () => {
                s ? i.append(a) : a.remove()
            }
            )
        }
    }
    open(t) {
        t === void 0 && (t = !0);
        const n = this
          , a = n.app;
        if (!a.panel.allowOpen)
            return !1;
        const {effect: r, $el: o, $backdropEl: i, opened: s, $containerEl: l} = n;
        if (!o || o.hasClass("panel-in"))
            return n;
        if (n.insertToRoot(),
        s || o.hasClass("panel-in-breakpoint") || o.hasClass("panel-in"))
            return !1;
        const c = a.panel.get(".panel-in");
        c && c !== n && c.close(t),
        o[t ? "removeClass" : "addClass"]("not-animated"),
        o.addClass("panel-in"),
        i && (i.addClass("panel-backdrop-in"),
        i[t ? "removeClass" : "addClass"]("not-animated")),
        (n.effect === "cover" || n.effect === "push") && (n._clientLeft = o[0].clientLeft);
        const u = $(n.getViewEl());
        l && l.hasClass("page") && u.add(l.children(".page-content, .tabs"));
        const f = r === "reveal" ? u : o;
        function d() {
            f.transitionStart( () => {
                n._openTransitionStarted = !0
            }
            )
        }
        function p() {
            f.transitionEnd(h => {
                $(h.target).is(f) ? o.hasClass("panel-out") ? n.onClosed() : n.onOpened() : p()
            }
            )
        }
        return t ? (i && i.removeClass("not-animated"),
        d(),
        p(),
        o.removeClass("panel-out not-animated").addClass("panel-in"),
        n.onOpen()) : (i && i.addClass("not-animated"),
        o.removeClass("panel-out").addClass("panel-in not-animated"),
        n.onOpen(),
        n.onOpened()),
        !0
    }
    close(t) {
        t === void 0 && (t = !0);
        const n = this
          , {effect: a, $el: r, $backdropEl: o, opened: i, $containerEl: s} = n;
        if (!i || r.hasClass("panel-in-breakpoint") || !r.hasClass("panel-in"))
            return n;
        r[t ? "removeClass" : "addClass"]("not-animated"),
        o && o[t ? "removeClass" : "addClass"]("not-animated");
        const l = $(n.getViewEl());
        s && s.hasClass("page") && l.add(s.children(".page-content, .tabs"));
        const c = a === "reveal" ? l : r;
        n._openTransitionStarted || (t = !1);
        function u() {
            r.hasClass("panel-out") ? n.onClosed() : r.hasClass("panel-in") && n.onOpened(),
            n.setStateClasses("after-closing")
        }
        return t ? (c.transitionEnd( () => {
            u()
        }
        ),
        r.removeClass("panel-in").addClass("panel-out"),
        n.onClose()) : (r.addClass("not-animated").removeClass("panel-in").addClass("panel-out"),
        n.onClose(),
        n.onClosed()),
        n
    }
    init() {
        const t = this;
        typeof t.params.visibleBreakpoint < "u" && t.setVisibleBreakpoint(),
        typeof t.params.collapsedBreakpoint < "u" && t.setCollapsedBreakpoint(),
        t.params.swipe && t.enableSwipe(),
        t.resizable && t.enableResizable()
    }
    destroy() {
        let t = this;
        const n = t.app
          , {$containerEl: a} = t;
        if (t.$el) {
            if (t.emit("local::beforeDestroy panelBeforeDestroy", t),
            t.$el.trigger("panel:beforedestroy"),
            t.visibleBreakpointResizeHandler && n.off("resize", t.visibleBreakpointResizeHandler),
            t.collapsedBreakpointResizeHandler && n.off("resize", t.collapsedBreakpointResizeHandler),
            t.$el.hasClass("panel-in-breakpoint") || t.$el.hasClass("panel-in-collapsed")) {
                const r = $(t.getViewEl());
                a && a.hasClass("page") && r.add(a.children(".page-content, .tabs")),
                t.$el.removeClass("panel-in-breakpoint panel-in-collapsed panel-in"),
                r.css({
                    [`margin-${t.side}`]: ""
                }),
                t.emit("local::breakpoint panelBreakpoint", t),
                t.$el.trigger("panel:breakpoint")
            }
            t.$el.trigger("panel:destroy"),
            t.emit("local::destroy panelDestroy", t),
            t.el && (t.el.f7Panel = null,
            delete t.el.f7Panel),
            Yt(t),
            t = null
        }
    }
}
;
const qF = {
    name: "panel",
    params: {
        panel: {
            opened: void 0,
            side: void 0,
            effect: void 0,
            resizable: void 0,
            backdrop: !0,
            backdropEl: void 0,
            visibleBreakpoint: void 0,
            collapsedBreakpoint: void 0,
            swipe: !1,
            swipeNoFollow: !1,
            swipeOnlyClose: !1,
            swipeActiveArea: 0,
            swipeThreshold: 0,
            closeByBackdropClick: !0,
            containerEl: void 0
        }
    },
    static: {
        Panel: y2
    },
    create() {
        const e = this;
        se(e, {
            panel: {
                allowOpen: !0,
                create(t) {
                    return new y2(e,t)
                },
                get(t) {
                    if (t === void 0 && (t = ".panel"),
                    t instanceof y2)
                        return t;
                    (t === "left" || t === "right") && (t = `.panel-${t}`);
                    const n = $(t);
                    if (!(n.length === 0 || n.length > 1))
                        return n[0].f7Panel
                },
                destroy(t) {
                    t === void 0 && (t = ".panel");
                    const n = e.panel.get(t);
                    if (n && n.destroy)
                        return n.destroy()
                },
                open(t, n) {
                    t === void 0 && (t = ".panel"),
                    (t === "left" || t === "right") && (t = `.panel-${t}`);
                    let a = e.panel.get(t);
                    if (a && a.open)
                        return a.open(n);
                    if (!a)
                        return a = e.panel.create({
                            el: t
                        }),
                        a.open(n)
                },
                close(t, n) {
                    t === void 0 && (t = ".panel-in"),
                    (t === "left" || t === "right") && (t = `.panel-${t}`);
                    let a = e.panel.get(t);
                    if (a && a.open)
                        return a.close(n);
                    if (!a)
                        return a = e.panel.create({
                            el: t
                        }),
                        a.close(n)
                },
                toggle(t, n) {
                    t === void 0 && (t = ".panel"),
                    (t === "left" || t === "right") && (t = `.panel-${t}`);
                    let a = e.panel.get(t);
                    if (a && a.toggle)
                        return a.toggle(n);
                    if (!a)
                        return a = e.panel.create({
                            el: t
                        }),
                        a.toggle(n)
                }
            }
        })
    },
    on: {
        init() {
            const e = this;
            $(".panel-init").each(t => {
                const n = Object.assign({
                    el: t
                }, $(t).dataset() || {});
                e.panel.create(n)
            }
            )
        },
        pageInit(e) {
            const t = this;
            e.$el.find(".panel-init").each(n => {
                const a = Object.assign({
                    el: n
                }, $(n).dataset() || {});
                t.panel.create(a)
            }
            )
        },
        pageBeforeRemove(e) {
            const t = this;
            e.$el.find(".panel-init").each(n => {
                const a = t.panel.get(n);
                a && a.destroy && a.destroy()
            }
            )
        }
    },
    vnode: {
        "panel-init": {
            insert(e) {
                const t = this
                  , n = e.elm
                  , a = Object.assign({
                    el: n
                }, $(n).dataset() || {});
                t.panel.create(a)
            },
            destroy(e) {
                const t = this
                  , n = e.elm
                  , a = t.panel.get(n);
                a && a.destroy && a.destroy()
            }
        }
    },
    clicks: {
        ".panel-open": function(t, n) {
            n === void 0 && (n = {}),
            this.panel.open(n.panel, n.animate)
        },
        ".panel-close": function(t, n) {
            n === void 0 && (n = {}),
            this.panel.close(n.panel, n.animate)
        },
        ".panel-toggle": function(t, n) {
            n === void 0 && (n = {}),
            this.panel.toggle(n.panel, n.animate)
        },
        ".panel-backdrop": function() {
            const t = this
              , n = $(".panel-in:not(.panel-out)");
            if (!n.length)
                return;
            const a = n[0] && n[0].f7Panel;
            n.trigger("panel:backdrop-click"),
            a && a.emit("backdropClick", a),
            t.emit("panelBackdropClick", a || n[0]),
            !(a && a.params.closeByBackdropClick === !1) && t.params.panel.closeByBackdropClick && t.panel.close()
        }
    }
}
  , WF = {
    open(e, t) {
        e === void 0 && (e = ".card-expandable"),
        t === void 0 && (t = !0);
        const n = this
          , a = yt()
          , r = Qe()
          , o = Mt()
          , i = $(e).eq(0);
        if (!i || !i.length || i.hasClass("card-opened") || i.hasClass("card-opening") || i.hasClass("card-closing"))
            return;
        const s = i.parents(".page").eq(0);
        if (!s.length || s.find(".card-opened").length)
            return;
        let l;
        function c() {
            l = !0
        }
        if (i.trigger("card:beforeopen", {
            prevent: c
        }),
        n.emit("cardBeforeOpen", i[0], c),
        l)
            return;
        const u = Object.assign({
            animate: t
        }, n.params.card, i.dataset())
          , f = i.parents(".page-content");
        let d;
        i.attr("data-backdrop-el") && (d = $(i.attr("data-backdrop-el"))),
        !d && u.backdrop && (d = f.find(".card-backdrop"),
        d.length || (d = $('<div class="card-backdrop"></div>'),
        f.append(d)));
        let p, h;
        u.hideNavbarOnOpen && (p = s.children(".navbar"),
        p.length || s[0].f7Page && (p = s[0].f7Page.$navbarEl)),
        u.hideToolbarOnOpen && (h = s.children(".toolbar"),
        h.length || (h = s.parents(".view").children(".toolbar")),
        h.length || (h = s.parents(".views").children(".toolbar")));
        const m = i.css("transform");
        let g;
        m && m.match(/[2-9]/) && (g = !0);
        const b = i.children(".card-content")
          , v = $(r.createElement("div")).addClass("card-expandable-size");
        i.append(v);
        let y = i[0].offsetWidth, w = i[0].offsetHeight, C = s[0].offsetWidth, _ = s[0].offsetHeight, E = v[0].offsetWidth || C, z = v[0].offsetHeight || _, T;
        p && !u.hideStatusbarOnOpen && z === _ && (T = parseInt(p.css("--f7-safe-area-top"), 10),
        Number.isNaN(T) && (T = 0)),
        T && (z -= T);
        let A = E / y
          , x = z / w
          , M = i.offset()
          , L = s.offset();
        T && (L.top += T / 2),
        M.left -= L.left;
        let U, Y;
        if (g) {
            const me = m.replace(/matrix\(|\)/g, "").split(",").map(ge => ge.trim());
            if (me && me.length > 1) {
                const ge = parseFloat(me[0]);
                U = M.left - y * (1 - ge) / 2,
                Y = M.top - L.top - w * (1 - ge) / 2,
                n.rtl && (U -= i[0].scrollLeft)
            } else
                U = i[0].offsetLeft,
                Y = i[0].offsetTop - (f.length ? f[0].scrollTop : 0)
        } else
            U = M.left,
            Y = M.top - L.top,
            n.rtl && (U -= i[0].scrollLeft);
        U -= (C - E) / 2,
        Y -= (_ - z) / 2;
        let H = E - y - U;
        n.rtl && ([U,H] = [H, U]);
        let W = z - w - Y
          , j = (H - U) / 2
          , Q = (W - Y) / 2;
        u.hideNavbarOnOpen && p && p.length && (p.closest(".navbar-hidden").length ? i[0].f7KeepNavbarOnClose = !0 : (delete i[0].f7KeepNavbarOnClose,
        n.navbar.hide(p, u.animate, u.hideStatusbarOnOpen, !0))),
        u.hideToolbarOnOpen && h && h.length && (h.closest(".toolbar-hidden").length ? i[0].f7KeepToolbarOnClose = !0 : (delete i[0].f7KeepToolbarOnClose,
        n.toolbar.hide(h, u.animate))),
        d && d.removeClass("card-backdrop-out").addClass("card-backdrop-in"),
        i.removeClass("card-transitioning"),
        u.animate && i.addClass("card-opening"),
        i.trigger("card:open"),
        n.emit("cardOpen", i[0]);
        function ne() {
            s.addClass("page-with-card-opened"),
            a.ios && f.length && (f.css("height", `${f[0].offsetHeight + 1}px`),
            setTimeout( () => {
                f.css("height", "")
            }
            )),
            i.addClass("card-opened"),
            i.removeClass("card-opening"),
            i.trigger("card:opened"),
            n.emit("cardOpened", i[0], s[0])
        }
        b.css({
            width: `${E}px`,
            height: `${z}px`
        }).transform(`translate3d(${n.rtl ? U + j : -U - j}px, 0px, 0) scale(${1 / A}, ${1 / x})`),
        i.transform(`translate3d(${n.rtl ? -j : j}px, ${Q}px, 0) scale(${A}, ${x})`),
        u.animate ? i.transitionEnd( () => {
            ne()
        }
        ) : ne();
        function re() {
            i.removeClass("card-transitioning"),
            y = i[0].offsetWidth,
            w = i[0].offsetHeight,
            C = s[0].offsetWidth,
            _ = s[0].offsetHeight,
            E = v[0].offsetWidth || C,
            z = v[0].offsetHeight || _,
            T = 0,
            p && !u.hideStatusbarOnOpen && z === _ && (T = parseInt(p.css("--f7-safe-area-top"), 10),
            Number.isNaN(T) && (T = 0)),
            T && (z -= T),
            A = E / y,
            x = z / w,
            i.transform("translate3d(0px, 0px, 0) scale(1)"),
            M = i.offset(),
            L = s.offset(),
            T && (L.top += T / 2),
            M.left -= L.left,
            M.top -= L.top,
            U = M.left - (C - E) / 2,
            n.rtl && (U -= i[0].scrollLeft),
            Y = M.top - (_ - z) / 2,
            H = E - y - U,
            W = z - w - Y,
            n.rtl && ([U,H] = [H, U]),
            j = (H - U) / 2,
            Q = (W - Y) / 2,
            i.transform(`translate3d(${n.rtl ? -j : j}px, ${Q}px, 0) scale(${A}, ${x})`),
            b.css({
                width: `${E}px`,
                height: `${z}px`
            }).transform(`translate3d(${n.rtl ? U + j : -U - j}px, 0px, 0) scale(${1 / A}, ${1 / x})`)
        }
        let ve, Ne, Ge, Ye, tt, ee, ye, Le, Se, Re, Ve, Ze;
        function q(me) {
            $(me.target).closest(i).length && i.hasClass("card-opened") && (Ze = i.find(u.scrollableEl),
            Ze[0] && Ze[0] !== b[0] && !Ze[0].contains(me.target) ? ve = 0 : ve = Ze.scrollTop(),
            Ne = !0,
            Ye = me.targetTouches[0].pageX,
            tt = me.targetTouches[0].pageY,
            Le = void 0,
            Re = !1,
            Ve = !1)
        }
        function Z(me) {
            if (Ne) {
                if (ee = me.targetTouches[0].pageX,
                ye = me.targetTouches[0].pageY,
                typeof Le > "u" && (Le = !!(Le || Math.abs(ye - tt) > Math.abs(ee - Ye))),
                !Ve && !Re && (!Le && me.targetTouches[0].clientX <= 50 ? Ve = !0 : Re = !0),
                !(Ve || Re) || Re && ve !== 0) {
                    Ne = !0,
                    Ge = !0;
                    return
                }
                Ge || i.removeClass("card-transitioning"),
                Ge = !0,
                Se = Math.max(Re ? (ye - tt) / 150 : (ee - Ye) / (y / 2), 0),
                (Se > 0 && Re || Ve) && (Re && a.ios && Ze[0] === b[0] && (Ze.css("-webkit-overflow-scrolling", "auto"),
                Ze.scrollTop(0)),
                me.preventDefault()),
                Se > 1 && (Se **= .3),
                Se > (Re ? 1.3 : 1.1) ? (Ne = !1,
                Ge = !1,
                n.card.close(i)) : i.transform(`translate3d(${n.rtl ? -j : j}px, ${Q}px, 0) scale(${A * (1 - Se * .2)}, ${x * (1 - Se * .2)})`)
            }
        }
        function de() {
            !Ne || !Ge || (Ne = !1,
            Ge = !1,
            a.ios && Ze.css("-webkit-overflow-scrolling", ""),
            Se >= .8 ? n.card.close(i) : i.addClass("card-transitioning").transform(`translate3d(${n.rtl ? -j : j}px, ${Q}px, 0) scale(${A}, ${x})`))
        }
        i[0].detachEventHandlers = function() {
            n.off("resize", re),
            o.touch && u.swipeToClose && (n.off("touchstart:passive", q),
            n.off("touchmove:active", Z),
            n.off("touchend:passive", de))
        }
        ,
        n.on("resize", re),
        o.touch && u.swipeToClose && (n.on("touchstart:passive", q),
        n.on("touchmove:active", Z),
        n.on("touchend:passive", de))
    },
    close(e, t) {
        e === void 0 && (e = ".card-expandable.card-opened"),
        t === void 0 && (t = !0);
        const n = this
          , a = yt()
          , r = $(e).eq(0);
        if (!r || !r.length || !r.hasClass("card-opened") || r.hasClass("card-opening") || r.hasClass("card-closing"))
            return;
        const o = r.children(".card-content")
          , i = r.parents(".page-content")
          , s = r.parents(".page").eq(0);
        if (!s.length)
            return;
        const l = Object.assign({
            animate: t
        }, n.params.card, r.dataset())
          , c = r.find(l.scrollableEl);
        let u, f, d;
        r.attr("data-backdrop-el") && (d = $(r.attr("data-backdrop-el"))),
        l.backdrop && (d = r.parents(".page-content").find(".card-backdrop")),
        l.hideNavbarOnOpen && (u = s.children(".navbar"),
        u.length || s[0].f7Page && (u = s[0].f7Page.$navbarEl),
        u && u.length && !r[0].f7KeepNavbarOnClose && n.navbar.show(u, l.animate, !0)),
        l.hideToolbarOnOpen && (f = s.children(".toolbar"),
        f.length || (f = s.parents(".view").children(".toolbar")),
        f.length || (f = s.parents(".views").children(".toolbar")),
        f && f.length && !r[0].f7KeepToolbarOnClose && n.toolbar.show(f, l.animate)),
        s.removeClass("page-with-card-opened"),
        a.ios && i.length && (i.css("height", `${i[0].offsetHeight + 1}px`),
        setTimeout( () => {
            i.css("height", "")
        }
        )),
        d && d.length && d.removeClass("card-backdrop-in").addClass("card-backdrop-out"),
        r.removeClass("card-opened card-transitioning"),
        l.animate ? r.addClass("card-closing") : r.addClass("card-no-transition"),
        r.transform(""),
        r.trigger("card:close"),
        n.emit("cardClose", r[0], s[0]);
        const p = r.hasClass("card-expandable-animate-width");
        function h() {
            p || o.css({
                width: "",
                height: ""
            }),
            d && d.length && d.removeClass("card-backdrop-in card-backdrop-out"),
            r.removeClass("card-closing card-no-transition"),
            r.trigger("card:closed"),
            r.find(".card-expandable-size").remove(),
            n.emit("cardClosed", r[0], s[0])
        }
        p && o.css({
            width: "",
            height: ""
        }),
        o.transform("").scrollTop(0, t ? 300 : 0),
        c.length && c[0] !== o[0] && c.scrollTop(0, t ? 300 : 0),
        t ? o.transitionEnd( () => {
            h()
        }
        ) : h(),
        r[0].detachEventHandlers && (r[0].detachEventHandlers(),
        delete r[0].detachEventHandlers)
    },
    toggle(e, t) {
        e === void 0 && (e = ".card-expandable");
        const n = this
          , a = $(e).eq(0);
        a.length && (a.hasClass("card-opened") ? n.card.close(a, t) : n.card.open(a, t))
    }
}
  , YF = {
    name: "card",
    params: {
        card: {
            hideNavbarOnOpen: !0,
            hideStatusbarOnOpen: !0,
            hideToolbarOnOpen: !0,
            scrollableEl: ".card-content",
            swipeToClose: !0,
            closeByBackdropClick: !0,
            backdrop: !0
        }
    },
    create() {
        hn(this, {
            card: WF
        })
    },
    on: {
        pageBeforeIn(e) {
            const t = this;
            if (t.params.card.hideNavbarOnOpen && e.navbarEl && e.$el.find(".card-opened.card-expandable").length && t.navbar.hide(e.navbarEl, !0, t.params.card.hideStatusbarOnOpen, !0),
            t.params.card.hideToolbarOnOpen && e.$el.find(".card-opened.card-expandable").length) {
                let n = e.$el.children(".toolbar");
                n.length || (n = e.$el.parents(".view").children(".toolbar")),
                n.length || (n = e.$el.parents(".views").children(".toolbar")),
                n && n.length && t.toolbar.hide(n)
            }
        }
    },
    clicks: {
        ".card-close": function(t, n) {
            this.card.close(n.card, n.animate)
        },
        ".card-open": function(t, n) {
            this.card.open(n.card, n.animate)
        },
        ".card-expandable": function(t, n, a) {
            const r = this;
            t.hasClass("card-opened") || t.hasClass("card-opening") || t.hasClass("card-closing") || $(a.target).closest(".card-prevent-open, .card-close").length || r.card.open(t)
        },
        ".card-backdrop-in": function() {
            const t = this;
            let n = !1;
            t.params.card.closeByBackdropClick && (n = !0);
            const a = $(".card-opened");
            a.length && (a.attr("data-close-by-backdrop-click") === "true" ? n = !0 : a.attr("data-close-by-backdrop-click") === "false" && (n = !1),
            n && t.card.close(a))
        }
    }
}
  , GF = {
    name: "chip"
}
  , C2 = {
    store(e, t) {
        const n = this
          , a = He();
        let r = e;
        const o = $(e);
        o.length && o.is("form") && o.attr("id") && (r = o.attr("id")),
        n.form.data[`form-${r}`] = t,
        a.localStorage[`f7form-${r}`] = JSON.stringify(t)
    },
    get(e) {
        const t = this
          , n = He();
        let a = e;
        const r = $(e);
        if (r.length && r.is("form") && r.attr("id") && (a = r.attr("id")),
        n.localStorage[`f7form-${a}`])
            return JSON.parse(n.localStorage[`f7form-${a}`]);
        if (t.form.data[`form-${a}`])
            return t.form.data[`form-${a}`]
    },
    remove(e) {
        const t = this
          , n = He();
        let a = e;
        const r = $(e);
        r.length && r.is("form") && r.attr("id") && (a = r.attr("id")),
        t.form.data[`form-${a}`] && (t.form.data[`form-${a}`] = "",
        delete t.form.data[`form-${a}`]),
        n.localStorage[`f7form-${a}`] && (n.localStorage[`f7form-${a}`] = "",
        n.localStorage.removeItem(`f7form-${a}`))
    }
}
  , Rp = {
    init(e) {
        const t = this
          , n = $(e)
          , a = n.attr("id");
        if (!a)
            return;
        const r = t.form.getFormData(a);
        r && t.form.fillFromData(n, r);
        function o() {
            const i = t.form.convertToData(n);
            i && (t.form.storeFormData(a, i),
            n.trigger("form:storedata", i),
            t.emit("formStoreData", n[0], i))
        }
        n.on("change submit", o)
    },
    destroy(e) {
        $(e).off("change submit")
    }
};
function XF(e) {
    const t = this
      , n = $(e).eq(0);
    if (n.length === 0)
        return;
    const a = {}
      , r = ["submit", "image", "button", "file"]
      , o = [];
    return n.find("input, select, textarea").each(i => {
        const s = $(i);
        if (s.hasClass("ignore-store-data") || s.hasClass("no-store-data"))
            return;
        const l = s.attr("name")
          , c = s.attr("type")
          , u = i.nodeName.toLowerCase();
        if (!(r.indexOf(c) >= 0) && !(o.indexOf(l) >= 0 || !l))
            if (u === "select" && s.prop("multiple"))
                o.push(l),
                a[l] = [],
                n.find(`select[name="${l}"] option`).each(f => {
                    f.selected && a[l].push(f.value)
                }
                );
            else
                switch (c) {
                case "checkbox":
                    o.push(l),
                    a[l] = [],
                    n.find(`input[name="${l}"]`).each(f => {
                        f.checked && a[l].push(f.value)
                    }
                    );
                    break;
                case "radio":
                    o.push(l),
                    n.find(`input[name="${l}"]`).each(f => {
                        f.checked && (a[l] = f.value)
                    }
                    );
                    break;
                default:
                    a[l] = s.val();
                    break
                }
    }
    ),
    n.trigger("form:todata", a),
    t.emit("formToData", n[0], a),
    a
}
function KF(e, t) {
    const n = this
      , a = $(e).eq(0);
    if (!a.length)
        return;
    let r = t;
    const o = a.attr("id");
    if (!r && o && (r = n.form.getFormData(o)),
    !r)
        return;
    const i = ["submit", "image", "button", "file"]
      , s = [];
    a.find("input, select, textarea").each(l => {
        const c = $(l);
        if (c.hasClass("ignore-store-data") || c.hasClass("no-store-data"))
            return;
        const u = c.attr("name")
          , f = c.attr("type")
          , d = l.nodeName.toLowerCase();
        if (!(typeof r[u] > "u" || r[u] === null) && !(i.indexOf(f) >= 0) && !(s.indexOf(u) >= 0 || !u)) {
            if (d === "select" && c.prop("multiple"))
                s.push(u),
                a.find(`select[name="${u}"] option`).each(p => {
                    const h = p;
                    r[u].indexOf(p.value) >= 0 ? h.selected = !0 : h.selected = !1
                }
                );
            else
                switch (f) {
                case "checkbox":
                    s.push(u),
                    a.find(`input[name="${u}"]`).each(p => {
                        const h = p;
                        r[u].indexOf(p.value) >= 0 ? h.checked = !0 : h.checked = !1
                    }
                    );
                    break;
                case "radio":
                    s.push(u),
                    a.find(`input[name="${u}"]`).each(p => {
                        const h = p;
                        r[u] === p.value ? h.checked = !0 : h.checked = !1
                    }
                    );
                    break;
                default:
                    c.val(r[u]);
                    break
                }
            (d === "select" || d === "input" || d === "textarea") && c.trigger("change", "fromdata")
        }
    }
    ),
    a.trigger("form:fromdata", r),
    n.emit("formFromData", a[0], r)
}
function ZF() {
    const e = this
      , t = He()
      , n = Qe();
    function a(r, o) {
        const i = $(this);
        if (r.type === "change" && !i.hasClass("form-ajax-submit-onchange") || (r.type === "submit" && r.preventDefault(),
        r.type === "change" && o === "fromdata"))
            return;
        const s = (i.attr("method") || "GET").toUpperCase()
          , l = i.prop("enctype") || i.attr("enctype")
          , c = i.attr("action");
        if (!c)
            return;
        let u;
        s === "POST" ? l === "application/x-www-form-urlencoded" ? u = e.form.convertToData(i[0]) : u = new t.FormData(i[0]) : u = er(e.form.convertToData(i[0])),
        e.request({
            method: s,
            url: c,
            contentType: l,
            data: u,
            beforeSend(f) {
                i.trigger("formajax:beforesend", {
                    data: u,
                    xhr: f
                }),
                e.emit("formAjaxBeforeSend", i[0], u, f)
            },
            error(f) {
                i.trigger("formajax:error", {
                    data: u,
                    xhr: f
                }),
                e.emit("formAjaxError", i[0], u, f)
            },
            complete(f) {
                i.trigger("formajax:complete", {
                    data: u,
                    xhr: f
                }),
                e.emit("formAjaxComplete", i[0], u, f)
            },
            success(f, d, p) {
                i.trigger("formajax:success", {
                    data: u,
                    xhr: p
                }),
                e.emit("formAjaxSuccess", i[0], u, p)
            }
        })
    }
    $(n).on("submit change", "form.form-ajax-submit, form.form-ajax-submit-onchange", a)
}
const JF = {
    name: "form",
    create() {
        const e = this;
        se(e, {
            form: {
                data: {},
                storeFormData: C2.store.bind(e),
                getFormData: C2.get.bind(e),
                removeFormData: C2.remove.bind(e),
                convertToData: XF.bind(e),
                fillFromData: KF.bind(e),
                storage: {
                    init: Rp.init.bind(e),
                    destroy: Rp.destroy.bind(e)
                }
            }
        })
    },
    on: {
        init() {
            const e = this;
            ZF.call(e)
        },
        tabBeforeRemove(e) {
            const t = this;
            $(e).find(".form-store-data").each(n => {
                t.form.storage.destroy(n)
            }
            )
        },
        tabMounted(e) {
            const t = this;
            $(e).find(".form-store-data").each(n => {
                t.form.storage.init(n)
            }
            )
        },
        pageBeforeRemove(e) {
            const t = this;
            e.$el.find(".form-store-data").each(n => {
                t.form.storage.destroy(n)
            }
            )
        },
        pageInit(e) {
            const t = this;
            e.$el.find(".form-store-data").each(n => {
                t.form.storage.init(n)
            }
            )
        }
    }
}
  , In = {
    ignoreTypes: ["checkbox", "button", "submit", "range", "radio", "image"],
    createTextareaResizableShadow() {
        const e = Qe()
          , t = $(e.createElement("textarea"));
        t.addClass("textarea-resizable-shadow"),
        t.prop({
            disabled: !0,
            readonly: !0
        }),
        In.textareaResizableShadow = t
    },
    textareaResizableShadow: void 0,
    resizeTextarea(e) {
        const t = this
          , n = He()
          , a = $(e);
        In.textareaResizableShadow || In.createTextareaResizableShadow();
        const r = In.textareaResizableShadow;
        if (!a.length || !a.hasClass("resizable"))
            return;
        In.textareaResizableShadow.parents().length === 0 && t.$el.append(r);
        const o = n.getComputedStyle(a[0]);
        "padding-top padding-bottom padding-left padding-right margin-left margin-right margin-top margin-bottom width font-size font-family font-style font-weight line-height font-variant text-transform letter-spacing border box-sizing display".split(" ").forEach(c => {
            let u = o[c];
            "font-size line-height letter-spacing width".split(" ").indexOf(c) >= 0 && (u = u.replace(",", ".")),
            r.css(c, u)
        }
        );
        const i = a[0].clientHeight;
        r.val("");
        const s = r[0].scrollHeight;
        r.val(a.val()),
        r.css("height", 0);
        const l = r[0].scrollHeight;
        i !== l && (l > s ? a.css("height", `${l}px`) : l < i && a.css("height", ""),
        (l > s || l < i) && (a.trigger("textarea:resize", {
            initialHeight: s,
            currentHeight: i,
            scrollHeight: l
        }),
        t.emit("textareaResize", {
            initialHeight: s,
            currentHeight: i,
            scrollHeight: l
        })))
    },
    validate(e) {
        const t = $(e);
        if (!t.length)
            return !0;
        const n = t.parents(".item-input")
          , a = t.parents(".input");
        function r() {
            t[0].f7ValidateReadonly && (t[0].readOnly = !1)
        }
        function o() {
            t[0].f7ValidateReadonly && (t[0].readOnly = !0)
        }
        r();
        const i = t[0].validity
          , s = t.dataset().errorMessage || t[0].validationMessage || "";
        if (!i)
            return o(),
            !0;
        if (!i.valid) {
            let l = t.nextAll(".item-input-error-message, .input-error-message");
            return s && (l.length === 0 && (l = $(`<div class="${a.length ? "input-error-message" : "item-input-error-message"}"></div>`),
            l.insertAfter(t)),
            l.text(s)),
            l.length > 0 && (n.addClass("item-input-with-error-message"),
            a.addClass("input-with-error-message")),
            n.addClass("item-input-invalid"),
            a.addClass("input-invalid"),
            t.addClass("input-invalid"),
            o(),
            !1
        }
        return n.removeClass("item-input-invalid item-input-with-error-message"),
        a.removeClass("input-invalid input-with-error-message"),
        t.removeClass("input-invalid"),
        o(),
        !0
    },
    validateInputs(e) {
        const t = this;
        return $(e).find("input, textarea, select").map(a => t.input.validate(a)).indexOf(!1) < 0
    },
    focus(e) {
        const t = $(e)
          , n = t.attr("type");
        In.ignoreTypes.indexOf(n) >= 0 || (t.parents(".item-input").addClass("item-input-focused"),
        t.parents(".input").addClass("input-focused"),
        t.addClass("input-focused"))
    },
    blur(e) {
        const t = $(e);
        t.parents(".item-input").removeClass("item-input-focused"),
        t.parents(".input").removeClass("input-focused"),
        t.removeClass("input-focused")
    },
    checkEmptyState(e) {
        const t = this;
        let n = $(e);
        if (n.is("input, select, textarea, .item-input [contenteditable]") || (n = n.find("input, select, textarea, .item-input [contenteditable]").eq(0)),
        !n.length)
            return;
        const a = n[0].hasAttribute("contenteditable");
        let r;
        a ? n.find(".text-editor-placeholder").length ? r = "" : r = n.html() : r = n.val();
        const o = n.parents(".item-input")
          , i = n.parents(".input");
        r && typeof r == "string" && r.trim() !== "" || Array.isArray(r) && r.length > 0 ? (o.addClass("item-input-with-value"),
        i.addClass("input-with-value"),
        n.addClass("input-with-value"),
        n.trigger("input:notempty"),
        t.emit("inputNotEmpty", n[0])) : (o.removeClass("item-input-with-value"),
        i.removeClass("input-with-value"),
        n.removeClass("input-with-value"),
        n.trigger("input:empty"),
        t.emit("inputEmpty", n[0]))
    },
    scrollIntoView(e, t, n, a) {
        t === void 0 && (t = 0);
        const r = $(e)
          , o = r.parents(".page-content, .panel, .card-expandable .card-content").eq(0);
        if (!o.length)
            return !1;
        const i = o[0].offsetHeight
          , s = o[0].scrollTop
          , l = parseInt(o.css("padding-top"), 10)
          , c = parseInt(o.css("padding-bottom"), 10)
          , u = o.offset().top - s
          , f = r.offset().top - u
          , d = r[0].offsetHeight
          , p = f + s - l
          , h = f + s - i + c + d
          , m = p + (h - p) / 2;
        return s > p ? (o.scrollTop(n ? m : p, t),
        !0) : s < h ? (o.scrollTop(n ? m : h, t),
        !0) : (a && o.scrollTop(n ? m : h, t),
        !1)
    },
    init() {
        const e = this
          , t = yt()
          , n = He()
          , a = Qe();
        In.createTextareaResizableShadow();
        function r() {
            const u = this;
            e.params.input.scrollIntoViewOnFocus && (t.android ? $(n).once("resize", () => {
                a && a.activeElement === u && e.input.scrollIntoView(u, e.params.input.scrollIntoViewDuration, e.params.input.scrollIntoViewCentered, e.params.input.scrollIntoViewAlways)
            }
            ) : e.input.scrollIntoView(u, e.params.input.scrollIntoViewDuration, e.params.input.scrollIntoViewCentered, e.params.input.scrollIntoViewAlways)),
            e.input.focus(u)
        }
        function o() {
            const u = $(this)
              , f = u[0].nodeName.toLowerCase();
            e.input.blur(u),
            (u.dataset().validate || u.attr("validate") !== null || u.attr("data-validate-on-blur") !== null) && e.input.validate(u),
            f === "textarea" && u.hasClass("resizable") && In.textareaResizableShadow && In.textareaResizableShadow.remove()
        }
        function i() {
            const u = $(this)
              , f = u.attr("type")
              , d = u[0].nodeName.toLowerCase()
              , p = u[0].hasAttribute("contenteditable");
            In.ignoreTypes.indexOf(f) >= 0 || (e.input.checkEmptyState(u),
            !p && (u.attr("data-validate-on-blur") === null && (u.dataset().validate || u.attr("validate") !== null) && e.input.validate(u),
            d === "textarea" && u.hasClass("resizable") && e.input.resizeTextarea(u)))
        }
        function s(u) {
            const f = $(this);
            f.attr("data-validate-on-blur") === null && (f.dataset().validate || f.attr("validate") !== null) && (u.preventDefault(),
            e.input.validate(f))
        }
        function l() {
            const f = $(this).siblings("input, textarea").eq(0)
              , d = f.val();
            f.val("").trigger("input change").focus().trigger("input:clear", d),
            e.emit("inputClear", d)
        }
        function c(u) {
            u.preventDefault()
        }
        $(a).on("click", ".input-clear-button", l),
        $(a).on("mousedown", ".input-clear-button", c),
        $(a).on("change input", "input, textarea, select, .item-input [contenteditable]", i, !0),
        $(a).on("focus", "input, textarea, select, .item-input [contenteditable]", r, !0),
        $(a).on("blur", "input, textarea, select, .item-input [contenteditable]", o, !0),
        $(a).on("invalid", "input, textarea, select", s, !0)
    }
}
  , QF = {
    name: "input",
    params: {
        input: {
            scrollIntoViewOnFocus: void 0,
            scrollIntoViewCentered: !1,
            scrollIntoViewDuration: 0,
            scrollIntoViewAlways: !1
        }
    },
    create() {
        const e = this;
        typeof e.params.input.scrollIntoViewOnFocus > "u" && (e.params.input.scrollIntoViewOnFocus = yt().android),
        hn(e, {
            input: In
        })
    },
    on: {
        init() {
            this.input.init()
        },
        tabMounted(e) {
            const t = this
              , n = $(e);
            n.find(".item-input, .input").each(a => {
                $(a).find("input, select, textarea, [contenteditable]").each(o => {
                    const i = $(o);
                    In.ignoreTypes.indexOf(i.attr("type")) >= 0 || t.input.checkEmptyState(i)
                }
                )
            }
            ),
            n.find("textarea.resizable").each(a => {
                t.input.resizeTextarea(a)
            }
            )
        },
        pageInit(e) {
            const t = this
              , n = e.$el;
            n.find(".item-input, .input").each(a => {
                $(a).find("input, select, textarea, [contenteditable]").each(o => {
                    const i = $(o);
                    In.ignoreTypes.indexOf(i.attr("type")) >= 0 || t.input.checkEmptyState(i)
                }
                )
            }
            ),
            n.find("textarea.resizable").each(a => {
                t.input.resizeTextarea(a)
            }
            )
        },
        "panelBreakpoint panelCollapsedBreakpoint panelResize panelOpen panelSwipeOpen resize viewMasterDetailBreakpoint": function(t) {
            const n = this;
            t && t.$el ? t.$el.find("textarea.resizable").each(a => {
                n.input.resizeTextarea(a)
            }
            ) : $("textarea.resizable").each(a => {
                n.input.resizeTextarea(a)
            }
            )
        }
    }
}
  , ej = {
    name: "checkbox"
}
  , tj = {
    name: "radio"
};
let Dp = class extends Bt {
    constructor(t, n) {
        n === void 0 && (n = {}),
        super(n, [t]);
        const a = this
          , r = Mt()
          , o = {};
        a.useModulesParams(o),
        a.params = se(o, n);
        const i = a.params.el;
        if (!i)
            return a;
        const s = $(i);
        if (s.length === 0)
            return a;
        if (s[0].f7Toggle)
            return s[0].f7Toggle;
        const l = s.children('input[type="checkbox"]');
        se(a, {
            app: t,
            $el: s,
            el: s[0],
            $inputEl: l,
            inputEl: l[0],
            disabled: s.hasClass("disabled") || l.hasClass("disabled") || l.attr("disabled") || l[0].disabled
        }),
        Object.defineProperty(a, "checked", {
            enumerable: !0,
            configurable: !0,
            set(w) {
                !a || typeof a.$inputEl > "u" || a.checked !== w && (l[0].checked = w,
                a.$inputEl.trigger("change"))
            },
            get() {
                return l[0].checked
            }
        }),
        s[0].f7Toggle = a;
        let c;
        const u = {};
        let f, d, p, h, m;
        function g(w) {
            c || a.disabled || (u.x = w.type === "touchstart" ? w.targetTouches[0].pageX : w.pageX,
            u.y = w.type === "touchstart" ? w.targetTouches[0].pageY : w.pageY,
            d = 0,
            c = !0,
            f = void 0,
            h = zn(),
            m = a.checked,
            p = s[0].offsetWidth,
            un( () => {
                c && s.addClass("toggle-active-state")
            }
            ))
        }
        function b(w) {
            if (!c || a.disabled)
                return;
            const C = w.type === "touchmove" ? w.targetTouches[0].pageX : w.pageX
              , _ = w.type === "touchmove" ? w.targetTouches[0].pageY : w.pageY
              , E = t.rtl ? -1 : 1;
            if (typeof f > "u" && (f = !!(f || Math.abs(_ - u.y) > Math.abs(C - u.x))),
            f) {
                c = !1;
                return
            }
            w.preventDefault(),
            d = C - u.x;
            let z;
            d * E < 0 && Math.abs(d) > p / 3 && m && (z = !0),
            d * E > 0 && Math.abs(d) > p / 3 && !m && (z = !0),
            z && (u.x = C,
            a.checked = !m,
            m = !m)
        }
        function v() {
            if (!c || a.disabled) {
                f && s.removeClass("toggle-active-state"),
                c = !1;
                return
            }
            const w = t.rtl ? -1 : 1;
            c = !1,
            s.removeClass("toggle-active-state");
            let C;
            zn() - h < 300 && (d * w < 0 && m && (C = !0),
            d * w > 0 && !m && (C = !0),
            C && (a.checked = !m))
        }
        function y() {
            a.$el.trigger("toggle:change"),
            a.emit("local::change toggleChange", a)
        }
        a.attachEvents = function() {
            const C = r.passiveListener ? {
                passive: !0
            } : !1;
            s.on(t.touchEvents.start, g, C),
            t.on("touchmove", b),
            t.on("touchend:passive", v),
            a.$inputEl.on("change", y)
        }
        ,
        a.detachEvents = function() {
            const C = r.passiveListener ? {
                passive: !0
            } : !1;
            s.off(t.touchEvents.start, g, C),
            t.off("touchmove", b),
            t.off("touchend:passive", v),
            a.$inputEl.off("change", y)
        }
        ,
        a.useModules(),
        a.init()
    }
    toggle() {
        const t = this;
        t.checked = !t.checked
    }
    init() {
        this.attachEvents()
    }
    destroy() {
        let t = this;
        t.$el.trigger("toggle:beforedestroy"),
        t.emit("local::beforeDestroy toggleBeforeDestroy", t),
        delete t.$el[0].f7Toggle,
        t.detachEvents(),
        Yt(t),
        t = null
    }
}
;
const nj = {
    name: "toggle",
    create() {
        const e = this;
        e.toggle = Gt({
            defaultSelector: ".toggle",
            constructor: Dp,
            app: e,
            domProp: "f7Toggle"
        })
    },
    static: {
        Toggle: Dp
    },
    on: {
        tabMounted(e) {
            const t = this;
            $(e).find(".toggle-init").each(n => t.toggle.create({
                el: n
            }))
        },
        tabBeforeRemove(e) {
            $(e).find(".toggle-init").each(t => {
                t.f7Toggle && t.f7Toggle.destroy()
            }
            )
        },
        pageInit(e) {
            const t = this;
            e.$el.find(".toggle-init").each(n => t.toggle.create({
                el: n
            }))
        },
        pageBeforeRemove(e) {
            e.$el.find(".toggle-init").each(t => {
                t.f7Toggle && t.f7Toggle.destroy()
            }
            )
        }
    },
    vnode: {
        "toggle-init": {
            insert(e) {
                const t = this
                  , n = e.elm;
                t.toggle.create({
                    el: n
                })
            },
            destroy(e) {
                const t = e.elm;
                t.f7Toggle && t.f7Toggle.destroy()
            }
        }
    }
};
let Hl = class extends Bt {
    constructor(t, n) {
        super(n, [t]);
        const a = this
          , r = Mt()
          , o = {
            el: null,
            inputEl: null,
            dual: !1,
            step: 1,
            label: !1,
            min: 0,
            max: 100,
            value: 0,
            draggableBar: !0,
            vertical: !1,
            verticalReversed: !1,
            formatLabel: null,
            scale: !1,
            scaleSteps: 5,
            scaleSubSteps: 0,
            formatScaleLabel: null,
            limitKnobPosition: t.theme === "ios"
        };
        a.useModulesParams(o),
        a.params = se(o, n);
        const i = a.params.el;
        if (!i)
            return a;
        const s = $(i);
        if (s.length === 0)
            return a;
        if (s[0].f7Range)
            return s[0].f7Range;
        const l = s.dataset();
        "step min max value scaleSteps scaleSubSteps".split(" ").forEach(Se => {
            typeof n[Se] > "u" && typeof l[Se] < "u" && (a.params[Se] = parseFloat(l[Se]))
        }
        ),
        "dual label vertical verticalReversed scale".split(" ").forEach(Se => {
            typeof n[Se] > "u" && typeof l[Se] < "u" && (a.params[Se] = l[Se])
        }
        ),
        a.params.value || (typeof l.value < "u" && (a.params.value = l.value),
        typeof l.valueLeft < "u" && typeof l.valueRight < "u" && (a.params.value = [parseFloat(l.valueLeft), parseFloat(l.valueRight)]));
        let c;
        a.params.dual || (a.params.inputEl ? c = $(a.params.inputEl) : s.find('input[type="range"]').length && (c = s.find('input[type="range"]').eq(0)));
        const {dual: u, step: f, label: d, min: p, max: h, value: m, vertical: g, verticalReversed: b, scale: v, scaleSteps: y, scaleSubSteps: w, limitKnobPosition: C} = a.params;
        se(a, {
            app: t,
            $el: s,
            el: s[0],
            $inputEl: c,
            inputEl: c ? c[0] : void 0,
            dual: u,
            step: f,
            label: d,
            min: p,
            max: h,
            value: m,
            previousValue: m,
            vertical: g,
            verticalReversed: b,
            scale: v,
            scaleSteps: y,
            scaleSubSteps: w,
            limitKnobPosition: C
        }),
        c && ("step min max".split(" ").forEach(Se => {
            !n[Se] && c.attr(Se) && (a.params[Se] = parseFloat(c.attr(Se)),
            a[Se] = parseFloat(c.attr(Se)))
        }
        ),
        typeof c.val() < "u" && (a.params.value = parseFloat(c.val()),
        a.value = parseFloat(c.val()))),
        a.dual && s.addClass("range-slider-dual"),
        a.label && s.addClass("range-slider-label"),
        a.vertical ? (s.addClass("range-slider-vertical"),
        a.verticalReversed && s.addClass("range-slider-vertical-reversed")) : s.addClass("range-slider-horizontal");
        const _ = $('<div class="range-bar"></div>')
          , E = $('<div class="range-bar-active"></div>');
        _.append(E);
        const z = `
      <div class="range-knob-wrap">
        <div class="range-knob"></div>
        ${a.label ? '<div class="range-knob-label"></div>' : ""}
      </div>
    `
          , T = [$(z)];
        a.dual && T.push($(z)),
        s.append(_),
        T.forEach(Se => {
            s.append(Se)
        }
        );
        const A = [];
        a.label && (A.push(T[0].find(".range-knob-label")),
        a.dual && A.push(T[1].find(".range-knob-label")));
        let x;
        a.scale && a.scaleSteps >= 1 && (x = $(`
        <div class="range-scale">
          ${a.renderScale()}
        </div>
      `),
        s.append(x)),
        se(a, {
            knobs: T,
            labels: A,
            $barEl: _,
            $barActiveEl: E,
            $scaleEl: x
        }),
        s[0].f7Range = a;
        let M;
        const L = {};
        let U, Y, H, W, j, Q, ne, re;
        function ve() {
            ne = !0
        }
        function Ne(Se) {
            if (M || !a.params.draggableBar && $(Se.target).closest(".range-knob").length === 0)
                return;
            ne = !1,
            L.x = Se.type === "touchstart" ? Se.targetTouches[0].pageX : Se.pageX,
            L.y = Se.type === "touchstart" ? Se.targetTouches[0].pageY : Se.pageY,
            Se.type === "touchstart" && (re = Se.targetTouches[0].identifier),
            M = !0,
            U = void 0,
            Y = s.offset(),
            H = Y.left,
            W = Y.top;
            let Re;
            a.vertical ? (Re = (L.y - W) / a.rangeHeight,
            a.verticalReversed || (Re = 1 - Re)) : a.app.rtl ? Re = (H + a.rangeWidth - L.x) / a.rangeWidth : Re = (L.x - H) / a.rangeWidth;
            let Ve = Re * (a.max - a.min) + a.min;
            a.dual ? Math.abs(a.value[0] - Ve) < Math.abs(a.value[1] - Ve) ? (Q = 0,
            j = a.knobs[0],
            Ve = [Ve, a.value[1]]) : (Q = 1,
            j = a.knobs[1],
            Ve = [a.value[0], Ve]) : (j = a.knobs[0],
            Ve = Re * (a.max - a.min) + a.min),
            un( () => {
                M && j.addClass("range-knob-active-state")
            }
            , 70),
            a.on("change", ve),
            a.setValue(Ve, !0)
        }
        function Ge(Se) {
            if (!M)
                return;
            let Re, Ve;
            if (Se.type === "touchmove")
                for (let Z = 0; Z < Se.targetTouches.length; Z += 1)
                    Se.targetTouches[Z].identifier === re && (Re = Se.targetTouches[Z].pageX,
                    Ve = Se.targetTouches[Z].pageY);
            else
                Re = Se.pageX,
                Ve = Se.pageY;
            if (typeof Re > "u" && typeof Ve > "u")
                return;
            if (typeof U > "u" && !a.vertical && (U = !!(U || Math.abs(Ve - L.y) > Math.abs(Re - L.x))),
            U) {
                M = !1;
                return
            }
            Se.preventDefault();
            let Ze;
            a.vertical ? (Ze = (Ve - W) / a.rangeHeight,
            a.verticalReversed || (Ze = 1 - Ze)) : a.app.rtl ? Ze = (H + a.rangeWidth - Re) / a.rangeWidth : Ze = (Re - H) / a.rangeWidth;
            let q = Ze * (a.max - a.min) + a.min;
            if (a.dual) {
                let Z, de;
                Q === 0 ? (Z = q,
                de = a.value[1],
                Z > de && (de = Z)) : (Z = a.value[0],
                de = q,
                de < Z && (Z = de)),
                q = [Z, de]
            }
            a.setValue(q, !0)
        }
        function Ye(Se) {
            if (Se.type === "touchend") {
                let Re;
                for (let Ve = 0; Ve < Se.changedTouches.length; Ve += 1)
                    Se.changedTouches[Ve].identifier === re && (Re = !0);
                if (!Re)
                    return
            }
            if (!M) {
                U && j.removeClass("range-knob-active-state"),
                M = !1;
                return
            }
            a.off("change", ve),
            M = !1,
            j.removeClass("range-knob-active-state"),
            ne && a.$inputEl && !a.dual && a.$inputEl.trigger("change"),
            ne = !1,
            typeof a.previousValue < "u" && (a.dual && (a.previousValue[0] !== a.value[0] || a.previousValue[1] !== a.value[1]) || !a.dual && a.previousValue !== a.value) && (a.$el.trigger("range:changed", a.value),
            a.emit("local::changed rangeChanged", a, a.value))
        }
        function tt() {
            a.calcSize(),
            a.layout()
        }
        let ee, ye, Le;
        return a.attachEvents = function() {
            const Re = r.passiveListener ? {
                passive: !0
            } : !1;
            a.$el.on(t.touchEvents.start, Ne, Re),
            t.on("touchmove", Ge),
            t.on("touchend:passive", Ye),
            t.on("tabShow", tt),
            t.on("resize", tt),
            ee = a.$el.parents(".sheet-modal, .actions-modal, .popup, .popover, .login-screen, .dialog, .toast"),
            ee.on("modal:open", tt),
            ye = a.$el.parents(".panel"),
            ye.on("panel:open panel:resize", tt),
            Le = a.$el.parents(".page").eq(0),
            Le.on("page:reinit", tt)
        }
        ,
        a.detachEvents = function() {
            const Re = r.passiveListener ? {
                passive: !0
            } : !1;
            a.$el.off(t.touchEvents.start, Ne, Re),
            t.off("touchmove", Ge),
            t.off("touchend:passive", Ye),
            t.off("tabShow", tt),
            t.off("resize", tt),
            ee && ee.off("modal:open", tt),
            ye && ye.off("panel:open panel:resize", tt),
            Le && Le.off("page:reinit", tt),
            ee = null,
            ye = null,
            Le = null
        }
        ,
        a.useModules(),
        a.init(),
        a
    }
    calcSize() {
        const t = this;
        if (t.vertical) {
            const n = t.$el.outerHeight();
            if (n === 0)
                return;
            t.rangeHeight = n,
            t.knobHeight = t.knobs[0].outerHeight()
        } else {
            const n = t.$el.outerWidth();
            if (n === 0)
                return;
            t.rangeWidth = n,
            t.knobWidth = t.knobs[0].outerWidth()
        }
    }
    layout() {
        const t = this
          , {app: n, knobWidth: a, knobHeight: r, rangeWidth: o, rangeHeight: i, min: s, max: l, knobs: c, $barActiveEl: u, value: f, label: d, labels: p, vertical: h, verticalReversed: m, limitKnobPosition: g} = t
          , b = h ? r : a
          , v = h ? i : o
          , y = h ? m ? "top" : "bottom" : n.rtl ? "right" : "left";
        if (t.dual) {
            const w = [(f[0] - s) / (l - s), (f[1] - s) / (l - s)];
            u.css({
                [y]: `${w[0] * 100}%`,
                [h ? "height" : "width"]: `${(w[1] - w[0]) * 100}%`
            }),
            c.forEach( (C, _) => {
                let E = v * w[_];
                if (g) {
                    const z = v * w[_] - b / 2;
                    z < 0 && (E = b / 2),
                    z + b > v && (E = v - b / 2)
                }
                C.css(y, `${E}px`),
                d && p[_].text(t.formatLabel(f[_], p[_][0]))
            }
            )
        } else {
            const w = (f - s) / (l - s);
            u.css(h ? "height" : "width", `${w * 100}%`);
            let C = v * w;
            if (g) {
                const _ = v * w - b / 2;
                _ < 0 && (C = b / 2),
                _ + b > v && (C = v - b / 2)
            }
            c[0].css(y, `${C}px`),
            d && p[0].text(t.formatLabel(f, p[0][0]))
        }
        t.dual && f.indexOf(s) >= 0 || !t.dual && f === s ? t.$el.addClass("range-slider-min") : t.$el.removeClass("range-slider-min"),
        t.dual && f.indexOf(l) >= 0 || !t.dual && f === l ? t.$el.addClass("range-slider-max") : t.$el.removeClass("range-slider-max")
    }
    setValue(t, n) {
        const a = this
          , {step: r, min: o, max: i} = a;
        let s, l;
        if (a.dual) {
            l = [a.value[0], a.value[1]];
            let c = t;
            if (Array.isArray(c) || (c = [t, t]),
            t[0] > t[1] && (c = [c[0], c[0]]),
            c = c.map(u => Math.max(Math.min(Math.round(u / r) * r, i), o)),
            c[0] === a.value[0] && c[1] === a.value[1])
                return a;
            c.forEach( (u, f) => {
                a.value[f] = u
            }
            ),
            s = l[0] !== c[0] || l[1] !== c[1],
            a.layout()
        } else {
            l = a.value;
            const c = Math.max(Math.min(Math.round(t / r) * r, i), o);
            a.value = c,
            a.layout(),
            s = l !== c
        }
        return s && (a.previousValue = l),
        s && (a.$el.trigger("range:change", a.value),
        a.$inputEl && !a.dual && (a.$inputEl.val(a.value),
        n ? a.$inputEl.trigger("input") : a.$inputEl.trigger("input change")),
        n || (a.$el.trigger("range:changed", a.value),
        a.emit("local::changed rangeChanged", a, a.value)),
        a.emit("local::change rangeChange", a, a.value)),
        a
    }
    getValue() {
        return this.value
    }
    formatLabel(t, n) {
        const a = this;
        return a.params.formatLabel ? a.params.formatLabel.call(a, t, n) : t
    }
    formatScaleLabel(t) {
        const n = this;
        return n.params.formatScaleLabel ? n.params.formatScaleLabel.call(n, t) : t
    }
    renderScale() {
        const t = this
          , {app: n, verticalReversed: a, vertical: r} = t
          , o = r ? a ? "top" : "bottom" : n.rtl ? "right" : "left";
        let i = "";
        return Array.from({
            length: t.scaleSteps + 1
        }).forEach( (s, l) => {
            const c = (t.max - t.min) / t.scaleSteps
              , u = t.min + c * l
              , f = (u - t.min) / (t.max - t.min);
            i += `<div class="range-scale-step" style="${o}: ${f * 100}%">${t.formatScaleLabel(u)}</div>`,
            t.scaleSubSteps && t.scaleSubSteps > 1 && l < t.scaleSteps && Array.from({
                length: t.scaleSubSteps - 1
            }).forEach( (d, p) => {
                const h = c / t.scaleSubSteps
                  , g = (u + h * (p + 1) - t.min) / (t.max - t.min);
                i += `<div class="range-scale-step range-scale-substep" style="${o}: ${g * 100}%"></div>`
            }
            )
        }
        ),
        i
    }
    updateScale() {
        const t = this;
        if (!t.scale || t.scaleSteps < 1) {
            t.$scaleEl && t.$scaleEl.remove(),
            delete t.$scaleEl;
            return
        }
        t.$scaleEl || (t.$scaleEl = $('<div class="range-scale"></div>'),
        t.$el.append(t.$scaleEl)),
        t.$scaleEl.html(t.renderScale())
    }
    init() {
        const t = this;
        return t.calcSize(),
        t.layout(),
        t.attachEvents(),
        t
    }
    destroy() {
        let t = this;
        t.$el.trigger("range:beforedestroy"),
        t.emit("local::beforeDestroy rangeBeforeDestroy", t),
        delete t.$el[0].f7Range,
        t.detachEvents(),
        Yt(t),
        t = null
    }
}
;
const aj = {
    name: "range",
    create() {
        const e = this;
        e.range = se(Gt({
            defaultSelector: ".range-slider",
            constructor: Hl,
            app: e,
            domProp: "f7Range"
        }), {
            getValue(t) {
                t === void 0 && (t = ".range-slider");
                const n = e.range.get(t);
                if (n)
                    return n.getValue()
            },
            setValue(t, n) {
                t === void 0 && (t = ".range-slider");
                const a = e.range.get(t);
                if (a)
                    return a.setValue(n)
            }
        })
    },
    static: {
        Range: Hl
    },
    on: {
        tabMounted(e) {
            const t = this;
            $(e).find(".range-slider-init").each(n => new Hl(t,{
                el: n
            }))
        },
        tabBeforeRemove(e) {
            $(e).find(".range-slider-init").each(t => {
                t.f7Range && t.f7Range.destroy()
            }
            )
        },
        pageInit(e) {
            const t = this;
            e.$el.find(".range-slider-init").each(n => new Hl(t,{
                el: n
            }))
        },
        pageBeforeRemove(e) {
            e.$el.find(".range-slider-init").each(t => {
                t.f7Range && t.f7Range.destroy()
            }
            )
        }
    },
    vnode: {
        "range-slider-init": {
            insert(e) {
                const t = e.elm;
                this.range.create({
                    el: t
                })
            },
            destroy(e) {
                const t = e.elm;
                t.f7Range && t.f7Range.destroy()
            }
        }
    }
};
let Np = class extends Bt {
    constructor(t, n) {
        super(n, [t]);
        const a = this
          , r = {
            el: null,
            inputEl: null,
            valueEl: null,
            value: 0,
            formatValue: null,
            step: 1,
            min: 0,
            max: 100,
            watchInput: !0,
            autorepeat: !1,
            autorepeatDynamic: !1,
            wraps: !1,
            manualInputMode: !1,
            decimalPoint: 4,
            buttonsEndInputMode: !0
        };
        a.useModulesParams(r),
        a.params = se(r, n),
        a.params.value < a.params.min && (a.params.value = a.params.min),
        a.params.value > a.params.max && (a.params.value = a.params.max);
        const o = a.params.el;
        if (!o)
            return a;
        const i = $(o);
        if (i.length === 0)
            return a;
        if (i[0].f7Stepper)
            return i[0].f7Stepper;
        let s;
        if (a.params.inputEl ? s = $(a.params.inputEl) : i.find(".stepper-input-wrap").find("input, textarea").length && (s = i.find(".stepper-input-wrap").find("input, textarea").eq(0)),
        s && s.length) {
            "step min max".split(" ").forEach(re => {
                !n[re] && s.attr(re) && (a.params[re] = parseFloat(s.attr(re)))
            }
            );
            const Q = parseInt(a.params.decimalPoint, 10);
            Number.isNaN(Q) ? a.params.decimalPoint = 0 : a.params.decimalPoint = Q;
            const ne = parseFloat(s.val());
            typeof n.value > "u" && !Number.isNaN(ne) && (ne || ne === 0) && (a.params.value = ne)
        }
        let l;
        a.params.valueEl ? l = $(a.params.valueEl) : i.find(".stepper-value").length && (l = i.find(".stepper-value").eq(0));
        const c = i.find(".stepper-button-plus")
          , u = i.find(".stepper-button-minus")
          , {step: f, min: d, max: p, value: h, decimalPoint: m} = a.params;
        se(a, {
            app: t,
            $el: i,
            el: i[0],
            $buttonPlusEl: c,
            buttonPlusEl: c[0],
            $buttonMinusEl: u,
            buttonMinusEl: u[0],
            $inputEl: s,
            inputEl: s ? s[0] : void 0,
            $valueEl: l,
            valueEl: l ? l[0] : void 0,
            step: f,
            min: d,
            max: p,
            value: h,
            decimalPoint: m,
            typeModeChanged: !1
        }),
        i[0].f7Stepper = a;
        const g = {};
        let b, v, y, w, C, _ = null, E = !1, z = !1;
        function T(Q, ne, re, ve, Ne, Ge) {
            clearTimeout(C),
            C = setTimeout( () => {
                Q === 1 && (y = !0,
                E = !0),
                clearInterval(w),
                Ge(),
                w = setInterval( () => {
                    Ge()
                }
                , Ne),
                Q < ne && T(Q + 1, ne, re, ve, Ne / 2, Ge)
            }
            , Q === 1 ? re : ve)
        }
        function A(Q) {
            if (b || z || ($(Q.target).closest(c).length ? _ = "increment" : $(Q.target).closest(u).length && (_ = "decrement"),
            !_))
                return;
            g.x = Q.type === "touchstart" ? Q.targetTouches[0].pageX : Q.pageX,
            g.y = Q.type === "touchstart" ? Q.targetTouches[0].pageY : Q.pageY,
            b = !0,
            v = void 0;
            const ne = a.params.autorepeatDynamic ? 4 : 1;
            T(1, ne, 500, 1e3, 300, () => {
                a[_]()
            }
            )
        }
        function x(Q) {
            if (!b || z)
                return;
            const ne = Q.type === "touchmove" ? Q.targetTouches[0].pageX : Q.pageX
              , re = Q.type === "touchmove" ? Q.targetTouches[0].pageY : Q.pageY;
            typeof v > "u" && !E && (v = !!(v || Math.abs(re - g.y) > Math.abs(ne - g.x)));
            const ve = ((ne - g.x) ** 2 + (re - g.y) ** 2) ** .5;
            (v || ve > 20) && (b = !1,
            clearTimeout(C),
            clearInterval(w))
        }
        function M() {
            clearTimeout(C),
            clearInterval(w),
            _ = null,
            E = !1,
            b = !1
        }
        function L() {
            if (z) {
                a.params.buttonsEndInputMode && (z = !1,
                a.endTypeMode(!0));
                return
            }
            if (y) {
                y = !1;
                return
            }
            a.decrement(!0)
        }
        function U() {
            if (z) {
                a.params.buttonsEndInputMode && (z = !1,
                a.endTypeMode(!0));
                return
            }
            if (y) {
                y = !1;
                return
            }
            a.increment(!0)
        }
        function Y(Q) {
            !Q.target.readOnly && a.params.manualInputMode && (z = !0,
            typeof Q.target.selectionStart == "number" && (Q.target.selectionStart = Q.target.value.length,
            Q.target.selectionEnd = Q.target.value.length))
        }
        function H(Q) {
            (Q.keyCode === 13 || Q.which === 13) && (Q.preventDefault(),
            z = !1,
            a.endTypeMode())
        }
        function W() {
            z = !1,
            a.endTypeMode(!0)
        }
        function j(Q) {
            if (z) {
                a.typeValue(Q.target.value);
                return
            }
            Q.detail && Q.detail.sentByF7Stepper || a.setValue(Q.target.value, !0)
        }
        return a.attachEvents = function() {
            u.on("click", L),
            c.on("click", U),
            a.params.watchInput && s && s.length && (s.on("input", j),
            s.on("click", Y),
            s.on("blur", W),
            s.on("keyup", H)),
            a.params.autorepeat && (t.on("touchstart:passive", A),
            t.on("touchmove:active", x),
            t.on("touchend:passive", M))
        }
        ,
        a.detachEvents = function() {
            u.off("click", L),
            c.off("click", U),
            a.params.watchInput && s && s.length && (s.off("input", j),
            s.off("click", Y),
            s.off("blur", W),
            s.off("keyup", H))
        }
        ,
        a.useModules(),
        a.init(),
        a
    }
    minus() {
        return this.decrement()
    }
    plus() {
        return this.increment()
    }
    decrement() {
        const t = this;
        return t.setValue(t.value - t.step, !1, !0)
    }
    increment() {
        const t = this;
        return t.setValue(t.value + t.step, !1, !0)
    }
    setValue(t, n, a) {
        const r = this
          , {step: o, min: i, max: s} = r
          , l = r.value;
        let c = Math.round(t / o) * o;
        if (r.params.wraps && a ? (c > s && (c = i),
        c < i && (c = s)) : c = Math.max(Math.min(c, s), i),
        Number.isNaN(c) && (c = l),
        r.value = c,
        !(l !== c) && !n)
            return r;
        r.$el.trigger("stepper:change", r.value);
        const f = r.formatValue(r.value);
        return r.$inputEl && r.$inputEl.length && (r.$inputEl.val(f),
        r.$inputEl.trigger("input change", {
            sentByF7Stepper: !0
        })),
        r.$valueEl && r.$valueEl.length && r.$valueEl.html(f),
        r.emit("local::change stepperChange", r, r.value),
        r
    }
    endTypeMode(t) {
        const n = this
          , {min: a, max: r} = n;
        let o = parseFloat(n.value);
        if (Number.isNaN(o) && (o = 0),
        o = Math.max(Math.min(o, r), a),
        n.value = o,
        !n.typeModeChanged)
            return n.$inputEl && n.$inputEl.length && !t && n.$inputEl.blur(),
            n;
        n.typeModeChanged = !1,
        n.$el.trigger("stepper:change", n.value);
        const i = n.formatValue(n.value);
        return n.$inputEl && n.$inputEl.length && (n.$inputEl.val(i),
        n.$inputEl.trigger("input change", {
            sentByF7Stepper: !0
        }),
        t || n.$inputEl.blur()),
        n.$valueEl && n.$valueEl.length && n.$valueEl.html(i),
        n.emit("local::change stepperChange", n, n.value),
        n
    }
    typeValue(t) {
        const n = this;
        n.typeModeChanged = !0;
        let a = String(t);
        if (a.length === 1 && a === "-")
            return n;
        if (a.lastIndexOf(".") + 1 === a.length || a.lastIndexOf(",") + 1 === a.length) {
            if (a.lastIndexOf(".") !== a.indexOf(".") || a.lastIndexOf(",") !== a.indexOf(","))
                return a = a.slice(0, -1),
                n.value = a,
                n.$inputEl.val(n.value),
                n
        } else {
            let r = parseFloat(a.replace(",", "."));
            if (r === 0)
                return n.value = a.replace(",", "."),
                n.$inputEl.val(n.value),
                n;
            if (Number.isNaN(r))
                return n.value = 0,
                n.$inputEl.val(n.value),
                n;
            const o = 10 ** n.params.decimalPoint;
            return r = Math.round(r * o).toFixed(n.params.decimalPoint + 1) / o,
            n.value = parseFloat(String(r).replace(",", ".")),
            n.$inputEl.val(n.value),
            n
        }
        return n.value = a,
        n.$inputEl.val(a),
        n
    }
    getValue() {
        return this.value
    }
    formatValue(t) {
        const n = this;
        return n.params.formatValue ? n.params.formatValue.call(n, t) : t
    }
    init() {
        const t = this;
        if (t.attachEvents(),
        t.$valueEl && t.$valueEl.length) {
            const n = t.formatValue(t.value);
            t.$valueEl.html(n)
        }
        return t
    }
    destroy() {
        let t = this;
        t.$el.trigger("stepper:beforedestroy"),
        t.emit("local::beforeDestroy stepperBeforeDestroy", t),
        delete t.$el[0].f7Stepper,
        t.detachEvents(),
        Yt(t),
        t = null
    }
}
;
const rj = {
    name: "stepper",
    create() {
        const e = this;
        e.stepper = se(Gt({
            defaultSelector: ".stepper",
            constructor: Np,
            app: e,
            domProp: "f7Stepper"
        }), {
            getValue(t) {
                t === void 0 && (t = ".stepper");
                const n = e.stepper.get(t);
                if (n)
                    return n.getValue()
            },
            setValue(t, n) {
                t === void 0 && (t = ".stepper");
                const a = e.stepper.get(t);
                if (a)
                    return a.setValue(n)
            }
        })
    },
    static: {
        Stepper: Np
    },
    on: {
        tabMounted(e) {
            const t = this;
            $(e).find(".stepper-init").each(n => {
                const a = $(n).dataset();
                t.stepper.create(se({
                    el: n
                }, a || {}))
            }
            )
        },
        tabBeforeRemove(e) {
            $(e).find(".stepper-init").each(t => {
                t.f7Stepper && t.f7Stepper.destroy()
            }
            )
        },
        pageInit(e) {
            const t = this;
            e.$el.find(".stepper-init").each(n => {
                const a = $(n).dataset();
                t.stepper.create(se({
                    el: n
                }, a || {}))
            }
            )
        },
        pageBeforeRemove(e) {
            e.$el.find(".stepper-init").each(t => {
                t.f7Stepper && t.f7Stepper.destroy()
            }
            )
        }
    },
    vnode: {
        "stepper-init": {
            insert(e) {
                const t = this
                  , n = e.elm
                  , a = $(n).dataset();
                t.stepper.create(se({
                    el: n
                }, a || {}))
            },
            destroy(e) {
                const t = e.elm;
                t.f7Stepper && t.f7Stepper.destroy()
            }
        }
    }
}
  , w2 = [{
    base: "A",
    letters: "A"
}, {
    base: "AA",
    letters: ""
}, {
    base: "AE",
    letters: ""
}, {
    base: "AO",
    letters: ""
}, {
    base: "AU",
    letters: ""
}, {
    base: "AV",
    letters: ""
}, {
    base: "AY",
    letters: ""
}, {
    base: "B",
    letters: "B"
}, {
    base: "C",
    letters: "C"
}, {
    base: "D",
    letters: "D"
}, {
    base: "DZ",
    letters: ""
}, {
    base: "Dz",
    letters: ""
}, {
    base: "E",
    letters: "E"
}, {
    base: "F",
    letters: "F"
}, {
    base: "G",
    letters: "G"
}, {
    base: "H",
    letters: "H"
}, {
    base: "I",
    letters: "I"
}, {
    base: "J",
    letters: "J"
}, {
    base: "K",
    letters: "K"
}, {
    base: "L",
    letters: "L"
}, {
    base: "LJ",
    letters: ""
}, {
    base: "Lj",
    letters: ""
}, {
    base: "M",
    letters: "M"
}, {
    base: "N",
    letters: "N"
}, {
    base: "NJ",
    letters: ""
}, {
    base: "Nj",
    letters: ""
}, {
    base: "O",
    letters: "O"
}, {
    base: "OI",
    letters: ""
}, {
    base: "OO",
    letters: ""
}, {
    base: "OU",
    letters: ""
}, {
    base: "OE",
    letters: ""
}, {
    base: "oe",
    letters: ""
}, {
    base: "P",
    letters: "P"
}, {
    base: "Q",
    letters: "Q"
}, {
    base: "R",
    letters: "R"
}, {
    base: "S",
    letters: "S"
}, {
    base: "T",
    letters: "T"
}, {
    base: "TZ",
    letters: ""
}, {
    base: "U",
    letters: "U"
}, {
    base: "V",
    letters: "V"
}, {
    base: "VY",
    letters: ""
}, {
    base: "W",
    letters: "W"
}, {
    base: "X",
    letters: "X"
}, {
    base: "Y",
    letters: "Y"
}, {
    base: "Z",
    letters: "Z"
}, {
    base: "a",
    letters: "a"
}, {
    base: "aa",
    letters: ""
}, {
    base: "ae",
    letters: ""
}, {
    base: "ao",
    letters: ""
}, {
    base: "au",
    letters: ""
}, {
    base: "av",
    letters: ""
}, {
    base: "ay",
    letters: ""
}, {
    base: "b",
    letters: "b"
}, {
    base: "c",
    letters: "c"
}, {
    base: "d",
    letters: "d"
}, {
    base: "dz",
    letters: ""
}, {
    base: "e",
    letters: "e"
}, {
    base: "f",
    letters: "f"
}, {
    base: "g",
    letters: "g"
}, {
    base: "h",
    letters: "h"
}, {
    base: "hv",
    letters: ""
}, {
    base: "i",
    letters: "i"
}, {
    base: "j",
    letters: "j"
}, {
    base: "k",
    letters: "k"
}, {
    base: "l",
    letters: "l"
}, {
    base: "lj",
    letters: ""
}, {
    base: "m",
    letters: "m"
}, {
    base: "n",
    letters: "n"
}, {
    base: "nj",
    letters: ""
}, {
    base: "o",
    letters: "o"
}, {
    base: "oi",
    letters: ""
}, {
    base: "ou",
    letters: ""
}, {
    base: "oo",
    letters: ""
}, {
    base: "p",
    letters: "p"
}, {
    base: "q",
    letters: "q"
}, {
    base: "r",
    letters: "r"
}, {
    base: "s",
    letters: "s"
}, {
    base: "t",
    letters: "t"
}, {
    base: "tz",
    letters: ""
}, {
    base: "u",
    letters: "u"
}, {
    base: "v",
    letters: "v"
}, {
    base: "vy",
    letters: ""
}, {
    base: "w",
    letters: "w"
}, {
    base: "x",
    letters: "x"
}, {
    base: "y",
    letters: "y"
}, {
    base: "z",
    letters: "z"
}]
  , Hh = {};
for (let e = 0; e < w2.length; e += 1) {
    const t = w2[e].letters;
    for (let n = 0; n < t.length; n += 1)
        Hh[t[n]] = w2[e].base
}
function o1(e) {
    return e.replace(/[^\u0000-\u007E]/g, t => Hh[t] || t)
}
let Hp = class extends Bt {
    constructor(t, n) {
        n === void 0 && (n = {}),
        super(n, [t]);
        const a = this
          , r = se({
            on: {}
        }, t.params.smartSelect);
        typeof r.searchbarDisableButton > "u" && (r.searchbarDisableButton = t.theme !== "aurora"),
        a.useModulesParams(r),
        a.params = se({}, r, n),
        a.app = t;
        const o = $(a.params.el).eq(0);
        if (o.length === 0)
            return a;
        if (o[0].f7SmartSelect)
            return o[0].f7SmartSelect;
        const i = o.find("select").eq(0);
        if (i.length === 0)
            return a;
        let s;
        a.params.setValueText && (s = $(a.params.valueEl),
        s.length === 0 && (s = o.find(".item-after")),
        s.length === 0 && (s = $('<div class="item-after"></div>'),
        s.insertAfter(o.find(".item-title"))));
        let l = n.url;
        l || (o.attr("href") && o.attr("href") !== "#" ? l = o.attr("href") : i.attr("name") && (l = `${i.attr("name").toLowerCase()}-select/`)),
        l || (l = a.params.url);
        const c = i[0].multiple
          , u = c ? "checkbox" : "radio"
          , f = ac();
        se(a, {
            $el: o,
            el: o[0],
            $selectEl: i,
            selectEl: i[0],
            $valueEl: s,
            valueEl: s && s[0],
            url: l,
            multiple: c,
            inputType: u,
            id: f,
            inputName: `${u}-${f}`,
            selectName: i.attr("name"),
            maxLength: i.attr("maxlength") || n.maxLength
        }),
        o[0].f7SmartSelect = a;
        function d() {
            a.open()
        }
        function p() {
            const m = a.$selectEl.val();
            a.$el.trigger("smartselect:change", m),
            a.emit("local::change smartSelectChange", a, m),
            a.vl && a.vl.clearCache(),
            a.setValueText()
        }
        a.attachEvents = function() {
            o.on("click", d),
            o.on("change", "select", p)
        }
        ,
        a.detachEvents = function() {
            o.off("click", d),
            o.off("change", "select", p)
        }
        ;
        function h() {
            let m, g;
            const b = this
              , v = b.value;
            let y = [], w;
            if (b.type === "checkbox") {
                for (let C = 0; C < a.selectEl.options.length; C += 1)
                    m = a.selectEl.options[C],
                    m.value === v && (m.selected = b.checked),
                    m.selected && (w = m.dataset ? m.dataset.displayAs : $(m).data("display-value-as"),
                    g = w && typeof w < "u" ? w : m.textContent,
                    y.push(g.trim()));
                a.maxLength && a.checkMaxLength()
            } else
                m = a.$selectEl.find(`option[value="${v}"]`)[0],
                m || (m = a.$selectEl.find("option").filter(C => C.value === v)[0]),
                w = m.dataset ? m.dataset.displayAs : $(m).data("display-as"),
                g = w && typeof w < "u" ? w : m.textContent,
                y = [g],
                a.selectEl.value = v;
            a.$selectEl.trigger("change"),
            a.params.setValueText && a.formatValueTextContent(y),
            a.params.closeOnSelect && a.inputType === "radio" && a.close()
        }
        return a.attachInputsEvents = function() {
            a.$containerEl.on("change", 'input[type="checkbox"], input[type="radio"]', h)
        }
        ,
        a.detachInputsEvents = function() {
            a.$containerEl.off("change", 'input[type="checkbox"], input[type="radio"]', h)
        }
        ,
        a.useModules(),
        a.init(),
        a
    }
    setValue(t) {
        const n = this;
        let a = t, r = [], o, i, s;
        if (n.multiple) {
            Array.isArray(a) || (a = [a]);
            for (let l = 0; l < n.selectEl.options.length; l += 1)
                o = n.selectEl.options[l],
                a.indexOf(o.value) >= 0 ? o.selected = !0 : o.selected = !1,
                o.selected && (i = o.dataset ? o.dataset.displayAs : $(o).data("display-value-as"),
                s = i && typeof i < "u" ? i : o.textContent,
                r.push(s.trim()))
        } else
            o = n.$selectEl.find(`option[value="${a}"]`)[0],
            o && (i = o.dataset ? o.dataset.displayAs : $(o).data("display-as"),
            s = i && typeof i < "u" ? i : o.textContent,
            r = [s]),
            n.selectEl.value = a;
        return n.params.setValueText && n.formatValueTextContent(r),
        n.$selectEl.trigger("change"),
        n
    }
    unsetValue() {
        const t = this;
        t.params.setValueText && t.formatValueTextContent([]),
        t.$selectEl.find("option").each(n => {
            n.selected = !1,
            n.checked = !1
        }
        ),
        t.$selectEl[0].value = null,
        t.$containerEl && t.$containerEl.find(`input[name="${t.inputName}"][type="checkbox"], input[name="${t.inputName}"][type="radio"]`).prop("checked", !1),
        t.$selectEl.trigger("change")
    }
    getValue() {
        return this.$selectEl.val()
    }
    get view() {
        const {params: t, $el: n} = this;
        let a;
        if (t.view && (a = t.view),
        a || (a = n.parents(".view").length && n.parents(".view")[0].f7View),
        !a && t.openIn === "page")
            throw Error("Smart Select requires initialized View");
        return a
    }
    checkMaxLength() {
        const t = this
          , n = t.$containerEl;
        t.selectEl.selectedOptions.length >= t.maxLength ? n.find('input[type="checkbox"]').each(a => {
            a.checked ? $(a).parents("li").removeClass("disabled") : $(a).parents("li").addClass("disabled")
        }
        ) : n.find(".disabled").removeClass("disabled")
    }
    formatValueTextContent(t) {
        const n = this
          , a = n.formatValueText(t);
        a.includes("<") && a.includes(">") ? n.$valueEl.html(a) : n.$valueEl.text(a)
    }
    formatValueText(t) {
        const n = this;
        let a;
        return n.params.formatValueText ? a = n.params.formatValueText.call(n, t, n) : a = t.join(", "),
        a
    }
    setValueText(t) {
        const n = this;
        let a = [];
        typeof t < "u" ? Array.isArray(t) ? a = t : a = [t] : n.$selectEl.find("option").each(r => {
            const o = $(r);
            if (r.selected) {
                const i = r.dataset ? r.dataset.displayAs : o.data("display-value-as");
                i && typeof i < "u" ? a.push(i) : a.push(r.textContent.trim())
            }
        }
        ),
        n.params.setValueText && n.formatValueTextContent(a)
    }
    getItemsData() {
        const t = this
          , n = t.app.theme
          , a = [];
        let r;
        return t.$selectEl.find("option").each(o => {
            const i = $(o)
              , s = i.dataset()
              , l = s.optionImage || t.params.optionImage
              , c = s.optionIcon || t.params.optionIcon
              , u = n === "ios" && (s.optionIconIos || t.params.optionIconIos)
              , f = n === "md" && (s.optionIconMd || t.params.optionIconMd)
              , d = n === "aurora" && (s.optionIconAurora || t.params.optionIconAurora)
              , p = l || c || u || f || d
              , h = s.optionColor;
            let m = s.optionClass || "";
            i[0].disabled && (m += " disabled");
            const g = i.parent("optgroup")[0]
              , b = g && g.label;
            let v = !1;
            g && g !== r && (v = !0,
            r = g,
            a.push({
                groupLabel: b,
                isLabel: v
            })),
            a.push({
                value: i[0].value,
                text: i[0].textContent.trim(),
                selected: i[0].selected,
                groupEl: g,
                groupLabel: b,
                image: l,
                icon: c,
                iconIos: u,
                iconMd: f,
                iconAurora: d,
                color: h,
                className: m,
                disabled: i[0].disabled,
                id: t.id,
                hasMedia: p,
                checkbox: t.inputType === "checkbox",
                radio: t.inputType === "radio",
                inputName: t.inputName,
                inputType: t.inputType
            })
        }
        ),
        t.items = a,
        a
    }
    renderSearchbar() {
        const t = this;
        return t.params.renderSearchbar ? t.params.renderSearchbar.call(t) : R("form", {
            class: "searchbar"
        }, R("div", {
            class: "searchbar-inner"
        }, R("div", {
            class: "searchbar-input-wrap"
        }, R("input", {
            type: "search",
            spellcheck: t.params.searchbarSpellcheck || "false",
            placeholder: t.params.searchbarPlaceholder
        }), R("i", {
            class: "searchbar-icon"
        }), R("span", {
            class: "input-clear-button"
        })), t.params.searchbarDisableButton && R("span", {
            class: "searchbar-disable-button"
        }, t.params.searchbarDisableText)))
    }
    renderItem(t, n) {
        const a = this;
        if (a.params.renderItem)
            return a.params.renderItem.call(a, t, n);
        function r(s) {
            return s === void 0 && (s = ""),
            s.indexOf(":") >= 0 ? s.split(":")[1] : ""
        }
        function o(s) {
            if (s === void 0 && (s = ""),
            s.indexOf(":") >= 0) {
                let l = s.split(":")[0];
                return l === "f7" && (l = "f7-icons"),
                l === "material" && (l = "material-icons"),
                l
            }
            return s
        }
        let i;
        if (t.isLabel)
            i = `<li class="item-divider">${t.groupLabel}</li>`;
        else {
            let s = t.selected, l;
            if (a.params.virtualList) {
                const g = a.getValue();
                s = a.multiple ? g.indexOf(t.value) >= 0 : g === t.value,
                a.multiple && (l = a.multiple && !s && g.length === parseInt(a.maxLength, 10))
            }
            const {icon: c, iconIos: u, iconMd: f, iconAurora: d} = t
              , p = c || u || f || d
              , h = r(c || u || f || d || "")
              , m = o(c || u || f || d || "");
            i = R("li", {
                class: `${t.className || ""}${l ? " disabled" : ""}`
            }, R("label", {
                class: `item-${t.inputType} item-content`
            }, R("input", {
                type: t.inputType,
                name: t.inputName,
                value: t.value,
                _checked: s
            }), R("i", {
                class: `icon icon-${t.inputType}`
            }), t.hasMedia && R("div", {
                class: "item-media"
            }, p && R("i", {
                class: `icon ${m}`
            }, h), t.image && R("img", {
                src: t.image
            })), R("div", {
                class: "item-inner"
            }, R("div", {
                class: `item-title${t.color ? ` text-color-${t.color}` : ""}`
            }, t.text))))
        }
        return i
    }
    renderItems() {
        const t = this;
        return t.params.renderItems ? t.params.renderItems.call(t, t.items) : `
      ${t.items.map( (a, r) => `${t.renderItem(a, r)}`).join("")}
    `
    }
    renderPage() {
        const t = this;
        if (t.params.renderPage)
            return t.params.renderPage.call(t, t.items);
        let n = t.params.pageTitle;
        if (typeof n > "u") {
            const r = t.$el.find(".item-title");
            n = r.length ? r.text().trim() : ""
        }
        const a = t.params.cssClass;
        return R("div", {
            class: `page smart-select-page ${a}`,
            "data-name": "smart-select-page",
            "data-select-name": t.selectName
        }, R("div", {
            class: `navbar ${t.params.navbarColorTheme ? `color-${t.params.navbarColorTheme}` : ""}`
        }, R("div", {
            class: "navbar-bg"
        }), R("div", {
            class: `navbar-inner sliding ${t.params.navbarColorTheme ? `color-${t.params.navbarColorTheme}` : ""}`
        }, R("div", {
            class: "left"
        }, R("a", {
            class: "link back"
        }, R("i", {
            class: "icon icon-back"
        }), R("span", {
            class: "if-not-md"
        }, t.params.pageBackLinkText))), n && R("div", {
            class: "title"
        }, n), t.params.searchbar && R("div", {
            class: "subnavbar"
        }, t.renderSearchbar()))), t.params.searchbar && R("div", {
            class: "searchbar-backdrop"
        }), R("div", {
            class: "page-content"
        }, R("div", {
            class: `list smart-select-list-${t.id} ${t.params.virtualList ? " virtual-list" : ""} ${t.params.formColorTheme ? `color-${t.params.formColorTheme}` : ""}`
        }, R("ul", null, !t.params.virtualList && t.renderItems(t.items)))))
    }
    renderPopup() {
        const t = this;
        if (t.params.renderPopup)
            return t.params.renderPopup.call(t, t.items);
        let n = t.params.pageTitle;
        if (typeof n > "u") {
            const r = t.$el.find(".item-title");
            n = r.length ? r.text().trim() : ""
        }
        const a = t.params.cssClass || "";
        return R("div", {
            class: `popup smart-select-popup ${a} ${t.params.popupTabletFullscreen ? "popup-tablet-fullscreen" : ""}`,
            "data-select-name": t.selectName
        }, R("div", {
            class: "view"
        }, R("div", {
            class: `page smart-select-page ${t.params.searchbar ? "page-with-subnavbar" : ""}`,
            "data-name": "smart-select-page"
        }, R("div", {
            class: `navbar ${t.params.navbarColorTheme ? `color-${t.params.navbarColorTheme}` : ""}`
        }, R("div", {
            class: "navbar-bg"
        }), R("div", {
            class: "navbar-inner sliding"
        }, n && R("div", {
            class: "title"
        }, n), R("div", {
            class: "right"
        }, R("a", {
            class: "link popup-close",
            "data-popup": `.smart-select-popup[data-select-name='${t.selectName}']`
        }, t.params.popupCloseLinkText)), t.params.searchbar && R("div", {
            class: "subnavbar"
        }, t.renderSearchbar()))), t.params.searchbar && R("div", {
            class: "searchbar-backdrop"
        }), R("div", {
            class: "page-content"
        }, R("div", {
            class: `list smart-select-list-${t.id} ${t.params.virtualList ? " virtual-list" : ""} ${t.params.formColorTheme ? `color-${t.params.formColorTheme}` : ""}`
        }, R("ul", null, !t.params.virtualList && t.renderItems(t.items)))))))
    }
    renderSheet() {
        const t = this;
        if (t.params.renderSheet)
            return t.params.renderSheet.call(t, t.items);
        const n = t.params.cssClass;
        return R("div", {
            class: `sheet-modal smart-select-sheet ${n}`,
            "data-select-name": t.selectName
        }, R("div", {
            class: `toolbar toolbar-top ${t.params.toolbarColorTheme ? `color-${t.params.toolbarColorTheme}` : ""}`
        }, R("div", {
            class: "toolbar-inner"
        }, R("div", {
            class: "left"
        }), R("div", {
            class: "right"
        }, R("a", {
            class: "link sheet-close"
        }, t.params.sheetCloseLinkText)))), R("div", {
            class: "sheet-modal-inner"
        }, R("div", {
            class: "page-content"
        }, R("div", {
            class: `list smart-select-list-${t.id} ${t.params.virtualList ? " virtual-list" : ""} ${t.params.formColorTheme ? `color-${t.params.formColorTheme}` : ""}`
        }, R("ul", null, !t.params.virtualList && t.renderItems(t.items))))))
    }
    renderPopover() {
        const t = this;
        if (t.params.renderPopover)
            return t.params.renderPopover.call(t, t.items);
        const n = t.params.cssClass;
        return R("div", {
            class: `popover smart-select-popover ${n}`,
            "data-select-name": t.selectName
        }, R("div", {
            class: "popover-inner"
        }, R("div", {
            class: `list smart-select-list-${t.id} ${t.params.virtualList ? " virtual-list" : ""} ${t.params.formColorTheme ? `color-${t.params.formColorTheme}` : ""}`
        }, R("ul", null, !t.params.virtualList && t.renderItems(t.items)))))
    }
    scrollToSelectedItem() {
        const t = this
          , {params: n, $containerEl: a} = t;
        if (!t.opened)
            return t;
        if (n.virtualList) {
            let r;
            t.vl.items.forEach( (o, i) => {
                typeof r > "u" && o.selected && (r = i)
            }
            ),
            typeof r < "u" && t.vl.scrollToItem(r)
        } else {
            const r = a.find("input:checked").parents("li");
            if (!r.length)
                return t;
            const o = a.find(".page-content, .popover-inner");
            if (!o.length)
                return t;
            o.scrollTop(r.offset().top - o.offset().top - parseInt(o.css("padding-top"), 10))
        }
        return t
    }
    onOpen(t, n) {
        const a = this
          , r = a.app
          , o = $(n);
        if (a.$containerEl = o,
        a.openedIn = t,
        a.opened = !0,
        a.params.virtualList && (a.vl = r.virtualList.create({
            el: o.find(".virtual-list"),
            items: a.items,
            renderItem: a.renderItem.bind(a),
            height: a.params.virtualListHeight,
            searchByItem(i, s) {
                return !!(s.text && o1(s.text).toLowerCase().indexOf(i.trim().toLowerCase()) >= 0)
            }
        })),
        a.params.scrollToSelectedItem && a.scrollToSelectedItem(),
        a.params.searchbar) {
            let i = o.find(".searchbar");
            if (t === "page" && r.theme === "ios" && (i = $(r.navbar.getElByPage(o)).find(".searchbar")),
            a.params.appendSearchbarNotFound && (t === "page" || t === "popup")) {
                let l = null;
                typeof a.params.appendSearchbarNotFound == "string" ? l = $(`<div class="block searchbar-not-found">${a.params.appendSearchbarNotFound}</div>`) : typeof a.params.appendSearchbarNotFound == "boolean" ? l = $('<div class="block searchbar-not-found">Nothing found</div>') : l = a.params.appendSearchbarNotFound,
                l && o.find(".page-content").append(l[0])
            }
            const s = se({
                el: i,
                backdropEl: o.find(".searchbar-backdrop"),
                searchContainer: `.smart-select-list-${a.id}`,
                searchIn: ".item-title"
            }, typeof a.params.searchbar == "object" ? a.params.searchbar : {});
            a.searchbar = r.searchbar.create(s)
        }
        a.maxLength && a.checkMaxLength(),
        a.params.closeOnSelect && a.$containerEl.find(`input[type="radio"][name="${a.inputName}"]:checked`).parents("label").once("click", () => {
            a.close()
        }
        ),
        a.attachInputsEvents(),
        a.$el.trigger("smartselect:open"),
        a.emit("local::open smartSelectOpen", a)
    }
    onOpened() {
        const t = this;
        t.$el.trigger("smartselect:opened"),
        t.emit("local::opened smartSelectOpened", t)
    }
    onClose() {
        const t = this;
        t.destroyed || (t.vl && t.vl.destroy && (t.vl.destroy(),
        t.vl = null,
        delete t.vl),
        t.searchbar && t.searchbar.destroy && (t.searchbar.destroy(),
        t.searchbar = null,
        delete t.searchbar),
        t.detachInputsEvents(),
        t.$el.trigger("smartselect:close"),
        t.emit("local::close smartSelectClose", t))
    }
    onClosed() {
        const t = this;
        t.destroyed || (t.opened = !1,
        t.$containerEl = null,
        delete t.$containerEl,
        t.$el.trigger("smartselect:closed"),
        t.emit("local::closed smartSelectClosed", t))
    }
    openPage() {
        const t = this;
        if (t.opened)
            return t;
        t.getItemsData();
        const n = t.renderPage(t.items);
        return t.view.router.navigate({
            url: t.url,
            route: {
                content: n,
                path: t.url,
                on: {
                    pageBeforeIn(a, r) {
                        t.onOpen("page", r.el)
                    },
                    pageAfterIn(a, r) {
                        t.onOpened("page", r.el)
                    },
                    pageBeforeOut(a, r) {
                        t.onClose("page", r.el)
                    },
                    pageAfterOut(a, r) {
                        t.onClosed("page", r.el)
                    }
                }
            }
        }),
        t
    }
    openPopup() {
        const t = this;
        if (t.opened)
            return t;
        t.getItemsData();
        const a = {
            content: t.renderPopup(t.items),
            push: t.params.popupPush,
            swipeToClose: t.params.popupSwipeToClose,
            closeByBackdropClick: t.params.closeByBackdropClick,
            on: {
                popupOpen(r) {
                    t.onOpen("popup", r.el)
                },
                popupOpened(r) {
                    t.onOpened("popup", r.el)
                },
                popupClose(r) {
                    t.onClose("popup", r.el)
                },
                popupClosed(r) {
                    t.onClosed("popup", r.el)
                }
            }
        };
        return t.params.routableModals && t.view ? t.view.router.navigate({
            url: t.url,
            route: {
                path: t.url,
                popup: a
            }
        }) : t.modal = t.app.popup.create(a).open(),
        t
    }
    openSheet() {
        const t = this;
        if (t.opened)
            return t;
        t.getItemsData();
        const a = {
            content: t.renderSheet(t.items),
            backdrop: t.params.sheetBackdrop,
            scrollToEl: t.$el,
            closeByOutsideClick: !0,
            push: t.params.sheetPush,
            swipeToClose: t.params.sheetSwipeToClose,
            closeByBackdropClick: t.params.closeByBackdropClick,
            on: {
                sheetOpen(r) {
                    t.onOpen("sheet", r.el)
                },
                sheetOpened(r) {
                    t.onOpened("sheet", r.el)
                },
                sheetClose(r) {
                    t.onClose("sheet", r.el)
                },
                sheetClosed(r) {
                    t.onClosed("sheet", r.el)
                }
            }
        };
        return t.params.routableModals && t.view ? t.view.router.navigate({
            url: t.url,
            route: {
                path: t.url,
                sheet: a
            }
        }) : t.modal = t.app.sheet.create(a).open(),
        t
    }
    openPopover() {
        const t = this;
        if (t.opened)
            return t;
        t.getItemsData();
        const a = {
            content: t.renderPopover(t.items),
            targetEl: t.$el,
            closeByBackdropClick: t.params.closeByBackdropClick,
            on: {
                popoverOpen(r) {
                    t.onOpen("popover", r.el)
                },
                popoverOpened(r) {
                    t.onOpened("popover", r.el)
                },
                popoverClose(r) {
                    t.onClose("popover", r.el)
                },
                popoverClosed(r) {
                    t.onClosed("popover", r.el)
                }
            }
        };
        return t.params.routableModals && t.view ? t.view.router.navigate({
            url: t.url,
            route: {
                path: t.url,
                popover: a
            }
        }) : t.modal = t.app.popover.create(a).open(),
        t
    }
    open(t) {
        const n = this;
        if (n.opened)
            return n;
        let a = !1;
        function r() {
            a = !0
        }
        if (n.$el && n.$el.trigger("smartselect:beforeopen", {
            prevent: r
        }),
        n.emit("local::beforeOpen smartSelectBeforeOpen", n, r),
        a)
            return n;
        const o = t || n.params.openIn;
        return n[`open${o.split("").map( (i, s) => s === 0 ? i.toUpperCase() : i).join("")}`](),
        n
    }
    close() {
        const t = this;
        return t.opened && (t.params.routableModals && t.view || t.openedIn === "page" ? t.view.router.back() : (t.modal.once("modalClosed", () => {
            un( () => {
                t.destroyed || (t.modal.destroy(),
                delete t.modal)
            }
            )
        }
        ),
        t.modal.close())),
        t
    }
    init() {
        const t = this;
        t.attachEvents(),
        t.setValueText()
    }
    destroy() {
        const t = this;
        t.emit("local::beforeDestroy smartSelectBeforeDestroy", t),
        t.$el.trigger("smartselect:beforedestroy"),
        t.detachEvents(),
        delete t.$el[0].f7SmartSelect,
        Yt(t),
        t.destroyed = !0
    }
}
;
const oj = {
    name: "smartSelect",
    params: {
        smartSelect: {
            el: void 0,
            valueEl: void 0,
            setValueText: !0,
            formatValueText: null,
            openIn: "page",
            popupPush: !1,
            popupSwipeToClose: void 0,
            sheetPush: !1,
            sheetSwipeToClose: void 0,
            sheetBackdrop: !1,
            pageTitle: void 0,
            pageBackLinkText: "Back",
            popupCloseLinkText: "Close",
            popupTabletFullscreen: !1,
            closeByBackdropClick: !0,
            sheetCloseLinkText: "Done",
            searchbar: !1,
            searchbarPlaceholder: "Search",
            searchbarDisableText: "Cancel",
            searchbarDisableButton: void 0,
            searchbarSpellcheck: !1,
            closeOnSelect: !1,
            virtualList: !1,
            virtualListHeight: void 0,
            scrollToSelectedItem: !1,
            formColorTheme: void 0,
            navbarColorTheme: void 0,
            routableModals: !1,
            url: "select/",
            cssClass: "",
            renderPage: void 0,
            renderPopup: void 0,
            renderSheet: void 0,
            renderPopover: void 0,
            renderItems: void 0,
            renderItem: void 0,
            renderSearchbar: void 0
        }
    },
    static: {
        SmartSelect: Hp
    },
    create() {
        const e = this;
        e.smartSelect = se(Gt({
            defaultSelector: ".smart-select",
            constructor: Hp,
            app: e,
            domProp: "f7SmartSelect"
        }), {
            open(t) {
                const n = e.smartSelect.get(t);
                if (n && n.open)
                    return n.open()
            },
            close(t) {
                const n = e.smartSelect.get(t);
                if (n && n.close)
                    return n.close()
            }
        })
    },
    on: {
        tabMounted(e) {
            const t = this;
            $(e).find(".smart-select-init").each(n => {
                t.smartSelect.create(se({
                    el: n
                }, $(n).dataset()))
            }
            )
        },
        tabBeforeRemove(e) {
            $(e).find(".smart-select-init").each(t => {
                t.f7SmartSelect && t.f7SmartSelect.destroy && t.f7SmartSelect.destroy()
            }
            )
        },
        pageInit(e) {
            const t = this;
            e.$el.find(".smart-select-init").each(n => {
                t.smartSelect.create(se({
                    el: n
                }, $(n).dataset()))
            }
            )
        },
        pageBeforeRemove(e) {
            e.$el.find(".smart-select-init").each(t => {
                t.f7SmartSelect && t.f7SmartSelect.destroy && t.f7SmartSelect.destroy()
            }
            )
        }
    },
    clicks: {
        ".smart-select": function(t, n) {
            const a = this;
            t[0].f7SmartSelect || a.smartSelect.create(se({
                el: t
            }, n)).open()
        }
    },
    vnode: {
        "smart-select-init": {
            insert(e) {
                const t = this
                  , n = e.elm;
                t.smartSelect.create(se({
                    el: n
                }, $(n).dataset()))
            },
            destroy(e) {
                const t = e.elm;
                t.f7SmartSelect && t.f7SmartSelect.destroy && t.f7SmartSelect.destroy()
            }
        }
    }
};
function Vp(e, t) {
    let n = t.css(`min-${e}`);
    return n === "auto" || n === "none" ? n = 0 : n.indexOf("px") >= 0 ? n = parseFloat(n) : n.indexOf("%") >= 0 && (n = t.parent()[0][e === "height" ? "offsetHeight" : "offsetWidth"] * parseFloat(n) / 100),
    n
}
function Fp(e, t) {
    let n = t.css(`max-${e}`);
    return n === "auto" || n === "none" ? n = null : n.indexOf("px") >= 0 ? n = parseFloat(n) : n.indexOf("%") >= 0 && (n = t.parent()[0][e === "height" ? "offsetHeight" : "offsetWidth"] * parseFloat(n) / 100),
    n
}
const ij = {
    init() {
        const e = this;
        let t, n, a, r, o, i, s, l, c, u, f, d, p, h, m, g, b;
        function v(_) {
            t || n || (o = $(_.target).closest(".resize-handler"),
            a = _.type === "touchstart" ? _.targetTouches[0].pageX : _.pageX,
            r = _.type === "touchstart" ? _.targetTouches[0].pageY : _.pageY,
            t = !0,
            i = void 0,
            s = void 0,
            b = void 0)
        }
        function y(_) {
            if (!t)
                return;
            const E = o.parent(".row").length === 1
              , z = E ? "height" : "width"
              , T = E ? "offsetHeight" : "offsetWidth";
            n || (i = o.parent(E ? ".row" : ".col"),
            i.length && (!i.hasClass("resizable") || i.hasClass("resizable-fixed")) && (i = i.prevAll(".resizable:not(.resizable-fixed)").eq(0)),
            s = i.next(E ? ".row" : ".col"),
            s.length && (!s.hasClass("resizable") || s.hasClass("resizable-fixed")) && (s = s.nextAll(".resizable:not(.resizable-fixed)").eq(0)),
            i.length && (l = i[0][T],
            c = Vp(z, i),
            u = Fp(z, i),
            h = i.parent()[0][T],
            m = i.parent().children(E ? ".row" : '[class*="col-"], .col').length,
            g = parseFloat(i.css(E ? "--f7-grid-row-gap" : "--f7-grid-gap"))),
            s.length && (f = s[0][T],
            d = Vp(z, s),
            p = Fp(z, s),
            i.length || (h = s.parent()[0][T],
            m = s.parent().children(E ? ".row" : '[class*="col-"], .col').length,
            g = parseFloat(s.css(E ? "--f7-grid-row-gap" : "--f7-grid-gap"))))),
            n = !0;
            const A = _.type === "touchmove" ? _.targetTouches[0].pageX : _.pageX
              , x = _.type === "touchmove" ? _.targetTouches[0].pageY : _.pageY;
            if (typeof b > "u" && !E && (b = !!(b || Math.abs(x - r) > Math.abs(A - a))),
            b) {
                t = !1,
                n = !1;
                return
            }
            const M = i.hasClass("resizable-absolute") || s.hasClass("resizable-absolute")
              , L = !E || E && !M;
            if (L && !s.length || !i.length) {
                t = !1,
                n = !1;
                return
            }
            _.preventDefault();
            let U = E ? x - r : A - a, Y, H;
            if (i.length && (Y = l + U,
            Y < c && (Y = c,
            U = Y - l),
            u && Y > u && (Y = u,
            U = Y - l)),
            s.length && L && (H = f - U,
            H < d && (H = d,
            U = f - H,
            Y = l + U),
            p && H > p && (H = p,
            U = f - H,
            Y = l + U)),
            M) {
                i[0].style[z] = `${Y}px`,
                L && (s[0].style[z] = `${H}px`),
                i.trigger("grid:resize"),
                s.trigger("grid:resize"),
                e.emit("gridResize", i[0]),
                e.emit("gridResize", s[0]);
                return
            }
            const W = (m - 1) * g / m
              , j = E ? `${m - 1} * var(--f7-grid-row-gap) / ${m}` : "(var(--f7-cols-per-row) - 1) * var(--f7-grid-gap) / var(--f7-cols-per-row)"
              , Q = Y + W
              , ne = H + W;
            i[0].style[z] = `calc(${Q / h * 100}% - ${j})`,
            s[0].style[z] = `calc(${ne / h * 100}% - ${j})`,
            i.trigger("grid:resize"),
            s.trigger("grid:resize"),
            e.emit("gridResize", i[0]),
            e.emit("gridResize", s[0])
        }
        function w() {
            t && (n || (t = !1),
            t = !1,
            n = !1)
        }
        const C = Qe();
        $(C).on(e.touchEvents.start, ".col > .resize-handler, .row > .resize-handler", v),
        e.on("touchmove", y),
        e.on("touchend", w)
    }
}
  , sj = {
    name: "grid",
    create() {
        const e = this;
        se(e, {
            grid: {
                init: ij.init.bind(e)
            }
        })
    },
    on: {
        init() {
            this.grid.init()
        }
    }
};
let jp = class extends Bt {
    constructor(t, n) {
        n === void 0 && (n = {}),
        super(n, [t]);
        const a = this;
        a.params = se({}, t.params.calendar, n);
        let r;
        if (a.params.containerEl && (r = $(a.params.containerEl),
        r.length === 0))
            return a;
        let o;
        a.params.inputEl && (o = $(a.params.inputEl));
        const i = a.params.direction === "horizontal";
        let s = 1;
        i && (s = t.rtl ? -1 : 1),
        se(a, {
            app: t,
            $containerEl: r,
            containerEl: r && r[0],
            inline: r && r.length > 0,
            $inputEl: o,
            inputEl: o && o[0],
            initialized: !1,
            opened: !1,
            url: a.params.url,
            isHorizontal: i,
            inverter: s,
            animating: !1,
            allowTouchMove: !0,
            hasTimePicker: a.params.timePicker && !a.params.rangePicker && !a.params.multiple
        }),
        a.dayFormatter = C => new Intl.DateTimeFormat(a.params.locale,{
            day: "numeric"
        }).format(C).replace(//, ""),
        a.monthFormatter = C => new Intl.DateTimeFormat(a.params.locale,{
            month: "long"
        }).format(C),
        a.yearFormatter = C => new Intl.DateTimeFormat(a.params.locale,{
            year: "numeric"
        }).format(C),
        a.timeSelectorFormatter = C => new Intl.DateTimeFormat(a.params.locale,a.params.timePickerFormat).format(C);
        const l = a.timeSelectorFormatter(new Date).toLowerCase();
        a.is12HoursFormat = l.indexOf("pm") >= 0 || l.indexOf("am") >= 0;
        let {monthNames: c, monthNamesShort: u, dayNames: f, dayNamesShort: d} = a.params;
        const {monthNamesIntl: p, monthNamesShortIntl: h, dayNamesIntl: m, dayNamesShortIntl: g} = a.getIntlNames();
        c === "auto" && (c = p),
        u === "auto" && (u = h),
        f === "auto" && (f = m),
        d === "auto" && (d = g),
        se(a, {
            monthNames: c,
            monthNamesShort: u,
            dayNames: f,
            dayNamesShort: d
        });
        function b() {
            a.open()
        }
        function v(C) {
            C.preventDefault()
        }
        function y() {
            a.setValue([]),
            a.opened && a.update()
        }
        function w(C) {
            const _ = $(C.target);
            a.destroyed || !a.params || a.isPopover() || !a.opened || a.closing || _.closest('[class*="backdrop"]').length || a.monthPickerPopover || a.yearPickerPopover || a.timePickerPopover || (o && o.length > 0 ? _[0] !== o[0] && _.closest(".sheet-modal, .calendar-modal").length === 0 && a.close() : $(C.target).closest(".sheet-modal, .calendar-modal").length === 0 && a.close())
        }
        return se(a, {
            attachInputEvents() {
                a.$inputEl.on("click", b),
                a.$inputEl.on("input:clear", y),
                a.params.inputReadOnly && (a.$inputEl.on("focus mousedown", v),
                a.$inputEl[0] && (a.$inputEl[0].f7ValidateReadonly = !0))
            },
            detachInputEvents() {
                a.$inputEl.off("click", b),
                a.$inputEl.off("input:clear", y),
                a.params.inputReadOnly && (a.$inputEl.off("focus mousedown", v),
                a.$inputEl[0] && delete a.$inputEl[0].f7ValidateReadonly)
            },
            attachHtmlEvents() {
                t.on("click", w)
            },
            detachHtmlEvents() {
                t.off("click", w)
            }
        }),
        a.attachCalendarEvents = function() {
            let _ = !0, E, z, T, A, x, M, L, U, Y, H, W, j, Q, ne;
            const {$el: re, $wrapperEl: ve} = a;
            function Ne(Z) {
                z || E || (E = !0,
                T = Z.type === "touchstart" ? Z.targetTouches[0].pageX : Z.pageX,
                x = T,
                A = Z.type === "touchstart" ? Z.targetTouches[0].pageY : Z.pageY,
                M = A,
                L = new Date().getTime(),
                j = 0,
                _ = !0,
                ne = void 0,
                Y = a.monthsTranslate)
            }
            function Ge(Z) {
                if (!E)
                    return;
                const {isHorizontal: de} = a;
                if (x = Z.type === "touchmove" ? Z.targetTouches[0].pageX : Z.pageX,
                M = Z.type === "touchmove" ? Z.targetTouches[0].pageY : Z.pageY,
                typeof ne > "u" && (ne = !!(ne || Math.abs(M - A) > Math.abs(x - T))),
                de && ne || !a.allowTouchMove) {
                    E = !1;
                    return
                }
                if (Z.preventDefault(),
                a.animating) {
                    E = !1;
                    return
                }
                _ = !1,
                z || (z = !0,
                H = ve[0].offsetWidth,
                W = ve[0].offsetHeight,
                ve.transition(0)),
                Q = de ? x - T : M - A,
                j = Q / (de ? H : W),
                Y = (a.monthsTranslate * a.inverter + j) * 100,
                ve.transform(`translate3d(${de ? Y : 0}%, ${de ? 0 : Y}%, 0)`)
            }
            function Ye() {
                if (!E || !z) {
                    E = !1,
                    z = !1;
                    return
                }
                E = !1,
                z = !1,
                U = new Date().getTime(),
                U - L < 300 ? Math.abs(Q) < 10 ? a.resetMonth() : Q >= 10 ? t.rtl ? a.nextMonth() : a.prevMonth() : t.rtl ? a.prevMonth() : a.nextMonth() : j <= -.5 ? t.rtl ? a.prevMonth() : a.nextMonth() : j >= .5 ? t.rtl ? a.nextMonth() : a.prevMonth() : a.resetMonth(),
                setTimeout( () => {
                    _ = !0
                }
                , 100)
            }
            function tt(Z) {
                if (!_)
                    return;
                let de = $(Z.target).parents(".calendar-day");
                if (de.length === 0 && $(Z.target).hasClass("calendar-day") && (de = $(Z.target)),
                de.length === 0 || de.hasClass("calendar-day-disabled"))
                    return;
                a.params.rangePicker || (de.hasClass("calendar-day-next") && a.nextMonth(),
                de.hasClass("calendar-day-prev") && a.prevMonth());
                const me = parseInt(de.attr("data-year"), 10)
                  , ge = parseInt(de.attr("data-month"), 10)
                  , ie = parseInt(de.attr("data-day"), 10);
                if (a.emit("local::dayClick calendarDayClick", a, de[0], me, ge, ie),
                !de.hasClass("calendar-day-selected") || a.params.multiple || a.params.rangePicker) {
                    const Ee = new Date(me,ge,ie,0,0,0);
                    a.hasTimePicker && (a.value && a.value[0] ? Ee.setHours(a.value[0].getHours(), a.value[0].getMinutes()) : Ee.setHours(new Date().getHours(), new Date().getMinutes())),
                    a.addValue(Ee)
                }
                a.params.closeOnSelect && (a.params.rangePicker && a.value.length === 2 || !a.params.rangePicker) && a.close()
            }
            function ee() {
                a.nextMonth()
            }
            function ye() {
                a.prevMonth()
            }
            function Le() {
                a.nextYear()
            }
            function Se() {
                a.prevYear()
            }
            function Re() {
                a.openMonthPicker()
            }
            function Ve() {
                a.openYearPicker()
            }
            function Ze() {
                a.openTimePicker()
            }
            const q = t.touchEvents.start === "touchstart" && Mt().passiveListener ? {
                passive: !0,
                capture: !1
            } : !1;
            re.find(".calendar-prev-month-button").on("click", ye),
            re.find(".calendar-next-month-button").on("click", ee),
            re.find(".calendar-prev-year-button").on("click", Se),
            re.find(".calendar-next-year-button").on("click", Le),
            a.params.monthPicker && re.find(".current-month-value").on("click", Re),
            a.params.yearPicker && re.find(".current-year-value").on("click", Ve),
            a.hasTimePicker && re.find(".calendar-time-selector a").on("click", Ze),
            ve.on("click", tt),
            a.params.touchMove && (ve.on(t.touchEvents.start, Ne, q),
            t.on("touchmove:active", Ge),
            t.on("touchend:passive", Ye)),
            a.detachCalendarEvents = function() {
                re.find(".calendar-prev-month-button").off("click", ye),
                re.find(".calendar-next-month-button").off("click", ee),
                re.find(".calendar-prev-year-button").off("click", Se),
                re.find(".calendar-next-year-button").off("click", Le),
                a.params.monthPicker && re.find(".current-month-value").off("click", Re),
                a.params.yearPicker && re.find(".current-year-value").off("click", Ve),
                a.hasTimePicker && re.find(".calendar-time-selector a").off("click", Ze),
                ve.off("click", tt),
                a.params.touchMove && (ve.off(t.touchEvents.start, Ne, q),
                t.off("touchmove:active", Ge),
                t.off("touchend:passive", Ye))
            }
        }
        ,
        a.init(),
        a
    }
    get view() {
        const {$inputEl: t, app: n, params: a} = this;
        let r;
        return a.view ? r = a.view : t && (r = t.parents(".view").length && t.parents(".view")[0].f7View),
        r || (r = n.views.main),
        r
    }
    getIntlNames() {
        const t = this
          , n = t.params.locale
          , a = []
          , r = []
          , o = []
          , i = []
          , s = new Intl.DateTimeFormat(n,{
            month: "long"
        })
          , l = new Intl.DateTimeFormat(n,{
            month: "short"
        })
          , c = new Intl.DateTimeFormat(n,{
            weekday: "long"
        })
          , u = new Intl.DateTimeFormat(n,{
            weekday: "short"
        });
        let f, d, p;
        for (let m = 0; m < 24; m += 1) {
            const g = new Date().setMonth(m, 1)
              , b = t.yearFormatter(g);
            f && b !== f && (d && (p = !0),
            d = !0,
            f = b),
            f || (f = b),
            d && f === b && !p && (a.push(s.format(g)),
            r.push(l.format(g)))
        }
        const h = new Date().getDay();
        for (let m = 0; m < 7; m += 1) {
            const g = new Date().getTime() + (m - h) * 24 * 60 * 60 * 1e3;
            o.push(c.format(g)),
            i.push(u.format(g))
        }
        return {
            monthNamesIntl: a,
            monthNamesShortIntl: r,
            dayNamesIntl: o,
            dayNamesShortIntl: i
        }
    }
    normalizeDate(t) {
        const n = this
          , a = new Date(t);
        return n.hasTimePicker ? new Date(a.getFullYear(),a.getMonth(),a.getDate(),a.getHours(),a.getMinutes()) : new Date(a.getFullYear(),a.getMonth(),a.getDate())
    }
    normalizeValues(t) {
        const n = this;
        let a = [];
        return t && Array.isArray(t) && (a = t.map(r => n.normalizeDate(r))),
        a
    }
    initInput() {
        const t = this;
        t.$inputEl && t.params.inputReadOnly && t.$inputEl.prop("readOnly", !0)
    }
    isPopover() {
        const t = this
          , {app: n, modal: a, params: r} = t
          , o = yt();
        if (r.openIn === "sheet" || a && a.type !== "popover")
            return !1;
        if (!t.inline && t.inputEl) {
            if (r.openIn === "popover")
                return !0;
            if (o.ios)
                return !!o.ipad;
            if (n.width >= 768 || o.desktop && n.theme === "aurora")
                return !0
        }
        return !1
    }
    formatDate(t) {
        const n = this
          , a = new Date(t)
          , r = a.getFullYear()
          , o = a.getMonth()
          , i = o + 1
          , s = a.getDate()
          , l = a.getDay()
          , {monthNames: c, monthNamesShort: u, dayNames: f, dayNamesShort: d} = n
          , {dateFormat: p, locale: h} = n.params;
        function m(b) {
            return b < 10 ? `0${b}` : b
        }
        if (typeof p == "string") {
            const b = {
                yyyy: r,
                yy: String(r).substring(2),
                mm: m(i),
                m: i,
                MM: c[o],
                M: u[o],
                dd: m(s),
                d: s,
                DD: f[l],
                D: d[l]
            };
            if (n.params.timePicker) {
                const y = a.getHours()
                  , w = a.getMinutes()
                  , C = a.getSeconds();
                let _ = y;
                y > 12 && (_ = y - 12),
                y === 0 && (_ = 12);
                const E = y >= 12 && y !== 0 ? "pm" : "am";
                Object.assign(b, {
                    HH: m(y),
                    H: y,
                    hh: m(_),
                    h: _,
                    ss: m(C),
                    s: C,
                    ":mm": m(w),
                    ":m": w,
                    a: E,
                    A: E.toUpperCase()
                })
            }
            const v = new RegExp(Object.keys(b).map(y => `(${y})`).join("|"),"g");
            return p.replace(v, y => y in b ? b[y] : y)
        }
        return typeof p == "function" ? p(a) : new Intl.DateTimeFormat(h,p).format(a)
    }
    formatValue() {
        const t = this
          , {value: n} = t;
        return t.params.formatValue ? t.params.formatValue.call(t, n) : n.map(a => t.formatDate(a)).join(t.params.rangePicker ? " - " : ", ")
    }
    addValue(t) {
        const n = this
          , {multiple: a, rangePicker: r, rangePickerMinDays: o, rangePickerMaxDays: i} = n.params;
        if (a) {
            n.value || (n.value = []);
            let s;
            for (let l = 0; l < n.value.length; l += 1)
                new Date(t).getTime() === new Date(n.value[l]).getTime() && (s = l);
            typeof s > "u" ? n.value.push(t) : n.value.splice(s, 1),
            n.updateValue()
        } else
            r ? (n.value || (n.value = []),
            (n.value.length === 2 || n.value.length === 0) && (n.value = []),
            n.value.length === 0 || Math.abs(n.value[0].getTime() - t.getTime()) >= (o - 1) * 60 * 60 * 24 * 1e3 && (i === 0 || Math.abs(n.value[0].getTime() - t.getTime()) <= (i - 1) * 60 * 60 * 24 * 1e3) ? n.value.push(t) : n.value = [],
            n.value.sort( (s, l) => s - l),
            n.updateValue()) : (n.value = [t],
            n.updateValue())
    }
    setValue(t) {
        const n = this
          , a = n.value;
        if (Array.isArray(a) && Array.isArray(t) && a.length === t.length) {
            let r = !0;
            if (a.forEach( (o, i) => {
                o !== t[i] && (r = !1)
            }
            ),
            r)
                return
        }
        n.value = t,
        n.updateValue()
    }
    getValue() {
        return this.value
    }
    updateValue(t) {
        const n = this
          , {$el: a, $wrapperEl: r, $inputEl: o, value: i, params: s} = n;
        let l;
        if (a && a.length > 0) {
            r.find(".calendar-day-selected").removeClass("calendar-day-selected calendar-day-selected-range calendar-day-selected-left calendar-day-selected-right");
            let c;
            if (s.rangePicker && i.length === 2) {
                const u = new Date(i[0]).getTime()
                  , f = new Date(i[1]).getTime();
                for (l = u; l <= f; l += 24 * 60 * 60 * 1e3) {
                    c = new Date(l);
                    let d = "calendar-day-selected";
                    u !== f && (l !== u && l !== f && (d += " calendar-day-selected-range"),
                    l === u && (d += " calendar-day-selected-left"),
                    l === f && (d += " calendar-day-selected-right")),
                    r.find(`.calendar-day[data-date="${c.getFullYear()}-${c.getMonth()}-${c.getDate()}"]`).addClass(d)
                }
                c = new Date(u),
                r.find(`.calendar-day[data-date="${c.getFullYear()}-${c.getMonth()}-${c.getDate()}"]`).removeClass("calendar-day-selected-range").addClass("calendar-day-selected calendar-day-selected-left"),
                c = new Date(f),
                r.find(`.calendar-day[data-date="${c.getFullYear()}-${c.getMonth()}-${c.getDate()}"]`).removeClass("calendar-day-selected-range").addClass("calendar-day-selected calendar-day-selected-right")
            } else
                for (l = 0; l < n.value.length; l += 1)
                    c = new Date(i[l]),
                    r.find(`.calendar-day[data-date="${c.getFullYear()}-${c.getMonth()}-${c.getDate()}"]`).addClass("calendar-day-selected")
        }
        if (t || n.emit("local::change calendarChange", n, i),
        a && a.length > 0 && n.hasTimePicker && a.find(".calendar-time-selector a").text(i && i.length ? n.timeSelectorFormatter(i[0]) : n.params.timePickerPlaceholder),
        o && o.length || s.header) {
            const c = n.formatValue(i);
            s.header && a && a.length && a.find(".calendar-selected-date").text(c),
            o && o.length && !t && (o.val(c),
            o.trigger("change"))
        }
    }
    updateCurrentMonthYear(t) {
        const n = this
          , {$months: a, $el: r, monthNames: o} = n;
        let i, s;
        typeof t > "u" ? (n.currentMonth = parseInt(a.eq(1).attr("data-month"), 10),
        n.currentYear = parseInt(a.eq(1).attr("data-year"), 10),
        i = a.eq(1).attr("data-locale-month"),
        s = a.eq(1).attr("data-locale-year")) : (n.currentMonth = parseInt(a.eq(t === "next" ? a.length - 1 : 0).attr("data-month"), 10),
        n.currentYear = parseInt(a.eq(t === "next" ? a.length - 1 : 0).attr("data-year"), 10),
        i = a.eq(t === "next" ? a.length - 1 : 0).attr("data-locale-month"),
        s = a.eq(t === "next" ? a.length - 1 : 0).attr("data-locale-year")),
        r.find(".current-month-value").text(o[i]),
        r.find(".current-year-value").text(s)
    }
    update() {
        const t = this
          , {currentYear: n, currentMonth: a, $wrapperEl: r} = t
          , o = new Date(n,a)
          , i = t.renderMonth(o, "prev")
          , s = t.renderMonth(o)
          , l = t.renderMonth(o, "next");
        r.transition(0).html(`${i}${s}${l}`).transform("translate3d(0,0,0)"),
        t.$months = r.find(".calendar-month"),
        t.monthsTranslate = 0,
        t.setMonthsTranslate(),
        t.$months.each(c => {
            t.emit("local::monthAdd calendarMonthAdd", c)
        }
        )
    }
    onMonthChangeStart(t) {
        const n = this
          , {$months: a, currentYear: r, currentMonth: o} = n;
        n.updateCurrentMonthYear(t),
        a.removeClass("calendar-month-current calendar-month-prev calendar-month-next");
        const i = t === "next" ? a.length - 1 : 0;
        a.eq(i).addClass("calendar-month-current"),
        a.eq(t === "next" ? i - 1 : i + 1).addClass(t === "next" ? "calendar-month-prev" : "calendar-month-next"),
        n.emit("local::monthYearChangeStart calendarMonthYearChangeStart", n, r, o)
    }
    onMonthChangeEnd(t, n) {
        const a = this
          , {currentYear: r, currentMonth: o, $wrapperEl: i, monthsTranslate: s} = a;
        a.animating = !1;
        let l, c, u;
        i.find(".calendar-month:not(.calendar-month-prev):not(.calendar-month-current):not(.calendar-month-next)").remove(),
        typeof t > "u" && (t = "next",
        n = !0),
        n ? (i.find(".calendar-month-next, .calendar-month-prev").remove(),
        c = a.renderMonth(new Date(r,o), "prev"),
        l = a.renderMonth(new Date(r,o), "next")) : u = a.renderMonth(new Date(r,o), t),
        (t === "next" || n) && i.append(u || l),
        (t === "prev" || n) && i.prepend(u || c);
        const f = i.find(".calendar-month");
        a.$months = f,
        a.setMonthsTranslate(s),
        a.emit("local::monthAdd calendarMonthAdd", a, t === "next" ? f.eq(f.length - 1)[0] : f.eq(0)[0]),
        a.emit("local::monthYearChangeEnd calendarMonthYearChangeEnd", a, r, o)
    }
    setMonthsTranslate(t) {
        const n = this
          , {$months: a, isHorizontal: r, inverter: o} = n;
        t = t || n.monthsTranslate || 0,
        typeof n.monthsTranslate > "u" && (n.monthsTranslate = t),
        a.removeClass("calendar-month-current calendar-month-prev calendar-month-next");
        const i = -(t + 1) * 100 * o
          , s = -t * 100 * o
          , l = -(t - 1) * 100 * o;
        a.eq(0).transform(`translate3d(${r ? i : 0}%, ${r ? 0 : i}%, 0)`).addClass("calendar-month-prev"),
        a.eq(1).transform(`translate3d(${r ? s : 0}%, ${r ? 0 : s}%, 0)`).addClass("calendar-month-current"),
        a.eq(2).transform(`translate3d(${r ? l : 0}%, ${r ? 0 : l}%, 0)`).addClass("calendar-month-next")
    }
    nextMonth(t) {
        const n = this
          , {params: a, $wrapperEl: r, inverter: o, isHorizontal: i} = n;
        (typeof t > "u" || typeof t == "object") && (t = "",
        a.animate || (t = 0));
        const s = parseInt(n.$months.eq(n.$months.length - 1).attr("data-month"), 10)
          , l = parseInt(n.$months.eq(n.$months.length - 1).attr("data-year"), 10)
          , u = new Date(l,s).getTime()
          , f = !n.animating;
        if (a.maxDate && u > new Date(a.maxDate).getTime()) {
            n.resetMonth();
            return
        }
        if (n.monthsTranslate -= 1,
        s === n.currentMonth) {
            const p = -n.monthsTranslate * 100 * o
              , h = $(n.renderMonth(u, "next")).transform(`translate3d(${i ? p : 0}%, ${i ? 0 : p}%, 0)`).addClass("calendar-month-next");
            r.append(h[0]),
            n.$months = r.find(".calendar-month"),
            n.emit("local::monthAdd calendarMonthAdd", n.$months.eq(n.$months.length - 1)[0])
        }
        n.animating = !0,
        n.onMonthChangeStart("next");
        const d = n.monthsTranslate * 100 * o;
        r.transition(t).transform(`translate3d(${i ? d : 0}%, ${i ? 0 : d}%, 0)`),
        f && r.transitionEnd( () => {
            n.onMonthChangeEnd("next")
        }
        ),
        a.animate || n.onMonthChangeEnd("next")
    }
    prevMonth(t) {
        const n = this
          , {params: a, $wrapperEl: r, inverter: o, isHorizontal: i} = n;
        (typeof t > "u" || typeof t == "object") && (t = "",
        a.animate || (t = 0));
        const s = parseInt(n.$months.eq(0).attr("data-month"), 10)
          , l = parseInt(n.$months.eq(0).attr("data-year"), 10)
          , u = new Date(l,s + 1,-1).getTime()
          , f = !n.animating;
        if (a.minDate) {
            let p = new Date(a.minDate);
            if (p = new Date(p.getFullYear(),p.getMonth(),1),
            u < p.getTime()) {
                n.resetMonth();
                return
            }
        }
        if (n.monthsTranslate += 1,
        s === n.currentMonth) {
            const p = -n.monthsTranslate * 100 * o
              , h = $(n.renderMonth(u, "prev")).transform(`translate3d(${i ? p : 0}%, ${i ? 0 : p}%, 0)`).addClass("calendar-month-prev");
            r.prepend(h[0]),
            n.$months = r.find(".calendar-month"),
            n.emit("local::monthAdd calendarMonthAdd", n.$months.eq(0)[0])
        }
        n.animating = !0,
        n.onMonthChangeStart("prev");
        const d = n.monthsTranslate * 100 * o;
        r.transition(t).transform(`translate3d(${i ? d : 0}%, ${i ? 0 : d}%, 0)`),
        f && r.transitionEnd( () => {
            n.onMonthChangeEnd("prev")
        }
        ),
        a.animate || n.onMonthChangeEnd("prev")
    }
    resetMonth(t) {
        t === void 0 && (t = "");
        const n = this
          , {$wrapperEl: a, inverter: r, isHorizontal: o, monthsTranslate: i} = n
          , s = i * 100 * r;
        a.transition(t).transform(`translate3d(${o ? s : 0}%, ${o ? 0 : s}%, 0)`)
    }
    setYearMonth(t, n, a) {
        const r = this
          , {params: o, isHorizontal: i, $wrapperEl: s, inverter: l} = r;
        typeof t > "u" && (t = r.currentYear),
        typeof n > "u" && (n = r.currentMonth),
        (typeof a > "u" || typeof a == "object") && (a = "",
        o.animate || (a = 0));
        let c;
        if (t < r.currentYear ? c = new Date(t,n + 1,-1).getTime() : c = new Date(t,n).getTime(),
        o.maxDate && c > new Date(o.maxDate).getTime())
            return !1;
        if (o.minDate) {
            let b = new Date(o.minDate);
            if (b = new Date(b.getFullYear(),b.getMonth(),1),
            c < b.getTime())
                return !1
        }
        const u = new Date(r.currentYear,r.currentMonth).getTime()
          , f = c > u ? "next" : "prev"
          , d = r.renderMonth(new Date(t,n));
        r.monthsTranslate = r.monthsTranslate || 0;
        const p = r.monthsTranslate;
        let h;
        const m = !r.animating && a !== 0;
        c > u ? (r.monthsTranslate -= 1,
        r.animating || r.$months.eq(r.$months.length - 1).remove(),
        s.append(d),
        r.$months = s.find(".calendar-month"),
        h = -(p - 1) * 100 * l,
        r.$months.eq(r.$months.length - 1).transform(`translate3d(${i ? h : 0}%, ${i ? 0 : h}%, 0)`).addClass("calendar-month-next")) : (r.monthsTranslate += 1,
        r.animating || r.$months.eq(0).remove(),
        s.prepend(d),
        r.$months = s.find(".calendar-month"),
        h = -(p + 1) * 100 * l,
        r.$months.eq(0).transform(`translate3d(${i ? h : 0}%, ${i ? 0 : h}%, 0)`).addClass("calendar-month-prev")),
        r.emit("local::monthAdd calendarMonthAdd", f === "next" ? r.$months.eq(r.$months.length - 1)[0] : r.$months.eq(0)[0]),
        r.animating = !0,
        r.onMonthChangeStart(f);
        const g = r.monthsTranslate * 100 * l;
        s.transition(a).transform(`translate3d(${i ? g : 0}%, ${i ? 0 : g}%, 0)`),
        m && s.transitionEnd( () => {
            r.onMonthChangeEnd(f, !0)
        }
        ),
        (!o.animate || a === 0) && r.onMonthChangeEnd(f, !0)
    }
    nextYear() {
        const t = this;
        t.setYearMonth(t.currentYear + 1)
    }
    prevYear() {
        const t = this;
        t.setYearMonth(t.currentYear - 1)
    }
    dateInRange(t, n) {
        let a = !1, r;
        if (!n)
            return !1;
        if (Array.isArray(n))
            for (r = 0; r < n.length; r += 1)
                n[r].from || n[r].to ? n[r].from && n[r].to ? t <= new Date(n[r].to).getTime() && t >= new Date(n[r].from).getTime() && (a = !0) : n[r].from ? t >= new Date(n[r].from).getTime() && (a = !0) : n[r].to && t <= new Date(n[r].to).getTime() && (a = !0) : n[r].date ? t === new Date(n[r].date).getTime() && (a = !0) : t === new Date(n[r]).getTime() && (a = !0);
        else
            n.from || n.to ? n.from && n.to ? t <= new Date(n.to).getTime() && t >= new Date(n.from).getTime() && (a = !0) : n.from ? t >= new Date(n.from).getTime() && (a = !0) : n.to && t <= new Date(n.to).getTime() && (a = !0) : n.date ? a = t === new Date(n.date).getTime() : typeof n == "function" && (a = n(new Date(t)));
        return a
    }
    daysInMonth(t) {
        const n = new Date(t);
        return new Date(n.getFullYear(),n.getMonth() + 1,0).getDate()
    }
    renderMonths(t) {
        const n = this;
        return n.params.renderMonths ? n.params.renderMonths.call(n, t) : R("div", {
            class: "calendar-months-wrapper"
        }, n.renderMonth(t, "prev"), n.renderMonth(t), n.renderMonth(t, "next"))
    }
    renderMonth(t, n) {
        const a = this
          , {params: r, value: o} = a;
        if (r.renderMonth)
            return r.renderMonth.call(a, t, n);
        let i = new Date(t)
          , s = i.getFullYear()
          , l = i.getMonth()
          , c = a.monthNames.indexOf(a.monthFormatter(i));
        c < 0 && (c = l);
        let u = a.yearFormatter(i);
        n === "next" && (l === 11 ? i = new Date(s + 1,0) : i = new Date(s,l + 1,1)),
        n === "prev" && (l === 0 ? i = new Date(s - 1,11) : i = new Date(s,l - 1,1)),
        (n === "next" || n === "prev") && (l = i.getMonth(),
        s = i.getFullYear(),
        c = a.monthNames.indexOf(a.monthFormatter(i)),
        c < 0 && (c = l),
        u = a.yearFormatter(i));
        const f = []
          , d = new Date().setHours(0, 0, 0, 0)
          , p = r.minDate ? new Date(r.minDate).getTime() : null
          , h = r.maxDate ? new Date(r.maxDate).getTime() : null
          , m = 6
          , g = 7
          , b = a.daysInMonth(new Date(i.getFullYear(),i.getMonth()).getTime() - 10 * 24 * 60 * 60 * 1e3)
          , v = a.daysInMonth(i)
          , y = r.firstDay === 6 ? 0 : 1;
        let w = "", C = 0 + (r.firstDay - 1), _, E, z = new Date(i.getFullYear(),i.getMonth()).getDay();
        if (z === 0 && (z = 7),
        o && o.length)
            for (let T = 0; T < o.length; T += 1)
                f.push(new Date(o[T]).setHours(0, 0, 0, 0));
        for (let T = 1; T <= m; T += 1) {
            let A = "";
            for (let x = 1; x <= g; x += 1) {
                C += 1;
                let M, L = C - z, U = "";
                T === 1 && x === 1 && L > y && r.firstDay !== 1 && (C -= 7,
                L = C - z);
                const Y = x - 1 + r.firstDay > 6 ? x - 1 - 7 + r.firstDay : x - 1 + r.firstDay;
                L < 0 ? (L = b + L + 1,
                U += " calendar-day-prev",
                M = new Date(l - 1 < 0 ? s - 1 : s,l - 1 < 0 ? 11 : l - 1,L).getTime()) : (L += 1,
                L > v ? (L -= v,
                U += " calendar-day-next",
                M = new Date(l + 1 > 11 ? s + 1 : s,l + 1 > 11 ? 0 : l + 1,L).getTime()) : M = new Date(s,l,L).getTime()),
                M === d && (U += " calendar-day-today"),
                r.rangePicker && f.length === 2 ? (M >= f[0] && M <= f[1] && (U += " calendar-day-selected"),
                f[0] !== f[1] && (M > f[0] && M < f[1] && (U += " calendar-day-selected-range"),
                M === f[0] && (U += " calendar-day-selected-left"),
                M === f[1] && (U += " calendar-day-selected-right"))) : f.indexOf(M) >= 0 && (U += " calendar-day-selected"),
                r.weekendDays.indexOf(Y) >= 0 && (U += " calendar-day-weekend");
                let H = "";
                if (E = !1,
                r.events && a.dateInRange(M, r.events) && (E = !0),
                E && (U += " calendar-day-has-events",
                H = `
            <span class="calendar-day-events">
              <span class="calendar-day-event"></span>
            </span>
          `,
                Array.isArray(r.events))) {
                    const ne = [];
                    r.events.forEach(re => {
                        const ve = re.color || "";
                        ne.indexOf(ve) < 0 && a.dateInRange(M, re) && ne.push(ve)
                    }
                    ),
                    H = `
              <span class="calendar-day-events">
                ${ne.map(re => `
                  <span class="calendar-day-event" style="${re ? `background-color: ${re}` : ""}"></span>
                `.trim()).join("")}
              </span>
            `
                }
                if (r.rangesClasses)
                    for (let ne = 0; ne < r.rangesClasses.length; ne += 1)
                        a.dateInRange(M, r.rangesClasses[ne].range) && (U += ` ${r.rangesClasses[ne].cssClass}`);
                _ = !1,
                (p && M < p || h && M > h) && (_ = !0),
                r.disabled && a.dateInRange(M, r.disabled) && (_ = !0),
                _ && (U += " calendar-day-disabled"),
                M = new Date(M);
                const W = M.getFullYear()
                  , j = M.getMonth()
                  , Q = a.dayFormatter(M);
                A += `
          <div data-year="${W}" data-month="${j}" data-day="${L}" class="calendar-day${U}" data-date="${W}-${j}-${L}">
            <span class="calendar-day-number">${Q}${H}</span>
          </div>`.trim()
            }
            w += `<div class="calendar-row">${A}</div>`
        }
        return w = `<div class="calendar-month" data-year="${s}" data-month="${l}" data-locale-year="${u}" data-locale-month="${c}">${w}</div>`,
        w
    }
    renderWeekHeader() {
        const t = this;
        if (t.params.renderWeekHeader)
            return t.params.renderWeekHeader.call(t);
        const {params: n} = t;
        let a = "";
        for (let r = 0; r < 7; r += 1) {
            const o = r + n.firstDay > 6 ? r - 7 + n.firstDay : r + n.firstDay
              , i = t.dayNamesShort[o];
            a += `<div class="calendar-week-day">${i}</div>`
        }
        return R("div", {
            class: "calendar-week-header"
        }, a)
    }
    renderMonthSelector() {
        const t = this;
        return t.params.renderMonthSelector ? t.params.renderMonthSelector.call(t) : R("div", {
            class: "calendar-month-selector"
        }, R("a", {
            class: "link icon-only calendar-prev-month-button"
        }, R("i", {
            class: "icon icon-prev"
        })), t.params.monthPicker ? R("a", {
            class: "current-month-value link"
        }) : R("span", {
            class: "current-month-value"
        }), R("a", {
            class: "link icon-only calendar-next-month-button"
        }, R("i", {
            class: "icon icon-next"
        })))
    }
    renderYearSelector() {
        const t = this;
        return t.params.renderYearSelector ? t.params.renderYearSelector.call(t) : R("div", {
            class: "calendar-year-selector"
        }, R("a", {
            class: "link icon-only calendar-prev-year-button"
        }, R("i", {
            class: "icon icon-prev"
        })), t.params.yearPicker ? R("a", {
            class: "current-year-value link"
        }) : R("span", {
            class: "current-year-value"
        }), R("a", {
            class: "link icon-only calendar-next-year-button"
        }, R("i", {
            class: "icon icon-next"
        })))
    }
    renderTimeSelector() {
        const t = this
          , n = t.value && t.value[0];
        let a;
        return n && (a = t.timeSelectorFormatter(n)),
        R("div", {
            class: "calendar-time-selector"
        }, R("span", null, t.params.timePickerLabel), R("a", {
            class: "link"
        }, a || t.params.timePickerPlaceholder))
    }
    renderHeader() {
        const t = this;
        return t.params.renderHeader ? t.params.renderHeader.call(t) : R("div", {
            class: "calendar-header"
        }, R("div", {
            class: "calendar-selected-date"
        }, t.params.headerPlaceholder))
    }
    renderFooter() {
        const t = this
          , n = t.app;
        return t.params.renderFooter ? t.params.renderFooter.call(t) : R("div", {
            class: "calendar-footer"
        }, R("a", {
            class: `${n.theme === "md" ? "button" : "link"} calendar-close sheet-close popover-close`
        }, t.params.toolbarCloseText))
    }
    renderToolbar() {
        const t = this;
        return t.params.renderToolbar ? t.params.renderToolbar.call(t, t) : R("div", {
            class: "toolbar toolbar-top no-shadow"
        }, R("div", {
            class: "toolbar-inner"
        }, t.params.monthSelector ? t.renderMonthSelector() : "", t.params.yearSelector ? t.renderYearSelector() : ""))
    }
    renderInline() {
        const t = this
          , {cssClass: n, toolbar: a, header: r, footer: o, rangePicker: i, weekHeader: s} = t.params
          , {value: l, hasTimePicker: c} = t
          , u = l && l.length ? l[0] : new Date().setHours(0, 0, 0);
        return R("div", {
            class: `calendar calendar-inline ${i ? "calendar-range" : ""} ${n || ""}`
        }, r && t.renderHeader(), a && t.renderToolbar(), s && t.renderWeekHeader(), R("div", {
            class: "calendar-months"
        }, t.renderMonths(u)), c && t.renderTimeSelector(), o && t.renderFooter())
    }
    renderCustomModal() {
        const t = this
          , {cssClass: n, toolbar: a, header: r, footer: o, rangePicker: i, weekHeader: s} = t.params
          , {value: l, hasTimePicker: c} = t
          , u = l && l.length ? l[0] : new Date().setHours(0, 0, 0);
        return R("div", {
            class: `calendar calendar-modal ${i ? "calendar-range" : ""} ${n || ""}`
        }, r && t.renderHeader(), a && t.renderToolbar(), s && t.renderWeekHeader(), R("div", {
            class: "calendar-months"
        }, t.renderMonths(u)), c && t.renderTimeSelector(), o && t.renderFooter())
    }
    renderSheet() {
        const t = this
          , {cssClass: n, toolbar: a, header: r, footer: o, rangePicker: i, weekHeader: s} = t.params
          , {value: l, hasTimePicker: c} = t
          , u = l && l.length ? l[0] : new Date().setHours(0, 0, 0);
        return R("div", {
            class: `sheet-modal calendar calendar-sheet ${i ? "calendar-range" : ""} ${n || ""}`
        }, r && t.renderHeader(), a && t.renderToolbar(), s && t.renderWeekHeader(), R("div", {
            class: "sheet-modal-inner calendar-months"
        }, t.renderMonths(u)), c && t.renderTimeSelector(), o && t.renderFooter())
    }
    renderPopover() {
        const t = this
          , {cssClass: n, toolbar: a, header: r, footer: o, rangePicker: i, weekHeader: s} = t.params
          , {value: l, hasTimePicker: c} = t
          , u = l && l.length ? l[0] : new Date().setHours(0, 0, 0);
        return R("div", {
            class: "popover calendar-popover"
        }, R("div", {
            class: "popover-inner"
        }, R("div", {
            class: `calendar ${i ? "calendar-range" : ""} ${n || ""}`
        }, r && t.renderHeader(), a && t.renderToolbar(), s && t.renderWeekHeader(), R("div", {
            class: "calendar-months"
        }, t.renderMonths(u)), c && t.renderTimeSelector(), o && t.renderFooter())))
    }
    render() {
        const t = this
          , {params: n} = t;
        if (n.render)
            return n.render.call(t);
        if (!t.inline) {
            let a = n.openIn;
            return a === "auto" && (a = t.isPopover() ? "popover" : "sheet"),
            a === "popover" ? t.renderPopover() : a === "sheet" ? t.renderSheet() : t.renderCustomModal()
        }
        return t.renderInline()
    }
    openMonthPicker() {
        const t = this
          , {$el: n, app: a} = t;
        if (!n || !n.length)
            return;
        n.append('<div class="popover calendar-popover calendar-month-picker-popover"><div class="popover-inner"><div class="calendar-month-picker"></div></div></div>'),
        t.monthPickerPopover = a.popover.create({
            el: n.find(".calendar-month-picker-popover"),
            targetEl: n.find(".calendar-month-selector"),
            backdrop: !0,
            backdropUnique: !0,
            on: {
                close() {
                    t.closeMonthPicker()
                },
                closed() {
                    t.monthPickerPopover.$el && t.monthPickerPopover.$el.remove(),
                    t.monthPickerPopover.destroy(),
                    t.monthPickerInstance && (t.monthPickerInstance.close(),
                    t.monthPickerInstance.destroy()),
                    delete t.monthPickerInstance,
                    delete t.monthPickerPopover
                }
            }
        }),
        t.monthPickerPopover.open();
        const r = parseInt(t.$el.find(".calendar-month-current").attr("data-locale-month"), 10)
          , o = []
          , i = [];
        t.monthNames.forEach( (s, l) => {
            o.push(l),
            i.push(s)
        }
        ),
        t.monthPickerInstance = a.picker.create({
            containerEl: t.monthPickerPopover.$el.find(".calendar-month-picker"),
            value: [r],
            toolbar: !1,
            rotateEffect: !1,
            toolbarCloseText: t.params.toolbarCloseText,
            cols: [{
                values: o,
                displayValues: i
            }]
        })
    }
    closeMonthPicker() {
        const t = this;
        t.monthPickerPopover && t.monthPickerPopover.opened && t.monthPickerPopover.close();
        const n = t.monthPickerInstance.value[0]
          , a = parseInt(t.$el.find(".calendar-month-current").attr("data-locale-month"), 10)
          , r = t.currentMonth
          , o = a - r
          , i = n - o;
        t.setYearMonth(t.currentYear, i, 0)
    }
    openYearPicker() {
        const t = this
          , {$el: n, app: a} = t;
        if (!n || !n.length)
            return;
        n.append('<div class="popover calendar-popover calendar-year-picker-popover"><div class="popover-inner"><div class="calendar-year-picker"></div></div></div>'),
        t.yearPickerPopover = a.popover.create({
            el: n.find(".calendar-year-picker-popover"),
            targetEl: n.find(".calendar-year-selector"),
            backdrop: !0,
            backdropUnique: !0,
            on: {
                close() {
                    t.closeYearPicker()
                },
                closed() {
                    t.yearPickerPopover.$el && t.yearPickerPopover.$el.remove(),
                    t.yearPickerPopover.destroy(),
                    t.yearPickerInstance && (t.yearPickerInstance.close(),
                    t.yearPickerInstance.destroy()),
                    delete t.yearPickerInstance,
                    delete t.yearPickerPopover
                }
            }
        }),
        t.yearPickerPopover.open();
        const r = t.currentYear;
        let o = t.params.yearPickerMin || new Date().getFullYear() - 100;
        t.params.minDate && (o = Math.max(o, new Date(t.params.minDate).getFullYear()));
        let i = t.params.yearPickerMax || new Date().getFullYear() + 100;
        t.params.maxDate && (i = Math.min(i, new Date(t.params.maxDate).getFullYear()));
        const s = [];
        for (let l = o; l <= i; l += 1)
            s.push(l);
        t.yearPickerInstance = a.picker.create({
            containerEl: t.yearPickerPopover.$el.find(".calendar-year-picker"),
            value: [r],
            toolbar: !1,
            rotateEffect: !1,
            toolbarCloseText: t.params.toolbarCloseText,
            cols: [{
                values: s
            }]
        })
    }
    closeYearPicker() {
        const t = this;
        t.yearPickerPopover && t.yearPickerPopover.opened && t.yearPickerPopover.close(),
        t.setYearMonth(t.yearPickerInstance.value[0], void 0, 0)
    }
    openTimePicker() {
        const t = this
          , {$el: n, app: a, is12HoursFormat: r} = t;
        if (!n || !n.length)
            return;
        n.append('<div class="popover calendar-popover calendar-time-picker-popover"><div class="popover-inner"><div class="calendar-time-picker"></div></div></div>');
        const o = []
          , i = []
          , s = r ? 1 : 0
          , l = r ? 12 : 23;
        for (let u = s; u <= l; u += 1)
            o.push(u);
        for (let u = 0; u <= 59; u += 1)
            i.push(u);
        let c;
        t.value && t.value.length ? c = [t.value[0].getHours(), t.value[0].getMinutes()] : c = [new Date().getHours(), new Date().getMinutes()],
        r && (c.push(c[0] < 12 ? "AM" : "PM"),
        c[0] > 12 && (c[0] -= 12),
        c[0] === 0 && (c[0] = 12)),
        t.timePickerPopover = a.popover.create({
            el: n.find(".calendar-time-picker-popover"),
            targetEl: n.find(".calendar-time-selector .link"),
            backdrop: !0,
            backdropUnique: !0,
            on: {
                close() {
                    t.closeTimePicker()
                },
                closed() {
                    t.timePickerPopover.$el && t.timePickerPopover.$el.remove(),
                    t.timePickerPopover.destroy(),
                    t.timePickerInstance && (t.timePickerInstance.close(),
                    t.timePickerInstance.destroy()),
                    delete t.timePickerInstance,
                    delete t.timePickerPopover
                }
            }
        }),
        t.timePickerPopover.open(),
        t.timePickerInstance = a.picker.create({
            containerEl: t.timePickerPopover.$el.find(".calendar-time-picker"),
            value: c,
            toolbar: !1,
            rotateEffect: !1,
            toolbarCloseText: t.params.toolbarCloseText,
            cols: [{
                values: o
            }, {
                divider: !0,
                content: ":"
            }, {
                values: i,
                displayValues: i.map(u => u < 10 ? `0${u}` : u)
            }, ...r ? [{
                values: ["AM", "PM"]
            }] : []]
        })
    }
    closeTimePicker() {
        const t = this
          , {is12HoursFormat: n} = t;
        if (t.timePickerInstance) {
            const a = t.timePickerInstance.value;
            let r = parseInt(a[0], 10);
            const o = parseInt(a[1], 10)
              , i = t.timePickerInstance.value[2];
            n && (i === "AM" && r === 12 ? r = 0 : i === "PM" && r !== 12 && (r += 12));
            let s = t.value && t.value.length && t.value[0];
            s ? (s = new Date(s),
            s.setHours(r, o)) : (s = new Date,
            s.setHours(r, o, 0, 0)),
            t.setValue([s]),
            t.timePickerPopover && t.timePickerPopover.opened && t.timePickerPopover.close()
        }
    }
    onOpen() {
        const t = this
          , {initialized: n, $el: a, app: r, $inputEl: o, inline: i, value: s, params: l} = t;
        t.closing = !1,
        t.opened = !0,
        t.opening = !0,
        t.attachCalendarEvents();
        const c = !s && l.value;
        n ? s && t.setValue(s, 0) : s ? t.setValue(s, 0) : l.value && t.setValue(t.normalizeValues(l.value), 0),
        t.updateCurrentMonthYear(),
        t.monthsTranslate = 0,
        t.setMonthsTranslate(),
        c ? t.updateValue() : l.header && s && t.updateValue(!0),
        !i && o && o.length && r.theme === "md" && o.trigger("focus"),
        t.initialized = !0,
        t.$months.each(u => {
            t.emit("local::monthAdd calendarMonthAdd", u)
        }
        ),
        a && a.trigger("calendar:open"),
        o && o.trigger("calendar:open"),
        t.emit("local::open calendarOpen", t)
    }
    onOpened() {
        const t = this;
        t.opening = !1,
        t.$el && t.$el.trigger("calendar:opened"),
        t.$inputEl && t.$inputEl.trigger("calendar:opened"),
        t.emit("local::opened calendarOpened", t)
    }
    onClose() {
        const t = this
          , n = t.app;
        if (t.opening = !1,
        t.closing = !0,
        t.$inputEl)
            if (n.theme === "md")
                t.$inputEl.trigger("blur");
            else {
                const a = t.$inputEl.attr("validate")
                  , r = t.$inputEl.attr("required");
                a && r && n.input.validate(t.$inputEl)
            }
        t.detachCalendarEvents && t.detachCalendarEvents(),
        t.$el && t.$el.trigger("calendar:close"),
        t.$inputEl && t.$inputEl.trigger("calendar:close"),
        t.emit("local::close calendarClose", t)
    }
    onClosed() {
        const t = this;
        t.opened = !1,
        t.closing = !1,
        t.inline || un( () => {
            t.modal && t.modal.el && t.modal.destroy && (t.params.routableModals || t.modal.destroy()),
            delete t.modal
        }
        ),
        t.timePickerInstance && (t.timePickerInstance.destroy && t.timePickerInstance.destroy(),
        delete t.timePickerInstance),
        t.$el && t.$el.trigger("calendar:closed"),
        t.$inputEl && t.$inputEl.trigger("calendar:closed"),
        t.emit("local::closed calendarClosed", t)
    }
    open() {
        const t = this
          , {app: n, opened: a, inline: r, $inputEl: o, params: i} = t;
        if (a)
            return;
        if (r) {
            t.$el = $(t.render()),
            t.$el[0].f7Calendar = t,
            t.$wrapperEl = t.$el.find(".calendar-months-wrapper"),
            t.$months = t.$wrapperEl.find(".calendar-month"),
            t.$containerEl.append(t.$el),
            t.onOpen(),
            t.onOpened();
            return
        }
        let s = i.openIn;
        s === "auto" && (s = t.isPopover() ? "popover" : "sheet");
        const l = t.render()
          , c = {
            targetEl: o,
            scrollToEl: i.scrollToInput ? o : void 0,
            content: l,
            backdrop: i.backdrop === !0 || s === "popover" && n.params.popover.backdrop !== !1 && i.backdrop !== !1,
            closeByBackdropClick: i.closeByBackdropClick,
            on: {
                open() {
                    const u = this;
                    t.modal = u,
                    t.$el = s === "popover" ? u.$el.find(".calendar") : u.$el,
                    t.$wrapperEl = t.$el.find(".calendar-months-wrapper"),
                    t.$months = t.$wrapperEl.find(".calendar-month"),
                    t.$el[0].f7Calendar = t,
                    s === "customModal" && $(t.$el).find(".calendar-close").once("click", () => {
                        t.close()
                    }
                    ),
                    t.onOpen()
                },
                opened() {
                    t.onOpened()
                },
                close() {
                    t.onClose()
                },
                closed() {
                    t.onClosed()
                }
            }
        };
        s === "sheet" && (c.push = i.sheetPush,
        c.swipeToClose = i.sheetSwipeToClose),
        i.routableModals && t.view ? t.view.router.navigate({
            url: t.url,
            route: {
                path: t.url,
                [s]: c
            }
        }) : (t.modal = n[s].create(c),
        t.modal.open())
    }
    close() {
        const t = this
          , {opened: n, inline: a} = t;
        if (n) {
            if (a) {
                t.onClose(),
                t.onClosed();
                return
            }
            t.params.routableModals && t.view ? t.view.router.back() : t.modal.close()
        }
    }
    init() {
        const t = this;
        if (t.initInput(),
        t.inline) {
            t.open(),
            t.emit("local::init calendarInit", t);
            return
        }
        !t.initialized && t.params.value && t.setValue(t.normalizeValues(t.params.value)),
        t.$inputEl && t.attachInputEvents(),
        t.params.closeByOutsideClick && t.attachHtmlEvents(),
        t.emit("local::init calendarInit", t)
    }
    destroy() {
        const t = this;
        if (t.destroyed)
            return;
        const {$el: n} = t;
        t.emit("local::beforeDestroy calendarBeforeDestroy", t),
        n && n.trigger("calendar:beforedestroy"),
        t.close(),
        t.$inputEl && t.detachInputEvents(),
        t.params.closeByOutsideClick && t.detachHtmlEvents(),
        t.timePickerInstance && (t.timePickerInstance.destroy && t.timePickerInstance.destroy(),
        delete t.timePickerInstance),
        n && n.length && delete t.$el[0].f7Calendar,
        Yt(t),
        t.destroyed = !0
    }
}
;
const lj = {
    name: "calendar",
    static: {
        Calendar: jp
    },
    create() {
        const e = this;
        e.calendar = Gt({
            defaultSelector: ".calendar",
            constructor: jp,
            app: e,
            domProp: "f7Calendar"
        }),
        e.calendar.close = function(n) {
            n === void 0 && (n = ".calendar");
            const a = $(n);
            if (a.length === 0)
                return;
            const r = a[0].f7Calendar;
            !r || r && !r.opened || r.close()
        }
    },
    params: {
        calendar: {
            dateFormat: void 0,
            monthNames: "auto",
            monthNamesShort: "auto",
            dayNames: "auto",
            dayNamesShort: "auto",
            locale: void 0,
            firstDay: 1,
            weekendDays: [0, 6],
            multiple: !1,
            rangePicker: !1,
            rangePickerMinDays: 1,
            rangePickerMaxDays: 0,
            direction: "horizontal",
            minDate: null,
            maxDate: null,
            disabled: null,
            events: null,
            rangesClasses: null,
            touchMove: !0,
            animate: !0,
            closeOnSelect: !1,
            monthSelector: !0,
            monthPicker: !0,
            yearSelector: !0,
            yearPicker: !0,
            yearPickerMin: void 0,
            yearPickerMax: void 0,
            timePicker: !1,
            timePickerLabel: "Time",
            timePickerFormat: {
                hour: "numeric",
                minute: "numeric"
            },
            timePickerPlaceholder: "Select time",
            weekHeader: !0,
            value: null,
            containerEl: null,
            openIn: "auto",
            sheetPush: !1,
            sheetSwipeToClose: void 0,
            formatValue: null,
            inputEl: null,
            inputReadOnly: !0,
            closeByOutsideClick: !0,
            scrollToInput: !0,
            header: !1,
            headerPlaceholder: "Select date",
            toolbar: !0,
            toolbarCloseText: "Done",
            footer: !1,
            cssClass: null,
            routableModals: !1,
            view: null,
            url: "date/",
            backdrop: null,
            closeByBackdropClick: !0,
            renderWeekHeader: null,
            renderMonths: null,
            renderMonth: null,
            renderMonthSelector: null,
            renderYearSelector: null,
            renderHeader: null,
            renderFooter: null,
            renderToolbar: null,
            renderInline: null,
            renderPopover: null,
            renderSheet: null,
            render: null
        }
    }
};
function cj(e, t) {
    const n = this
      , a = $(e)
      , r = a.index()
      , o = n.cols[r];
    if (o.divider)
        return;
    o.$el = a,
    o.el = a[0],
    o.$itemsEl = o.$el.find(".picker-items"),
    o.items = o.$itemsEl.find(".picker-item");
    let i, s;
    o.replaceValues = function(f, d) {
        o.detachEvents(),
        o.values = f,
        o.displayValues = d,
        o.$itemsEl.html(n.renderColumn(o, !0)),
        o.items = o.$itemsEl.find(".picker-item"),
        o.calcSize(),
        o.setValue(o.values[0], !0),
        o.attachEvents()
    }
    ,
    o.calcSize = function() {
        s = o.$el[0].offsetHeight,
        i = o.items[0].offsetHeight;
        const f = o.el.style.getPropertyValue("--f7-picker-scroll-padding");
        o.el.style.setProperty("--f7-picker-scroll-padding", `${(s - i) / 2}px`),
        f || (o.$itemsEl[0].scrollTop = 0)
    }
    ,
    o.setValue = function(f, d) {
        const p = o.$itemsEl.find(`.picker-item[data-picker-value="${f}"]`).index();
        if (typeof p > "u" || p === -1)
            return;
        const h = p * i;
        o.$itemsEl[0].scrollTop = h,
        o.updateItems(p, h, d)
    }
    ,
    o.updateItems = function(f, d, p) {
        typeof d > "u" && (d = o.$itemsEl[0].scrollTop),
        typeof f > "u" && (f = Math.round(d / i)),
        f < 0 && (f = 0),
        f >= o.items.length && (f = o.items.length - 1);
        const h = o.activeIndex;
        o.activeIndex = f,
        o.$itemsEl.find(".picker-item-selected").removeClass("picker-item-selected");
        const m = o.items.eq(f);
        m.addClass("picker-item-selected").children().transform(""),
        n.params.rotateEffect && o.items.each(g => {
            const b = $(g)
              , y = (g.offsetTop - (s - i) / 2 - d) / i
              , w = Math.ceil(o.height / i / 2) + 1;
            let C = -24 * y;
            C > 180 && (C = 180),
            C < -180 && (C = -180),
            Math.abs(y) > w ? b.addClass("picker-item-far") : b.removeClass("picker-item-far"),
            b.children("span").transform(`translate3d(0, ${-y * i}px, -100px) rotateX(${C}deg)`)
        }
        ),
        (p || typeof p > "u") && (o.value = m.attr("data-picker-value"),
        o.displayValue = o.displayValues ? o.displayValues[f] : o.value,
        h !== f && (o.onChange && o.onChange(n, o.value, o.displayValue),
        n.updateValue()))
    }
    ;
    function l() {
        o.updateItems()
    }
    function c() {
        const u = $(this).attr("data-picker-value");
        o.setValue(u)
    }
    o.attachEvents = function() {
        o.$itemsEl.on("scroll", l),
        o.items.on("click", c)
    }
    ,
    o.detachEvents = function() {
        o.items.off("click", c)
    }
    ,
    o.init = function() {
        o.calcSize(),
        r === 0 && o.$el.addClass("picker-column-first"),
        r === n.cols.length - 1 && o.$el.addClass("picker-column-last"),
        n.params.freeMode && o.$el.addClass("picker-column-free-mode"),
        t && o.updateItems(0),
        o.attachEvents()
    }
    ,
    o.destroy = function() {
        o.detachEvents()
    }
    ,
    o.init()
}
let Up = class extends Bt {
    constructor(t, n) {
        n === void 0 && (n = {}),
        super(n, [t]);
        const a = this
          , r = yt()
          , o = He();
        a.params = se({}, t.params.picker, n);
        let i;
        if (a.params.containerEl && (i = $(a.params.containerEl),
        i.length === 0))
            return a;
        let s;
        a.params.inputEl && (s = $(a.params.inputEl));
        let l = a.params.scrollToInput ? s : void 0;
        if (a.params.scrollToEl) {
            const m = $(a.params.scrollToEl);
            m.length > 0 && (l = m)
        }
        se(a, {
            app: t,
            $containerEl: i,
            containerEl: i && i[0],
            inline: i && i.length > 0,
            needsOriginFix: r.ios || o.navigator.userAgent.toLowerCase().indexOf("safari") >= 0 && o.navigator.userAgent.toLowerCase().indexOf("chrome") < 0 && !r.android,
            cols: [],
            $inputEl: s,
            inputEl: s && s[0],
            $scrollToEl: l,
            initialized: !1,
            opened: !1,
            url: a.params.url
        });
        function c() {
            a.resizeCols()
        }
        function u() {
            a.open()
        }
        function f(m) {
            m.preventDefault()
        }
        let d = null;
        function p(m) {
            d = m.target
        }
        function h(m) {
            if (a.destroyed || !a.params)
                return;
            const g = $(m.target);
            a.isPopover() || !a.opened || a.closing || g.closest('[class*="backdrop"]').length || (s && s.length > 0 ? d === m.target && g[0] !== s[0] && g.closest(".sheet-modal").length === 0 && a.close() : $(m.target).closest(".sheet-modal").length === 0 && a.close())
        }
        return se(a, {
            attachResizeEvent() {
                t.on("resize", c)
            },
            detachResizeEvent() {
                t.off("resize", c)
            },
            attachInputEvents() {
                a.$inputEl.on("click", u),
                a.params.inputReadOnly && (a.$inputEl.on("focus mousedown", f),
                a.$inputEl[0] && (a.$inputEl[0].f7ValidateReadonly = !0))
            },
            detachInputEvents() {
                a.$inputEl.off("click", u),
                a.params.inputReadOnly && (a.$inputEl.off("focus mousedown", f),
                a.$inputEl[0] && delete a.$inputEl[0].f7ValidateReadonly)
            },
            attachHtmlEvents() {
                t.on("click", h),
                t.on("touchstart", p)
            },
            detachHtmlEvents() {
                t.off("click", h),
                t.off("touchstart", p)
            }
        }),
        a.init(),
        a
    }
    get view() {
        const {app: t, params: n, $inputEl: a} = this;
        let r;
        return n.view ? r = n.view : a && (r = a.parents(".view").length && a.parents(".view")[0].f7View),
        r || (r = t.views.main),
        r
    }
    initInput() {
        const t = this;
        t.$inputEl && t.params.inputReadOnly && t.$inputEl.prop("readOnly", !0)
    }
    resizeCols() {
        const t = this;
        if (t.opened)
            for (let n = 0; n < t.cols.length; n += 1)
                t.cols[n].divider || (t.cols[n].calcSize(),
                t.cols[n].setValue(t.cols[n].value, !1))
    }
    isPopover() {
        const t = this
          , {app: n, modal: a, params: r} = t
          , o = yt();
        if (r.openIn === "sheet" || a && a.type !== "popover")
            return !1;
        if (!t.inline && t.inputEl) {
            if (r.openIn === "popover")
                return !0;
            if (o.ios)
                return !!o.ipad;
            if (n.width >= 768 || o.desktop && n.theme === "aurora")
                return !0
        }
        return !1
    }
    formatValue() {
        const t = this
          , {value: n, displayValue: a} = t;
        return t.params.formatValue ? t.params.formatValue.call(t, n, a) : n.join(" ")
    }
    setValue(t) {
        const n = this;
        let a = 0;
        if (n.cols.length === 0) {
            n.value = t,
            n.updateValue(t);
            return
        }
        for (let r = 0; r < n.cols.length; r += 1)
            n.cols[r] && !n.cols[r].divider && (n.cols[r].setValue(t[a]),
            a += 1)
    }
    getValue() {
        return this.value
    }
    updateValue(t) {
        const n = this
          , a = t || []
          , r = [];
        let o;
        if (n.cols.length === 0) {
            const i = n.params.cols.filter(s => !s.divider);
            for (let s = 0; s < i.length; s += 1)
                o = i[s],
                o.displayValues !== void 0 && o.values !== void 0 && o.values.indexOf(a[s]) !== -1 ? r.push(o.displayValues[o.values.indexOf(a[s])]) : r.push(a[s])
        } else
            for (let i = 0; i < n.cols.length; i += 1)
                n.cols[i].divider || (a.push(n.cols[i].value),
                r.push(n.cols[i].displayValue));
        a.indexOf(void 0) >= 0 || (n.value = a,
        n.displayValue = r,
        n.emit("local::change pickerChange", n, n.value, n.displayValue),
        n.inputEl && (n.$inputEl.val(n.formatValue()),
        n.$inputEl.trigger("change")))
    }
    initColumn(t, n) {
        const a = this;
        cj.call(a, t, n)
    }
    destroyColumn(t) {
        const n = this
          , r = $(t).index();
        n.cols[r] && n.cols[r].destroy && n.cols[r].destroy()
    }
    renderToolbar() {
        const t = this;
        return t.params.renderToolbar ? t.params.renderToolbar.call(t, t) : R("div", {
            class: "toolbar toolbar-top no-shadow"
        }, R("div", {
            class: "toolbar-inner"
        }, R("div", {
            class: "left"
        }), R("div", {
            class: "right"
        }, R("a", {
            class: "link sheet-close popover-close"
        }, t.params.toolbarCloseText))))
    }
    renderColumn(t, n) {
        const a = `picker-column ${t.textAlign ? `picker-column-${t.textAlign}` : ""} ${t.cssClass || ""}`;
        let r, o;
        return t.divider ? r = `
        <div class="${a} picker-column-divider">${t.content}</div>
      ` : (o = t.values.map( (i, s) => `
        <div class="picker-item" data-picker-value="${i}">
          <span>${t.displayValues ? t.displayValues[s] : i}</span>
        </div>
      `).join(""),
        r = `
        <div class="${a}">
          <div class="picker-items">${o}</div>
        </div>
      `),
        n ? o.trim() : r.trim()
    }
    renderInline() {
        const t = this
          , {rotateEffect: n, cssClass: a, toolbar: r} = t.params;
        return R("div", {
            class: `picker picker-inline ${n ? "picker-3d" : ""} ${a || ""}`
        }, r && t.renderToolbar(), R("div", {
            class: "picker-columns"
        }, t.cols.map(i => t.renderColumn(i)), R("div", {
            class: "picker-center-highlight"
        })))
    }
    renderSheet() {
        const t = this
          , {rotateEffect: n, cssClass: a, toolbar: r} = t.params;
        return R("div", {
            class: `sheet-modal picker picker-sheet ${n ? "picker-3d" : ""} ${a || ""}`
        }, r && t.renderToolbar(), R("div", {
            class: "sheet-modal-inner picker-columns"
        }, t.cols.map(i => t.renderColumn(i)), R("div", {
            class: "picker-center-highlight"
        })))
    }
    renderPopover() {
        const t = this
          , {rotateEffect: n, cssClass: a, toolbar: r} = t.params;
        return R("div", {
            class: "popover picker-popover"
        }, R("div", {
            class: "popover-inner"
        }, R("div", {
            class: `picker ${n ? "picker-3d" : ""} ${a || ""}`
        }, r && t.renderToolbar(), R("div", {
            class: "picker-columns"
        }, t.cols.map(i => t.renderColumn(i)), R("div", {
            class: "picker-center-highlight"
        })))))
    }
    render() {
        const t = this;
        return t.params.render ? t.params.render.call(t) : t.inline ? t.renderInline() : t.isPopover() ? t.renderPopover() : t.renderSheet()
    }
    onOpen() {
        const t = this
          , {initialized: n, $el: a, app: r, $inputEl: o, inline: i, value: s, params: l} = t;
        t.opened = !0,
        t.closing = !1,
        t.opening = !0,
        t.attachResizeEvent(),
        a.find(".picker-column").each(c => {
            let u = !0;
            (!n && l.value || n && s) && (u = !1),
            t.initColumn(c, u)
        }
        ),
        n ? s && t.setValue(s) : s ? t.setValue(s) : l.value && t.setValue(l.value),
        !i && o && o.length && r.theme === "md" && o.trigger("focus"),
        t.initialized = !0,
        a && a.trigger("picker:open"),
        o && o.trigger("picker:open"),
        t.emit("local::open pickerOpen", t)
    }
    onOpened() {
        const t = this;
        t.opening = !1,
        t.$el && t.$el.trigger("picker:opened"),
        t.$inputEl && t.$inputEl.trigger("picker:opened"),
        t.emit("local::opened pickerOpened", t)
    }
    onClose() {
        const t = this
          , n = t.app;
        if (t.opening = !1,
        t.closing = !0,
        t.detachResizeEvent(),
        t.cols.forEach(a => {
            a.destroy && a.destroy()
        }
        ),
        t.$inputEl)
            if (n.theme === "md")
                t.$inputEl.trigger("blur");
            else {
                const a = t.$inputEl.attr("validate")
                  , r = t.$inputEl.attr("required");
                a && r && n.input.validate(t.$inputEl)
            }
        t.$el && t.$el.trigger("picker:close"),
        t.$inputEl && t.$inputEl.trigger("picker:close"),
        t.emit("local::close pickerClose", t)
    }
    onClosed() {
        const t = this;
        t.opened = !1,
        t.closing = !1,
        t.inline || un( () => {
            t.modal && t.modal.el && t.modal.destroy && (t.params.routableModals || t.modal.destroy()),
            delete t.modal
        }
        ),
        t.$el && t.$el.trigger("picker:closed"),
        t.$inputEl && t.$inputEl.trigger("picker:closed"),
        t.emit("local::closed pickerClosed", t)
    }
    open() {
        const t = this
          , {app: n, opened: a, inline: r, $inputEl: o, $scrollToEl: i, params: s} = t;
        if (a)
            return;
        if (t.cols.length === 0 && s.cols.length && s.cols.forEach(f => {
            t.cols.push(f)
        }
        ),
        r) {
            t.$el = $(t.render()),
            t.$el[0].f7Picker = t,
            t.$containerEl.append(t.$el),
            t.onOpen(),
            t.onOpened();
            return
        }
        const l = t.isPopover()
          , c = l ? "popover" : "sheet"
          , u = {
            targetEl: o,
            scrollToEl: i,
            content: t.render(),
            backdrop: typeof s.backdrop < "u" ? s.backdrop : l,
            on: {
                open() {
                    const f = this;
                    t.modal = f,
                    t.$el = l ? f.$el.find(".picker") : f.$el,
                    t.$el[0].f7Picker = t,
                    t.onOpen()
                },
                opened() {
                    t.onOpened()
                },
                close() {
                    t.onClose()
                },
                closed() {
                    t.onClosed()
                }
            }
        };
        c === "sheet" && (u.push = s.sheetPush,
        u.swipeToClose = s.sheetSwipeToClose),
        s.routableModals && t.view ? t.view.router.navigate({
            url: t.url,
            route: {
                path: t.url,
                [c]: u
            }
        }) : (t.modal = n[c].create(u),
        t.modal.open())
    }
    close() {
        const t = this
          , {opened: n, inline: a} = t;
        if (n) {
            if (a) {
                t.onClose(),
                t.onClosed();
                return
            }
            t.params.routableModals && t.view ? t.view.router.back() : t.modal.close()
        }
    }
    init() {
        const t = this;
        if (t.initInput(),
        t.inline) {
            t.open(),
            t.emit("local::init pickerInit", t);
            return
        }
        !t.initialized && t.params.value && t.setValue(t.params.value),
        t.$inputEl && t.attachInputEvents(),
        t.params.closeByOutsideClick && t.attachHtmlEvents(),
        t.emit("local::init pickerInit", t)
    }
    destroy() {
        const t = this;
        if (t.destroyed)
            return;
        const {$el: n} = t;
        t.emit("local::beforeDestroy pickerBeforeDestroy", t),
        n && n.trigger("picker:beforedestroy"),
        t.close(),
        t.$inputEl && t.detachInputEvents(),
        t.params.closeByOutsideClick && t.detachHtmlEvents(),
        n && n.length && delete t.$el[0].f7Picker,
        Yt(t),
        t.destroyed = !0
    }
}
;
const uj = {
    name: "picker",
    static: {
        Picker: Up
    },
    create() {
        const e = this;
        e.picker = Gt({
            defaultSelector: ".picker",
            constructor: Up,
            app: e,
            domProp: "f7Picker"
        }),
        e.picker.close = function(n) {
            n === void 0 && (n = ".picker");
            const a = $(n);
            if (a.length === 0)
                return;
            const r = a[0].f7Picker;
            !r || r && !r.opened || r.close()
        }
    },
    params: {
        picker: {
            rotateEffect: !1,
            freeMode: !1,
            cols: [],
            containerEl: null,
            openIn: "auto",
            sheetPush: !1,
            sheetSwipeToClose: void 0,
            backdrop: void 0,
            formatValue: null,
            inputEl: null,
            inputReadOnly: !0,
            closeByOutsideClick: !0,
            scrollToInput: !0,
            scrollToEl: void 0,
            toolbar: !0,
            toolbarCloseText: "Done",
            cssClass: null,
            routableModals: !1,
            view: null,
            url: "select/",
            renderToolbar: null,
            render: null
        }
    }
}
  , fj = {
    handle(e, t) {
        const n = this
          , a = $(e)
          , r = a[0].scrollTop
          , o = a[0].scrollHeight
          , i = a[0].offsetHeight;
        let s = a[0].getAttribute("data-infinite-distance");
        const l = a.find(".virtual-list");
        let c;
        const u = a.hasClass("infinite-scroll-top");
        if (s || (s = 50),
        typeof s == "string" && s.indexOf("%") >= 0 && (s = parseInt(s, 10) / 100 * i),
        s > i && (s = i),
        u)
            r < s && (a.trigger("infinite", t),
            n.emit("infinite", a[0], t));
        else if (r + i >= o - s) {
            if (l.length > 0 && (c = l.eq(-1)[0].f7VirtualList,
            c && !c.reachEnd && !c.params.updatableScroll))
                return;
            a.trigger("infinite", t),
            n.emit("infinite", a[0], t)
        }
    },
    create(e) {
        const t = $(e)
          , n = this;
        function a(r) {
            n.infiniteScroll.handle(this, r)
        }
        t.each(r => {
            r.f7InfiniteScrollHandler = a,
            r.addEventListener("scroll", r.f7InfiniteScrollHandler)
        }
        )
    },
    destroy(e) {
        $(e).each(n => {
            n.removeEventListener("scroll", n.f7InfiniteScrollHandler),
            delete n.f7InfiniteScrollHandler
        }
        )
    }
}
  , dj = {
    name: "infiniteScroll",
    create() {
        hn(this, {
            infiniteScroll: fj
        })
    },
    on: {
        tabMounted(e) {
            const t = this
              , n = $(e)
              , a = n.find(".infinite-scroll-content");
            n.is(".infinite-scroll-content") && a.add(n),
            a.each(r => {
                t.infiniteScroll.create(r)
            }
            )
        },
        tabBeforeRemove(e) {
            const t = $(e)
              , n = this
              , a = t.find(".infinite-scroll-content");
            t.is(".infinite-scroll-content") && a.add(t),
            a.each(r => {
                n.infiniteScroll.destroy(r)
            }
            )
        },
        pageInit(e) {
            const t = this;
            e.$el.find(".infinite-scroll-content").each(n => {
                t.infiniteScroll.create(n)
            }
            )
        },
        pageBeforeRemove(e) {
            const t = this;
            e.$el.find(".infinite-scroll-content").each(n => {
                t.infiniteScroll.destroy(n)
            }
            )
        }
    }
};
let qp = class extends Bt {
    constructor(t, n) {
        super({}, [t]);
        const a = this
          , r = yt()
          , o = Mt()
          , i = $(n)
          , s = i.find(".ptr-preloader");
        a.$el = i,
        a.el = i[0],
        a.app = t,
        a.bottom = a.$el.hasClass("ptr-bottom"),
        a.useModulesParams({});
        const l = t.theme === "md"
          , c = t.theme === "ios"
          , u = t.theme === "aurora";
        a.done = function() {
            const ye = l ? s : i
              , Le = Se => {
                $(Se.target).closest(s).length || (i.removeClass("ptr-transitioning ptr-pull-up ptr-pull-down ptr-closing"),
                i.trigger("ptr:done"),
                a.emit("local::done ptrDone", i[0]),
                ye.off("transitionend", Le))
            }
            ;
            return ye.on("transitionend", Le),
            i.removeClass("ptr-refreshing").addClass("ptr-transitioning ptr-closing"),
            a
        }
        ,
        a.refresh = function() {
            return i.hasClass("ptr-refreshing") || (i.addClass("ptr-transitioning ptr-refreshing"),
            i.trigger("ptr:refresh", a.done),
            a.emit("local::refresh ptrRefresh", i[0], a.done)),
            a
        }
        ,
        a.mousewheel = i.attr("data-ptr-mousewheel") === "true";
        let f, d, p;
        const h = {};
        let m, g, b = !1, v = !1, y = !1, w = 0, C, _, E, z, T, A, x = !1, M, L, U;
        const Y = i.parents(".page");
        if ((Y.find(".navbar").length > 0 || Y.parents(".view").children(".navbars").length > 0) && (x = !0),
        Y.hasClass("no-navbar") && (x = !1),
        !a.bottom) {
            const ee = t.navbar.getElByPage(Y[0]);
            if (ee) {
                const ye = $(ee)
                  , Le = ye.hasClass("navbar-large-transparent") || ye.hasClass("navbar-large") && ye.hasClass("navbar-transparent")
                  , Se = ye.hasClass("navbar-transparent") && !ye.hasClass("navbar-large");
                Le ? i.addClass("ptr-with-navbar-large-transparent") : Se && i.addClass("ptr-with-navbar-transparent")
            }
        }
        !x && !a.bottom && i.addClass("ptr-no-navbar"),
        i.attr("data-ptr-distance") ? T = !0 : l ? z = 66 : c ? z = 44 : u && (z = 38);
        function H(ee) {
            ee === void 0 && (ee = 0);
            const ye = s.find(".preloader-inner-line")
              , Le = 1 / ye.length;
            ye.forEach( (Se, Re) => {
                const Ve = (ee - Re * Le) / Le;
                Se.style.opacity = Math.max(Math.min(Ve, 1), 0) * .27
            }
            )
        }
        function W() {
            s.find(".preloader-inner-line").css("opacity", "")
        }
        function j(ee) {
            if (d)
                if (r.os === "android") {
                    if ("targetTouches"in ee && ee.targetTouches.length > 1)
                        return
                } else
                    return;
            i.hasClass("ptr-refreshing") || $(ee.target).closest(".sortable-handler, .ptr-ignore, .card-expandable.card-opened").length || (p = !1,
            A = !1,
            d = !0,
            m = void 0,
            E = void 0,
            ee.type === "touchstart" && (f = ee.targetTouches[0].identifier),
            h.x = ee.type === "touchstart" ? ee.targetTouches[0].pageX : ee.pageX,
            h.y = ee.type === "touchstart" ? ee.targetTouches[0].pageY : ee.pageY)
        }
        function Q(ee) {
            if (!d)
                return;
            let ye, Le, Se;
            if (ee.type === "touchmove") {
                if (f && ee.touches)
                    for (let Ve = 0; Ve < ee.touches.length; Ve += 1)
                        ee.touches[Ve].identifier === f && (Se = ee.touches[Ve]);
                Se || (Se = ee.targetTouches[0]),
                ye = Se.pageX,
                Le = Se.pageY
            } else
                ye = ee.pageX,
                Le = ee.pageY;
            if (!ye || !Le)
                return;
            if (typeof m > "u" && (m = !!(m || Math.abs(Le - h.y) > Math.abs(ye - h.x))),
            !m) {
                d = !1;
                return
            }
            if (_ = i[0].scrollTop,
            !p) {
                i.removeClass("ptr-transitioning"),
                c && H(0);
                let Ve;
                if (M = i[0].scrollHeight,
                L = i[0].offsetHeight,
                a.bottom && (U = M - L),
                _ > M) {
                    d = !1;
                    return
                }
                const Ze = $(ee.target).closest(".ptr-watch-scroll");
                if (Ze.length && Ze.each(q => {
                    q !== n && q.scrollHeight > q.offsetHeight && $(q).css("overflow") === "auto" && (!a.bottom && q.scrollTop > 0 || a.bottom && q.scrollTop < q.scrollHeight - q.offsetHeight) && (Ve = !0)
                }
                ),
                Ve) {
                    d = !1;
                    return
                }
                T && (z = i.attr("data-ptr-distance"),
                z.indexOf("%") >= 0 && (z = M * parseInt(z, 10) / 100)),
                w = i.hasClass("ptr-refreshing") ? z : 0,
                M === L || r.os !== "ios" || l ? v = !0 : v = !1,
                y = !1
            }
            if (p = !0,
            g = Le - h.y,
            typeof E > "u" && (a.bottom ? _ !== U : _ !== 0) && (E = !0),
            a.bottom ? g < 0 && _ >= U || _ > U : g > 0 && _ <= 0 || _ < 0) {
                r.os === "ios" && parseInt(r.osVersion.split(".")[0], 10) > 7 && (!a.bottom && _ === 0 && !E && (v = !0),
                a.bottom && _ === U && !E && (v = !0)),
                !v && a.bottom && !l && (i.css("-webkit-overflow-scrolling", "auto"),
                i.scrollTop(U),
                y = !0),
                v || y ? (ee.cancelable && ee.preventDefault(),
                C = (a.bottom ? -1 * Math.abs(g) ** .85 : g ** .85) + w,
                l ? s.transform(`translate3d(0,${C}px,0)`).find(".ptr-arrow").transform(`rotate(${180 * (Math.abs(g) / 66) + 100}deg)`) : (a.bottom || c ? i.children().transform(`translate3d(0,${C}px,0)`) : i.transform(`translate3d(0,${C}px,0)`),
                c && s.transform("translate3d(0,0px,0)"))) : c && !a.bottom && s.transform(`translate3d(0,${_}px,0)`);
                let Ve;
                c && !b && (Ve = v || y ? Math.abs(g) ** .85 / z : Math.abs(g) / (z * 2),
                H(Ve)),
                (v || y) && Math.abs(g) ** .85 > z || !v && Math.abs(g) >= z * 2 ? (b = !0,
                i.addClass("ptr-pull-up").removeClass("ptr-pull-down"),
                W()) : (b = !1,
                i.removeClass("ptr-pull-up").addClass("ptr-pull-down")),
                A || (i.trigger("ptr:pullstart"),
                a.emit("local::pullStart ptrPullStart", i[0]),
                A = !0),
                i.trigger("ptr:pullmove", {
                    event: ee,
                    scrollTop: _,
                    translate: C,
                    touchesDiff: g
                }),
                a.emit("local::pullMove ptrPullMove", i[0], {
                    event: ee,
                    scrollTop: _,
                    translate: C,
                    touchesDiff: g
                })
            } else
                A = !1,
                i.removeClass("ptr-pull-up ptr-pull-down"),
                b = !1
        }
        function ne(ee) {
            if (ee.type === "touchend" && ee.changedTouches && ee.changedTouches.length > 0 && f && ee.changedTouches[0].identifier !== f) {
                d = !1,
                m = !1,
                p = !1,
                f = null;
                return
            }
            if (!d || !p) {
                d = !1,
                p = !1;
                return
            }
            C && (i.addClass("ptr-transitioning"),
            C = 0),
            l ? s.transform("").find(".ptr-arrow").transform("") : (s.transform(""),
            a.bottom || c ? i.children().transform("") : i.transform("")),
            !v && a.bottom && !l && i.css("-webkit-overflow-scrolling", ""),
            b ? (i.addClass("ptr-refreshing"),
            i.trigger("ptr:refresh", a.done),
            a.emit("local::refresh ptrRefresh", i[0], a.done)) : i.removeClass("ptr-pull-down"),
            d = !1,
            p = !1,
            A && (i.trigger("ptr:pullend"),
            a.emit("local::pullEnd ptrPullEnd", i[0]))
        }
        let re, ve, Ne = !0, Ge = 0;
        function Ye() {
            Ne = !0,
            ve = !1,
            Ge = 0,
            C && (i.addClass("ptr-transitioning"),
            C = 0),
            l ? s.transform("").find(".ptr-arrow").transform("") : (s.transform(""),
            a.bottom ? i.children().transform("") : i.transform("")),
            b ? (i.addClass("ptr-refreshing"),
            i.trigger("ptr:refresh", a.done),
            a.emit("local::refresh ptrRefresh", i[0], a.done)) : i.removeClass("ptr-pull-down"),
            A && (i.trigger("ptr:pullend"),
            a.emit("local::pullEnd ptrPullEnd", i[0]))
        }
        function tt(ee) {
            if (!Ne)
                return;
            const {deltaX: ye, deltaY: Le} = ee;
            if (Math.abs(ye) > Math.abs(Le) || i.hasClass("ptr-refreshing") || $(ee.target).closest(".sortable-handler, .ptr-ignore, .card-expandable.card-opened").length)
                return;
            if (clearTimeout(re),
            _ = i[0].scrollTop,
            !ve) {
                i.removeClass("ptr-transitioning"),
                c && H(0);
                let Re;
                if (M = i[0].scrollHeight,
                L = i[0].offsetHeight,
                a.bottom && (U = M - L),
                _ > M) {
                    Ne = !1;
                    return
                }
                const Ve = $(ee.target).closest(".ptr-watch-scroll");
                if (Ve.length && Ve.each(Ze => {
                    Ze !== n && Ze.scrollHeight > Ze.offsetHeight && $(Ze).css("overflow") === "auto" && (!a.bottom && Ze.scrollTop > 0 || a.bottom && Ze.scrollTop < Ze.scrollHeight - Ze.offsetHeight) && (Re = !0)
                }
                ),
                Re) {
                    Ne = !1;
                    return
                }
                T && (z = i.attr("data-ptr-distance"),
                z.indexOf("%") >= 0 && (z = M * parseInt(z, 10) / 100))
            }
            if (p = !0,
            Ge -= Le,
            g = Ge,
            typeof E > "u" && (a.bottom ? _ !== U : _ !== 0) && (E = !0),
            a.bottom ? g < 0 && _ >= U || _ > U : g > 0 && _ <= 0 || _ < 0) {
                ee.cancelable && ee.preventDefault(),
                C = g,
                Math.abs(C) > z && (C = z + (Math.abs(C) - z) ** .7,
                a.bottom && (C = -C)),
                l ? s.transform(`translate3d(0,${C}px,0)`).find(".ptr-arrow").transform(`rotate(${180 * (Math.abs(g) / 66) + 100}deg)`) : a.bottom ? i.children().transform(`translate3d(0,${C}px,0)`) : (i.transform(`translate3d(0,${C}px,0)`),
                c && s.transform(`translate3d(0,${-C}px,0)`));
                let Re;
                c && !b && (Re = Math.abs(C) / z,
                H(Re)),
                Math.abs(C) > z ? (b = !0,
                i.addClass("ptr-pull-up").removeClass("ptr-pull-down"),
                W()) : (b = !1,
                i.removeClass("ptr-pull-up").addClass("ptr-pull-down")),
                A || (i.trigger("ptr:pullstart"),
                a.emit("local::pullStart ptrPullStart", i[0]),
                A = !0),
                i.trigger("ptr:pullmove", {
                    event: ee,
                    scrollTop: _,
                    translate: C,
                    touchesDiff: g
                }),
                a.emit("local::pullMove ptrPullMove", i[0], {
                    event: ee,
                    scrollTop: _,
                    translate: C,
                    touchesDiff: g
                })
            } else
                A = !1,
                i.removeClass("ptr-pull-up ptr-pull-down"),
                b = !1;
            re = setTimeout(Ye, 300)
        }
        return !Y.length || !i.length || (i[0].f7PullToRefresh = a,
        a.attachEvents = function() {
            const ye = o.passiveListener ? {
                passive: !0
            } : !1;
            i.on(t.touchEvents.start, j, ye),
            t.on("touchmove:active", Q),
            t.on("touchend:passive", ne),
            a.mousewheel && !a.bottom && i.on("wheel", tt)
        }
        ,
        a.detachEvents = function() {
            const ye = o.passiveListener ? {
                passive: !0
            } : !1;
            i.off(t.touchEvents.start, j, ye),
            t.off("touchmove:active", Q),
            t.off("touchend:passive", ne),
            a.mousewheel && !a.bottom && i.off("wheel", tt)
        }
        ,
        a.useModules(),
        a.init()),
        a
    }
    init() {
        this.attachEvents()
    }
    destroy() {
        let t = this;
        t.emit("local::beforeDestroy ptrBeforeDestroy", t),
        t.$el.trigger("ptr:beforedestroy"),
        delete t.el.f7PullToRefresh,
        t.detachEvents(),
        Yt(t),
        t = null
    }
}
;
const pj = {
    name: "pullToRefresh",
    create() {
        const e = this;
        e.ptr = se(Gt({
            defaultSelector: ".ptr-content",
            constructor: qp,
            app: e,
            domProp: "f7PullToRefresh"
        }), {
            done(t) {
                const n = e.ptr.get(t);
                if (n)
                    return n.done()
            },
            refresh(t) {
                const n = e.ptr.get(t);
                if (n)
                    return n.refresh()
            }
        })
    },
    static: {
        PullToRefresh: qp
    },
    on: {
        tabMounted(e) {
            const t = this
              , n = $(e)
              , a = n.find(".ptr-content");
            n.is(".ptr-content") && a.add(n),
            a.each(r => {
                t.ptr.create(r)
            }
            )
        },
        tabBeforeRemove(e) {
            const t = $(e)
              , n = this
              , a = t.find(".ptr-content");
            t.is(".ptr-content") && a.add(t),
            a.each(r => {
                n.ptr.destroy(r)
            }
            )
        },
        pageInit(e) {
            const t = this;
            e.$el.find(".ptr-content").each(n => {
                t.ptr.create(n)
            }
            )
        },
        pageBeforeRemove(e) {
            const t = this;
            e.$el.find(".ptr-content").each(n => {
                t.ptr.destroy(n)
            }
            )
        }
    }
}
  , hj = {
    destroy(e) {
        const t = $(e).closest(".page");
        t.length && t[0].f7LazyDestroy && t[0].f7LazyDestroy()
    },
    create(e) {
        const t = this
          , n = He()
          , a = Mt()
          , r = $(e).closest(".page").eq(0)
          , o = r.find(".lazy");
        if (o.length === 0 && !r.hasClass("lazy"))
            return;
        const i = t.params.lazy.placeholder;
        i !== !1 && o.each(h => {
            $(h).attr("data-src") && !$(h).attr("src") && $(h).attr("src", i)
        }
        );
        const s = [];
        let l = !1;
        function c(h) {
            s.indexOf(h) >= 0 && s.splice(s.indexOf(h), 1),
            l = !1,
            t.params.lazy.sequential && s.length > 0 && (l = !0,
            t.lazy.loadImage(s[0], c))
        }
        function u(h, m) {
            h.forEach(g => {
                if (g.isIntersecting) {
                    if (t.params.lazy.sequential && l) {
                        s.indexOf(g.target) < 0 && s.push(g.target);
                        return
                    }
                    l = !0,
                    t.lazy.loadImage(g.target, c),
                    m.unobserve(g.target)
                }
            }
            )
        }
        if (t.params.lazy.observer && a.intersectionObserver) {
            let h = r[0].f7LazyObserver;
            h || (h = new n.IntersectionObserver(u,{
                root: r[0]
            })),
            o.each(m => {
                m.f7LazyObserverAdded || (m.f7LazyObserverAdded = !0,
                h.observe(m))
            }
            ),
            r[0].f7LazyDestroy || (r[0].f7LazyDestroy = () => {
                h.disconnect(),
                delete r[0].f7LazyDestroy,
                delete r[0].f7LazyObserver
            }
            );
            return
        }
        function f() {
            t.lazy.load(r, h => {
                if (t.params.lazy.sequential && l) {
                    s.indexOf(h) < 0 && s.push(h);
                    return
                }
                l = !0,
                t.lazy.loadImage(h, c)
            }
            )
        }
        function d() {
            r[0].f7LazyAttached = !0,
            r.on("lazy", f),
            r.on("scroll", f, !0),
            r.find(".tab").on("tab:mounted tab:show", f),
            t.on("resize", f)
        }
        function p() {
            r[0].f7LazyAttached = !1,
            delete r[0].f7LazyAttached,
            r.off("lazy", f),
            r.off("scroll", f, !0),
            r.find(".tab").off("tab:mounted tab:show", f),
            t.off("resize", f)
        }
        r[0].f7LazyDestroy || (r[0].f7LazyDestroy = p),
        r[0].f7LazyAttached || d(),
        f()
    },
    isInViewport(e) {
        const t = this
          , n = e.getBoundingClientRect()
          , a = t.params.lazy.threshold || 0;
        return n.top >= 0 - a && n.left >= 0 - a && n.top <= t.height + a && n.left <= t.width + a
    },
    loadImage(e, t) {
        const n = this
          , a = He()
          , r = $(e)
          , o = r.attr("data-background")
          , i = o || r.attr("data-src");
        function s() {
            r.removeClass("lazy").addClass("lazy-loaded"),
            o ? r.css("background-image", `url(${i})`) : i && r.attr("src", i),
            t && t(e),
            r.trigger("lazy:loaded"),
            n.emit("lazyLoaded", r[0])
        }
        if (!i) {
            r.trigger("lazy:load"),
            n.emit("lazyLoad", r[0]),
            s();
            return
        }
        function l() {
            r.removeClass("lazy").addClass("lazy-loaded"),
            o ? r.css("background-image", `url(${n.params.lazy.placeholder || ""})`) : r.attr("src", n.params.lazy.placeholder || ""),
            t && t(e),
            r.trigger("lazy:error"),
            n.emit("lazyError", r[0])
        }
        const c = new a.Image;
        c.onload = s,
        c.onerror = l,
        c.src = i,
        r.removeAttr("data-src").removeAttr("data-background"),
        r.trigger("lazy:load"),
        n.emit("lazyLoad", r[0])
    },
    load(e, t) {
        const n = this;
        let a = $(e);
        a.hasClass("page") || (a = a.parents(".page").eq(0)),
        a.length !== 0 && a.find(".lazy").each(r => {
            $(r).parents(".tab:not(.tab-active)").length > 0 || n.lazy.isInViewport(r) && (t ? t(r) : n.lazy.loadImage(r))
        }
        )
    }
}
  , mj = {
    name: "lazy",
    params: {
        lazy: {
            placeholder: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAAA1BMVEXCwsK592mkAAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==",
            threshold: 0,
            sequential: !0,
            observer: !0
        }
    },
    create() {
        hn(this, {
            lazy: hj
        })
    },
    on: {
        pageInit(e) {
            const t = this;
            (e.$el.find(".lazy").length > 0 || e.$el.hasClass("lazy")) && t.lazy.create(e.$el)
        },
        pageAfterIn(e) {
            const t = this
              , n = Mt();
            t.params.lazy.observer && n.intersectionObserver || (e.$el.find(".lazy").length > 0 || e.$el.hasClass("lazy")) && t.lazy.create(e.$el)
        },
        pageBeforeRemove(e) {
            const t = this;
            (e.$el.find(".lazy").length > 0 || e.$el.hasClass("lazy")) && t.lazy.destroy(e.$el)
        },
        tabMounted(e) {
            const t = this
              , n = $(e);
            (n.find(".lazy").length > 0 || n.hasClass("lazy")) && t.lazy.create(n)
        },
        tabBeforeRemove(e) {
            const t = this
              , n = Mt();
            if (t.params.lazy.observer && n.intersectionObserver)
                return;
            const a = $(e);
            (a.find(".lazy").length > 0 || a.hasClass("lazy")) && t.lazy.destroy(a)
        }
    }
};
let Wp = class extends Bt {
    constructor(t, n) {
        n === void 0 && (n = {}),
        super(n, [t]);
        const a = this
          , r = {};
        a.useModulesParams(r),
        a.params = se(r, n);
        const o = $(a.params.el);
        if (o.length === 0)
            return;
        if (a.$el = o,
        a.el = o[0],
        a.$el[0].f7DataTable) {
            const l = a.$el[0].f7DataTable;
            return a.destroy(),
            l
        }
        a.$el[0].f7DataTable = a,
        se(a, {
            collapsible: o.hasClass("data-table-collapsible"),
            $headerEl: o.find(".data-table-header"),
            $headerSelectedEl: o.find(".data-table-header-selected")
        });
        function i(l) {
            if (l.detail && l.detail.sentByF7DataTable)
                return;
            const c = $(this)
              , u = c[0].checked
              , f = c.parents("td,th").index();
            if (c.parents("thead").length > 0)
                f === 0 && o.find("tbody tr")[u ? "addClass" : "removeClass"]("data-table-row-selected"),
                o.find(`tbody tr td:nth-child(${f + 1}) input`).prop("checked", u).trigger("change", {
                    sentByF7DataTable: !0
                }),
                c.prop("indeterminate", !1);
            else {
                f === 0 && c.parents("tr")[u ? "addClass" : "removeClass"]("data-table-row-selected");
                const d = o.find(`tbody .checkbox-cell:nth-child(${f + 1}) input[type="checkbox"]:checked`).length
                  , p = o.find("tbody tr").length
                  , h = o.find(`thead .checkbox-cell:nth-child(${f + 1}) input[type="checkbox"]`);
                u ? d === p && h.prop("checked", !0).trigger("change", {
                    sentByF7DataTable: !0
                }) : h.prop("checked", !1),
                h.prop("indeterminate", d > 0 && d < p)
            }
            a.checkSelectedHeader()
        }
        function s() {
            const l = $(this)
              , c = l.hasClass("sortable-cell-active")
              , u = l.hasClass("sortable-desc") ? "desc" : "asc";
            let f;
            c ? (f = u === "desc" ? "asc" : "desc",
            l.removeClass("sortable-desc sortable-asc").addClass(`sortable-${f}`)) : (o.find("thead .sortable-cell-active").removeClass("sortable-cell-active"),
            l.addClass("sortable-cell-active"),
            f = u),
            l.trigger("datatable:sort", f),
            a.emit("local::sort dataTableSort", a, f)
        }
        return a.attachEvents = function() {
            a.$el.on("change", '.checkbox-cell input[type="checkbox"]', i),
            a.$el.find("thead .sortable-cell").on("click", s)
        }
        ,
        a.detachEvents = function() {
            a.$el.off("change", '.checkbox-cell input[type="checkbox"]', i),
            a.$el.find("thead .sortable-cell").off("click", s)
        }
        ,
        a.useModules(),
        a.init(),
        a
    }
    setCollapsibleLabels() {
        const t = this;
        t.collapsible && t.$el.find("tbody td:not(.checkbox-cell)").each(n => {
            const a = $(n)
              , r = a.index()
              , o = a.attr("data-collapsible-title");
            !o && o !== "" && a.attr("data-collapsible-title", t.$el.find("thead th").eq(r).text())
        }
        )
    }
    checkSelectedHeader() {
        const t = this;
        if (t.$headerEl.length > 0 && t.$headerSelectedEl.length > 0) {
            const n = t.$el.find("tbody .checkbox-cell input:checked").length;
            t.$el[n > 0 ? "addClass" : "removeClass"]("data-table-has-checked"),
            t.$headerSelectedEl.find(".data-table-selected-count").text(n)
        }
    }
    init() {
        const t = this;
        t.attachEvents(),
        t.setCollapsibleLabels(),
        t.checkSelectedHeader()
    }
    destroy() {
        let t = this;
        t.$el.trigger("datatable:beforedestroy"),
        t.emit("local::beforeDestroy dataTableBeforeDestroy", t),
        t.attachEvents(),
        t.$el[0] && (t.$el[0].f7DataTable = null,
        delete t.$el[0].f7DataTable),
        Yt(t),
        t = null
    }
}
;
const gj = {
    name: "dataTable",
    static: {
        DataTable: Wp
    },
    create() {
        const e = this;
        e.dataTable = Gt({
            defaultSelector: ".data-table",
            constructor: Wp,
            app: e,
            domProp: "f7DataTable"
        })
    },
    on: {
        tabBeforeRemove(e) {
            const t = this;
            $(e).find(".data-table-init").each(n => {
                t.dataTable.destroy(n)
            }
            )
        },
        tabMounted(e) {
            const t = this;
            $(e).find(".data-table-init").each(n => {
                t.dataTable.create({
                    el: n
                })
            }
            )
        },
        pageBeforeRemove(e) {
            const t = this;
            e.$el.find(".data-table-init").each(n => {
                t.dataTable.destroy(n)
            }
            )
        },
        pageInit(e) {
            const t = this;
            e.$el.find(".data-table-init").each(n => {
                t.dataTable.create({
                    el: n
                })
            }
            )
        }
    },
    vnode: {
        "data-table-init": {
            insert(e) {
                const t = this
                  , n = e.elm;
                t.dataTable.create({
                    el: n
                })
            },
            destroy(e) {
                const t = this
                  , n = e.elm;
                t.dataTable.destroy(n)
            }
        }
    }
}
  , vj = {
    morphOpen(e, t) {
        const n = this
          , a = $(e)
          , r = $(t);
        if (r.length === 0)
            return;
        r.transition(0).addClass("fab-morph-target-visible");
        const o = {
            width: r[0].offsetWidth,
            height: r[0].offsetHeight,
            offset: r.offset(),
            borderRadius: r.css("border-radius"),
            zIndex: r.css("z-index")
        }
          , i = {
            width: a[0].offsetWidth,
            height: a[0].offsetHeight,
            offset: a.offset(),
            translateX: w1(a[0], "x"),
            translateY: w1(a[0], "y")
        };
        a[0].f7FabMorphData = {
            $targetEl: r,
            target: o,
            fab: i
        };
        const s = i.offset.left + i.width / 2 - (o.offset.left + o.width / 2) - i.translateX
          , l = i.offset.top + i.height / 2 - (o.offset.top + o.height / 2) - i.translateY
          , c = o.width / i.width
          , u = o.height / i.height;
        let f = Math.ceil(parseInt(o.borderRadius, 10) / Math.max(c, u));
        f > 0 && (f += 2),
        a[0].f7FabMorphResizeHandler = function() {
            a.transition(0).transform(""),
            r.transition(0),
            o.width = r[0].offsetWidth,
            o.height = r[0].offsetHeight,
            o.offset = r.offset(),
            i.offset = a.offset();
            const p = i.offset.left + i.width / 2 - (o.offset.left + o.width / 2) - i.translateX
              , h = i.offset.top + i.height / 2 - (o.offset.top + o.height / 2) - i.translateY
              , m = o.width / i.width
              , g = o.height / i.height;
            a.transform(`translate3d(${-p}px, ${-h}px, 0) scale(${m}, ${g})`)
        }
        ,
        r.css("opacity", 0).transform(`scale(${1 / c}, ${1 / u})`),
        a.addClass("fab-opened").css("z-index", o.zIndex - 1).transform(`translate3d(${-s}px, ${-l}px, 0)`),
        a.transitionEnd( () => {
            r.transition(""),
            xn( () => {
                r.css("opacity", 1).transform("scale(1,1)"),
                a.transform(`translate3d(${-s}px, ${-l}px, 0) scale(${c}, ${u})`).css("border-radius", `${f}px`).css("box-shadow", "none").css("opacity", "0")
            }
            ),
            n.on("resize", a[0].f7FabMorphResizeHandler),
            r.parents(".page-content").length > 0 && r.parents(".page-content").on("scroll", a[0].f7FabMorphResizeHandler)
        }
        )
    },
    morphClose(e) {
        const t = this
          , n = $(e)
          , a = n[0].f7FabMorphData;
        if (!a)
            return;
        const {$targetEl: r, target: o, fab: i} = a;
        if (r.length === 0)
            return;
        const s = i.offset.left + i.width / 2 - (o.offset.left + o.width / 2) - i.translateX
          , l = i.offset.top + i.height / 2 - (o.offset.top + o.height / 2) - i.translateY
          , c = o.width / i.width
          , u = o.height / i.height;
        t.off("resize", n[0].f7FabMorphResizeHandler),
        r.parents(".page-content").length > 0 && r.parents(".page-content").off("scroll", n[0].f7FabMorphResizeHandler),
        r.css("opacity", 0).transform(`scale(${1 / c}, ${1 / u})`),
        n.transition("").css("box-shadow", "").css("border-radius", "").css("opacity", "1").transform(`translate3d(${-s}px, ${-l}px, 0)`),
        n.transitionEnd( () => {
            n.css("z-index", "").removeClass("fab-opened").transform(""),
            xn( () => {
                n.transitionEnd( () => {
                    r.removeClass("fab-morph-target-visible").css("opacity", "").transform("").transition("")
                }
                )
            }
            )
        }
        )
    },
    open(e, t) {
        const n = this
          , a = $(e).eq(0)
          , r = a.find(".fab-buttons");
        if (a.length && !a.hasClass("fab-opened") && !(!r.length && !a.hasClass("fab-morph"))) {
            if (n.fab.openedEl) {
                if (n.fab.openedEl === a[0])
                    return;
                n.fab.close(n.fab.openedEl)
            }
            n.fab.openedEl = a[0],
            a.hasClass("fab-morph") ? n.fab.morphOpen(a, t || a.attr("data-morph-to")) : a.addClass("fab-opened"),
            a.siblings(".fab-backdrop").addClass("backdrop-in"),
            a.trigger("fab:open")
        }
    },
    close(e) {
        e === void 0 && (e = ".fab-opened");
        const t = this
          , n = $(e).eq(0)
          , a = n.find(".fab-buttons");
        n.length && n.hasClass("fab-opened") && (!a.length && !n.hasClass("fab-morph") || (t.fab.openedEl = null,
        n.hasClass("fab-morph") ? t.fab.morphClose(n) : n.removeClass("fab-opened"),
        n.siblings(".fab-backdrop").removeClass("backdrop-in"),
        n.trigger("fab:close")))
    },
    toggle(e) {
        const t = this;
        $(e).hasClass("fab-opened") ? t.fab.close(e) : t.fab.open(e)
    }
}
  , bj = {
    name: "fab",
    create() {
        hn(this, {
            fab: {
                openedEl: null,
                ...vj
            }
        })
    },
    clicks: {
        ".fab > a": function(t) {
            this.fab.toggle(t.parents(".fab"))
        },
        ".fab-open": function(t, n) {
            n === void 0 && (n = {}),
            this.fab.open(n.fab)
        },
        ".fab-close": function(t, n) {
            n === void 0 && (n = {}),
            this.fab.close(n.fab)
        },
        ".fab-backdrop": function() {
            this.fab.close()
        }
    }
};
let Yp = class extends Bt {
    constructor(t, n) {
        n === void 0 && (n = {}),
        super(n, [t]);
        const a = this
          , r = {
            el: void 0,
            inputEl: void 0,
            inputEvents: "change input compositionend",
            disableButton: !0,
            disableButtonEl: void 0,
            backdropEl: void 0,
            searchContainer: void 0,
            searchItem: "li",
            searchIn: void 0,
            searchGroup: ".list-group",
            searchGroupTitle: ".item-divider, .list-group-title",
            ignore: ".searchbar-ignore",
            foundEl: ".searchbar-found",
            notFoundEl: ".searchbar-not-found",
            hideOnEnableEl: ".searchbar-hide-on-enable",
            hideOnSearchEl: ".searchbar-hide-on-search",
            backdrop: void 0,
            removeDiacritics: !0,
            customSearch: !1,
            hideDividers: !0,
            hideGroups: !0,
            disableOnBackdropClick: !0,
            expandable: !1,
            inline: !1
        };
        a.useModulesParams(r),
        a.params = se(r, n);
        const o = $(a.params.el);
        if (o.length === 0)
            return a;
        if (o[0].f7Searchbar)
            return o[0].f7Searchbar;
        o[0].f7Searchbar = a;
        let i;
        const s = o.parents(".navbar");
        if (o.parents(".page").length > 0)
            i = o.parents(".page");
        else if (s.length > 0 && (i = $(t.navbar.getPageByEl(s[0])),
        !i.length)) {
            const A = o.parents(".view").find(".page-current");
            A[0] && A[0].f7Page && A[0].f7Page.navbarEl === s[0] && (i = A)
        }
        let l;
        n.foundEl ? l = $(n.foundEl) : typeof a.params.foundEl == "string" && i && (l = i.find(a.params.foundEl));
        let c;
        n.notFoundEl ? c = $(n.notFoundEl) : typeof a.params.notFoundEl == "string" && i && (c = i.find(a.params.notFoundEl));
        let u;
        n.hideOnEnableEl ? u = $(n.hideOnEnableEl) : typeof a.params.hideOnEnableEl == "string" && i && (u = i.find(a.params.hideOnEnableEl));
        let f;
        n.hideOnSearchEl ? f = $(n.hideOnSearchEl) : typeof a.params.hideOnSearchEl == "string" && i && (f = i.find(a.params.hideOnSearchEl));
        const d = a.params.expandable || o.hasClass("searchbar-expandable")
          , p = a.params.inline || o.hasClass("searchbar-inline");
        typeof a.params.backdrop > "u" && (p ? a.params.backdrop = !1 : a.params.backdrop = t.theme !== "aurora");
        let h;
        a.params.backdrop && (a.params.backdropEl ? h = $(a.params.backdropEl) : i && i.length > 0 ? h = i.find(".searchbar-backdrop") : h = o.siblings(".searchbar-backdrop"),
        h.length === 0 && (h = $('<div class="searchbar-backdrop"></div>'),
        i && i.length ? o.parents(i).length > 0 && s && o.parents(s).length === 0 ? h.insertBefore(o) : h.insertBefore(i.find(".page-content").eq(0)) : h.insertBefore(o)));
        let m;
        a.params.searchContainer && (m = $(a.params.searchContainer));
        let g;
        a.params.inputEl ? g = $(a.params.inputEl) : g = o.find('input[type="search"]').eq(0);
        let b;
        a.params.disableButton && (a.params.disableButtonEl ? b = $(a.params.disableButtonEl) : b = o.find(".searchbar-disable-button")),
        se(a, {
            app: t,
            view: t.views.get(o.parents(".view")),
            $el: o,
            el: o[0],
            $backdropEl: h,
            backdropEl: h && h[0],
            $searchContainer: m,
            searchContainer: m && m[0],
            $inputEl: g,
            inputEl: g[0],
            $disableButtonEl: b,
            disableButtonEl: b && b[0],
            disableButtonHasMargin: !1,
            $pageEl: i,
            pageEl: i && i[0],
            $navbarEl: s,
            navbarEl: s && s[0],
            $foundEl: l,
            foundEl: l && l[0],
            $notFoundEl: c,
            notFoundEl: c && c[0],
            $hideOnEnableEl: u,
            hideOnEnableEl: u && u[0],
            $hideOnSearchEl: f,
            hideOnSearchEl: f && f[0],
            previousQuery: "",
            query: "",
            isVirtualList: m && m.hasClass("virtual-list"),
            virtualList: void 0,
            enabled: !1,
            expandable: d,
            inline: p
        });
        function v(A) {
            A.preventDefault()
        }
        function y(A) {
            a.enable(A),
            a.$el.addClass("searchbar-focused")
        }
        function w() {
            a.$el.removeClass("searchbar-focused"),
            t.theme === "aurora" && (!b || !b.length || !a.params.disableButton) && !a.query && a.disable()
        }
        function C() {
            const A = a.$inputEl.val().trim();
            (a.$searchContainer && a.$searchContainer.length > 0 && (a.params.searchIn || a.isVirtualList || a.params.searchIn === a.params.searchItem) || a.params.customSearch) && a.search(A, !0)
        }
        function _(A, x) {
            a.$el.trigger("searchbar:clear", x),
            a.emit("local::clear searchbarClear", a, x)
        }
        function E(A) {
            a.disable(A)
        }
        function z() {
            !a || a && !a.$el || a.enabled && (a.$el.removeClass("searchbar-enabled"),
            a.expandable && a.$el.parents(".navbar").removeClass("with-searchbar-expandable-enabled with-searchbar-expandable-enabled-no-transition"))
        }
        function T() {
            !a || a && !a.$el || a.enabled && (a.$el.addClass("searchbar-enabled"),
            a.expandable && a.$el.parents(".navbar").addClass("with-searchbar-expandable-enabled-no-transition"))
        }
        return a.attachEvents = function() {
            o.on("submit", v),
            a.params.disableButton && a.$disableButtonEl.on("click", E),
            a.params.disableOnBackdropClick && a.$backdropEl && a.$backdropEl.on("click", E),
            a.expandable && t.theme === "ios" && a.view && s.length && a.$pageEl && (a.$pageEl.on("page:beforeout", z),
            a.$pageEl.on("page:beforein", T)),
            a.$inputEl.on("focus", y),
            a.$inputEl.on("blur", w),
            a.$inputEl.on(a.params.inputEvents, C),
            a.$inputEl.on("input:clear", _)
        }
        ,
        a.detachEvents = function() {
            o.off("submit", v),
            a.params.disableButton && a.$disableButtonEl.off("click", E),
            a.params.disableOnBackdropClick && a.$backdropEl && a.$backdropEl.off("click", E),
            a.expandable && t.theme === "ios" && a.view && s.length && a.$pageEl && (a.$pageEl.off("page:beforeout", z),
            a.$pageEl.off("page:beforein", T)),
            a.$inputEl.off("focus", y),
            a.$inputEl.off("blur", w),
            a.$inputEl.off(a.params.inputEvents, C),
            a.$inputEl.off("input:clear", _)
        }
        ,
        a.useModules(),
        a.init(),
        a
    }
    clear(t) {
        const n = this;
        if (!n.query && t && $(t.target).hasClass("searchbar-clear"))
            return n.disable(),
            n;
        const a = n.value;
        return n.$inputEl.val("").trigger("change").focus(),
        n.$el.trigger("searchbar:clear", a),
        n.emit("local::clear searchbarClear", n, a),
        n
    }
    setDisableButtonMargin() {
        const t = this;
        if (t.expandable)
            return;
        const n = t.app;
        t.$disableButtonEl.transition(0).show(),
        t.$disableButtonEl.css(`margin-${n.rtl ? "left" : "right"}`, `${-t.disableButtonEl.offsetWidth}px`),
        t._clientLeft = t.$disableButtonEl[0].clientLeft,
        t.$disableButtonEl.transition(""),
        t.disableButtonHasMargin = !0
    }
    enable(t) {
        const n = this;
        if (n.enabled)
            return n;
        const a = n.app
          , r = Qe()
          , o = yt();
        n.enabled = !0;
        function i() {
            if (n.$backdropEl && (n.$searchContainer && n.$searchContainer.length || n.params.customSearch) && !n.$el.hasClass("searchbar-enabled") && !n.query && n.backdropShow(),
            n.$el.addClass("searchbar-enabled"),
            (!n.$disableButtonEl || n.$disableButtonEl && n.$disableButtonEl.length === 0) && n.$el.addClass("searchbar-enabled-no-disable-button"),
            !n.expandable && n.$disableButtonEl && n.$disableButtonEl.length > 0 && a.theme !== "md" && (n.disableButtonHasMargin || n.setDisableButtonMargin(),
            n.$disableButtonEl.css(`margin-${a.rtl ? "left" : "right"}`, "0px")),
            n.expandable) {
                const c = n.$el.parents(".navbar");
                if (c.hasClass("navbar-large") && n.$pageEl) {
                    const u = n.$pageEl.find(".page-content")
                      , f = c.find(".title-large");
                    u.addClass("with-searchbar-expandable-enabled"),
                    c.hasClass("navbar-large") && c.hasClass("navbar-large-collapsed") && f.length && u.length && (u.transition(0),
                    u[0].scrollTop -= f[0].offsetHeight,
                    setTimeout( () => {
                        u.transition("")
                    }
                    , 200))
                }
                a.theme === "md" && c.length ? c.addClass("with-searchbar-expandable-enabled") : (c.addClass("with-searchbar-expandable-enabled"),
                c.hasClass("navbar-large") && c.addClass("navbar-large-collapsed"))
            }
            n.$hideOnEnableEl && n.$hideOnEnableEl.addClass("hidden-by-searchbar"),
            n.$el.trigger("searchbar:enable"),
            n.emit("local::enable searchbarEnable", n)
        }
        let s = !1;
        return t === !0 && r.activeElement !== n.inputEl && (s = !0),
        o.ios && a.theme === "ios" ? n.expandable ? (s && n.$inputEl.focus(),
        i()) : (s && n.$inputEl.focus(),
        t && (t.type === "focus" || t === !0) ? un( () => {
            i()
        }
        , 400) : i()) : (s && n.$inputEl.focus(),
        a.theme === "md" && n.expandable && n.$el.parents(".page, .view, .navbar-inner, .navbar").scrollLeft(a.rtl ? 100 : 0),
        i()),
        n
    }
    disable() {
        const t = this;
        if (!t.enabled)
            return t;
        const n = t.app;
        if (t.$inputEl.val("").trigger("change"),
        t.$el.removeClass("searchbar-enabled searchbar-focused searchbar-enabled-no-disable-button"),
        t.expandable) {
            const a = t.$el.parents(".navbar")
              , r = t.$pageEl && t.$pageEl.find(".page-content");
            if (a.hasClass("navbar-large") && r.length) {
                const o = a.find(".title-large");
                if (t.$el.transitionEnd( () => {
                    r.removeClass("with-searchbar-expandable-closing")
                }
                ),
                a.hasClass("navbar-large") && a.hasClass("navbar-large-collapsed") && o.length) {
                    const i = r[0].scrollTop
                      , s = o[0].offsetHeight;
                    i > s && (r.transition(0),
                    r[0].scrollTop = i + s,
                    setTimeout( () => {
                        r.transition("")
                    }
                    , 200))
                }
                r.removeClass("with-searchbar-expandable-enabled").addClass("with-searchbar-expandable-closing")
            }
            n.theme === "md" && a.length ? (a.removeClass("with-searchbar-expandable-enabled with-searchbar-expandable-enabled-no-transition").addClass("with-searchbar-expandable-closing"),
            t.$el.transitionEnd( () => {
                a.removeClass("with-searchbar-expandable-closing")
            }
            )) : (a.removeClass("with-searchbar-expandable-enabled with-searchbar-expandable-enabled-no-transition").addClass("with-searchbar-expandable-closing"),
            t.$el.transitionEnd( () => {
                a.removeClass("with-searchbar-expandable-closing")
            }
            ),
            t.$pageEl && t.$pageEl.find(".page-content").trigger("scroll"))
        }
        return !t.expandable && t.$disableButtonEl && t.$disableButtonEl.length > 0 && n.theme !== "md" && t.$disableButtonEl.css(`margin-${n.rtl ? "left" : "right"}`, `${-t.disableButtonEl.offsetWidth}px`),
        t.$backdropEl && (t.$searchContainer && t.$searchContainer.length || t.params.customSearch) && t.backdropHide(),
        t.enabled = !1,
        t.$inputEl.blur(),
        t.$hideOnEnableEl && t.$hideOnEnableEl.removeClass("hidden-by-searchbar"),
        t.$el.trigger("searchbar:disable"),
        t.emit("local::disable searchbarDisable", t),
        t
    }
    toggle() {
        const t = this;
        return t.enabled ? t.disable() : t.enable(!0),
        t
    }
    backdropShow() {
        const t = this;
        return t.$backdropEl && t.$backdropEl.addClass("searchbar-backdrop-in"),
        t
    }
    backdropHide() {
        const t = this;
        return t.$backdropEl && t.$backdropEl.removeClass("searchbar-backdrop-in"),
        t
    }
    search(t, n) {
        const a = this;
        if (a.previousQuery = a.query || "",
        t === a.previousQuery)
            return a;
        n || (a.enabled || a.enable(),
        a.$inputEl.val(t),
        a.$inputEl.trigger("input")),
        a.query = t,
        a.value = t;
        const {$searchContainer: r, $el: o, $foundEl: i, $notFoundEl: s, $hideOnSearchEl: l, isVirtualList: c} = a;
        if (t.length > 0 && l ? l.addClass("hidden-by-searchbar") : l && l.removeClass("hidden-by-searchbar"),
        (r && r.length && o.hasClass("searchbar-enabled") || a.params.customSearch && o.hasClass("searchbar-enabled")) && (t.length === 0 ? a.backdropShow() : a.backdropHide()),
        a.params.customSearch)
            return o.trigger("searchbar:search", {
                query: t,
                previousQuery: a.previousQuery
            }),
            a.emit("local::search searchbarSearch", a, t, a.previousQuery),
            a;
        let u = [], f;
        if (c) {
            if (a.virtualList = r[0].f7VirtualList,
            t.trim() === "")
                return a.virtualList.resetFilter(),
                s && s.hide(),
                i && i.show(),
                o.trigger("searchbar:search", {
                    query: t,
                    previousQuery: a.previousQuery
                }),
                a.emit("local::search searchbarSearch", a, t, a.previousQuery),
                a;
            if (f = a.params.removeDiacritics ? o1(t) : t,
            a.virtualList.params.searchAll)
                u = a.virtualList.params.searchAll(f, a.virtualList.items) || [];
            else if (a.virtualList.params.searchByItem)
                for (let d = 0; d < a.virtualList.items.length; d += 1)
                    a.virtualList.params.searchByItem(f, a.virtualList.items[d], d) && u.push(d)
        } else {
            let d;
            a.params.removeDiacritics ? d = o1(t.trim().toLowerCase()).split(" ") : d = t.trim().toLowerCase().split(" "),
            r.find(a.params.searchItem).removeClass("hidden-by-searchbar").each(p => {
                const h = $(p);
                let m = []
                  , g = a.params.searchIn ? h.find(a.params.searchIn) : h;
                a.params.searchIn === a.params.searchItem && (g = h),
                g.each(v => {
                    let y = $(v).text().trim().toLowerCase();
                    a.params.removeDiacritics && (y = o1(y)),
                    m.push(y)
                }
                ),
                m = m.join(" ");
                let b = 0;
                for (let v = 0; v < d.length; v += 1)
                    m.indexOf(d[v]) >= 0 && (b += 1);
                b !== d.length && !(a.params.ignore && h.is(a.params.ignore)) ? h.addClass("hidden-by-searchbar") : u.push(h[0])
            }
            ),
            a.params.hideDividers && r.find(a.params.searchGroupTitle).each(p => {
                const h = $(p)
                  , m = h.nextAll(a.params.searchItem);
                let g = !0;
                for (let v = 0; v < m.length; v += 1) {
                    const y = m.eq(v);
                    if (y.is(a.params.searchGroupTitle))
                        break;
                    y.hasClass("hidden-by-searchbar") || (g = !1)
                }
                const b = a.params.ignore && h.is(a.params.ignore);
                g && !b ? h.addClass("hidden-by-searchbar") : h.removeClass("hidden-by-searchbar")
            }
            ),
            a.params.hideGroups && r.find(a.params.searchGroup).each(p => {
                const h = $(p)
                  , m = a.params.ignore && h.is(a.params.ignore);
                h.find(a.params.searchItem).filter(b => !$(b).hasClass("hidden-by-searchbar")).length === 0 && !m ? h.addClass("hidden-by-searchbar") : h.removeClass("hidden-by-searchbar")
            }
            )
        }
        return u.length === 0 ? (s && s.show(),
        i && i.hide()) : (s && s.hide(),
        i && i.show()),
        c && a.virtualList && a.virtualList.filterItems(u),
        o.trigger("searchbar:search", {
            query: t,
            previousQuery: a.previousQuery,
            foundItems: u
        }),
        a.emit("local::search searchbarSearch", a, t, a.previousQuery, u),
        a
    }
    init() {
        const t = this;
        t.expandable && t.$el && t.$el.addClass("searchbar-expandable"),
        t.inline && t.$el && t.$el.addClass("searchbar-inline"),
        t.attachEvents()
    }
    destroy() {
        const t = this;
        t.emit("local::beforeDestroy searchbarBeforeDestroy", t),
        t.$el.trigger("searchbar:beforedestroy"),
        t.detachEvents(),
        t.$el[0] && (t.$el[0].f7Searchbar = null,
        delete t.$el[0].f7Searchbar),
        Yt(t)
    }
}
;
const yj = {
    name: "searchbar",
    static: {
        Searchbar: Yp
    },
    create() {
        const e = this;
        e.searchbar = Gt({
            defaultSelector: ".searchbar",
            constructor: Yp,
            app: e,
            domProp: "f7Searchbar",
            addMethods: "clear enable disable toggle search".split(" ")
        })
    },
    on: {
        tabMounted(e) {
            const t = this;
            $(e).find(".searchbar-init").each(n => {
                const a = $(n);
                t.searchbar.create(se(a.dataset(), {
                    el: n
                }))
            }
            )
        },
        tabBeforeRemove(e) {
            $(e).find(".searchbar-init").each(t => {
                t.f7Searchbar && t.f7Searchbar.destroy && t.f7Searchbar.destroy()
            }
            )
        },
        pageInit(e) {
            const t = this;
            e.$el.find(".searchbar-init").each(n => {
                const a = $(n);
                t.searchbar.create(se(a.dataset(), {
                    el: n
                }))
            }
            ),
            t.theme === "ios" && e.view && e.view.router.dynamicNavbar && e.$navbarEl && e.$navbarEl.length > 0 && e.$navbarEl.find(".searchbar-init").each(n => {
                const a = $(n);
                t.searchbar.create(se(a.dataset(), {
                    el: n
                }))
            }
            )
        },
        pageBeforeRemove(e) {
            const t = this;
            e.$el.find(".searchbar-init").each(n => {
                n.f7Searchbar && n.f7Searchbar.destroy && n.f7Searchbar.destroy()
            }
            ),
            t.theme === "ios" && e.view && e.view.router.dynamicNavbar && e.$navbarEl && e.$navbarEl.length > 0 && e.$navbarEl.find(".searchbar-init").each(n => {
                n.f7Searchbar && n.f7Searchbar.destroy && n.f7Searchbar.destroy()
            }
            )
        }
    },
    clicks: {
        ".searchbar-clear": function(t, n) {
            n === void 0 && (n = {});
            const r = this.searchbar.get(n.searchbar);
            r && r.clear()
        },
        ".searchbar-enable": function(t, n) {
            n === void 0 && (n = {});
            const r = this.searchbar.get(n.searchbar);
            r && r.enable(!0)
        },
        ".searchbar-disable": function(t, n) {
            n === void 0 && (n = {});
            const r = this.searchbar.get(n.searchbar);
            r && r.disable()
        },
        ".searchbar-toggle": function(t, n) {
            n === void 0 && (n = {});
            const r = this.searchbar.get(n.searchbar);
            r && r.toggle()
        }
    },
    vnode: {
        "searchbar-init": {
            insert(e) {
                const t = this
                  , n = e.elm
                  , a = $(n);
                t.searchbar.create(se(a.dataset(), {
                    el: n
                }))
            },
            destroy(e) {
                const t = e.elm;
                t.f7Searchbar && t.f7Searchbar.destroy && t.f7Searchbar.destroy()
            }
        }
    }
};
function Fu() {
    return Fu = Object.assign || function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var a in n)
                Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a])
        }
        return e
    }
    ,
    Fu.apply(this, arguments)
}
let Gp = class extends Bt {
    constructor(t, n) {
        n === void 0 && (n = {}),
        super(n, [t]);
        const a = this
          , r = {
            autoLayout: !0,
            messages: [],
            newMessagesFirst: !1,
            scrollMessages: !0,
            scrollMessagesOnEdge: !0,
            firstMessageRule: void 0,
            lastMessageRule: void 0,
            tailMessageRule: void 0,
            sameNameMessageRule: void 0,
            sameHeaderMessageRule: void 0,
            sameFooterMessageRule: void 0,
            sameAvatarMessageRule: void 0,
            customClassMessageRule: void 0,
            renderMessage: void 0
        };
        a.useModulesParams(r),
        a.params = se(r, n);
        const o = $(n.el).eq(0);
        if (o.length === 0)
            return a;
        if (o[0].f7Messages)
            return o[0].f7Messages;
        o[0].f7Messages = a;
        const i = o.closest(".page-content").eq(0);
        return se(a, {
            messages: a.params.messages,
            $el: o,
            el: o[0],
            $pageContentEl: i,
            pageContentEl: i[0]
        }),
        a.useModules(),
        a.init(),
        a
    }
    getMessageData(t) {
        const n = $(t)
          , a = {
            name: n.find(".message-name").html(),
            header: n.find(".message-header").html(),
            textHeader: n.find(".message-text-header").html(),
            textFooter: n.find(".message-text-footer").html(),
            footer: n.find(".message-footer").html(),
            isTitle: n.hasClass("messages-title"),
            type: n.hasClass("message-sent") ? "sent" : "received",
            text: n.find(".message-text").html(),
            image: n.find(".message-image").html(),
            imageSrc: n.find(".message-image img").attr("src"),
            typing: n.hasClass("message-typing")
        };
        a.isTitle && (a.text = n.html()),
        a.text && a.textHeader && (a.text = a.text.replace(`<div class="message-text-header">${a.textHeader}</div>`, "")),
        a.text && a.textFooter && (a.text = a.text.replace(`<div class="message-text-footer">${a.textFooter}</div>`, ""));
        let r = n.find(".message-avatar").css("background-image");
        return (r === "none" || r === "") && (r = void 0),
        r && typeof r == "string" ? r = r.replace("url(", "").replace(")", "").replace(/"/g, "").replace(/'/g, "") : r = void 0,
        a.avatar = r,
        a
    }
    getMessagesData() {
        const t = this
          , n = [];
        return t.$el.find(".message, .messages-title").each(a => {
            n.push(t.getMessageData(a))
        }
        ),
        n
    }
    renderMessage(t) {
        const n = this
          , a = se({
            type: "sent",
            attrs: {}
        }, t);
        return n.params.renderMessage ? n.params.renderMessage.call(n, a) : a.isTitle ? `<div class="messages-title">${a.text}</div>` : R("div", Fu({
            class: `message message-${a.type} ${a.isTyping ? "message-typing" : ""} ${a.cssClass || ""}`
        }, a.attrs), a.avatar && R("div", {
            class: "message-avatar",
            style: `background-image:url(${a.avatar})`
        }), R("div", {
            class: "message-content"
        }, a.name && R("div", {
            class: "message-name"
        }, a.name), a.header && R("div", {
            class: "message-header"
        }, a.header), R("div", {
            class: "message-bubble"
        }, a.textHeader && R("div", {
            class: "message-text-header"
        }, a.textHeader), a.image && R("div", {
            class: "message-image"
        }, a.image), a.imageSrc && !a.image && R("div", {
            class: "message-image"
        }, R("img", {
            src: a.imageSrc
        })), (a.text || a.isTyping) && R("div", {
            class: "message-text"
        }, a.text || "", a.isTyping && R("div", {
            class: "message-typing-indicator"
        }, R("div", null), R("div", null), R("div", null))), a.textFooter && R("div", {
            class: "message-text-footer"
        }, a.textFooter)), a.footer && R("div", {
            class: "message-footer"
        }, a.footer)))
    }
    renderMessages(t, n) {
        t === void 0 && (t = this.messages),
        n === void 0 && (n = this.params.newMessagesFirst ? "prepend" : "append");
        const a = this
          , r = t.map(o => a.renderMessage(o)).join("");
        a.$el[n](r)
    }
    isFirstMessage() {
        const t = this;
        return t.params.firstMessageRule ? t.params.firstMessageRule(...arguments) : !1
    }
    isLastMessage() {
        const t = this;
        return t.params.lastMessageRule ? t.params.lastMessageRule(...arguments) : !1
    }
    isTailMessage() {
        const t = this;
        return t.params.tailMessageRule ? t.params.tailMessageRule(...arguments) : !1
    }
    isSameNameMessage() {
        const t = this;
        return t.params.sameNameMessageRule ? t.params.sameNameMessageRule(...arguments) : !1
    }
    isSameHeaderMessage() {
        const t = this;
        return t.params.sameHeaderMessageRule ? t.params.sameHeaderMessageRule(...arguments) : !1
    }
    isSameFooterMessage() {
        const t = this;
        return t.params.sameFooterMessageRule ? t.params.sameFooterMessageRule(...arguments) : !1
    }
    isSameAvatarMessage() {
        const t = this;
        return t.params.sameAvatarMessageRule ? t.params.sameAvatarMessageRule(...arguments) : !1
    }
    isCustomClassMessage() {
        const t = this;
        if (t.params.customClassMessageRule)
            return t.params.customClassMessageRule(...arguments)
    }
    layout() {
        const t = this;
        t.$el.find(".message, .messages-title").each( (n, a) => {
            const r = $(n);
            t.messages || (t.messages = t.getMessagesData());
            const o = []
              , i = t.messages[a]
              , s = t.messages[a - 1]
              , l = t.messages[a + 1];
            t.isFirstMessage(i, s, l) && o.push("message-first"),
            t.isLastMessage(i, s, l) && o.push("message-last"),
            t.isTailMessage(i, s, l) && o.push("message-tail"),
            t.isSameNameMessage(i, s, l) && o.push("message-same-name"),
            t.isSameHeaderMessage(i, s, l) && o.push("message-same-header"),
            t.isSameFooterMessage(i, s, l) && o.push("message-same-footer"),
            t.isSameAvatarMessage(i, s, l) && o.push("message-same-avatar");
            let c = t.isCustomClassMessage(i, s, l);
            c && c.length && (typeof c == "string" && (c = c.split(" ")),
            c.forEach(u => {
                o.push(u)
            }
            )),
            r.removeClass("message-first message-last message-tail message-same-name message-same-header message-same-footer message-same-avatar"),
            o.forEach(u => {
                r.addClass(u)
            }
            )
        }
        )
    }
    clear() {
        const t = this;
        t.messages = [],
        t.$el.html("")
    }
    removeMessage(t, n) {
        n === void 0 && (n = !0);
        const a = this;
        let r, o;
        return typeof t == "number" ? (r = t,
        o = a.$el.find(".message, .messages-title").eq(r)) : a.messages && a.messages.indexOf(t) >= 0 ? (r = a.messages.indexOf(t),
        o = a.$el.children().eq(r)) : (o = $(t),
        r = o.index()),
        o.length === 0 || (o.remove(),
        a.messages.splice(r, 1),
        a.params.autoLayout && n && a.layout()),
        a
    }
    removeMessages(t, n) {
        n === void 0 && (n = !0);
        const a = this;
        if (Array.isArray(t)) {
            const r = [];
            t.forEach(o => {
                r.push(a.$el.find(".message, .messages-title").eq(o))
            }
            ),
            r.forEach(o => {
                a.removeMessage(o, !1)
            }
            )
        } else
            $(t).each(r => {
                a.removeMessage(r, !1)
            }
            );
        return a.params.autoLayout && n && a.layout(),
        a
    }
    addMessage() {
        const t = this;
        let n, a, r;
        for (var o = arguments.length, i = new Array(o), s = 0; s < o; s++)
            i[s] = arguments[s];
        return typeof i[1] == "boolean" ? [n,a,r] = i : [n,r,a] = i,
        typeof a > "u" && (a = !0),
        typeof r > "u" && (r = t.params.newMessagesFirst ? "prepend" : "append"),
        t.addMessages([n], a, r)
    }
    setScrollData() {
        const t = this
          , n = t.pageContentEl.scrollHeight
          , a = t.pageContentEl.offsetHeight
          , r = t.pageContentEl.scrollTop;
        return t.scrollData = {
            scrollHeightBefore: n,
            heightBefore: a,
            scrollBefore: r
        },
        {
            scrollHeightBefore: n,
            heightBefore: a,
            scrollBefore: r
        }
    }
    addMessages() {
        const t = this;
        let n, a, r;
        for (var o = arguments.length, i = new Array(o), s = 0; s < o; s++)
            i[s] = arguments[s];
        typeof i[1] == "boolean" ? [n,a,r] = i : [n,r,a] = i,
        typeof a > "u" && (a = !0),
        typeof r > "u" && (r = t.params.newMessagesFirst ? "prepend" : "append");
        const {scrollHeightBefore: l, scrollBefore: c} = t.setScrollData();
        let u = "";
        const f = t.messages.filter(p => p.isTyping)[0];
        n.forEach(p => {
            f ? r === "append" ? t.messages.splice(t.messages.indexOf(f), 0, p) : t.messages.splice(t.messages.indexOf(f) + 1, 0, p) : t.messages[r === "append" ? "push" : "unshift"](p),
            u += t.renderMessage(p)
        }
        );
        const d = $(u);
        return a && (r === "append" && !t.params.newMessagesFirst && d.addClass("message-appear-from-bottom"),
        r === "prepend" && t.params.newMessagesFirst && d.addClass("message-appear-from-top")),
        f ? r === "append" ? d.insertBefore(t.$el.find(".message-typing")) : d.insertAfter(t.$el.find(".message-typing")) : t.$el[r](d),
        t.params.autoLayout && t.layout(),
        r === "prepend" && !f && (t.pageContentEl.scrollTop = c + (t.pageContentEl.scrollHeight - l)),
        t.params.scrollMessages && (r === "append" && !t.params.newMessagesFirst || r === "prepend" && t.params.newMessagesFirst && !f) && t.scrollWithEdgeCheck(a),
        t
    }
    showTyping(t) {
        t === void 0 && (t = {});
        const n = this
          , a = n.messages.filter(r => r.isTyping)[0];
        return a && n.removeMessage(n.messages.indexOf(a)),
        n.addMessage(se({
            type: "received",
            isTyping: !0
        }, t)),
        n
    }
    hideTyping() {
        const t = this;
        let n, a;
        if (t.messages.forEach( (r, o) => {
            r.isTyping && (n = o)
        }
        ),
        typeof n < "u" && t.$el.find(".message").eq(n).hasClass("message-typing") && (a = !0,
        t.removeMessage(n)),
        !a) {
            const r = t.$el.find(".message-typing");
            r.length && t.removeMessage(r)
        }
        return t
    }
    scrollWithEdgeCheck(t) {
        const n = this
          , {scrollBefore: a, scrollHeightBefore: r, heightBefore: o} = n.scrollData;
        if (n.params.scrollMessagesOnEdge) {
            let i = !1;
            n.params.newMessagesFirst && a === 0 && (i = !0),
            !n.params.newMessagesFirst && a - (r - o) >= -10 && (i = !0),
            i && n.scroll(t ? void 0 : 0)
        } else
            n.scroll(t ? void 0 : 0)
    }
    scroll(t, n) {
        t === void 0 && (t = 300);
        const a = this
          , r = a.pageContentEl.scrollTop;
        let o;
        if (typeof n < "u")
            o = n;
        else if (o = a.params.newMessagesFirst ? 0 : a.pageContentEl.scrollHeight - a.pageContentEl.offsetHeight,
        o === r)
            return a;
        return a.$pageContentEl.scrollTop(o, t),
        a
    }
    init() {
        const t = this;
        (!t.messages || t.messages.length === 0) && (t.messages = t.getMessagesData()),
        t.params.messages && t.params.messages.length && t.renderMessages(),
        t.params.autoLayout && t.layout(),
        t.params.scrollMessages && t.scroll(0)
    }
    destroy() {
        const t = this;
        t.emit("local::beforeDestroy messagesBeforeDestroy", t),
        t.$el.trigger("messages:beforedestroy"),
        t.$el[0] && (t.$el[0].f7Messages = null,
        delete t.$el[0].f7Messages),
        Yt(t)
    }
}
;
const Cj = {
    name: "messages",
    static: {
        Messages: Gp
    },
    create() {
        const e = this;
        e.messages = Gt({
            defaultSelector: ".messages",
            constructor: Gp,
            app: e,
            domProp: "f7Messages",
            addMethods: "renderMessages layout scroll clear removeMessage removeMessages addMessage addMessages".split(" ")
        })
    },
    on: {
        tabBeforeRemove(e) {
            const t = this;
            $(e).find(".messages-init").each(n => {
                t.messages.destroy(n)
            }
            )
        },
        tabMounted(e) {
            const t = this;
            $(e).find(".messages-init").each(n => {
                t.messages.create({
                    el: n
                })
            }
            )
        },
        pageBeforeRemove(e) {
            const t = this;
            e.$el.find(".messages-init").each(n => {
                t.messages.destroy(n)
            }
            )
        },
        pageInit(e) {
            const t = this;
            e.$el.find(".messages-init").each(n => {
                t.messages.create({
                    el: n
                })
            }
            )
        }
    },
    vnode: {
        "messages-init": {
            insert(e) {
                const t = this
                  , n = e.elm;
                t.messages.create({
                    el: n
                })
            },
            destroy(e) {
                const t = this
                  , n = e.elm;
                t.messages.destroy(n)
            }
        }
    }
};
let Xp = class extends Bt {
    constructor(t, n) {
        n === void 0 && (n = {}),
        super(n, [t]);
        const a = this
          , r = {
            top: !1,
            topOffset: 0,
            bottomOffset: 0,
            attachments: [],
            renderAttachments: void 0,
            renderAttachment: void 0,
            maxHeight: null,
            resizePage: !0
        };
        a.useModulesParams(r),
        a.params = se(r, n);
        const o = $(a.params.el);
        if (o.length === 0)
            return a;
        if (o[0].f7Messagebar)
            return o[0].f7Messagebar;
        o[0].f7Messagebar = a;
        const i = o.parents(".page").eq(0)
          , s = i.find(".page-content").eq(0)
          , l = o.find(".messagebar-area");
        let c;
        a.params.textareaEl ? c = $(a.params.textareaEl) : c = o.find("textarea");
        const u = o.find(".messagebar-attachments")
          , f = o.find(".messagebar-sheet");
        a.params.top && o.addClass("messagebar-top"),
        se(a, {
            $el: o,
            el: o[0],
            $areaEl: l,
            areaEl: l[0],
            $textareaEl: c,
            textareaEl: c[0],
            $attachmentsEl: u,
            attachmentsEl: u[0],
            attachmentsVisible: u.hasClass("messagebar-attachments-visible"),
            $sheetEl: f,
            sheetEl: f[0],
            sheetVisible: f.hasClass("messagebar-sheet-visible"),
            $pageEl: i,
            pageEl: i[0],
            $pageContentEl: s,
            pageContentEl: s,
            top: o.hasClass("messagebar-top") || a.params.top,
            attachments: []
        });
        function d() {
            a.params.resizePage && a.resizePage()
        }
        function p(v) {
            v.preventDefault()
        }
        function h(v) {
            const y = $(this).index();
            $(v.target).closest(".messagebar-attachment-delete").length ? ($(this).trigger("messagebar:attachmentdelete", y),
            a.emit("local::attachmentDelete messagebarAttachmentDelete", a, this, y)) : ($(this).trigger("messagebar:attachmentclick", y),
            a.emit("local::attachmentClick messagebarAttachmentClick", a, this, y))
        }
        function m() {
            a.checkEmptyState(),
            a.$el.trigger("messagebar:change"),
            a.emit("local::change messagebarChange", a)
        }
        function g() {
            a.sheetHide(),
            a.$el.addClass("messagebar-focused"),
            a.$el.trigger("messagebar:focus"),
            a.emit("local::focus messagebarFocus", a)
        }
        function b() {
            a.$el.removeClass("messagebar-focused"),
            a.$el.trigger("messagebar:blur"),
            a.emit("local::blur messagebarBlur", a)
        }
        return a.attachEvents = function() {
            o.on("textarea:resize", d),
            o.on("submit", p),
            o.on("click", ".messagebar-attachment", h),
            c.on("change input", m),
            c.on("focus", g),
            c.on("blur", b),
            t.on("resize", d)
        }
        ,
        a.detachEvents = function() {
            o.off("textarea:resize", d),
            o.off("submit", p),
            o.off("click", ".messagebar-attachment", h),
            c.off("change input", m),
            c.off("focus", g),
            c.off("blur", b),
            t.off("resize", d)
        }
        ,
        a.useModules(),
        a.init(),
        a
    }
    focus() {
        const t = this;
        return t.$textareaEl.focus(),
        t
    }
    blur() {
        const t = this;
        return t.$textareaEl.blur(),
        t
    }
    clear() {
        const t = this;
        return t.$textareaEl.val("").trigger("change"),
        t
    }
    getValue() {
        return this.$textareaEl.val().trim()
    }
    setValue(t) {
        const n = this;
        return n.$textareaEl.val(t).trigger("change"),
        n
    }
    setPlaceholder(t) {
        const n = this;
        return n.$textareaEl.attr("placeholder", t),
        n
    }
    resizePage() {
        const t = this
          , {params: n, $el: a, top: r, $pageEl: o, $pageContentEl: i, $areaEl: s, $textareaEl: l, $sheetEl: c, $attachmentsEl: u} = t
          , f = a[0].offsetHeight;
        let d = n.maxHeight;
        if (!r) {
            const p = parseInt(i.css("padding-bottom"), 10)
              , h = f + n.bottomOffset;
            if (h !== p && i.length) {
                const m = parseInt(i.css("padding-top"), 10)
                  , g = i[0].scrollHeight
                  , b = i[0].offsetHeight
                  , y = i[0].scrollTop === g - b;
                d || (d = o[0].offsetHeight - m - c.outerHeight() - u.outerHeight() - parseInt(s.css("margin-top"), 10) - parseInt(s.css("margin-bottom"), 10)),
                l.css("max-height", `${d}px`),
                i.css("padding-bottom", `${h}px`),
                y && i.scrollTop(i[0].scrollHeight - b),
                a.trigger("messagebar:resizepage"),
                t.emit("local::resizePage messagebarResizePage", t)
            }
        }
    }
    checkEmptyState() {
        const t = this
          , {$el: n, $textareaEl: a} = t
          , r = a.val().trim();
        r && r.length ? n.addClass("messagebar-with-value") : n.removeClass("messagebar-with-value")
    }
    attachmentsCreate(t) {
        t === void 0 && (t = "");
        const n = this
          , a = $(`<div class="messagebar-attachments">${t}</div>`);
        return a.insertBefore(n.$textareaEl),
        se(n, {
            $attachmentsEl: a,
            attachmentsEl: a[0]
        }),
        n
    }
    attachmentsShow(t) {
        t === void 0 && (t = "");
        const n = this;
        return n.$attachmentsEl = n.$el.find(".messagebar-attachments"),
        n.$attachmentsEl.length === 0 && n.attachmentsCreate(t),
        n.$el.addClass("messagebar-attachments-visible"),
        n.attachmentsVisible = !0,
        n.params.resizePage && n.resizePage(),
        n
    }
    attachmentsHide() {
        const t = this;
        return t.$el.removeClass("messagebar-attachments-visible"),
        t.attachmentsVisible = !1,
        t.params.resizePage && t.resizePage(),
        t
    }
    attachmentsToggle() {
        const t = this;
        return t.attachmentsVisible ? t.attachmentsHide() : t.attachmentsShow(),
        t
    }
    renderAttachment(t) {
        const n = this;
        return n.params.renderAttachment ? n.params.renderAttachment.call(n, t) : `
      <div class="messagebar-attachment">
        <img src="${t}">
        <span class="messagebar-attachment-delete"></span>
      </div>
    `
    }
    renderAttachments() {
        const t = this;
        let n;
        t.params.renderAttachments ? n = t.params.renderAttachments.call(t, t.attachments) : n = `${t.attachments.map(a => t.renderAttachment(a)).join("")}`,
        t.$attachmentsEl.length === 0 ? t.attachmentsCreate(n) : t.$attachmentsEl.html(n)
    }
    sheetCreate(t) {
        t === void 0 && (t = "");
        const n = this
          , a = $(`<div class="messagebar-sheet">${t}</div>`);
        return n.$el.append(a),
        se(n, {
            $sheetEl: a,
            sheetEl: a[0]
        }),
        n
    }
    sheetShow(t) {
        t === void 0 && (t = "");
        const n = this;
        return n.$sheetEl = n.$el.find(".messagebar-sheet"),
        n.$sheetEl.length === 0 && n.sheetCreate(t),
        n.$el.addClass("messagebar-sheet-visible"),
        n.sheetVisible = !0,
        n.params.resizePage && n.resizePage(),
        n
    }
    sheetHide() {
        const t = this;
        return t.$el.removeClass("messagebar-sheet-visible"),
        t.sheetVisible = !1,
        t.params.resizePage && t.resizePage(),
        t
    }
    sheetToggle() {
        const t = this;
        return t.sheetVisible ? t.sheetHide() : t.sheetShow(),
        t
    }
    init() {
        const t = this;
        return t.attachEvents(),
        t.checkEmptyState(),
        t
    }
    destroy() {
        const t = this;
        t.emit("local::beforeDestroy messagebarBeforeDestroy", t),
        t.$el.trigger("messagebar:beforedestroy"),
        t.detachEvents(),
        t.$el[0] && (t.$el[0].f7Messagebar = null,
        delete t.$el[0].f7Messagebar),
        Yt(t)
    }
}
;
const wj = {
    name: "messagebar",
    static: {
        Messagebar: Xp
    },
    create() {
        const e = this;
        e.messagebar = Gt({
            defaultSelector: ".messagebar",
            constructor: Xp,
            app: e,
            domProp: "f7Messagebar",
            addMethods: "clear getValue setValue setPlaceholder resizePage focus blur attachmentsCreate attachmentsShow attachmentsHide attachmentsToggle renderAttachments sheetCreate sheetShow sheetHide sheetToggle".split(" ")
        })
    },
    on: {
        tabBeforeRemove(e) {
            const t = this;
            $(e).find(".messagebar-init").each(n => {
                t.messagebar.destroy(n)
            }
            )
        },
        tabMounted(e) {
            const t = this;
            $(e).find(".messagebar-init").each(n => {
                t.messagebar.create(se({
                    el: n
                }, $(n).dataset()))
            }
            )
        },
        pageBeforeRemove(e) {
            const t = this;
            e.$el.find(".messagebar-init").each(n => {
                t.messagebar.destroy(n)
            }
            )
        },
        pageInit(e) {
            const t = this;
            e.$el.find(".messagebar-init").each(n => {
                t.messagebar.create(se({
                    el: n
                }, $(n).dataset()))
            }
            )
        }
    },
    vnode: {
        "messagebar-init": {
            insert(e) {
                const t = this
                  , n = e.elm;
                t.messagebar.create(se({
                    el: n
                }, $(n).dataset()))
            },
            destroy(e) {
                const t = this
                  , n = e.elm;
                t.messagebar.destroy(n)
            }
        }
    }
}
  , _j = [Y$, G$, X$, K$, Z$, J$, Q$, eE, tE, nE, aE, rE, oE, iE, sE, lE, cE, mE, gE, vE, bE, yE, CE, wE];
ar.use(_j);
function qi(e) {
    const t = this
      , n = $(e);
    if (n.length === 0 || n[0].swiper)
        return;
    let a, r = {}, o, i;
    n.hasClass("tabs-swipeable-wrap") && (n.addClass("swiper").children(".tabs").addClass("swiper-wrapper").children(".tab").addClass("swiper-slide"),
    a = n.children(".tabs").children(".tab-active").index(),
    o = !0,
    i = n.find(".tabs-routable").length > 0),
    n.attr("data-swiper") ? r = JSON.parse(n.attr("data-swiper")) : n[0].f7SwiperParams ? r = n[0].f7SwiperParams : (r = n.dataset(),
    Object.keys(r).forEach(u => {
        const f = r[u];
        if (typeof f == "string" && f.indexOf("{") === 0 && f.indexOf("}") > 0)
            try {
                r[u] = JSON.parse(f)
            } catch {}
    }
    )),
    typeof r.initialSlide > "u" && typeof a < "u" && (r.initialSlide = a);
    const s = t.swiper.create(n[0], r);
    function l() {
        s.update()
    }
    const c = n.parents(".tab").filter(u => $(u).parent(".tabs").parent(".tabs-animated-wrap, .tabs-swipeable-wrap").length === 0).eq(0);
    n.parents(".popup, .login-screen, .sheet-modal, .popover").on("modal:open", l),
    n.parents(".panel").on("panel:open", l),
    c && c.length && c.on("tab:show", l),
    s.on("beforeDestroy", () => {
        n.parents(".popup, .login-screen, .sheet-modal, .popover").off("modal:open", l),
        n.parents(".panel").off("panel:open", l),
        c && c.length && c.off("tab:show", l)
    }
    ),
    o && s.on("slideChange", () => {
        if (i) {
            let u = t.views.get(n.parents(".view"));
            u || (u = t.views.main);
            const f = u.router
              , d = f.findTabRouteUrl(s.slides.eq(s.activeIndex)[0]);
            d && setTimeout( () => {
                f.navigate(d)
            }
            , 0)
        } else
            t.tab.show({
                tabEl: s.slides.eq(s.activeIndex)
            })
    }
    )
}
const kj = {
    name: "swiper",
    static: {
        Swiper: ar
    },
    create() {
        const e = this;
        e.swiper = Gt({
            defaultSelector: ".swiper",
            constructor: ar,
            domProp: "swiper"
        })
    },
    on: {
        pageBeforeRemove(e) {
            const t = this;
            e.$el.find(".swiper-init, .tabs-swipeable-wrap").each(n => {
                t.swiper.destroy(n)
            }
            )
        },
        pageMounted(e) {
            const t = this;
            e.$el.find(".tabs-swipeable-wrap").each(n => {
                qi.call(t, n)
            }
            )
        },
        pageInit(e) {
            const t = this;
            e.$el.find(".swiper-init, .tabs-swipeable-wrap").each(n => {
                qi.call(t, n)
            }
            )
        },
        pageReinit(e) {
            const t = this;
            e.$el.find(".swiper-init, .tabs-swipeable-wrap").each(n => {
                const a = t.swiper.get(n);
                a && a.update && a.update()
            }
            )
        },
        tabMounted(e) {
            const t = this;
            $(e).find(".swiper-init, .tabs-swipeable-wrap").each(n => {
                qi.call(t, n)
            }
            )
        },
        tabShow(e) {
            const t = this;
            $(e).find(".swiper-init, .tabs-swipeable-wrap").each(n => {
                const a = t.swiper.get(n);
                a && a.update && a.update()
            }
            )
        },
        tabBeforeRemove(e) {
            const t = this;
            $(e).find(".swiper-init, .tabs-swipeable-wrap").each(n => {
                t.swiper.destroy(n)
            }
            )
        }
    },
    vnode: {
        "swiper-init": {
            insert(e) {
                const t = this
                  , n = e.elm;
                qi.call(t, n)
            },
            destroy(e) {
                const t = this
                  , n = e.elm;
                t.swiper.destroy(n)
            }
        },
        "tabs-swipeable-wrap": {
            insert(e) {
                const t = this
                  , n = e.elm;
                qi.call(t, n)
            },
            destroy(e) {
                const t = this
                  , n = e.elm;
                t.swiper.destroy(n)
            }
        }
    }
};
let Kp = class extends Bt {
    constructor(t, n) {
        n === void 0 && (n = {}),
        super(n, [t]);
        const a = this;
        a.app = t;
        const r = se({
            on: {}
        }, t.params.photoBrowser);
        a.useModulesParams(r),
        a.params = se(r, n),
        se(a, {
            exposed: !1,
            opened: !1,
            activeIndex: a.params.swiper.initialSlide,
            url: a.params.url,
            swipeToClose: {
                allow: !0,
                isTouched: !1,
                diff: void 0,
                start: void 0,
                current: void 0,
                started: !1,
                activeSlide: void 0,
                timeStart: void 0
            }
        }),
        a.useModules(),
        a.init()
    }
    get view() {
        const {params: t, app: n} = this;
        return t.view || n.views.main
    }
    onSlideChange(t) {
        const n = this;
        n.activeIndex = t.activeIndex;
        let a = t.activeIndex + 1
          , r = n.params.virtualSlides ? n.params.photos.length : t.slides.length;
        t.params.loop && (r -= 2,
        a -= t.loopedSlides,
        a < 1 && (a = r + a),
        a > r && (a -= r));
        const o = n.params.virtualSlides ? t.$wrapperEl.find(`.swiper-slide[data-swiper-slide-index="${t.activeIndex}"]`) : t.slides.eq(t.activeIndex)
          , i = n.params.virtualSlides ? t.$wrapperEl.find(`.swiper-slide[data-swiper-slide-index="${t.previousIndex}"]`) : t.slides.eq(t.previousIndex);
        let s = n.$el.find(".photo-browser-current"), l = n.$el.find(".photo-browser-total"), c;
        if (n.params.type === "page" && n.params.navbar && s.length === 0 && n.app.theme === "ios" && (c = n.app.navbar.getElByPage(n.$el),
        c && (s = $(c).find(".photo-browser-current"),
        l = $(c).find(".photo-browser-total"))),
        s.length && l.length && (s.text(a),
        l.text(r),
        c || (c = s.parents(".navbar")[0]),
        c && n.app.navbar.size(c)),
        n.captions.length > 0) {
            const f = t.params.loop ? o.attr("data-swiper-slide-index") : n.activeIndex;
            n.$captionsContainerEl.find(".photo-browser-caption-active").removeClass("photo-browser-caption-active"),
            n.$captionsContainerEl.find(`[data-caption-index="${f}"]`).addClass("photo-browser-caption-active")
        }
        const u = i.find("video");
        u.length > 0 && "pause"in u[0] && u[0].pause()
    }
    onTouchStart() {
        const n = this.swipeToClose;
        n.allow && (n.isTouched = !0)
    }
    onTouchMove(t) {
        const n = this
          , a = n.swipeToClose;
        a.isTouched && (a.started || (a.started = !0,
        a.start = t.type === "touchmove" ? t.targetTouches[0].pageY : t.pageY,
        n.params.virtualSlides ? a.activeSlide = n.swiper.$wrapperEl.children(".swiper-slide-active") : a.activeSlide = n.swiper.slides.eq(n.swiper.activeIndex),
        a.timeStart = zn()),
        t.preventDefault(),
        a.current = t.type === "touchmove" ? t.targetTouches[0].pageY : t.pageY,
        a.diff = a.start - a.current,
        n.$el.transition(0).transform(`translate3d(0,${-a.diff}px,0)`))
    }
    onTouchEnd() {
        const t = this
          , n = t.swipeToClose;
        if (n.isTouched = !1,
        !n.started) {
            n.started = !1;
            return
        }
        n.started = !1,
        n.allow = !1;
        const a = Math.abs(n.diff)
          , r = new Date().getTime() - n.timeStart;
        if (r < 300 && a > 20 || r >= 300 && a > 100) {
            un( () => {
                t.$el && (n.diff < 0 ? t.$el.addClass("swipe-close-to-bottom") : t.$el.addClass("swipe-close-to-top")),
                t.emit("local::swipeToClose", t),
                t.$el.transform("").transition(""),
                t.close(),
                n.allow = !0
            }
            );
            return
        }
        a !== 0 ? t.$el.addClass("photo-browser-transitioning").transitionEnd( () => {
            n.allow = !0,
            t.$el.removeClass("photo-browser-transitioning")
        }
        ) : n.allow = !0,
        un( () => {
            t.$el.transform("").transition("")
        }
        )
    }
    renderNavbar() {
        const t = this;
        if (t.params.renderNavbar)
            return t.params.renderNavbar.call(t);
        let n = t.params.iconsColor;
        !t.params.iconsColor && t.params.theme === "dark" && (n = "white");
        const a = (t.app.theme === "ios" || t.app.theme === "aurora") && t.params.pageBackLinkText ? t.params.pageBackLinkText : ""
          , r = typeof t.params.navbarShowCount > "u" ? t.params.photos.length > 1 : t.params.navbarShowCount
          , o = t.params.type !== "page";
        return R("div", {
            class: `navbar navbar-photo-browser ${t.params.theme === "dark" ? "navbar-photo-browser-dark" : ""}`
        }, R("div", {
            class: "navbar-bg"
        }), R("div", {
            class: "navbar-inner navbar-inner-centered-title sliding"
        }, !o && R("div", {
            class: "left"
        }, R("a", {
            class: `link ${a ? "" : "icon-only"} back`
        }, R("i", {
            class: `icon icon-back ${n ? `color-${n}` : ""}`
        }), a && R("span", null, a))), r && R("div", {
            class: "title"
        }, R("span", {
            class: "photo-browser-current"
        }), R("span", {
            class: "photo-browser-of"
        }, t.params.navbarOfText), R("span", {
            class: "photo-browser-total"
        })), o && R("div", {
            class: "right"
        }, R("a", {
            class: "link popup-close",
            "data-popup": ".photo-browser-popup"
        }, R("span", null, t.params.popupCloseLinkText)))))
    }
    renderToolbar() {
        const t = this;
        if (t.params.renderToolbar)
            return t.params.renderToolbar.call(t);
        let n = t.params.iconsColor;
        return !t.params.iconsColor && t.params.theme === "dark" && (n = "white"),
        R("div", {
            class: "toolbar toolbar-bottom tabbar"
        }, R("div", {
            class: "toolbar-inner"
        }, R("a", {
            class: "link photo-browser-prev"
        }, R("i", {
            class: `icon icon-back ${n ? `color-${n}` : ""}`
        })), R("a", {
            class: "link photo-browser-next"
        }, R("i", {
            class: `icon icon-forward ${n ? `color-${n}` : ""}`
        }))))
    }
    renderCaption(t, n) {
        const a = this;
        return a.params.renderCaption ? a.params.renderCaption.call(a, t, n) : R("div", {
            class: "photo-browser-caption",
            "data-caption-index": n
        }, t)
    }
    renderObject(t, n) {
        const a = this;
        return a.params.renderObject ? a.params.renderObject.call(a, t, n) : R("div", {
            class: "photo-browser-slide photo-browser-object-slide swiper-slide",
            "data-swiper-slide-index": n
        }, t.html ? t.html : t)
    }
    renderLazyPhoto(t, n) {
        const a = this;
        return a.params.renderLazyPhoto ? a.params.renderLazyPhoto.call(a, t, n) : R("div", {
            class: "photo-browser-slide photo-browser-slide-lazy swiper-slide",
            "data-swiper-slide-index": n
        }, R("div", {
            class: "swiper-lazy-preloader"
        }), R("span", {
            class: "swiper-zoom-container"
        }, R("img", {
            "data-src": t.url ? t.url : t,
            class: "swiper-lazy"
        })))
    }
    renderPhoto(t, n) {
        const a = this;
        return a.params.renderPhoto ? a.params.renderPhoto.call(a, t, n) : R("div", {
            class: "photo-browser-slide swiper-slide",
            "data-swiper-slide-index": n
        }, R("span", {
            class: "swiper-zoom-container"
        }, R("img", {
            src: t.url ? t.url : t
        })))
    }
    render() {
        const t = this;
        return t.params.render ? t.params.render.call(t, t.params) : R("div", {
            class: `photo-browser photo-browser-${t.params.theme}`
        }, R("div", {
            class: "view"
        }, R("div", {
            class: `page photo-browser-page photo-browser-page-${t.params.theme} no-toolbar ${t.params.navbar ? "" : "no-navbar"}`,
            "data-name": "photo-browser-page"
        }, t.params.navbar && t.renderNavbar(), t.params.toolbar && t.renderToolbar(), R("div", {
            class: `photo-browser-captions photo-browser-captions-${t.params.captionsTheme || t.params.theme}`
        }, t.params.photos.map( (n, a) => n.caption ? t.renderCaption(n.caption, a) : "")), R("div", {
            class: "photo-browser-swiper-container swiper"
        }, R("div", {
            class: "photo-browser-swiper-wrapper swiper-wrapper"
        }, !t.params.virtualSlides && t.params.photos.map( (n, a) => n.html || (typeof n == "string" || n instanceof String) && n.indexOf("<") >= 0 && n.indexOf(">") >= 0 ? t.renderObject(n, a) : t.params.swiper.lazy === !0 || t.params.swiper.lazy && t.params.swiper.lazy.enabled ? t.renderLazyPhoto(n, a) : t.renderPhoto(n, a)))))))
    }
    renderStandalone() {
        const t = this;
        return t.params.renderStandalone ? t.params.renderStandalone.call(t) : `<div class="popup photo-browser-popup photo-browser-standalone popup-tablet-fullscreen">${t.render()}</div>`
    }
    renderPage() {
        const t = this;
        return t.params.renderPage ? t.params.renderPage.call(t) : t.render()
    }
    renderPopup() {
        const t = this;
        return t.params.renderPopup ? t.params.renderPopup.call(t) : `<div class="popup photo-browser-popup">${t.render()}</div>`
    }
    onOpen(t, n) {
        const a = this
          , r = a.app
          , o = $(n);
        o[0].f7PhotoBrowser = a,
        a.$el = o,
        a.el = o[0],
        a.openedIn = t,
        a.opened = !0,
        a.$swiperContainerEl = a.$el.find(".photo-browser-swiper-container"),
        a.$swiperWrapperEl = a.$el.find(".photo-browser-swiper-wrapper"),
        a.slides = a.$el.find(".photo-browser-slide"),
        a.$captionsContainerEl = a.$el.find(".photo-browser-captions"),
        a.captions = a.$el.find(".photo-browser-caption");
        let i;
        const s = se({}, a.params.swiper, {
            initialSlide: a.activeIndex,
            cssMode: typeof a.params.swiper.cssMode > "u" && (r.device.ios || r.device.android) ? !0 : a.params.swiper.cssMode,
            on: {
                click(c) {
                    clearTimeout(i),
                    a.params.exposition && (i = setTimeout( () => {
                        a.expositionToggle()
                    }
                    , 350)),
                    a.emit("local::tap", c),
                    a.emit("local::click", c)
                },
                doubleClick(c) {
                    clearTimeout(i),
                    a.emit("local::doubleTap", c),
                    a.emit("local::doubleClick", c)
                },
                slideChange() {
                    const c = this;
                    a.onSlideChange(c);
                    for (var u = arguments.length, f = new Array(u), d = 0; d < u; d++)
                        f[d] = arguments[d];
                    a.emit("local::slideChange", ...f)
                },
                transitionStart() {
                    for (var c = arguments.length, u = new Array(c), f = 0; f < c; f++)
                        u[f] = arguments[f];
                    a.emit("local::transitionStart", ...u)
                },
                transitionEnd() {
                    for (var c = arguments.length, u = new Array(c), f = 0; f < c; f++)
                        u[f] = arguments[f];
                    a.emit("local::transitionEnd", ...u)
                },
                slideChangeTransitionStart() {
                    const c = this;
                    a.onSlideChange(c);
                    for (var u = arguments.length, f = new Array(u), d = 0; d < u; d++)
                        f[d] = arguments[d];
                    a.emit("local::slideChangeTransitionStart", ...f)
                },
                slideChangeTransitionEnd() {
                    for (var c = arguments.length, u = new Array(c), f = 0; f < c; f++)
                        u[f] = arguments[f];
                    a.emit("local::slideChangeTransitionEnd", ...u)
                },
                lazyImageLoad() {
                    for (var c = arguments.length, u = new Array(c), f = 0; f < c; f++)
                        u[f] = arguments[f];
                    a.emit("local::lazyImageLoad", ...u)
                },
                lazyImageReady() {
                    for (var c = arguments.length, u = new Array(c), f = 0; f < c; f++)
                        u[f] = arguments[f];
                    const d = u[0];
                    $(d).removeClass("photo-browser-slide-lazy"),
                    a.emit("local::lazyImageReady", ...u)
                }
            }
        });
        a.params.swipeToClose && a.params.type !== "page" && se(s.on, {
            touchStart(c, u) {
                a.onTouchStart(u),
                a.emit("local::touchStart", u)
            },
            touchMoveOpposite(c, u) {
                a.onTouchMove(u),
                a.emit("local::touchMoveOpposite", u)
            },
            touchEnd(c, u) {
                a.onTouchEnd(u),
                a.emit("local::touchEnd", u)
            }
        }),
        a.params.virtualSlides && se(s, {
            virtual: {
                slides: a.params.photos,
                renderSlide(c, u) {
                    return c.html || (typeof c == "string" || c instanceof String) && c.indexOf("<") >= 0 && c.indexOf(">") >= 0 ? a.renderObject(c, u) : a.params.swiper.lazy === !0 || a.params.swiper.lazy && a.params.swiper.lazy.enabled ? a.renderLazyPhoto(c, u) : a.renderPhoto(c, u)
                }
            }
        });
        const l = He();
        a.swiper = r.swiper ? r.swiper.create(a.$swiperContainerEl, s) : new l.Swiper(a.$swiperContainerEl,s),
        a.activeIndex === 0 && a.onSlideChange(a.swiper),
        a.$el && a.$el.trigger("photobrowser:open"),
        a.emit("local::open photoBrowserOpen", a)
    }
    onOpened() {
        const t = this;
        t.$el && t.params.type === "standalone" && t.$el.css("animation", "none"),
        t.$el && t.$el.trigger("photobrowser:opened"),
        t.emit("local::opened photoBrowserOpened", t)
    }
    onClose() {
        const t = this;
        t.destroyed || (t.swiper && t.swiper.destroy && (t.swiper.destroy(!0, !1),
        t.swiper = null,
        delete t.swiper),
        t.$el && t.$el.trigger("photobrowser:close"),
        t.emit("local::close photoBrowserClose", t))
    }
    onClosed() {
        const t = this;
        t.destroyed || (t.opened = !1,
        t.$el = null,
        t.el = null,
        delete t.$el,
        delete t.el,
        t.$el && t.$el.trigger("photobrowser:closed"),
        t.emit("local::closed photoBrowserClosed", t))
    }
    openPage() {
        const t = this;
        if (t.opened)
            return t;
        const n = t.renderPage();
        return t.view.router.navigate({
            url: t.url,
            route: {
                content: n,
                path: t.url,
                on: {
                    pageBeforeIn(a, r) {
                        t.view.$el.addClass(`with-photo-browser-page with-photo-browser-page-${t.params.theme}`),
                        t.onOpen("page", r.el)
                    },
                    pageAfterIn(a, r) {
                        t.onOpened("page", r.el)
                    },
                    pageBeforeOut(a, r) {
                        t.view.$el.removeClass(`with-photo-browser-page with-photo-browser-page-exposed with-photo-browser-page-${t.params.theme}`),
                        t.onClose("page", r.el)
                    },
                    pageAfterOut(a, r) {
                        t.onClosed("page", r.el)
                    }
                }
            }
        }),
        t
    }
    openStandalone() {
        const t = this;
        if (t.opened)
            return t;
        const a = {
            backdrop: !1,
            content: t.renderStandalone(),
            on: {
                popupOpen(r) {
                    t.onOpen("popup", r.el)
                },
                popupOpened(r) {
                    t.onOpened("popup", r.el)
                },
                popupClose(r) {
                    t.onClose("popup", r.el)
                },
                popupClosed(r) {
                    t.onClosed("popup", r.el)
                }
            }
        };
        return t.params.routableModals && t.view ? t.view.router.navigate({
            url: t.url,
            route: {
                path: t.url,
                popup: a
            }
        }) : t.modal = t.app.popup.create(a).open(),
        t
    }
    openPopup() {
        const t = this;
        if (t.opened)
            return t;
        const a = {
            content: t.renderPopup(),
            push: t.params.popupPush,
            closeByBackdropClick: t.params.closeByBackdropClick,
            on: {
                popupOpen(r) {
                    t.onOpen("popup", r.el)
                },
                popupOpened(r) {
                    t.onOpened("popup", r.el)
                },
                popupClose(r) {
                    t.onClose("popup", r.el)
                },
                popupClosed(r) {
                    t.onClosed("popup", r.el)
                }
            }
        };
        return t.params.routableModals && t.view ? t.view.router.navigate({
            url: t.url,
            route: {
                path: t.url,
                popup: a
            }
        }) : t.modal = t.app.popup.create(a).open(),
        t
    }
    expositionEnable() {
        const t = this;
        return t.params.type === "page" && t.view.$el.addClass("with-photo-browser-page-exposed"),
        t.$el && t.$el.addClass("photo-browser-exposed"),
        t.params.expositionHideCaptions && t.$captionsContainerEl.addClass("photo-browser-captions-exposed"),
        t.exposed = !0,
        t
    }
    expositionDisable() {
        const t = this;
        return t.params.type === "page" && t.view.$el.removeClass("with-photo-browser-page-exposed"),
        t.$el && t.$el.removeClass("photo-browser-exposed"),
        t.params.expositionHideCaptions && t.$captionsContainerEl.removeClass("photo-browser-captions-exposed"),
        t.exposed = !1,
        t
    }
    expositionToggle() {
        const t = this;
        return t.params.type === "page" && t.view.$el.toggleClass("with-photo-browser-page-exposed"),
        t.$el && t.$el.toggleClass("photo-browser-exposed"),
        t.params.expositionHideCaptions && t.$captionsContainerEl.toggleClass("photo-browser-captions-exposed"),
        t.exposed = !t.exposed,
        t
    }
    open(t) {
        const n = this
          , a = n.params.type;
        return n.opened ? (n.swiper && typeof t < "u" && n.swiper.slideTo(parseInt(t, 10)),
        n) : (typeof t < "u" && (n.activeIndex = t),
        a === "standalone" && n.openStandalone(),
        a === "page" && n.openPage(),
        a === "popup" && n.openPopup(),
        n)
    }
    close() {
        const t = this;
        return t.opened && (t.params.routableModals && t.view || t.openedIn === "page" ? t.view.router.back() : (t.modal.once("modalClosed", () => {
            un( () => {
                t.destroyed || (t.modal.destroy(),
                delete t.modal)
            }
            )
        }
        ),
        t.modal.close())),
        t
    }
    init() {}
    destroy() {
        let t = this;
        t.emit("local::beforeDestroy photoBrowserBeforeDestroy", t),
        t.$el && (t.$el.trigger("photobrowser:beforedestroy"),
        t.$el[0].f7PhotoBrowser = null,
        delete t.$el[0].f7PhotoBrowser),
        Yt(t),
        t.destroyed = !0,
        t = null
    }
}
;
const Sj = {
    name: "photoBrowser",
    params: {
        photoBrowser: {
            photos: [],
            exposition: !0,
            expositionHideCaptions: !1,
            type: "standalone",
            navbar: !0,
            toolbar: !0,
            theme: "light",
            captionsTheme: void 0,
            iconsColor: void 0,
            popupPush: !1,
            swipeToClose: !0,
            pageBackLinkText: "Back",
            popupCloseLinkText: "Close",
            navbarOfText: "of",
            navbarShowCount: void 0,
            view: void 0,
            url: "photos/",
            routableModals: !1,
            virtualSlides: !0,
            closeByBackdropClick: !0,
            renderNavbar: void 0,
            renderToolbar: void 0,
            renderCaption: void 0,
            renderObject: void 0,
            renderLazyPhoto: void 0,
            renderPhoto: void 0,
            renderPage: void 0,
            renderPopup: void 0,
            renderStandalone: void 0,
            swiper: {
                cssMode: !1,
                initialSlide: 0,
                spaceBetween: 20,
                speed: 300,
                loop: !1,
                preloadImages: !0,
                keyboard: {
                    enabled: !0
                },
                navigation: {
                    nextEl: ".photo-browser-next",
                    prevEl: ".photo-browser-prev"
                },
                zoom: {
                    enabled: !0,
                    maxRatio: 3,
                    minRatio: 1
                },
                lazy: {
                    enabled: !0
                }
            }
        }
    },
    create() {
        const e = this;
        e.photoBrowser = Gt({
            defaultSelector: ".photo-browser-popup, .photo-browser-page",
            constructor: Kp,
            app: e,
            domProp: "f7PhotoBrowser"
        })
    },
    static: {
        PhotoBrowser: Kp
    }
};
let Zp = class extends Va {
    constructor(t, n) {
        const a = se({
            on: {}
        }, t.params.notification, n);
        super(t, a);
        const r = this;
        r.app = t,
        r.params = a;
        const {icon: o, title: i, titleRightText: s, subtitle: l, text: c, closeButton: u, closeTimeout: f, cssClass: d, closeOnClick: p} = r.params;
        let h;
        if (r.params.el)
            h = $(r.params.el);
        else {
            const L = r.render({
                icon: o,
                title: i,
                titleRightText: s,
                subtitle: l,
                text: c,
                closeButton: u,
                cssClass: d
            });
            h = $(L)
        }
        if (h && h.length > 0 && h[0].f7Modal)
            return h[0].f7Modal;
        if (h.length === 0)
            return r.destroy();
        se(r, {
            $el: h,
            el: h[0],
            type: "notification"
        }),
        h[0].f7Modal = r,
        u && h.find(".notification-close-button").on("click", () => {
            r.close()
        }
        ),
        h.on("click", L => {
            u && $(L.target).closest(".notification-close-button").length || (r.emit("local::click notificationClick", r),
            p && r.close())
        }
        ),
        r.on("beforeDestroy", () => {
            h.off("click")
        }
        );
        let m, g, b, v, y, w;
        const C = {};
        function _(L) {
            m || (m = !0,
            g = !1,
            b = void 0,
            y = zn(),
            C.x = L.type === "touchstart" ? L.targetTouches[0].pageX : L.pageX,
            C.y = L.type === "touchstart" ? L.targetTouches[0].pageY : L.pageY)
        }
        function E(L) {
            if (!m)
                return;
            const U = L.type === "touchmove" ? L.targetTouches[0].pageX : L.pageX
              , Y = L.type === "touchmove" ? L.targetTouches[0].pageY : L.pageY;
            if (typeof b > "u" && (b = !!(b || Math.abs(Y - C.y) < Math.abs(U - C.x))),
            b) {
                m = !1;
                return
            }
            L.preventDefault(),
            g || (r.$el.removeClass("notification-transitioning"),
            r.$el.transition(0),
            w = r.$el[0].offsetHeight / 2),
            g = !0,
            v = Y - C.y;
            let H = v;
            v > 0 && (H = v ** .8),
            r.$el.transform(`translate3d(0, ${H}px, 0)`)
        }
        function z() {
            if (!m || !g) {
                m = !1,
                g = !1;
                return
            }
            if (m = !1,
            g = !1,
            v === 0)
                return;
            const L = zn() - y;
            r.$el.transition(""),
            r.$el.addClass("notification-transitioning"),
            r.$el.transform(""),
            (v < -10 && L < 300 || -v >= w / 1) && r.close()
        }
        function T() {
            r.$el.on(t.touchEvents.start, _, {
                passive: !0
            }),
            t.on("touchmove:active", E),
            t.on("touchend:passive", z)
        }
        function A() {
            r.$el.off(t.touchEvents.start, _, {
                passive: !0
            }),
            t.off("touchmove:active", E),
            t.off("touchend:passive", z)
        }
        let x;
        function M() {
            x = un( () => {
                if (m && g) {
                    M();
                    return
                }
                r.close()
            }
            , f)
        }
        return r.on("open", () => {
            r.params.swipeToClose && T(),
            $(".notification.modal-in").each(L => {
                const U = t.notification.get(L);
                L !== r.el && U && U.close()
            }
            ),
            f && M()
        }
        ),
        r.on("close beforeDestroy", () => {
            r.params.swipeToClose && A(),
            clearTimeout(x)
        }
        ),
        r
    }
    render() {
        const t = this;
        if (t.params.render)
            return t.params.render.call(t, t);
        const {icon: n, title: a, titleRightText: r, subtitle: o, text: i, closeButton: s, cssClass: l} = t.params;
        return R("div", {
            class: `notification ${l || ""}`
        }, R("div", {
            class: "notification-header"
        }, n && R("div", {
            class: "notification-icon"
        }, n), a && R("div", {
            class: "notification-title"
        }, a), r && R("div", {
            class: "notification-title-right-text"
        }, r), s && R("span", {
            class: "notification-close-button"
        })), R("div", {
            class: "notification-content"
        }, o && R("div", {
            class: "notification-subtitle"
        }, o), i && R("div", {
            class: "notification-text"
        }, i)))
    }
}
;
const $j = {
    name: "notification",
    static: {
        Notification: Zp
    },
    create() {
        const e = this;
        e.notification = se({}, cr({
            app: e,
            constructor: Zp,
            defaultSelector: ".notification.modal-in"
        }))
    },
    params: {
        notification: {
            icon: null,
            title: null,
            titleRightText: null,
            subtitle: null,
            text: null,
            closeButton: !1,
            closeTimeout: null,
            closeOnClick: !1,
            swipeToClose: !0,
            cssClass: null,
            render: null,
            containerEl: null
        }
    }
};
let Jp = class extends Bt {
    constructor(t, n) {
        n === void 0 && (n = {}),
        super(n, [t]);
        const a = this;
        a.app = t;
        const r = yt()
          , o = se({
            on: {}
        }, t.params.autocomplete);
        typeof o.searchbarDisableButton > "u" && (o.searchbarDisableButton = t.theme !== "aurora"),
        a.useModulesParams(o),
        a.params = se(o, n);
        let i;
        a.params.openerEl && (i = $(a.params.openerEl),
        i.length && (i[0].f7Autocomplete = a));
        let s;
        a.params.inputEl && (s = $(a.params.inputEl),
        s.length && (s[0].f7Autocomplete = a));
        const l = ac();
        let c = n.url;
        !c && i && i.length && (i.attr("href") ? c = i.attr("href") : i.find("a").length > 0 && (c = i.find("a").attr("href"))),
        (!c || c === "#" || c === "") && (c = a.params.url);
        const u = a.params.multiple ? "checkbox" : "radio";
        se(a, {
            $openerEl: i,
            openerEl: i && i[0],
            $inputEl: s,
            inputEl: s && s[0],
            id: l,
            url: c,
            value: a.params.value || [],
            inputType: u,
            inputName: `${u}-${l}`,
            $modalEl: void 0,
            $dropdownEl: void 0
        });
        let f = "";
        function d() {
            let C = a.$inputEl.val().trim();
            a.params.source && a.params.source.call(a, C, _ => {
                let E = "";
                const z = a.params.limit ? Math.min(a.params.limit, _.length) : _.length;
                a.items = _;
                let T;
                a.params.highlightMatches && (C = C.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&"),
                T = new RegExp(`(${C})`,"i"));
                let A, x;
                for (let M = 0; M < z; M += 1) {
                    const L = typeof _[M] == "object" ? _[M][a.params.valueProperty] : _[M]
                      , U = typeof _[M] == "object" ? _[M][a.params.textProperty] : _[M];
                    M === 0 && (A = L,
                    x = a.items[M]),
                    E += a.renderItem({
                        value: L,
                        text: a.params.highlightMatches ? U.replace(T, "<b>$1</b>") : U
                    }, M)
                }
                if (E === "" && C === "" && a.params.dropdownPlaceholderText && (E += a.renderItem({
                    placeholder: !0,
                    text: a.params.dropdownPlaceholderText
                })),
                a.$dropdownEl.find("ul").html(E),
                a.params.typeahead) {
                    if (!A || !x || A.toLowerCase().indexOf(C.toLowerCase()) !== 0)
                        return;
                    if (f.toLowerCase() === C.toLowerCase()) {
                        a.value = [];
                        return
                    }
                    if (f.toLowerCase().indexOf(C.toLowerCase()) === 0) {
                        f = C,
                        a.value = [];
                        return
                    }
                    s.val(A),
                    s[0].setSelectionRange(C.length, A.length);
                    const M = typeof a.value[0] == "object" ? a.value[0][a.params.valueProperty] : a.value[0];
                    (!M || A.toLowerCase() !== M.toLowerCase()) && (a.value = [x],
                    a.emit("local::change autocompleteChange", [x]))
                }
                f = C
            }
            )
        }
        function p() {
            const C = this
              , _ = C.value
              , E = $(C).parents(".autocomplete-values").length > 0;
            let z, T, A;
            if (E) {
                if (a.inputType === "checkbox" && !C.checked) {
                    for (let x = 0; x < a.value.length; x += 1)
                        A = typeof a.value[x] == "string" ? a.value[x] : a.value[x][a.params.valueProperty],
                        (A === _ || A * 1 === _ * 1) && a.value.splice(x, 1);
                    a.updateValues(),
                    a.emit("local::change autocompleteChange", a.value)
                }
                return
            }
            for (let x = 0; x < a.items.length; x += 1)
                T = typeof a.items[x] == "object" ? a.items[x][a.params.valueProperty] : a.items[x],
                (T === _ || T * 1 === _ * 1) && (z = a.items[x]);
            if (a.inputType === "radio")
                a.value = [z];
            else if (C.checked)
                a.value.push(z);
            else
                for (let x = 0; x < a.value.length; x += 1)
                    A = typeof a.value[x] == "object" ? a.value[x][a.params.valueProperty] : a.value[x],
                    (A === _ || A * 1 === _ * 1) && a.value.splice(x, 1);
            a.updateValues(),
            (a.inputType === "radio" && C.checked || a.inputType === "checkbox") && a.emit("local::change autocompleteChange", a.value)
        }
        function h(C) {
            const _ = $(C.target);
            _.is(a.$inputEl[0]) || a.$dropdownEl && _.closest(a.$dropdownEl[0]).length || a.close()
        }
        function m() {
            a.open()
        }
        function g() {
            a.open()
        }
        function b() {
            a.$dropdownEl.find("label.active-state").length > 0 || setTimeout( () => {
                a.close()
            }
            , 0)
        }
        function v() {
            a.positionDropdown()
        }
        function y(C) {
            if (!a.opened)
                return;
            if (C.keyCode === 27) {
                C.preventDefault(),
                a.$inputEl.blur();
                return
            }
            if (C.keyCode === 13) {
                const z = a.$dropdownEl.find(".autocomplete-dropdown-selected label");
                if (z.length) {
                    C.preventDefault(),
                    z.trigger("click"),
                    a.$inputEl.blur();
                    return
                }
                a.params.typeahead && (C.preventDefault(),
                a.$inputEl.blur());
                return
            }
            if (C.keyCode !== 40 && C.keyCode !== 38)
                return;
            C.preventDefault();
            const _ = a.$dropdownEl.find(".autocomplete-dropdown-selected");
            let E;
            _.length ? (E = _[C.keyCode === 40 ? "next" : "prev"]("li"),
            E.length || (E = a.$dropdownEl.find("li").eq(C.keyCode === 40 ? 0 : a.$dropdownEl.find("li").length - 1))) : E = a.$dropdownEl.find("li").eq(C.keyCode === 40 ? 0 : a.$dropdownEl.find("li").length - 1),
            !E.hasClass("autocomplete-dropdown-placeholder") && (_.removeClass("autocomplete-dropdown-selected"),
            E.addClass("autocomplete-dropdown-selected"))
        }
        function w() {
            const C = $(this);
            let _;
            for (let E = 0; E < a.items.length; E += 1) {
                const z = typeof a.items[E] == "object" ? a.items[E][a.params.valueProperty] : a.items[E]
                  , T = C.attr("data-value");
                (z === T || z * 1 === T * 1) && (_ = a.items[E])
            }
            a.params.updateInputValueOnSelect && (a.$inputEl.val(typeof _ == "object" ? _[a.params.valueProperty] : _),
            a.$inputEl.trigger("input change")),
            a.value = [_],
            a.emit("local::change autocompleteChange", [_]),
            a.close()
        }
        return a.attachEvents = function() {
            a.params.openIn !== "dropdown" && a.$openerEl && a.$openerEl.on("click", m),
            a.params.openIn === "dropdown" && a.$inputEl && (a.$inputEl.on("focus", g),
            a.$inputEl.on(a.params.inputEvents, d),
            r.android ? $("html").on("click", h) : a.$inputEl.on("blur", b),
            a.$inputEl.on("keydown", y))
        }
        ,
        a.detachEvents = function() {
            a.params.openIn !== "dropdown" && a.$openerEl && a.$openerEl.off("click", m),
            a.params.openIn === "dropdown" && a.$inputEl && (a.$inputEl.off("focus", g),
            a.$inputEl.off(a.params.inputEvents, d),
            r.android ? $("html").off("click", h) : a.$inputEl.off("blur", b),
            a.$inputEl.off("keydown", y))
        }
        ,
        a.attachDropdownEvents = function() {
            a.$dropdownEl.on("click", "label", w),
            t.on("resize", v)
        }
        ,
        a.detachDropdownEvents = function() {
            a.$dropdownEl.off("click", "label", w),
            t.off("resize", v)
        }
        ,
        a.attachPageEvents = function() {
            a.$el.on("change", 'input[type="radio"], input[type="checkbox"]', p),
            a.params.closeOnSelect && !a.params.multiple && a.$el.once("click", ".list label", () => {
                un( () => {
                    a.close()
                }
                )
            }
            )
        }
        ,
        a.detachPageEvents = function() {
            a.$el.off("change", 'input[type="radio"], input[type="checkbox"]', p)
        }
        ,
        a.useModules(),
        a.init(),
        a
    }
    get view() {
        const t = this
          , {$openerEl: n, $inputEl: a, app: r} = t;
        let o;
        if (t.params.view)
            o = t.params.view;
        else if (n || a) {
            const i = n || a;
            o = i.closest(".view").length && i.closest(".view")[0].f7View
        }
        return o || (o = r.views.main),
        o
    }
    positionDropdown() {
        const t = this
          , {$inputEl: n, app: a, $dropdownEl: r} = t
          , o = n.parents(".page-content");
        if (o.length === 0)
            return;
        const i = n.offset()
          , s = n[0].offsetWidth
          , l = n[0].offsetHeight
          , c = n.parents(".list");
        let u;
        c.parents().each(y => {
            if (u)
                return;
            const w = $(y);
            w.parent(o).length && (u = w)
        }
        );
        const f = c.offset()
          , d = parseInt(o.css("padding-bottom"), 10)
          , p = c.length > 0 ? f.left - o.offset().left : 0
          , h = i.left - (c.length > 0 ? f.left : 0) - (a.rtl,
        0)
          , m = i.top - (o.offset().top - o[0].scrollTop)
          , g = o[0].scrollHeight - d - (m + o[0].scrollTop) - n[0].offsetHeight
          , b = a.rtl ? "padding-right" : "padding-left";
        let v;
        c.length && !t.params.expandInput && (v = (a.rtl ? c[0].offsetWidth - h - s : h) - (a.theme === "md" ? 16 : 15)),
        r.css({
            left: `${c.length > 0 ? p : h}px`,
            top: `${m + o[0].scrollTop + l}px`,
            width: `${c.length > 0 ? c[0].offsetWidth : s}px`
        }),
        r.children(".autocomplete-dropdown-inner").css({
            maxHeight: `${g}px`,
            [b]: c.length > 0 && !t.params.expandInput ? `${v}px` : ""
        })
    }
    focus() {
        this.$el.find("input[type=search]").focus()
    }
    source(t) {
        const n = this;
        if (!n.params.source)
            return;
        const {$el: a} = n;
        n.params.source.call(n, t, r => {
            let o = "";
            const i = n.params.limit ? Math.min(n.params.limit, r.length) : r.length;
            n.items = r;
            for (let s = 0; s < i; s += 1) {
                let l = !1;
                const c = typeof r[s] == "object" ? r[s][n.params.valueProperty] : r[s];
                for (let u = 0; u < n.value.length; u += 1) {
                    const f = typeof n.value[u] == "object" ? n.value[u][n.params.valueProperty] : n.value[u];
                    (f === c || f * 1 === c * 1) && (l = !0)
                }
                o += n.renderItem({
                    value: c,
                    text: typeof r[s] == "object" ? r[s][n.params.textProperty] : r[s],
                    inputType: n.inputType,
                    id: n.id,
                    inputName: n.inputName,
                    selected: l
                }, s)
            }
            a.find(".autocomplete-found ul").html(o),
            r.length === 0 ? t.length !== 0 ? (a.find(".autocomplete-not-found").show(),
            a.find(".autocomplete-found, .autocomplete-values").hide()) : (a.find(".autocomplete-values").show(),
            a.find(".autocomplete-found, .autocomplete-not-found").hide()) : (a.find(".autocomplete-found").show(),
            a.find(".autocomplete-not-found, .autocomplete-values").hide())
        }
        )
    }
    updateValues() {
        const t = this;
        let n = "";
        for (let a = 0; a < t.value.length; a += 1)
            n += t.renderItem({
                value: typeof t.value[a] == "object" ? t.value[a][t.params.valueProperty] : t.value[a],
                text: typeof t.value[a] == "object" ? t.value[a][t.params.textProperty] : t.value[a],
                inputType: t.inputType,
                id: t.id,
                inputName: `${t.inputName}-checked}`,
                selected: !0
            }, a);
        t.$el.find(".autocomplete-values ul").html(n)
    }
    preloaderHide() {
        const t = this;
        t.params.openIn === "dropdown" && t.$dropdownEl ? t.$dropdownEl.find(".autocomplete-preloader").removeClass("autocomplete-preloader-visible") : $(".autocomplete-preloader").removeClass("autocomplete-preloader-visible")
    }
    preloaderShow() {
        const t = this;
        t.params.openIn === "dropdown" && t.$dropdownEl ? t.$dropdownEl.find(".autocomplete-preloader").addClass("autocomplete-preloader-visible") : $(".autocomplete-preloader").addClass("autocomplete-preloader-visible")
    }
    renderPreloader() {
        const t = this
          , n = {
            iosPreloaderContent: ho,
            mdPreloaderContent: po,
            auroraPreloaderContent: mo
        };
        return R("div", {
            class: `autocomplete-preloader preloader ${t.params.preloaderColor ? `color-${t.params.preloaderColor}` : ""}`
        }, n[`${t.app.theme}PreloaderContent`] || "")
    }
    renderSearchbar() {
        const t = this;
        return t.params.renderSearchbar ? t.params.renderSearchbar.call(t) : R("form", {
            class: "searchbar"
        }, R("div", {
            class: "searchbar-inner"
        }, R("div", {
            class: "searchbar-input-wrap"
        }, R("input", {
            type: "search",
            spellcheck: t.params.searchbarSpellcheck || "false",
            placeholder: t.params.searchbarPlaceholder
        }), R("i", {
            class: "searchbar-icon"
        }), R("span", {
            class: "input-clear-button"
        })), t.params.searchbarDisableButton && R("span", {
            class: "searchbar-disable-button"
        }, t.params.searchbarDisableText)))
    }
    renderItem(t, n) {
        const a = this;
        if (a.params.renderItem)
            return a.params.renderItem.call(a, t, n);
        const r = t.value && typeof t.value == "string" ? t.value.replace(/"/g, "&quot;") : t.value;
        return a.params.openIn !== "dropdown" ? R("li", null, R("label", {
            class: `item-${t.inputType} item-content`
        }, R("input", {
            type: t.inputType,
            name: t.inputName,
            value: r,
            _checked: t.selected
        }), R("i", {
            class: `icon icon-${t.inputType}`
        }), R("div", {
            class: "item-inner"
        }, R("div", {
            class: "item-title"
        }, t.text)))) : t.placeholder ? R("li", {
            class: "autocomplete-dropdown-placeholder"
        }, R("label", {
            class: "item-content"
        }, R("div", {
            class: "item-inner"
        }, R("div", {
            class: "item-title"
        }, t.text)))) : R("li", null, R("label", {
            class: "item-radio item-content",
            "data-value": r
        }, R("div", {
            class: "item-inner"
        }, R("div", {
            class: "item-title"
        }, t.text))))
    }
    renderNavbar() {
        const t = this;
        if (t.params.renderNavbar)
            return t.params.renderNavbar.call(t);
        let n = t.params.pageTitle;
        typeof n > "u" && t.$openerEl && t.$openerEl.length && (n = t.$openerEl.find(".item-title").text().trim());
        const a = t.params.openIn === "popup"
          , r = a ? t.params.preloader && R("div", {
            class: "left"
        }, t.renderPreloader()) : R("div", {
            class: "left sliding"
        }, R("a", {
            class: "link back"
        }, R("i", {
            class: "icon icon-back"
        }), R("span", {
            class: "if-not-md"
        }, t.params.pageBackLinkText)))
          , o = a ? R("div", {
            class: "right"
        }, R("a", {
            class: "link popup-close",
            "data-popup": ".autocomplete-popup"
        }, t.params.popupCloseLinkText)) : t.params.preloader && R("div", {
            class: "right"
        }, t.renderPreloader());
        return R("div", {
            class: `navbar ${t.params.navbarColorTheme ? `color-${t.params.navbarColorTheme}` : ""}`
        }, R("div", {
            class: "navbar-bg"
        }), R("div", {
            class: `navbar-inner ${t.params.navbarColorTheme ? `color-${t.params.navbarColorTheme}` : ""}`
        }, r, n && R("div", {
            class: "title sliding"
        }, n), o, R("div", {
            class: "subnavbar sliding"
        }, t.renderSearchbar())))
    }
    renderDropdown() {
        const t = this;
        return t.params.renderDropdown ? t.params.renderDropdown.call(t, t.items) : R("div", {
            class: "autocomplete-dropdown"
        }, R("div", {
            class: "autocomplete-dropdown-inner"
        }, R("div", {
            class: `list ${t.params.expandInput ? "" : "no-safe-areas"}`
        }, R("ul", null))), t.params.preloader && t.renderPreloader())
    }
    renderPage(t) {
        const n = this;
        return n.params.renderPage ? n.params.renderPage.call(n, n.items) : R("div", {
            class: "page page-with-subnavbar autocomplete-page",
            "data-name": "autocomplete-page"
        }, n.renderNavbar(t), R("div", {
            class: "searchbar-backdrop"
        }), R("div", {
            class: "page-content"
        }, R("div", {
            class: `list autocomplete-list autocomplete-found autocomplete-list-${n.id} ${n.params.formColorTheme ? `color-${n.params.formColorTheme}` : ""}`
        }, R("ul", null)), R("div", {
            class: "list autocomplete-not-found"
        }, R("ul", null, R("li", {
            class: "item-content"
        }, R("div", {
            class: "item-inner"
        }, R("div", {
            class: "item-title"
        }, n.params.notFoundText))))), R("div", {
            class: "list autocomplete-values"
        }, R("ul", null))))
    }
    renderPopup() {
        const t = this;
        return t.params.renderPopup ? t.params.renderPopup.call(t, t.items) : R("div", {
            class: "popup autocomplete-popup"
        }, R("div", {
            class: "view"
        }, t.renderPage(!0), ";"))
    }
    onOpen(t, n) {
        const a = this
          , r = a.app
          , o = $(n);
        if (a.$el = o,
        a.el = o[0],
        a.openedIn = t,
        a.opened = !0,
        a.params.openIn === "dropdown")
            a.attachDropdownEvents(),
            a.$dropdownEl.addClass("autocomplete-dropdown-in"),
            a.$inputEl.trigger("input");
        else {
            let i = o.find(".searchbar");
            a.params.openIn === "page" && r.theme === "ios" && i.length === 0 && (i = $(r.navbar.getElByPage(o)).find(".searchbar")),
            a.searchbar = r.searchbar.create({
                el: i,
                backdropEl: o.find(".searchbar-backdrop"),
                customSearch: !0,
                on: {
                    search(s, l) {
                        l.length === 0 && a.searchbar.enabled ? a.searchbar.backdropShow() : a.searchbar.backdropHide(),
                        a.source(l)
                    }
                }
            }),
            a.attachPageEvents(),
            a.updateValues(),
            a.params.requestSourceOnOpen && a.source("")
        }
        a.emit("local::open autocompleteOpen", a)
    }
    autoFocus() {
        const t = this;
        return t.searchbar && t.searchbar.$inputEl && t.searchbar.$inputEl.focus(),
        t
    }
    onOpened() {
        const t = this;
        t.params.openIn !== "dropdown" && t.params.autoFocus && t.autoFocus(),
        t.emit("local::opened autocompleteOpened", t)
    }
    onClose() {
        const t = this;
        t.destroyed || (t.searchbar && t.searchbar.destroy && (t.searchbar.destroy(),
        t.searchbar = null,
        delete t.searchbar),
        t.params.openIn === "dropdown" ? (t.detachDropdownEvents(),
        t.$dropdownEl.removeClass("autocomplete-dropdown-in").remove(),
        t.$inputEl.parents(".item-content-dropdown-expanded").removeClass("item-content-dropdown-expanded")) : t.detachPageEvents(),
        t.emit("local::close autocompleteClose", t))
    }
    onClosed() {
        const t = this;
        t.destroyed || (t.opened = !1,
        t.$el = null,
        t.el = null,
        delete t.$el,
        delete t.el,
        t.emit("local::closed autocompleteClosed", t))
    }
    openPage() {
        const t = this;
        if (t.opened)
            return t;
        const n = t.renderPage();
        return t.view.router.navigate({
            url: t.url,
            route: {
                content: n,
                path: t.url,
                on: {
                    pageBeforeIn(a, r) {
                        t.onOpen("page", r.el)
                    },
                    pageAfterIn(a, r) {
                        t.onOpened("page", r.el)
                    },
                    pageBeforeOut(a, r) {
                        t.onClose("page", r.el)
                    },
                    pageAfterOut(a, r) {
                        t.onClosed("page", r.el)
                    }
                },
                options: {
                    animate: t.params.animate
                }
            }
        }),
        t
    }
    openPopup() {
        const t = this;
        if (t.opened)
            return t;
        const a = {
            content: t.renderPopup(),
            animate: t.params.animate,
            push: t.params.popupPush,
            swipeToClose: t.params.popupSwipeToClose,
            on: {
                popupOpen(r) {
                    t.onOpen("popup", r.el)
                },
                popupOpened(r) {
                    t.onOpened("popup", r.el)
                },
                popupClose(r) {
                    t.onClose("popup", r.el)
                },
                popupClosed(r) {
                    t.onClosed("popup", r.el)
                }
            }
        };
        return t.params.routableModals && t.view ? t.view.router.navigate({
            url: t.url,
            route: {
                path: t.url,
                popup: a
            }
        }) : t.modal = t.app.popup.create(a).open(t.params.animate),
        t
    }
    openDropdown() {
        const t = this;
        t.$dropdownEl || (t.$dropdownEl = $(t.renderDropdown())),
        t.$inputEl.parents(".list").length && t.$inputEl.parents(".item-content").length > 0 && t.params.expandInput && t.$inputEl.parents(".item-content").addClass("item-content-dropdown-expanded");
        const a = t.$inputEl.parents(".page-content");
        t.params.dropdownContainerEl ? $(t.params.dropdownContainerEl).append(t.$dropdownEl) : a.length === 0 ? t.$dropdownEl.insertAfter(t.$inputEl) : (t.positionDropdown(),
        a.append(t.$dropdownEl)),
        t.onOpen("dropdown", t.$dropdownEl),
        t.onOpened("dropdown", t.$dropdownEl)
    }
    open() {
        const t = this;
        if (t.opened)
            return t;
        const n = t.params.openIn;
        return t[`open${n.split("").map( (a, r) => r === 0 ? a.toUpperCase() : a).join("")}`](),
        t
    }
    close() {
        const t = this;
        return t.opened && (t.params.openIn === "dropdown" ? (t.onClose(),
        t.onClosed()) : t.params.routableModals && t.view || t.openedIn === "page" ? t.view.router.back({
            animate: t.params.animate
        }) : (t.modal.once("modalClosed", () => {
            un( () => {
                t.destroyed || (t.modal.destroy(),
                delete t.modal)
            }
            )
        }
        ),
        t.modal.close())),
        t
    }
    init() {
        this.attachEvents()
    }
    destroy() {
        const t = this;
        t.emit("local::beforeDestroy autocompleteBeforeDestroy", t),
        t.detachEvents(),
        t.$inputEl && t.$inputEl[0] && delete t.$inputEl[0].f7Autocomplete,
        t.$openerEl && t.$openerEl[0] && delete t.$openerEl[0].f7Autocomplete,
        Yt(t),
        t.destroyed = !0
    }
}
;
const Ej = {
    name: "autocomplete",
    params: {
        autocomplete: {
            openerEl: void 0,
            inputEl: void 0,
            view: void 0,
            dropdownContainerEl: void 0,
            dropdownPlaceholderText: void 0,
            typeahead: !1,
            highlightMatches: !0,
            expandInput: !1,
            updateInputValueOnSelect: !0,
            inputEvents: "input",
            value: void 0,
            multiple: !1,
            source: void 0,
            limit: void 0,
            valueProperty: "id",
            textProperty: "text",
            openIn: "page",
            pageBackLinkText: "Back",
            popupCloseLinkText: "Close",
            pageTitle: void 0,
            searchbarPlaceholder: "Search...",
            searchbarDisableText: "Cancel",
            searchbarDisableButton: void 0,
            searchbarSpellcheck: !1,
            popupPush: !1,
            popupSwipeToClose: void 0,
            animate: !0,
            autoFocus: !1,
            closeOnSelect: !1,
            notFoundText: "Nothing found",
            requestSourceOnOpen: !1,
            preloaderColor: void 0,
            preloader: !1,
            formColorTheme: void 0,
            navbarColorTheme: void 0,
            routableModals: !1,
            url: "select/",
            renderDropdown: void 0,
            renderPage: void 0,
            renderPopup: void 0,
            renderItem: void 0,
            renderSearchbar: void 0,
            renderNavbar: void 0
        }
    },
    static: {
        Autocomplete: Jp
    },
    create() {
        const e = this;
        e.autocomplete = se(Gt({
            defaultSelector: void 0,
            constructor: Jp,
            app: e,
            domProp: "f7Autocomplete"
        }), {
            open(t) {
                const n = e.autocomplete.get(t);
                if (n && n.open)
                    return n.open()
            },
            close(t) {
                const n = e.autocomplete.get(t);
                if (n && n.close)
                    return n.close()
            }
        })
    }
};
let Qp = class extends Bt {
    constructor(t, n) {
        n === void 0 && (n = {}),
        super(n, [t]);
        const a = this
          , r = Mt()
          , o = se({}, t.params.tooltip)
          , i = Qe();
        a.useModulesParams(o),
        a.params = se(o, n),
        typeof n.offset > "u" && r.touch && a.params.trigger === "hover" && (a.params.offset = 10);
        const {targetEl: s, containerEl: l} = a.params;
        if (!s && !a.params.delegated)
            return a;
        const c = $(s);
        if (c.length === 0 && !a.params.delegated)
            return a;
        if (c[0] && c[0].f7Tooltip && !a.params.delegated)
            return c[0].f7Tooltip;
        let u = $(l || t.$el).eq(0);
        u.length === 0 && (u = t.$el);
        const f = $(a.render()).eq(0);
        se(a, {
            app: t,
            $targetEl: c,
            targetEl: c && c[0],
            $containerEl: u,
            containerEl: u && u[0],
            $el: f,
            el: f && f[0],
            text: a.params.text || "",
            visible: !1,
            opened: !1
        }),
        c[0] && (c[0].f7Tooltip = a);
        const d = {};
        let p;
        function h() {
            a.opened ? a.hide() : a.show(this)
        }
        function m(_) {
            a.opened && ($(_.target).closest(c).length || $(_.target).closest(a.$el).length) || a.hide()
        }
        function g(_) {
            p || (p = !0,
            d.x = _.type === "touchstart" ? _.targetTouches[0].pageX : _.pageX,
            d.y = _.type === "touchstart" ? _.targetTouches[0].pageY : _.pageY,
            a.show(this))
        }
        function b(_) {
            if (!p)
                return;
            const E = _.type === "touchmove" ? _.targetTouches[0].pageX : _.pageX
              , z = _.type === "touchmove" ? _.targetTouches[0].pageY : _.pageY;
            ((E - d.x) ** 2 + (z - d.y) ** 2) ** .5 > 50 && (p = !1,
            a.hide())
        }
        function v() {
            p && (p = !1,
            a.hide())
        }
        function y() {
            a.show(this)
        }
        function w() {
            a.hide()
        }
        function C() {
            f.hasClass("tooltip-in") || f.removeClass("tooltip-out").remove()
        }
        return a.attachEvents = function() {
            if (f.on("transitionend", C),
            a.params.trigger === "click") {
                a.params.delegated ? $(i).on("click", a.params.targetEl, h) : a.$targetEl.on("click", h),
                $("html").on("click", m);
                return
            }
            if (a.params.trigger !== "manual")
                if (r.touch) {
                    const E = r.passiveListener ? {
                        passive: !0
                    } : !1;
                    a.params.delegated ? $(i).on(t.touchEvents.start, a.params.targetEl, g, E) : a.$targetEl.on(t.touchEvents.start, g, E),
                    t.on("touchmove", b),
                    t.on("touchend:passive", v)
                } else
                    a.params.delegated ? ($(i).on(r.pointerEvents ? "pointerenter" : "mouseenter", a.params.targetEl, y, !0),
                    $(i).on(r.pointerEvents ? "pointerleave" : "mouseleave", a.params.targetEl, w, !0)) : (a.$targetEl.on(r.pointerEvents ? "pointerenter" : "mouseenter", y),
                    a.$targetEl.on(r.pointerEvents ? "pointerleave" : "mouseleave", w))
        }
        ,
        a.detachEvents = function() {
            if (f.off("transitionend", C),
            a.params.trigger === "click") {
                a.params.delegated ? $(i).on("click", a.params.targetEl, h) : a.$targetEl.off("click", h),
                $("html").off("click", m);
                return
            }
            if (a.params.trigger !== "manual")
                if (r.touch) {
                    const E = r.passiveListener ? {
                        passive: !0
                    } : !1;
                    a.params.delegated ? $(i).off(t.touchEvents.start, a.params.targetEl, g, E) : a.$targetEl.off(t.touchEvents.start, g, E),
                    t.off("touchmove", b),
                    t.off("touchend:passive", v)
                } else
                    a.params.delegated ? ($(i).off(r.pointerEvents ? "pointerenter" : "mouseenter", a.params.targetEl, y, !0),
                    $(i).off(r.pointerEvents ? "pointerleave" : "mouseleave", a.params.targetEl, w, !0)) : (a.$targetEl.off(r.pointerEvents ? "pointerenter" : "mouseenter", y),
                    a.$targetEl.off(r.pointerEvents ? "pointerleave" : "mouseleave", w))
        }
        ,
        a.useModules(),
        a.init(),
        a
    }
    setTargetEl(t) {
        const n = this;
        return n.detachEvents(),
        n.$targetEl = $(t),
        n.targetEl = n.$targetEl[0],
        n.attachEvents(),
        n
    }
    position(t) {
        const n = this
          , {$el: a, app: r, $containerEl: o} = n
          , i = !!n.params.containerEl
          , s = n.params.offset || 0;
        a.css({
            left: "",
            top: ""
        });
        const l = $(t || n.targetEl)
          , [c,u] = [a.width(), a.height()];
        a.css({
            left: "",
            top: ""
        });
        let f, d, p, h;
        const m = i && o.length ? o[0].getBoundingClientRect() : r;
        if (l && l.length > 0) {
            if (f = l.outerWidth(),
            d = l.outerHeight(),
            typeof f > "u" && typeof d > "u") {
                const C = l[0].getBoundingClientRect();
                f = C.width,
                d = C.height
            }
            const y = l.offset();
            p = y.left - m.left,
            h = y.top - m.top;
            const w = l.parents(".page");
            w.length > 0 && (h -= w[0].scrollTop)
        }
        let[g,b] = [0, 0, 0]
          , v = "top";
        u + s < h ? b = h - u - s : u < m.height - h - d ? (v = "bottom",
        b = h + d + s) : (v = "middle",
        b = d / 2 + h - u / 2,
        b <= 0 ? b = 8 : b + u >= m.height && (b = m.height - u - 8)),
        v === "top" || v === "bottom" ? (g = f / 2 + p - c / 2,
        g < 8 && (g = 8),
        g + c > m.width && (g = m.width - c - 8),
        g < 0 && (g = 0)) : v === "middle" && (g = p - c,
        (g < 8 || g + c > m.width) && (g < 8 && (g = p + f),
        g + c > m.width && (g = m.width - c - 8))),
        a.css({
            top: `${b}px`,
            left: `${g}px`
        })
    }
    show(t) {
        const n = this
          , {$el: a, $targetEl: r, $containerEl: o} = n;
        o[0] && a[0] && !o[0].contains(a[0]) && o.append(a),
        n.position(t);
        const i = $(t);
        return n.visible = !0,
        n.opened = !0,
        r.trigger("tooltip:show"),
        a.trigger("tooltip:show"),
        i.length && i[0] !== r[0] && i.trigger("tooltip:show"),
        n.emit("local::show tooltipShow", n),
        a.removeClass("tooltip-out").addClass("tooltip-in"),
        n
    }
    hide() {
        const t = this
          , {$el: n, $targetEl: a} = t;
        return t.visible = !1,
        t.opened = !1,
        a.trigger("tooltip:hide"),
        n.trigger("tooltip:hide"),
        t.emit("local::hide tooltipHide", t),
        n.addClass("tooltip-out").removeClass("tooltip-in"),
        t
    }
    render() {
        const t = this;
        if (t.params.render)
            return t.params.render.call(t, t);
        const {cssClass: n, text: a} = t.params;
        return `
      <div class="tooltip ${n || ""}">
        <div class="tooltip-content">${a || ""}</div>
      </div>
    `.trim()
    }
    setText(t) {
        const n = this;
        return typeof t > "u" || (n.params.text = t,
        n.text = t,
        n.$el && n.$el.children(".tooltip-content").html(t),
        n.opened && n.position()),
        n
    }
    init() {
        this.attachEvents()
    }
    destroy() {
        const t = this;
        !t.$targetEl || t.destroyed || (t.$targetEl.trigger("tooltip:beforedestroy"),
        t.emit("local::beforeDestroy tooltipBeforeDestroy", t),
        t.$el.remove(),
        t.$targetEl[0] && delete t.$targetEl[0].f7Tooltip,
        t.detachEvents(),
        Yt(t),
        t.destroyed = !0)
    }
}
;
const xj = {
    name: "tooltip",
    static: {
        Tooltip: Qp
    },
    create() {
        const e = this;
        e.tooltip = Gt({
            defaultSelector: ".tooltip",
            constructor: Qp,
            app: e,
            domProp: "f7Tooltip"
        }),
        e.tooltip.show = function(n) {
            const a = $(n);
            if (a.length === 0)
                return;
            const r = a[0].f7Tooltip;
            if (r)
                return r.show(a[0]),
                r
        }
        ,
        e.tooltip.hide = function(n) {
            const a = $(n);
            if (a.length === 0)
                return;
            const r = a[0].f7Tooltip;
            if (r)
                return r.hide(),
                r
        }
        ,
        e.tooltip.setText = function(n, a) {
            const r = $(n);
            if (r.length === 0)
                return;
            const o = r[0].f7Tooltip;
            if (o)
                return o.setText(a),
                o
        }
    },
    params: {
        tooltip: {
            targetEl: null,
            delegated: !1,
            text: null,
            cssClass: null,
            render: null,
            offset: 0,
            trigger: "hover",
            containerEl: void 0
        }
    },
    on: {
        tabMounted(e) {
            const t = this;
            $(e).find(".tooltip-init").each(n => {
                const a = $(n).attr("data-tooltip");
                a && t.tooltip.create({
                    targetEl: n,
                    text: a
                })
            }
            )
        },
        tabBeforeRemove(e) {
            $(e).find(".tooltip-init").each(t => {
                t.f7Tooltip && t.f7Tooltip.destroy()
            }
            )
        },
        pageInit(e) {
            const t = this;
            e.$el.find(".tooltip-init").each(n => {
                const a = $(n).attr("data-tooltip");
                a && t.tooltip.create({
                    targetEl: n,
                    text: a
                })
            }
            ),
            t.theme === "ios" && e.view && e.view.router.dynamicNavbar && e.$navbarEl && e.$navbarEl.length > 0 && e.$navbarEl.find(".tooltip-init").each(n => {
                const a = $(n).attr("data-tooltip");
                a && t.tooltip.create({
                    targetEl: n,
                    text: a
                })
            }
            )
        },
        pageBeforeRemove(e) {
            const t = this;
            e.$el.find(".tooltip-init").each(n => {
                n.f7Tooltip && n.f7Tooltip.destroy()
            }
            ),
            t.theme === "ios" && e.view && e.view.router.dynamicNavbar && e.$navbarEl && e.$navbarEl.length > 0 && e.$navbarEl.find(".tooltip-init").each(n => {
                n.f7Tooltip && n.f7Tooltip.destroy()
            }
            )
        }
    },
    vnode: {
        "tooltip-init": {
            insert(e) {
                const t = this
                  , n = e.elm
                  , a = $(n).attr("data-tooltip");
                a && t.tooltip.create({
                    targetEl: n,
                    text: a
                })
            },
            update(e) {
                const t = e.elm;
                t.f7Tooltip && e && e.data && e.data.attrs && e.data.attrs["data-tooltip"] && t.f7Tooltip.setText(e.data.attrs["data-tooltip"])
            },
            destroy(e) {
                const t = e.elm;
                t.f7Tooltip && t.f7Tooltip.destroy()
            }
        }
    }
}
  , Tj = {
    name: "skeleton"
}
  , Mj = {
    open(e) {
        e === void 0 && (e = ".menu-item-dropdown");
        const t = this;
        if (!e)
            return;
        const n = $(e).closest(".menu-item-dropdown");
        if (!n.length)
            return;
        const a = n.closest(".menu").eq(0);
        if (a.length) {
            const r = a.css("z-index")
              , o = a[0].style.zIndex;
            a.css("z-index", parseInt(r || 0, 10) + 1),
            a[0].f7MenuZIndex = o
        }
        n.eq(0).addClass("menu-item-dropdown-opened").trigger("menu:opened"),
        t.emit("menuOpened", n.eq(0)[0])
    },
    close(e) {
        e === void 0 && (e = ".menu-item-dropdown-opened");
        const t = this;
        if (!e)
            return;
        const n = $(e).closest(".menu-item-dropdown-opened");
        if (!n.length)
            return;
        const a = n.closest(".menu").eq(0);
        if (a.length) {
            const r = a[0].f7MenuZIndex;
            a.css("z-index", r),
            delete a[0].f7MenuZIndex
        }
        n.eq(0).removeClass("menu-item-dropdown-opened").trigger("menu:closed"),
        t.emit("menuClosed", n.eq(0)[0])
    }
}
  , zj = {
    name: "menu",
    create() {
        hn(this, {
            menu: Mj
        })
    },
    on: {
        click(e) {
            const t = this
              , n = $(".menu-item-dropdown-opened");
            n.length && n.each(a => {
                $(e.target).closest(".menu-item-dropdown-opened").length || t.menu.close(a)
            }
            )
        }
    },
    clicks: {
        ".menu-item-dropdown": function(t, n, a) {
            const r = this;
            if (t.hasClass("menu-item-dropdown-opened")) {
                if ($(a.target).closest(".menu-dropdown").length)
                    return;
                r.menu.close(t)
            } else
                r.menu.open(t)
        },
        ".menu-close": function() {
            this.menu.close()
        }
    }
}
  , Aj = {
    render(e) {
        const {sliderLabel: t, sliderValue: n, sliderValueEditable: a, alphaLabelText: r} = e.params;
        return R("div", {
            class: "color-picker-module color-picker-module-alpha-slider"
        }, R("div", {
            class: "color-picker-slider-wrap"
        }, t && R("div", {
            class: "color-picker-slider-label"
        }, r), R("div", {
            class: "range-slider color-picker-slider color-picker-slider-alpha"
        }), n && R("div", {
            class: "color-picker-slider-value"
        }, a ? R("input", {
            type: "number",
            step: "0.01",
            min: "0",
            max: "1",
            class: "color-picker-value-alpha"
        }) : R("span", {
            class: "color-picker-value-alpha"
        }))))
    },
    init(e) {
        e.alphaRangeSlider = e.app.range.create({
            el: e.$el.find(".color-picker-slider-alpha"),
            min: 0,
            max: 1,
            step: .01,
            value: 1,
            on: {
                change(n, a) {
                    const r = Math.floor(a * 100) / 100;
                    e.setValue({
                        alpha: r
                    })
                }
            }
        });
        function t(n) {
            const a = e.value.alpha;
            let r = parseFloat(n.target.value);
            if (Number.isNaN(r)) {
                n.target.value = a;
                return
            }
            r = Math.max(0, Math.min(1, r)),
            e.setValue({
                alpha: r
            })
        }
        e.$el.on("change", ".color-picker-module-alpha-slider input", t),
        e.destroyAlphaSliderEvents = function() {
            e.$el.off("change", ".color-picker-module-alpha-slider input", t)
        }
    },
    update(e) {
        const {value: t} = e
          , {sliderValue: n, sliderValueEditable: a} = e.params
          , {alpha: r} = t;
        e.alphaRangeSlider.value = r,
        e.alphaRangeSlider.layout(),
        n && a ? e.$el.find("input.color-picker-value-alpha").val(r) : e.$el.find("span.color-picker-value-alpha").text(r)
    },
    destroy(e) {
        e.alphaRangeSlider && e.alphaRangeSlider.destroy && e.alphaRangeSlider.destroy(),
        delete e.alphaRangeSlider,
        e.destroyAlphaSliderEvents && e.destroyAlphaSliderEvents(),
        delete e.destroyAlphaSliderEvents
    }
}
  , Oj = {
    render() {
        return R("div", {
            class: "color-picker-module color-picker-module-current-color"
        }, R("div", {
            class: "color-picker-current-color"
        }))
    },
    update(e) {
        e.$el.find(".color-picker-module-current-color .color-picker-current-color").css("background-color", e.value.hex)
    }
}
  , Pj = {
    render(e) {
        const {hexLabel: t, hexLabelText: n, hexValueEditable: a} = e.params;
        return R("div", {
            class: "color-picker-module color-picker-module-hex"
        }, R("div", {
            class: "color-picker-hex-wrap"
        }, t && R("div", {
            class: "color-picker-hex-label"
        }, n), R("div", {
            class: "color-picker-hex-value"
        }, a ? R("input", {
            type: "text",
            class: "color-picker-value-hex"
        }) : R("span", {
            class: "color-picker-value-hex"
        }))))
    },
    init(e) {
        function t(n) {
            const a = e.value.hex;
            let r = n.target.value.replace(/#/g, "");
            if (Number.isNaN(r) || !r || r.length !== 3 && r.length !== 6) {
                n.target.value = a;
                return
            }
            const o = 0
              , i = parseInt(r, 16)
              , s = parseInt("ffffff", 16);
            i > s && (r = "fff"),
            i < o && (r = "000"),
            e.setValue({
                hex: r
            })
        }
        e.$el.on("change", ".color-picker-module-hex input", t),
        e.destroyHexEvents = function() {
            e.$el.off("change", ".color-picker-module-hex input", t)
        }
    },
    update(e) {
        const {value: t} = e
          , {hexValueEditable: n} = e.params
          , {hex: a} = t;
        n ? e.$el.find("input.color-picker-value-hex").val(a) : e.$el.find("span.color-picker-value-hex").text(a)
    },
    destroy(e) {
        e.destroyHexEvents && e.destroyHexEvents(),
        delete e.destroyHexEvents
    }
}
  , Lj = {
    render(e) {
        const {sliderLabel: t, sliderValue: n, sliderValueEditable: a, hueLabelText: r, saturationLabelText: o, brightnessLabelText: i} = e.params;
        return R("div", {
            class: "color-picker-module color-picker-module-hsb-sliders"
        }, R("div", {
            class: "color-picker-slider-wrap"
        }, t && R("div", {
            class: "color-picker-slider-label"
        }, r), R("div", {
            class: "range-slider color-picker-slider color-picker-slider-hue"
        }), n && R("div", {
            class: "color-picker-slider-value"
        }, a ? R("input", {
            type: "number",
            step: "0.1",
            min: "0",
            max: "360",
            class: "color-picker-value-hue",
            "data-color-index": "0"
        }) : R("span", {
            class: "color-picker-value-hue"
        }))), R("div", {
            class: "color-picker-slider-wrap"
        }, t && R("div", {
            class: "color-picker-slider-label"
        }, o), R("div", {
            class: "range-slider color-picker-slider color-picker-slider-saturation"
        }), n && R("div", {
            class: "color-picker-slider-value"
        }, a ? R("input", {
            type: "number",
            step: "0.1",
            min: "0",
            max: "100",
            class: "color-picker-value-saturation",
            "data-color-index": "1"
        }) : R("span", {
            class: "color-picker-value-saturation"
        }))), R("div", {
            class: "color-picker-slider-wrap"
        }, t && R("div", {
            class: "color-picker-slider-label"
        }, i), R("div", {
            class: "range-slider color-picker-slider color-picker-slider-brightness"
        }), n && R("div", {
            class: "color-picker-slider-value"
        }, a ? R("input", {
            type: "number",
            step: "0.1",
            min: "0",
            max: "100",
            class: "color-picker-value-brightness",
            "data-color-index": "2"
        }) : R("span", {
            class: "color-picker-value-brightness"
        }))))
    },
    init(e) {
        e.hueRangeSlider = e.app.range.create({
            el: e.$el.find(".color-picker-slider-hue"),
            min: 0,
            max: 360,
            step: .1,
            value: 0,
            on: {
                change(n, a) {
                    e.setValue({
                        hue: a
                    })
                }
            }
        }),
        e.saturationRangeSlider = e.app.range.create({
            el: e.$el.find(".color-picker-slider-saturation"),
            min: 0,
            max: 1,
            step: .001,
            value: 0,
            on: {
                change(n, a) {
                    const r = Math.floor(a * 1e3) / 1e3;
                    e.setValue({
                        hsb: [e.value.hsb[0], r, e.value.hsb[2]]
                    })
                }
            }
        }),
        e.brightnessRangeSlider = e.app.range.create({
            el: e.$el.find(".color-picker-slider-brightness"),
            min: 0,
            max: 1,
            step: .001,
            value: 0,
            on: {
                change(n, a) {
                    const r = Math.floor(a * 1e3) / 1e3;
                    e.setValue({
                        hsb: [e.value.hsb[0], e.value.hsb[1], r]
                    })
                }
            }
        });
        function t(n) {
            const a = [...e.value.hsb]
              , r = parseInt($(n.target).attr("data-color-index"), 10);
            let o = parseFloat(n.target.value);
            if (Number.isNaN(o)) {
                n.target.value = a[r];
                return
            }
            r === 0 ? o = Math.max(0, Math.min(360, o)) : o = Math.max(0, Math.min(100, o)) / 100,
            a[r] = o,
            e.setValue({
                hsb: a
            })
        }
        e.$el.on("change", ".color-picker-module-hsb-sliders input", t),
        e.destroyHsbSlidersEvents = function() {
            e.$el.off("change", ".color-picker-module-hsb-sliders input", t)
        }
    },
    update(e) {
        const {app: t, value: n} = e
          , {sliderValue: a, sliderValueEditable: r} = e.params
          , {hsb: o, hue: i} = n;
        e.hueRangeSlider.value = i,
        e.saturationRangeSlider.value = o[1],
        e.brightnessRangeSlider.value = o[2],
        e.hueRangeSlider.layout(),
        e.saturationRangeSlider.layout(),
        e.brightnessRangeSlider.layout();
        const s = tr(o[0], o[1], 1)
          , l = tr(o[0], 0, 1)
          , c = tr(o[0], 1, 1)
          , u = o[2];
        e.hueRangeSlider.$el[0].style.setProperty("--f7-range-knob-color", `hsl(${i}, 100%, 50%)`),
        e.saturationRangeSlider.$el[0].style.setProperty("--f7-range-knob-color", `hsl(${s[0]}, ${s[1] * 100}%, ${s[2] * 100}%)`),
        e.brightnessRangeSlider.$el[0].style.setProperty("--f7-range-knob-color", `rgb(${u * 255}, ${u * 255}, ${u * 255})`),
        e.saturationRangeSlider.$el.find(".range-bar").css("background-image", `linear-gradient(${t.rtl ? "to left" : "to right"}, hsl(${l[0]}, ${l[1] * 100}%, ${l[2] * 100}%), hsl(${c[0]}, ${c[1] * 100}%, ${c[2] * 100}%))`),
        a && r ? (e.$el.find("input.color-picker-value-hue").val(`${i}`),
        e.$el.find("input.color-picker-value-saturation").val(`${o[1] * 1e3 / 10}`),
        e.$el.find("input.color-picker-value-brightness").val(`${o[2] * 1e3 / 10}`)) : a && (e.$el.find("span.color-picker-value-hue").text(`${i}`),
        e.$el.find("span.color-picker-value-saturation").text(`${o[1] * 1e3 / 10}`),
        e.$el.find("span.color-picker-value-brightness").text(`${o[2] * 1e3 / 10}`))
    },
    destroy(e) {
        e.hueRangeSlider && e.hueRangeSlider.destroy && e.hueRangeSlider.destroy(),
        e.saturationRangeSlider && e.saturationRangeSlider.destroy && e.saturationRangeSlider.destroy(),
        e.brightnessRangeSlider && e.brightnessRangeSlider.destroy && e.brightnessRangeSlider.destroy(),
        delete e.hueRangeSlider,
        delete e.saturationRangeSlider,
        delete e.brightnessRangeSlider,
        e.destroyHsbSlidersEvents && e.destroyHsbSlidersEvents(),
        delete e.destroyHsbSlidersEvents
    }
}
  , Ij = {
    render(e) {
        const {sliderLabel: t, sliderValue: n, sliderValueEditable: a, hueLabelText: r} = e.params;
        return R("div", {
            class: "color-picker-module color-picker-module-hue-slider"
        }, R("div", {
            class: "color-picker-slider-wrap"
        }, t && R("div", {
            class: "color-picker-slider-label"
        }, r), R("div", {
            class: "range-slider color-picker-slider color-picker-slider-hue"
        }), n && R("div", {
            class: "color-picker-slider-value"
        }, a ? R("input", {
            type: "number",
            step: "0.1",
            min: "0",
            max: "360",
            class: "color-picker-value-hue"
        }) : R("span", {
            class: "color-picker-value-hue"
        }))))
    },
    init(e) {
        e.hueRangeSlider = e.app.range.create({
            el: e.$el.find(".color-picker-slider-hue"),
            min: 0,
            max: 360,
            step: .1,
            value: 0,
            on: {
                change(t, n) {
                    e.setValue({
                        hue: n
                    })
                }
            }
        })
    },
    update(e) {
        const {value: t} = e
          , {sliderValue: n, sliderValueEditable: a} = e.params
          , {hue: r} = t;
        e.hueRangeSlider.value = r,
        e.hueRangeSlider.layout(),
        e.hueRangeSlider.$el[0].style.setProperty("--f7-range-knob-color", `hsl(${r}, 100%, 50%)`),
        n && a ? e.$el.find("input.color-picker-value-hue").val(`${r}`) : n && e.$el.find("span.color-picker-value-hue").text(`${r}`)
    },
    destroy(e) {
        e.hueRangeSlider && e.hueRangeSlider.destroy && e.hueRangeSlider.destroy(),
        delete e.hueRangeSlider
    }
}
  , Bj = {
    render(e) {
        const {sliderLabel: t, sliderValue: n, sliderValueEditable: a, brightnessLabelText: r} = e.params;
        return R("div", {
            class: "color-picker-module color-picker-module-brightness-slider"
        }, R("div", {
            class: "color-picker-slider-wrap"
        }, t && R("div", {
            class: "color-picker-slider-label"
        }, r), R("div", {
            class: "range-slider color-picker-slider color-picker-slider-brightness"
        }), n && R("div", {
            class: "color-picker-slider-value"
        }, a ? R("input", {
            type: "number",
            step: "0.1",
            min: "0",
            max: "100",
            class: "color-picker-value-brightness"
        }) : R("span", {
            class: "color-picker-value-brightness"
        }))))
    },
    init(e) {
        e.brightnessRangeSlider = e.app.range.create({
            el: e.$el.find(".color-picker-slider-brightness"),
            min: 0,
            max: 1,
            step: .001,
            value: 0,
            on: {
                change(t, n) {
                    const a = Math.floor(n * 1e3) / 1e3;
                    e.setValue({
                        hsb: [e.value.hsb[0], e.value.hsb[1], a]
                    })
                }
            }
        })
    },
    update(e) {
        const {value: t, app: n} = e
          , {sliderValue: a, sliderValueEditable: r} = e.params
          , {hsb: o} = t;
        e.brightnessRangeSlider.value = o[2],
        e.brightnessRangeSlider.layout();
        const i = tr(o[0], o[1], o[2])
          , s = tr(o[0], o[1], 0)
          , l = tr(o[0], o[1], 1);
        e.brightnessRangeSlider.$el[0].style.setProperty("--f7-range-knob-color", `hsl(${i[0]}, ${i[1] * 100}%, ${i[2] * 100}%)`),
        e.brightnessRangeSlider.$el.find(".range-bar").css("background-image", `linear-gradient(${n.rtl ? "to left" : "to right"}, hsl(${s[0]}, ${s[1] * 100}%, ${s[2] * 100}%), hsl(${l[0]}, ${l[1] * 100}%, ${l[2] * 100}%))`),
        a && r ? e.$el.find("input.color-picker-value-brightness").val(`${o[2] * 1e3 / 10}`) : a && e.$el.find("span.color-picker-value-brightness").text(`${o[2] * 1e3 / 10}`)
    },
    destroy(e) {
        e.brightnessRangeSlider && e.brightnessRangeSlider.destroy && e.brightnessRangeSlider.destroy(),
        delete e.brightnessRangeSlider
    }
}
  , Rj = {
    render(e) {
        return R("div", {
            class: "color-picker-module color-picker-module-palette"
        }, R("div", {
            class: "color-picker-palette"
        }, e.params.palette.map(t => {
            if (Array.isArray(t)) {
                let n = '<div class="color-picker-palette-row">';
                return n += t.map(a => `
                <div class="color-picker-palette-value" data-palette-color="${a}" style="background-color: ${a}"></div>
              `).join(""),
                n += "</div>",
                n
            }
            return R("div", {
                class: "color-picker-palette-value",
                "data-palette-color": t,
                style: `background-color: ${t}`
            })
        }
        )))
    },
    init(e) {
        function t(n) {
            const a = $(n.target).attr("data-palette-color");
            e.setValue({
                hex: a
            })
        }
        e.$el.on("click", ".color-picker-module-palette .color-picker-palette-value", t),
        e.destroyPaletteEvents = function() {
            e.$el.off("click", ".color-picker-module-hex input", t)
        }
    },
    destroy(e) {
        e.destroyPaletteEvents && e.destroyPaletteEvents(),
        delete e.destroyPaletteEvents
    }
}
  , Dj = {
    render() {
        return R("div", {
            class: "color-picker-module color-picker-module-initial-current-colors"
        }, R("div", {
            class: "color-picker-initial-current-colors"
        }, R("div", {
            class: "color-picker-initial-color"
        }), R("div", {
            class: "color-picker-current-color"
        })))
    },
    init(e) {
        function t() {
            if (e.initialValue) {
                const {hex: n, alpha: a} = e.initialValue;
                e.setValue({
                    hex: n,
                    alpha: a
                })
            }
        }
        e.$el.on("click", ".color-picker-initial-color", t),
        e.destroyInitialCurrentEvents = function() {
            e.$el.off("click", ".color-picker-initial-color", t)
        }
    },
    update(e) {
        e.$el.find(".color-picker-module-initial-current-colors .color-picker-initial-color").css("background-color", e.initialValue.hex),
        e.$el.find(".color-picker-module-initial-current-colors .color-picker-current-color").css("background-color", e.value.hex)
    },
    destroy(e) {
        e.destroyInitialCurrentEvents && e.destroyInitialCurrentEvents(),
        delete e.destroyInitialCurrentEvents
    }
}
  , Nj = {
    render(e) {
        const {barLabel: t, barValue: n, barValueEditable: a, redLabelText: r, greenLabelText: o, blueLabelText: i} = e.params;
        return R("div", {
            class: "color-picker-module color-picker-module-rgb-bars"
        }, R("div", {
            class: "color-picker-bar-wrap"
        }, t && R("div", {
            class: "color-picker-bar-label"
        }, r), R("div", {
            class: "range-slider color-picker-bar color-picker-bar-red"
        }), n && R("div", {
            class: "color-picker-bar-value"
        }, a ? R("input", {
            type: "number",
            step: "1",
            min: "0",
            max: "255",
            class: "color-picker-value-bar-red",
            "data-color-index": "0"
        }) : R("span", {
            class: "color-picker-value-bar-red"
        }))), R("div", {
            class: "color-picker-bar-wrap"
        }, t && R("div", {
            class: "color-picker-bar-label"
        }, o), R("div", {
            class: "range-slider color-picker-bar color-picker-bar-green"
        }), n && R("div", {
            class: "color-picker-bar-value"
        }, a ? R("input", {
            type: "number",
            step: "1",
            min: "0",
            max: "255",
            class: "color-picker-value-bar-green",
            "data-color-index": "1"
        }) : R("span", {
            class: "color-picker-value-bar-green"
        }))), R("div", {
            class: "color-picker-bar-wrap"
        }, t && R("div", {
            class: "color-picker-bar-label"
        }, i), R("div", {
            class: "range-slider color-picker-bar color-picker-bar-blue"
        }), n && R("div", {
            class: "color-picker-bar-value"
        }, a ? R("input", {
            type: "number",
            step: "1",
            min: "0",
            max: "255",
            class: "color-picker-value-bar-blue",
            "data-color-index": "2"
        }) : R("span", {
            class: "color-picker-value-bar-blue"
        }))))
    },
    init(e) {
        e.redBar = e.app.range.create({
            el: e.$el.find(".color-picker-bar-red"),
            min: 0,
            max: 255,
            step: 1,
            value: 0,
            vertical: !0,
            on: {
                change(n, a) {
                    e.setValue({
                        rgb: [a, e.value.rgb[1], e.value.rgb[2]]
                    })
                }
            }
        }),
        e.greenBar = e.app.range.create({
            el: e.$el.find(".color-picker-bar-green"),
            min: 0,
            max: 255,
            step: 1,
            value: 0,
            vertical: !0,
            on: {
                change(n, a) {
                    e.setValue({
                        rgb: [e.value.rgb[0], a, e.value.rgb[2]]
                    })
                }
            }
        }),
        e.blueBar = e.app.range.create({
            el: e.$el.find(".color-picker-bar-blue"),
            min: 0,
            max: 255,
            step: 1,
            value: 0,
            vertical: !0,
            on: {
                change(n, a) {
                    e.setValue({
                        rgb: [e.value.rgb[0], e.value.rgb[1], a]
                    })
                }
            }
        });
        function t(n) {
            const a = [...e.value.rgb]
              , r = parseInt($(n.target).attr("data-color-index"), 10);
            let o = parseInt(n.target.value, 10);
            if (Number.isNaN(o)) {
                n.target.value = a[r];
                return
            }
            o = Math.max(0, Math.min(255, o)),
            a[r] = o,
            e.setValue({
                rgb: a
            })
        }
        e.$el.on("change", ".color-picker-module-rgb-bars input", t),
        e.destroyRgbBarsEvents = function() {
            e.$el.off("change", ".color-picker-module-rgb-bars input", t)
        }
    },
    update(e) {
        const {value: t, redBar: n, greenBar: a, blueBar: r} = e
          , {barValue: o, barValueEditable: i} = e.params
          , {rgb: s} = t;
        n.value = s[0],
        a.value = s[1],
        r.value = s[2],
        n.layout(),
        a.layout(),
        r.layout(),
        n.$el.find(".range-bar").css("background-image", `linear-gradient(to top, rgb(0, ${s[1]}, ${s[2]}), rgb(255, ${s[1]}, ${s[2]}))`),
        a.$el.find(".range-bar").css("background-image", `linear-gradient(to top, rgb(${s[0]}, 0, ${s[2]}), rgb(${s[0]}, 255, ${s[2]}))`),
        r.$el.find(".range-bar").css("background-image", `linear-gradient(to top, rgb(${s[0]}, ${s[1]}, 0), rgb(${s[0]}, ${s[1]}, 255))`),
        o && i ? (e.$el.find("input.color-picker-value-bar-red").val(s[0]),
        e.$el.find("input.color-picker-value-bar-green").val(s[1]),
        e.$el.find("input.color-picker-value-bar-blue").val(s[2])) : o && (e.$el.find("span.color-picker-value-bar-red").text(s[0]),
        e.$el.find("span.color-picker-value-bar-green").text(s[1]),
        e.$el.find("span.color-picker-value-bar-blue").text(s[2]))
    },
    destroy(e) {
        e.redBar && e.redBar.destroy && e.redBar.destroy(),
        e.greenBar && e.greenBar.destroy && e.greenBar.destroy(),
        e.blueBar && e.blueBar.destroy && e.blueBar.destroy(),
        delete e.redBar,
        delete e.greenBar,
        delete e.blueBar,
        e.destroyRgbBarsEvents && e.destroyRgbBarsEvents(),
        delete e.destroyRgbBarsEvents
    }
}
  , Hj = {
    render(e) {
        const {sliderLabel: t, sliderValue: n, sliderValueEditable: a, redLabelText: r, greenLabelText: o, blueLabelText: i} = e.params;
        return R("div", {
            class: "color-picker-module color-picker-module-rgb-sliders"
        }, R("div", {
            class: "color-picker-slider-wrap"
        }, t && R("div", {
            class: "color-picker-slider-label"
        }, r), R("div", {
            class: "range-slider color-picker-slider color-picker-slider-red"
        }), n && R("div", {
            class: "color-picker-slider-value"
        }, a ? R("input", {
            type: "number",
            step: "1",
            min: "0",
            max: "255",
            class: "color-picker-value-red",
            "data-color-index": "0"
        }) : R("span", {
            class: "color-picker-value-red"
        }))), R("div", {
            class: "color-picker-slider-wrap"
        }, t && R("div", {
            class: "color-picker-slider-label"
        }, o), R("div", {
            class: "range-slider color-picker-slider color-picker-slider-green"
        }), n && R("div", {
            class: "color-picker-slider-value"
        }, a ? R("input", {
            type: "number",
            step: "1",
            min: "0",
            max: "255",
            class: "color-picker-value-green",
            "data-color-index": "1"
        }) : R("span", {
            class: "color-picker-value-green"
        }))), R("div", {
            class: "color-picker-slider-wrap"
        }, t && R("div", {
            class: "color-picker-slider-label"
        }, i), R("div", {
            class: "range-slider color-picker-slider color-picker-slider-blue"
        }), n && R("div", {
            class: "color-picker-slider-value"
        }, a ? R("input", {
            type: "number",
            step: "1",
            min: "0",
            max: "255",
            class: "color-picker-value-blue",
            "data-color-index": "2"
        }) : R("span", {
            class: "color-picker-value-blue"
        }))))
    },
    init(e) {
        e.redRangeSlider = e.app.range.create({
            el: e.$el.find(".color-picker-slider-red"),
            min: 0,
            max: 255,
            step: 1,
            value: 0,
            on: {
                change(n, a) {
                    e.setValue({
                        rgb: [a, e.value.rgb[1], e.value.rgb[2]]
                    })
                }
            }
        }),
        e.greenRangeSlider = e.app.range.create({
            el: e.$el.find(".color-picker-slider-green"),
            min: 0,
            max: 255,
            step: 1,
            value: 0,
            on: {
                change(n, a) {
                    e.setValue({
                        rgb: [e.value.rgb[0], a, e.value.rgb[2]]
                    })
                }
            }
        }),
        e.blueRangeSlider = e.app.range.create({
            el: e.$el.find(".color-picker-slider-blue"),
            min: 0,
            max: 255,
            step: 1,
            value: 0,
            on: {
                change(n, a) {
                    e.setValue({
                        rgb: [e.value.rgb[0], e.value.rgb[1], a]
                    })
                }
            }
        });
        function t(n) {
            const a = [...e.value.rgb]
              , r = parseInt($(n.target).attr("data-color-index"), 10);
            let o = parseInt(n.target.value, 10);
            if (Number.isNaN(o)) {
                n.target.value = a[r];
                return
            }
            o = Math.max(0, Math.min(255, o)),
            a[r] = o,
            e.setValue({
                rgb: a
            })
        }
        e.$el.on("change", ".color-picker-module-rgb-sliders input", t),
        e.destroyRgbSlidersEvents = function() {
            e.$el.off("change", ".color-picker-module-rgb-sliders input", t)
        }
    },
    update(e) {
        const {app: t, value: n, redRangeSlider: a, greenRangeSlider: r, blueRangeSlider: o} = e
          , {sliderValue: i, sliderValueEditable: s} = e.params
          , {rgb: l} = n;
        a.value = l[0],
        r.value = l[1],
        o.value = l[2],
        a.layout(),
        r.layout(),
        o.layout(),
        a.$el[0].style.setProperty("--f7-range-knob-color", `rgb(${l[0]}, ${l[1]}, ${l[2]})`),
        r.$el[0].style.setProperty("--f7-range-knob-color", `rgb(${l[0]}, ${l[1]}, ${l[2]})`),
        o.$el[0].style.setProperty("--f7-range-knob-color", `rgb(${l[0]}, ${l[1]}, ${l[2]})`);
        const c = t.rtl ? "to left" : "to right";
        a.$el.find(".range-bar").css("background-image", `linear-gradient(${c}, rgb(0, ${l[1]}, ${l[2]}), rgb(255, ${l[1]}, ${l[2]}))`),
        r.$el.find(".range-bar").css("background-image", `linear-gradient(${c}, rgb(${l[0]}, 0, ${l[2]}), rgb(${l[0]}, 255, ${l[2]}))`),
        o.$el.find(".range-bar").css("background-image", `linear-gradient(${c}, rgb(${l[0]}, ${l[1]}, 0), rgb(${l[0]}, ${l[1]}, 255))`),
        i && s ? (e.$el.find("input.color-picker-value-red").val(l[0]),
        e.$el.find("input.color-picker-value-green").val(l[1]),
        e.$el.find("input.color-picker-value-blue").val(l[2])) : i && (e.$el.find("span.color-picker-value-red").text(l[0]),
        e.$el.find("span.color-picker-value-green").text(l[1]),
        e.$el.find("span.color-picker-value-blue").text(l[2]))
    },
    destroy(e) {
        e.redRangeSlider && e.redRangeSlider.destroy && e.redRangeSlider.destroy(),
        e.greenRangeSlider && e.greenRangeSlider.destroy && e.greenRangeSlider.destroy(),
        e.blueRangeSlider && e.blueRangeSlider.destroy && e.blueRangeSlider.destroy(),
        delete e.redRangeSlider,
        delete e.greenRangeSlider,
        delete e.blueRangeSlider,
        e.destroyRgbSlidersEvents && e.destroyRgbSlidersEvents(),
        delete e.destroyRgbSlidersEvents
    }
}
  , Vj = {
    render() {
        return R("div", {
            class: "color-picker-module color-picker-module-sb-spectrum"
        }, R("div", {
            class: "color-picker-sb-spectrum",
            style: "background-color: hsl(0, 100%, 50%)"
        }, R("div", {
            class: "color-picker-sb-spectrum-handle"
        })))
    },
    init(e) {
        const {app: t} = e;
        let n, a, r, o, i, s, l, c, u;
        const {$el: f} = e;
        function d(v, y) {
            let w = (v - l.left) / l.width
              , C = (y - l.top) / l.height;
            w = Math.max(0, Math.min(1, w)),
            C = 1 - Math.max(0, Math.min(1, C)),
            e.setValue({
                hsb: [e.value.hue, w, C]
            })
        }
        function p(v) {
            if (a || n)
                return;
            r = v.type === "touchstart" ? v.targetTouches[0].pageX : v.pageX,
            i = r,
            o = v.type === "touchstart" ? v.targetTouches[0].pageY : v.pageY,
            s = o;
            const y = $(v.target);
            u = y.closest(".color-picker-sb-spectrum-handle").length > 0,
            u || (c = y.closest(".color-picker-sb-spectrum").length > 0),
            c && (l = f.find(".color-picker-sb-spectrum")[0].getBoundingClientRect(),
            d(r, o)),
            (u || c) && f.find(".color-picker-sb-spectrum-handle").addClass("color-picker-sb-spectrum-handle-pressed")
        }
        function h(v) {
            (c || u) && (i = v.type === "touchmove" ? v.targetTouches[0].pageX : v.pageX,
            s = v.type === "touchmove" ? v.targetTouches[0].pageY : v.pageY,
            v.preventDefault(),
            a || (a = !0,
            u && (l = f.find(".color-picker-sb-spectrum")[0].getBoundingClientRect())),
            (c || u) && d(i, s))
        }
        function m() {
            a = !1,
            (c || u) && f.find(".color-picker-sb-spectrum-handle").removeClass("color-picker-sb-spectrum-handle-pressed"),
            c = !1,
            u = !1
        }
        function g() {
            e.modules["sb-spectrum"].update(e)
        }
        const b = t.touchEvents.start === "touchstart" && Mt().passiveListener ? {
            passive: !0,
            capture: !1
        } : !1;
        e.$el.on(t.touchEvents.start, p, b),
        t.on("touchmove:active", h),
        t.on("touchend:passive", m),
        t.on("resize", g),
        e.destroySpectrumEvents = function() {
            e.$el.off(t.touchEvents.start, p, b),
            t.off("touchmove:active", h),
            t.off("touchend:passive", m),
            t.off("resize", g)
        }
    },
    update(e) {
        const {value: t} = e
          , {hsl: n, hsb: a} = t
          , r = e.$el.find(".color-picker-sb-spectrum")[0].offsetWidth
          , o = e.$el.find(".color-picker-sb-spectrum")[0].offsetHeight;
        e.$el.find(".color-picker-sb-spectrum").css("background-color", `hsl(${n[0]}, 100%, 50%)`),
        e.$el.find(".color-picker-sb-spectrum-handle").css("background-color", `hsl(${n[0]}, ${n[1] * 100}%, ${n[2] * 100}%)`).transform(`translate(${r * a[1]}px, ${o * (1 - a[2])}px)`)
    },
    destroy(e) {
        e.destroySpectrumEvents && e.destroySpectrumEvents(),
        delete e.destroySpectrumEvents
    }
}
  , Fj = {
    render() {
        return R("div", {
            class: "color-picker-module color-picker-module-hs-spectrum"
        }, R("div", {
            class: "color-picker-hs-spectrum"
        }, R("div", {
            class: "color-picker-hs-spectrum-handle"
        })))
    },
    init(e) {
        const {app: t} = e;
        let n, a, r, o, i, s, l, c, u;
        const {$el: f} = e;
        function d(v, y) {
            let w = (v - l.left) / l.width * 360
              , C = (y - l.top) / l.height;
            w = Math.max(0, Math.min(360, w)),
            C = 1 - Math.max(0, Math.min(1, C)),
            e.setValue({
                hsb: [w, C, e.value.hsb[2]]
            })
        }
        function p(v) {
            if (a || n)
                return;
            r = v.type === "touchstart" ? v.targetTouches[0].pageX : v.pageX,
            i = r,
            o = v.type === "touchstart" ? v.targetTouches[0].pageY : v.pageY,
            s = o;
            const y = $(v.target);
            u = y.closest(".color-picker-hs-spectrum-handle").length > 0,
            u || (c = y.closest(".color-picker-hs-spectrum").length > 0),
            c && (l = f.find(".color-picker-hs-spectrum")[0].getBoundingClientRect(),
            d(r, o)),
            (u || c) && f.find(".color-picker-hs-spectrum-handle").addClass("color-picker-hs-spectrum-handle-pressed")
        }
        function h(v) {
            (c || u) && (i = v.type === "touchmove" ? v.targetTouches[0].pageX : v.pageX,
            s = v.type === "touchmove" ? v.targetTouches[0].pageY : v.pageY,
            v.preventDefault(),
            a || (a = !0,
            u && (l = f.find(".color-picker-hs-spectrum")[0].getBoundingClientRect())),
            (c || u) && d(i, s))
        }
        function m() {
            a = !1,
            (c || u) && f.find(".color-picker-hs-spectrum-handle").removeClass("color-picker-hs-spectrum-handle-pressed"),
            c = !1,
            u = !1
        }
        function g() {
            e.modules["hs-spectrum"].update(e)
        }
        const b = t.touchEvents.start === "touchstart" && Mt().passiveListener ? {
            passive: !0,
            capture: !1
        } : !1;
        e.$el.on(t.touchEvents.start, p, b),
        t.on("touchmove:active", h),
        t.on("touchend:passive", m),
        t.on("resize", g),
        e.destroySpectrumEvents = function() {
            e.$el.off(t.touchEvents.start, p, b),
            t.off("touchmove:active", h),
            t.off("touchend:passive", m),
            t.off("resize", g)
        }
    },
    update(e) {
        const {value: t} = e
          , {hsb: n} = t
          , a = e.$el.find(".color-picker-hs-spectrum")[0].offsetWidth
          , r = e.$el.find(".color-picker-hs-spectrum")[0].offsetHeight
          , o = tr(n[0], n[1], 1);
        e.$el.find(".color-picker-hs-spectrum-handle").css("background-color", `hsl(${o[0]}, ${o[1] * 100}%, ${o[2] * 100}%)`).transform(`translate(${a * (n[0] / 360)}px, ${r * (1 - n[1])}px)`)
    },
    destroy(e) {
        e.destroySpectrumEvents && e.destroySpectrumEvents(),
        delete e.destroySpectrumEvents
    }
};
function jj() {
    let t = "";
    for (let n = 256; n > 0; n -= 1) {
        const a = n * Math.PI / 128
          , r = 360 / 256 * n;
        t += `<circle cx="${150 - Math.sin(a) * 125}" cy="${150 - Math.cos(a) * 125}" r="25" fill="hsl(${r}, 100%, 50%)"></circle>`
    }
    return t
}
const Uj = {
    render() {
        return R("div", {
            class: "color-picker-module color-picker-module-wheel"
        }, R("div", {
            class: "color-picker-wheel"
        }, R("svg", {
            viewBox: "0 0 300 300",
            width: "300",
            height: "300"
        }, jj()), R("div", {
            class: "color-picker-wheel-handle"
        }), R("div", {
            class: "color-picker-sb-spectrum",
            style: "background-color: hsl(0, 100%, 50%)"
        }, R("div", {
            class: "color-picker-sb-spectrum-handle"
        }))))
    },
    init(e) {
        const {app: t} = e;
        let n, a, r, o, i, s, l, c, u, f, d, p;
        const {$el: h} = e;
        function m(_, E) {
            const z = l.left + l.width / 2
              , T = l.top + l.height / 2;
            let x = Math.atan2(E - T, _ - z) * 180 / Math.PI + 90;
            x < 0 && (x += 360),
            x = 360 - x,
            e.setValue({
                hue: x
            })
        }
        function g(_, E) {
            let z = (_ - f.left) / f.width
              , T = (E - f.top) / f.height;
            z = Math.max(0, Math.min(1, z)),
            T = 1 - Math.max(0, Math.min(1, T)),
            e.setValue({
                hsb: [e.value.hue, z, T]
            })
        }
        function b(_) {
            if (a || n)
                return;
            r = _.type === "touchstart" ? _.targetTouches[0].pageX : _.pageX,
            i = r,
            o = _.type === "touchstart" ? _.targetTouches[0].pageY : _.pageY,
            s = o;
            const E = $(_.target);
            u = E.closest(".color-picker-wheel-handle").length > 0,
            c = E.closest("circle").length > 0,
            p = E.closest(".color-picker-sb-spectrum-handle").length > 0,
            p || (d = E.closest(".color-picker-sb-spectrum").length > 0),
            c && (l = h.find(".color-picker-wheel")[0].getBoundingClientRect(),
            m(r, o)),
            d && (f = h.find(".color-picker-sb-spectrum")[0].getBoundingClientRect(),
            g(r, o)),
            (p || d) && h.find(".color-picker-sb-spectrum-handle").addClass("color-picker-sb-spectrum-handle-pressed")
        }
        function v(_) {
            !(c || u) && !(d || p) || (i = _.type === "touchmove" ? _.targetTouches[0].pageX : _.pageX,
            s = _.type === "touchmove" ? _.targetTouches[0].pageY : _.pageY,
            _.preventDefault(),
            a || (a = !0,
            u && (l = h.find(".color-picker-wheel")[0].getBoundingClientRect()),
            p && (f = h.find(".color-picker-sb-spectrum")[0].getBoundingClientRect())),
            (c || u) && m(i, s),
            (d || p) && g(i, s))
        }
        function y() {
            a = !1,
            (d || p) && h.find(".color-picker-sb-spectrum-handle").removeClass("color-picker-sb-spectrum-handle-pressed"),
            c = !1,
            u = !1,
            d = !1,
            p = !1
        }
        function w() {
            e.modules.wheel.update(e)
        }
        const C = t.touchEvents.start === "touchstart" && Mt().passiveListener ? {
            passive: !0,
            capture: !1
        } : !1;
        e.$el.on(t.touchEvents.start, b, C),
        t.on("touchmove:active", v),
        t.on("touchend:passive", y),
        t.on("resize", w),
        e.destroyWheelEvents = function() {
            e.$el.off(t.touchEvents.start, b, C),
            t.off("touchmove:active", v),
            t.off("touchend:passive", y),
            t.off("resize", w)
        }
    },
    update(e) {
        const {value: t} = e
          , {hsl: n, hsb: a} = t
          , r = e.$el.find(".color-picker-sb-spectrum")[0].offsetWidth
          , o = e.$el.find(".color-picker-sb-spectrum")[0].offsetHeight
          , i = e.$el.find(".color-picker-wheel")[0].offsetWidth
          , s = i / 2
          , l = t.hue * Math.PI / 180
          , u = i / 6 / 2
          , f = s - Math.sin(l) * (s - u) - u
          , d = s - Math.cos(l) * (s - u) - u;
        e.$el.find(".color-picker-wheel-handle").css("background-color", `hsl(${n[0]}, 100%, 50%)`).transform(`translate(${f}px, ${d}px)`),
        e.$el.find(".color-picker-sb-spectrum").css("background-color", `hsl(${n[0]}, 100%, 50%)`),
        e.$el.find(".color-picker-sb-spectrum-handle").css("background-color", `hsl(${n[0]}, ${n[1] * 100}%, ${n[2] * 100}%)`).transform(`translate(${r * a[1]}px, ${o * (1 - a[2])}px)`)
    },
    destroy(e) {
        e.destroyWheelEvents && e.destroyWheelEvents(),
        delete e.destroyWheelEvents
    }
};
let e0 = class extends Bt {
    constructor(t, n) {
        n === void 0 && (n = {}),
        super(n, [t]);
        const a = this;
        a.params = se({}, t.params.colorPicker, n);
        let r;
        if (a.params.containerEl && (r = $(a.params.containerEl),
        r.length === 0))
            return a;
        let o;
        a.params.inputEl && (o = $(a.params.inputEl));
        let i;
        a.params.targetEl && (i = $(a.params.targetEl)),
        se(a, {
            app: t,
            $containerEl: r,
            containerEl: r && r[0],
            inline: r && r.length > 0,
            $inputEl: o,
            inputEl: o && o[0],
            $targetEl: i,
            targetEl: i && i[0],
            initialized: !1,
            opened: !1,
            url: a.params.url,
            modules: {
                "alpha-slider": Aj,
                "current-color": Oj,
                hex: Pj,
                "hsb-sliders": Lj,
                "hue-slider": Ij,
                "brightness-slider": Bj,
                palette: Rj,
                "initial-current-colors": Dj,
                "rgb-bars": Nj,
                "rgb-sliders": Hj,
                "sb-spectrum": Vj,
                "hs-spectrum": Fj,
                wheel: Uj
            }
        });
        function s() {
            a.open()
        }
        function l(f) {
            f.preventDefault()
        }
        function c() {
            a.open()
        }
        function u(f) {
            if (a.destroyed || !a.params || a.params.openIn === "page")
                return;
            const d = $(f.target);
            !a.opened || a.closing || d.closest('[class*="backdrop"]').length || d.closest(".color-picker-popup, .color-picker-popover").length || (o && o.length > 0 ? d[0] !== o[0] && d.closest(".sheet-modal").length === 0 && a.close() : $(f.target).closest(".sheet-modal").length === 0 && a.close())
        }
        return se(a, {
            attachInputEvents() {
                a.$inputEl.on("click", s),
                a.params.inputReadOnly && (a.$inputEl.on("focus mousedown", l),
                a.$inputEl[0] && (a.$inputEl[0].f7ValidateReadonly = !0))
            },
            detachInputEvents() {
                a.$inputEl.off("click", s),
                a.params.inputReadOnly && (a.$inputEl.off("focus mousedown", l),
                a.$inputEl[0] && delete a.$inputEl[0].f7ValidateReadonly)
            },
            attachTargetEvents() {
                a.$targetEl.on("click", c)
            },
            detachTargetEvents() {
                a.$targetEl.off("click", c)
            },
            attachHtmlEvents() {
                t.on("click", u)
            },
            detachHtmlEvents() {
                t.off("click", u)
            }
        }),
        a.init(),
        a
    }
    get view() {
        const {$inputEl: t, $targetEl: n, app: a, params: r} = this;
        let o;
        return r.view ? o = r.view : (t && (o = t.parents(".view").length && t.parents(".view")[0].f7View),
        !o && n && (o = n.parents(".view").length && n.parents(".view")[0].f7View)),
        o || (o = a.views.main),
        o
    }
    attachEvents() {
        const t = this;
        t.centerModules = t.centerModules.bind(t),
        t.params.centerModules && t.app.on("resize", t.centerModules)
    }
    detachEvents() {
        const t = this;
        t.params.centerModules && t.app.off("resize", t.centerModules)
    }
    centerModules() {
        const t = this;
        if (!t.opened || !t.$el || t.inline)
            return;
        const n = t.$el.find(".page-content");
        if (!n.length)
            return;
        const {scrollHeight: a, offsetHeight: r} = n[0];
        a <= r ? n.addClass("justify-content-center") : n.removeClass("justify-content-center")
    }
    initInput() {
        const t = this;
        t.$inputEl && t.params.inputReadOnly && t.$inputEl.prop("readOnly", !0)
    }
    getModalType() {
        const t = this
          , {app: n, modal: a, params: r} = t
          , {openIn: o, openInPhone: i} = r
          , s = yt();
        return a && a.type ? a.type : o !== "auto" ? o : t.inline ? null : s.ios ? s.ipad ? "popover" : i : n.width >= 768 || s.desktop && n.theme === "aurora" ? "popover" : i
    }
    formatValue() {
        const t = this
          , {value: n} = t;
        return t.params.formatValue ? t.params.formatValue.call(t, n) : n.hex
    }
    normalizeHsValues(t) {
        return [Math.floor(t[0] * 10) / 10, Math.floor(t[1] * 1e3) / 1e3, Math.floor(t[2] * 1e3) / 1e3]
    }
    setValue(t, n) {
        t === void 0 && (t = {}),
        n === void 0 && (n = !0);
        const a = this;
        if (typeof t > "u")
            return;
        let {hex: r, rgb: o, hsl: i, hsb: s, alpha: l=1, hue: c, rgba: u, hsla: f} = a.value || {};
        const d = a.value || !a.value && !a.params.value;
        let p;
        if (Object.keys(t).forEach(h => {
            if (!a.value || typeof a.value[h] > "u") {
                p = !0;
                return
            }
            const m = t[h];
            Array.isArray(m) ? m.forEach( (g, b) => {
                g !== a.value[h][b] && (p = !0)
            }
            ) : m !== a.value[h] && (p = !0)
        }
        ),
        !!p) {
            if (t.rgb || t.rgba) {
                const [h,m,g,b=l] = t.rgb || t.rgba;
                o = [h, m, g],
                r = Ja(...o),
                i = _1(...o),
                s = Ki(...i),
                i = a.normalizeHsValues(i),
                s = a.normalizeHsValues(s),
                c = s[0],
                l = b,
                u = [o[0], o[1], o[2], b],
                f = [i[0], i[1], i[2], b]
            }
            if (t.hsl || t.hsla) {
                const [h,m,g,b=l] = t.hsl || t.hsla;
                i = [h, m, g],
                o = ri(...i),
                r = Ja(...o),
                s = Ki(...i),
                i = a.normalizeHsValues(i),
                s = a.normalizeHsValues(s),
                c = s[0],
                l = b,
                u = [o[0], o[1], o[2], b],
                f = [i[0], i[1], i[2], b]
            }
            if (t.hsb) {
                const [h,m,g,b=l] = t.hsb;
                s = [h, m, g],
                i = tr(...s),
                o = ri(...i),
                r = Ja(...o),
                i = a.normalizeHsValues(i),
                s = a.normalizeHsValues(s),
                c = s[0],
                l = b,
                u = [o[0], o[1], o[2], b],
                f = [i[0], i[1], i[2], b]
            }
            if (t.hex && (o = xf(t.hex),
            r = Ja(...o),
            i = _1(...o),
            s = Ki(...i),
            i = a.normalizeHsValues(i),
            s = a.normalizeHsValues(s),
            c = s[0],
            u = [o[0], o[1], o[2], l],
            f = [i[0], i[1], i[2], l]),
            typeof t.alpha < "u" && (l = t.alpha,
            typeof o < "u" && (u = [o[0], o[1], o[2], l]),
            typeof i < "u" && (f = [i[0], i[1], i[2], l])),
            typeof t.hue < "u") {
                const [h,m,g] = i;
                i = [t.hue, m, g],
                s = Ki(...i),
                o = ri(...i),
                r = Ja(...o),
                i = a.normalizeHsValues(i),
                s = a.normalizeHsValues(s),
                c = s[0],
                u = [o[0], o[1], o[2], l],
                f = [i[0], i[1], i[2], l]
            }
            a.value = {
                hex: r,
                alpha: l,
                hue: c,
                rgb: o,
                hsl: i,
                hsb: s,
                rgba: u,
                hsla: f
            },
            a.initialValue || (a.initialValue = se({}, a.value)),
            a.updateValue(d),
            a.opened && n && a.updateModules()
        }
    }
    getValue() {
        return this.value
    }
    updateValue(t) {
        t === void 0 && (t = !0);
        const n = this
          , {$inputEl: a, value: r, $targetEl: o} = n;
        if (o && n.params.targetElSetBackgroundColor) {
            const {rgba: i} = r;
            o.css("background-color", `rgba(${i.join(", ")})`)
        }
        if (t && n.emit("local::change colorPickerChange", n, r),
        a && a.length) {
            const i = n.formatValue(r);
            a && a.length && (a.val(i),
            t && a.trigger("change"))
        }
    }
    updateModules() {
        const t = this
          , {modules: n} = t;
        t.params.modules.forEach(a => {
            typeof a == "string" && n[a] && n[a].update ? n[a].update(t) : a && a.update && a.update(t)
        }
        )
    }
    update() {
        this.updateModules()
    }
    renderPicker() {
        const t = this
          , {params: n, modules: a} = t;
        let r = "";
        return n.modules.forEach(o => {
            typeof o == "string" && a[o] && a[o].render ? r += a[o].render(t) : o && o.render && (r += o.render(t))
        }
        ),
        r
    }
    renderNavbar() {
        const t = this;
        if (t.params.renderNavbar)
            return t.params.renderNavbar.call(t, t);
        const {openIn: n, navbarTitleText: a, navbarBackLinkText: r, navbarCloseText: o} = t.params;
        return R("div", {
            class: "navbar"
        }, R("div", {
            class: "navbar-bg"
        }), R("div", {
            class: "navbar-inner sliding"
        }, n === "page" && R("div", {
            class: "left"
        }, R("a", {
            class: "link back"
        }, R("i", {
            class: "icon icon-back"
        }), R("span", {
            class: "if-not-md"
        }, r))), R("div", {
            class: "title"
        }, a), n !== "page" && R("div", {
            class: "right"
        }, R("a", {
            class: "link popup-close",
            "data-popup": ".color-picker-popup"
        }, o))))
    }
    renderToolbar() {
        const t = this;
        return t.params.renderToolbar ? t.params.renderToolbar.call(t, t) : R("div", {
            class: "toolbar toolbar-top no-shadow"
        }, R("div", {
            class: "toolbar-inner"
        }, R("div", {
            class: "left"
        }), R("div", {
            class: "right"
        }, R("a", {
            class: "link sheet-close popover-close",
            "data-sheet": ".color-picker-sheet-modal",
            "data-popover": ".color-picker-popover"
        }, t.params.toolbarCloseText))))
    }
    renderInline() {
        const t = this
          , {cssClass: n, groupedModules: a} = t.params;
        return R("div", {
            class: `color-picker color-picker-inline ${a ? "color-picker-grouped-modules" : ""} ${n || ""}`
        }, t.renderPicker())
    }
    renderSheet() {
        const t = this
          , {cssClass: n, toolbarSheet: a, groupedModules: r} = t.params;
        return R("div", {
            class: `sheet-modal color-picker color-picker-sheet-modal ${r ? "color-picker-grouped-modules" : ""} ${n || ""}`
        }, a && t.renderToolbar(), R("div", {
            class: "sheet-modal-inner"
        }, R("div", {
            class: "page-content"
        }, t.renderPicker())))
    }
    renderPopover() {
        const t = this
          , {cssClass: n, toolbarPopover: a, groupedModules: r} = t.params;
        return R("div", {
            class: `popover color-picker-popover ${n || ""}`
        }, R("div", {
            class: "popover-inner"
        }, R("div", {
            class: `color-picker ${r ? "color-picker-grouped-modules" : ""}`
        }, a && t.renderToolbar(), R("div", {
            class: "page-content"
        }, t.renderPicker()))))
    }
    renderPopup() {
        const t = this
          , {cssClass: n, navbarPopup: a, groupedModules: r} = t.params;
        return R("div", {
            class: `popup color-picker-popup ${n || ""}`
        }, R("div", {
            class: "page"
        }, a && t.renderNavbar(), R("div", {
            class: `color-picker ${r ? "color-picker-grouped-modules" : ""}`
        }, R("div", {
            class: "page-content"
        }, t.renderPicker()))))
    }
    renderPage() {
        const t = this
          , {cssClass: n, groupedModules: a} = t.params;
        return R("div", {
            class: `page color-picker-page ${n || ""}`,
            "data-name": "color-picker-page"
        }, t.renderNavbar(), R("div", {
            class: `color-picker ${a ? "color-picker-grouped-modules" : ""}`
        }, R("div", {
            class: "page-content"
        }, t.renderPicker())))
    }
    render() {
        const t = this
          , {params: n} = t;
        if (n.render)
            return n.render.call(t);
        if (t.inline)
            return t.renderInline();
        if (n.openIn === "page")
            return t.renderPage();
        const a = t.getModalType();
        if (a === "popover")
            return t.renderPopover();
        if (a === "sheet")
            return t.renderSheet();
        if (a === "popup")
            return t.renderPopup()
    }
    onOpen() {
        const t = this
          , {initialized: n, $el: a, app: r, $inputEl: o, inline: i, value: s, params: l, modules: c} = t;
        t.closing = !1,
        t.opened = !0,
        t.opening = !0,
        t.attachEvents(),
        l.modules.forEach(f => {
            typeof f == "string" && c[f] && c[f].init ? c[f].init(t) : f && f.init && f.init(t)
        }
        );
        const u = !s && l.value;
        n ? s && (t.initialValue = se({}, s),
        t.setValue(s, !1)) : s ? t.setValue(s) : l.value ? t.setValue(l.value, !1) : l.value || t.setValue({
            hex: "#ff0000"
        }, !1),
        u && t.updateValue(),
        t.updateModules(),
        l.centerModules && t.centerModules(),
        !i && o && o.length && r.theme === "md" && o.trigger("focus"),
        t.initialized = !0,
        a && a.trigger("colorpicker:open"),
        o && o.trigger("colorpicker:open"),
        t.emit("local::open colorPickerOpen", t)
    }
    onOpened() {
        const t = this;
        t.opening = !1,
        t.$el && t.$el.trigger("colorpicker:opened"),
        t.$inputEl && t.$inputEl.trigger("colorpicker:opened"),
        t.emit("local::opened colorPickerOpened", t)
    }
    onClose() {
        const t = this
          , {app: n, params: a, modules: r} = t;
        if (t.opening = !1,
        t.closing = !0,
        t.detachEvents(),
        t.$inputEl)
            if (n.theme === "md")
                t.$inputEl.trigger("blur");
            else {
                const o = t.$inputEl.attr("validate")
                  , i = t.$inputEl.attr("required");
                o && i && n.input.validate(t.$inputEl)
            }
        a.modules.forEach(o => {
            typeof o == "string" && r[o] && r[o].destroy ? r[o].destroy(t) : o && o.destroy && o.destroy(t)
        }
        ),
        t.$el && t.$el.trigger("colorpicker:close"),
        t.$inputEl && t.$inputEl.trigger("colorpicker:close"),
        t.emit("local::close colorPickerClose", t)
    }
    onClosed() {
        const t = this;
        t.opened = !1,
        t.closing = !1,
        t.inline || un( () => {
            t.modal && t.modal.el && t.modal.destroy && (t.params.routableModals || t.modal.destroy()),
            delete t.modal
        }
        ),
        t.$el && t.$el.trigger("colorpicker:closed"),
        t.$inputEl && t.$inputEl.trigger("colorpicker:closed"),
        t.emit("local::closed colorPickerClosed", t)
    }
    open() {
        const t = this
          , {app: n, opened: a, inline: r, $inputEl: o, $targetEl: i, params: s} = t;
        if (a)
            return;
        if (r) {
            t.$el = $(t.render()),
            t.$el[0].f7ColorPicker = t,
            t.$containerEl.append(t.$el),
            t.onOpen(),
            t.onOpened();
            return
        }
        const l = t.render();
        if (s.openIn === "page")
            t.view.router.navigate({
                url: t.url,
                route: {
                    content: l,
                    path: t.url,
                    on: {
                        pageBeforeIn(c, u) {
                            t.$el = u.$el.find(".color-picker"),
                            t.$el[0].f7ColorPicker = t,
                            t.onOpen()
                        },
                        pageAfterIn() {
                            t.onOpened()
                        },
                        pageBeforeOut() {
                            t.onClose()
                        },
                        pageAfterOut() {
                            t.onClosed(),
                            t.$el && t.$el[0] && (t.$el[0].f7ColorPicker = null,
                            delete t.$el[0].f7ColorPicker)
                        }
                    }
                }
            });
        else {
            const c = t.getModalType();
            let u = s.backdrop;
            (u === null || typeof u > "u") && (c === "popover" && n.params.popover.backdrop !== !1 && (u = !0),
            c === "popup" && (u = !0));
            const f = {
                targetEl: i || o,
                scrollToEl: s.scrollToInput ? i || o : void 0,
                content: l,
                backdrop: u,
                closeByBackdropClick: s.closeByBackdropClick,
                on: {
                    open() {
                        const d = this;
                        t.modal = d,
                        t.$el = c === "popover" || c === "popup" ? d.$el.find(".color-picker") : d.$el,
                        t.$el[0].f7ColorPicker = t,
                        t.onOpen()
                    },
                    opened() {
                        t.onOpened()
                    },
                    close() {
                        t.onClose()
                    },
                    closed() {
                        t.onClosed(),
                        t.$el && t.$el[0] && (t.$el[0].f7ColorPicker = null,
                        delete t.$el[0].f7ColorPicker)
                    }
                }
            };
            c === "popup" && (f.push = s.popupPush,
            f.swipeToClose = s.popupSwipeToClose),
            c === "sheet" && (f.push = s.sheetPush,
            f.swipeToClose = s.sheetSwipeToClose),
            s.routableModals && t.view ? t.view.router.navigate({
                url: t.url,
                route: {
                    path: t.url,
                    [c]: f
                }
            }) : (t.modal = n[c].create(f),
            t.modal.open())
        }
    }
    close() {
        const t = this
          , {opened: n, inline: a} = t;
        if (n) {
            if (a) {
                t.onClose(),
                t.onClosed();
                return
            }
            t.params.routableModals && t.view || t.params.openIn === "page" ? t.view.router.back() : t.modal.close()
        }
    }
    init() {
        const t = this;
        if (t.initInput(),
        t.inline) {
            t.open(),
            t.emit("local::init colorPickerInit", t);
            return
        }
        !t.initialized && t.params.value && t.setValue(t.params.value),
        t.$inputEl && t.attachInputEvents(),
        t.$targetEl && t.attachTargetEvents(),
        t.params.closeByOutsideClick && t.attachHtmlEvents(),
        t.emit("local::init colorPickerInit", t)
    }
    destroy() {
        const t = this;
        if (t.destroyed)
            return;
        const {$el: n} = t;
        t.emit("local::beforeDestroy colorPickerBeforeDestroy", t),
        n && n.trigger("colorpicker:beforedestroy"),
        t.close(),
        t.detachEvents(),
        t.$inputEl && t.detachInputEvents(),
        t.$targetEl && t.detachTargetEvents(),
        t.params.closeByOutsideClick && t.detachHtmlEvents(),
        n && n.length && delete t.$el[0].f7ColorPicker,
        Yt(t),
        t.destroyed = !0
    }
}
;
const qj = {
    name: "colorPicker",
    static: {
        ColorPicker: e0
    },
    create() {
        const e = this;
        e.colorPicker = Gt({
            defaultSelector: ".color-picker",
            constructor: e0,
            app: e,
            domProp: "f7ColorPicker"
        }),
        e.colorPicker.close = function(n) {
            n === void 0 && (n = ".color-picker");
            const a = $(n);
            if (a.length === 0)
                return;
            const r = a[0].f7ColorPicker;
            !r || r && !r.opened || r.close()
        }
    },
    params: {
        colorPicker: {
            value: null,
            modules: ["wheel"],
            palette: [["#FFEBEE", "#FFCDD2", "#EF9A9A", "#E57373", "#EF5350", "#F44336", "#E53935", "#D32F2F", "#C62828", "#B71C1C"], ["#F3E5F5", "#E1BEE7", "#CE93D8", "#BA68C8", "#AB47BC", "#9C27B0", "#8E24AA", "#7B1FA2", "#6A1B9A", "#4A148C"], ["#E8EAF6", "#C5CAE9", "#9FA8DA", "#7986CB", "#5C6BC0", "#3F51B5", "#3949AB", "#303F9F", "#283593", "#1A237E"], ["#E1F5FE", "#B3E5FC", "#81D4FA", "#4FC3F7", "#29B6F6", "#03A9F4", "#039BE5", "#0288D1", "#0277BD", "#01579B"], ["#E0F2F1", "#B2DFDB", "#80CBC4", "#4DB6AC", "#26A69A", "#009688", "#00897B", "#00796B", "#00695C", "#004D40"], ["#F1F8E9", "#DCEDC8", "#C5E1A5", "#AED581", "#9CCC65", "#8BC34A", "#7CB342", "#689F38", "#558B2F", "#33691E"], ["#FFFDE7", "#FFF9C4", "#FFF59D", "#FFF176", "#FFEE58", "#FFEB3B", "#FDD835", "#FBC02D", "#F9A825", "#F57F17"], ["#FFF3E0", "#FFE0B2", "#FFCC80", "#FFB74D", "#FFA726", "#FF9800", "#FB8C00", "#F57C00", "#EF6C00", "#E65100"]],
            groupedModules: !1,
            centerModules: !0,
            sliderLabel: !1,
            sliderValue: !1,
            sliderValueEdiable: !1,
            barLabel: !1,
            barValue: !1,
            barValueEdiable: !1,
            hexLabel: !1,
            hexValueEditable: !1,
            redLabelText: "R",
            greenLabelText: "G",
            blueLabelText: "B",
            hueLabelText: "H",
            saturationLabelText: "S",
            brightnessLabelText: "B",
            hexLabelText: "HEX",
            alphaLabelText: "A",
            containerEl: null,
            openIn: "popover",
            openInPhone: "popup",
            popupPush: !1,
            popupSwipeToClose: void 0,
            sheetPush: !1,
            sheetSwipeToClose: void 0,
            formatValue: null,
            targetEl: null,
            targetElSetBackgroundColor: !1,
            inputEl: null,
            inputReadOnly: !0,
            closeByOutsideClick: !0,
            scrollToInput: !0,
            toolbarSheet: !0,
            toolbarPopover: !1,
            toolbarCloseText: "Done",
            navbarPopup: !0,
            navbarCloseText: "Done",
            navbarTitleText: "Color",
            navbarBackLinkText: "Back",
            cssClass: null,
            routableModals: !1,
            view: null,
            url: "color/",
            backdrop: null,
            closeByBackdropClick: !0,
            renderToolbar: null,
            renderNavbar: null,
            renderInline: null,
            renderPopover: null,
            renderSheet: null,
            renderPopup: null,
            render: null
        }
    }
}
  , Wj = {
    open(e) {
        const t = this
          , n = $(e).eq(0);
        if (!n.length)
            return;
        n.addClass("treeview-item-opened"),
        n.trigger("treeview:open"),
        t.emit("treeviewOpen", n[0]);
        function a(r) {
            r ? (n.removeClass("treeview-item-opened"),
            n.trigger("treeview:close"),
            t.emit("treeviewClose", n[0])) : n[0].f7TreeviewChildrenLoaded = !0,
            n.find(".treeview-toggle").removeClass("treeview-toggle-hidden"),
            n.find(".treeview-preloader").remove()
        }
        if (n.hasClass("treeview-load-children") && !n[0].f7TreeviewChildrenLoaded) {
            const r = {
                iosPreloaderContent: ho,
                mdPreloaderContent: po,
                auroraPreloaderContent: mo
            };
            n.trigger("treeview:loadchildren", a),
            t.emit("treeviewLoadChildren", n[0], a),
            n.find(".treeview-toggle").addClass("treeview-toggle-hidden"),
            n.find(".treeview-item-root").prepend(`<div class="preloader treeview-preloader">${r[`${t.theme}PreloaderContent`]}</div>`)
        }
    },
    close(e) {
        const t = this
          , n = $(e).eq(0);
        n.length && (n.removeClass("treeview-item-opened"),
        n.trigger("treeview:close"),
        t.emit("treeviewClose", n[0]))
    },
    toggle(e) {
        const t = this
          , n = $(e).eq(0);
        if (!n.length)
            return;
        const a = n.hasClass("treeview-item-opened");
        t.treeview[a ? "close" : "open"](n)
    }
}
  , Yj = {
    name: "treeview",
    create() {
        hn(this, {
            treeview: Wj
        })
    },
    clicks: {
        ".treeview-toggle": function(t, n, a) {
            const r = this;
            if (t.parents(".treeview-item-toggle").length)
                return;
            const o = t.parents(".treeview-item").eq(0);
            o.length && (a.preventF7Router = !0,
            r.treeview.toggle(o[0]))
        },
        ".treeview-item-toggle": function(t, n, a) {
            const r = this
              , o = t.closest(".treeview-item").eq(0);
            o.length && (a.preventF7Router = !0,
            r.treeview.toggle(o[0]))
        }
    }
}
  , Vl = {
    bold: ["bold", "format_bold", "bold"],
    italic: ["italic", "format_italic", "italic"],
    underline: ["underline", "format_underlined", "underline"],
    strikeThrough: ["strikethrough", "strikethrough_s", "strikeThrough"],
    orderedList: ["list_number", "format_list_numbered", "insertOrderedList"],
    unorderedList: ["list_bullet", "format_list_bulleted", "insertUnorderedList"],
    link: ["link", "link", "createLink"],
    image: ["photo", "image", "insertImage"],
    paragraph: ["paragraph", '<i class="icon"></i>', "formatBlock.P"],
    h1: ['<i class="icon">H<sub>1</sub></i>', '<i class="icon">H<sub>1</sub></i>', "formatBlock.H1"],
    h2: ['<i class="icon">H<sub>2</sub></i>', '<i class="icon">H<sub>2</sub></i>', "formatBlock.H2"],
    h3: ['<i class="icon">H<sub>3</sub></i>', '<i class="icon">H<sub>3</sub></i>', "formatBlock.H3"],
    alignLeft: ["text_alignleft", "format_align_left", "justifyLeft"],
    alignCenter: ["text_aligncenter", "format_align_center", "justifyCenter"],
    alignRight: ["text_alignright", "format_align_right", "justifyRight"],
    alignJustify: ["text_justify", "format_align_justify", "justifyFull"],
    subscript: ["textformat_subscript", '<i class="icon">A<sub>1</sub></i>', "subscript"],
    superscript: ["textformat_superscript", '<i class="icon">A<sup>1</sup></i>', "superscript"],
    indent: ["increase_indent", "format_indent_increase", "indent"],
    outdent: ["decrease_indent", "format_indent_decrease", "outdent"]
};
let t0 = class extends Bt {
    constructor(t, n) {
        super(n, [t]);
        const a = this
          , r = Qe()
          , o = yt()
          , i = se({}, t.params.textEditor);
        a.useModulesParams(i),
        a.params = se(i, n);
        const s = a.params.el;
        if (!s)
            return a;
        const l = $(s);
        if (l.length === 0)
            return a;
        if (l[0].f7TextEditor)
            return l[0].f7TextEditor;
        let c = l.children(".text-editor-content");
        if (c.length || (l.append('<div class="text-editor-content" contenteditable></div>'),
        c = l.children(".text-editor-content")),
        se(a, {
            app: t,
            $el: l,
            el: l[0],
            $contentEl: c,
            contentEl: c[0]
        }),
        "value"in n && (a.value = a.params.value),
        a.params.mode === "keyboard-toolbar" && !(o.cordova || o.capacitor) && !o.android && (a.params.mode = "popover"),
        typeof a.params.buttons == "string")
            try {
                a.params.buttons = JSON.parse(a.params.buttons)
            } catch {
                throw new Error('Framework7: TextEditor: wrong "buttons" parameter format')
            }
        return l[0].f7TextEditor = a,
        a.onButtonClick = a.onButtonClick.bind(a),
        a.onFocus = a.onFocus.bind(a),
        a.onBlur = a.onBlur.bind(a),
        a.onInput = a.onInput.bind(a),
        a.onPaste = a.onPaste.bind(a),
        a.onSelectionChange = a.onSelectionChange.bind(a),
        a.closeKeyboardToolbar = a.closeKeyboardToolbar.bind(a),
        a.attachEvents = function() {
            a.params.mode === "toolbar" && a.$el.find(".text-editor-toolbar").on("click", "button", a.onButtonClick),
            a.params.mode === "keyboard-toolbar" && (a.$keyboardToolbarEl.on("click", "button", a.onButtonClick),
            a.$el.parents(".page").on("page:beforeout", a.closeKeyboardToolbar)),
            a.params.mode === "popover" && a.popover && a.popover.$el.on("click", "button", a.onButtonClick),
            a.$contentEl.on("paste", a.onPaste),
            a.$contentEl.on("focus", a.onFocus),
            a.$contentEl.on("blur", a.onBlur),
            a.$contentEl.on("input", a.onInput, !0),
            $(r).on("selectionchange", a.onSelectionChange)
        }
        ,
        a.detachEvents = function() {
            a.params.mode === "toolbar" && a.$el.find(".text-editor-toolbar").off("click", "button", a.onButtonClick),
            a.params.mode === "keyboard-toolbar" && (a.$keyboardToolbarEl.off("click", "button", a.onButtonClick),
            a.$el.parents(".page").off("page:beforeout", a.closeKeyboardToolbar)),
            a.params.mode === "popover" && a.popover && a.popover.$el.off("click", "button", a.onButtonClick),
            a.$contentEl.off("paste", a.onPaste),
            a.$contentEl.off("focus", a.onFocus),
            a.$contentEl.off("blur", a.onBlur),
            a.$contentEl.off("input", a.onInput, !0),
            $(r).off("selectionchange", a.onSelectionChange)
        }
        ,
        a.useModules(),
        a.init(),
        a
    }
    setValue(t) {
        const n = this;
        return n.value === t || (n.value = t,
        n.$contentEl.html(t),
        n.$el.trigger("texteditor:change", n.value),
        n.emit("local::change textEditorChange", n, n.value)),
        n
    }
    getValue() {
        return this.value
    }
    clearValue() {
        const t = this;
        return t.setValue(""),
        t.params.placeholder && !t.$contentEl.html() && t.insertPlaceholder(),
        t
    }
    createLink() {
        const t = this
          , n = He()
          , a = Qe()
          , r = n.getSelection()
          , o = [];
        let i;
        if (r && r.anchorNode && $(r.anchorNode).parents(t.$el).length) {
            let c = r.anchorNode;
            for (; c; )
                o.push(c),
                (!c.nextSibling || c === r.focusNode) && (c = null),
                c && (c = c.nextSibling);
            const u = []
              , f = $(o);
            for (let d = 0; d < f.length; d += 1) {
                const p = f[d].children;
                if (p)
                    for (let h = 0; h < p.length; h += 1)
                        $(p[h]).is("a") && u.push(p[h])
            }
            i = f.closest("a").add($(u))
        }
        if (i && i.length)
            return i.each(c => {
                const u = n.getSelection()
                  , f = a.createRange();
                f.selectNodeContents(c),
                u.removeAllRanges(),
                u.addRange(f),
                a.execCommand("unlink", !1),
                u.removeAllRanges()
            }
            ),
            t;
        const s = t.getSelectionRange();
        return s && t.app.dialog.prompt(t.params.linkUrlText, "", c => {
            c && c.trim().length && (t.setSelectionRange(s),
            a.execCommand("createLink", !1, c.trim()),
            t.$el.trigger("texteditor:insertlink", {
                url: c.trim()
            }),
            t.emit("local:insertLink textEditorInsertLink", t, c.trim()))
        }
        ).$el.find("input").focus(),
        t
    }
    insertImage() {
        const t = this
          , n = Qe()
          , a = t.getSelectionRange();
        return a && t.app.dialog.prompt(t.params.imageUrlText, "", o => {
            o && o.trim().length && (t.setSelectionRange(a),
            n.execCommand("insertImage", !1, o.trim()),
            t.$el.trigger("texteditor:insertimage", {
                url: o.trim()
            }),
            t.emit("local:insertImage textEditorInsertImage", t, o.trim()))
        }
        ).$el.find("input").focus(),
        t
    }
    removePlaceholder() {
        this.$contentEl.find(".text-editor-placeholder").remove()
    }
    insertPlaceholder() {
        const t = this;
        t.$contentEl.append(`<div class="text-editor-placeholder">${t.params.placeholder}</div>`)
    }
    onSelectionChange() {
        const t = this
          , n = He()
          , a = Qe();
        if (t.params.mode === "toolbar")
            return;
        const r = n.getSelection()
          , o = $(r.anchorNode).parents(t.contentEl).length || r.anchorNode === t.contentEl;
        if (t.params.mode === "keyboard-toolbar") {
            o ? t.openKeyboardToolbar() : t.closeKeyboardToolbar();
            return
        }
        if (t.params.mode === "popover") {
            const i = $(r.anchorNode).parents(t.popover.el).length || r.anchorNode === t.popover.el;
            if (!o && !i) {
                t.closePopover();
                return
            }
            if (!r.isCollapsed && r.rangeCount) {
                const l = r.getRangeAt(0).getBoundingClientRect()
                  , c = t.app.$el[0] || a.body;
                t.openPopover(l.x + (n.scrollX || 0) - c.offsetLeft, l.y + (n.scrollY || 0) - c.offsetTop, l.width, l.height)
            } else
                r.isCollapsed && t.closePopover()
        }
    }
    onPaste(t) {
        const n = this
          , a = Qe();
        if (n.params.clearFormattingOnPaste && t.clipboardData && t.clipboardData.getData) {
            const r = t.clipboardData.getData("text/plain");
            t.preventDefault(),
            a.execCommand("insertText", !1, r)
        }
    }
    onInput() {
        const t = this
          , n = t.$contentEl.html();
        t.value = n,
        t.$el.trigger("texteditor:input"),
        t.emit("local:input textEditorInput", t, t.value),
        t.$el.trigger("texteditor:change", t.value),
        t.emit("local::change textEditorChange", t, t.value)
    }
    onFocus() {
        const t = this;
        t.removePlaceholder(),
        t.$contentEl.focus(),
        t.$el.trigger("texteditor:focus"),
        t.emit("local::focus textEditorFocus", t)
    }
    onBlur() {
        const t = this
          , n = He()
          , a = Qe();
        if (t.params.placeholder && t.$contentEl.html() === "" && t.insertPlaceholder(),
        t.params.mode === "popover") {
            const r = n.getSelection()
              , o = $(r.anchorNode).parents(t.contentEl).length || r.anchorNode === t.contentEl;
            !(a.activeElement && t.popover && $(a.activeElement).closest(t.popover.$el).length) && !o && t.closePopover()
        }
        if (t.params.mode === "keyboard-toolbar") {
            const r = n.getSelection();
            $(r.anchorNode).parents(t.contentEl).length || r.anchorNode === t.contentEl || t.closeKeyboardToolbar()
        }
        t.$el.trigger("texteditor:blur"),
        t.emit("local::blur textEditorBlur", t)
    }
    onButtonClick(t) {
        const n = this
          , a = He()
          , r = Qe()
          , o = a.getSelection();
        if (!($(o.anchorNode).parents(n.contentEl).length || o.anchorNode === n.contentEl))
            return;
        const s = $(t.target).closest("button");
        s.parents("form").length && t.preventDefault();
        const l = s.attr("data-button")
          , c = n.params.customButtons && n.params.customButtons[l];
        if (!l || !(Vl[l] || c))
            return;
        if (s.trigger("texteditor:buttonclick", l),
        n.emit("local::buttonClick textEditorButtonClick", n, l),
        c) {
            c.onClick && c.onClick(n, s[0]);
            return
        }
        const u = Vl[l][2];
        if (u === "createLink") {
            n.createLink();
            return
        }
        if (u === "insertImage") {
            n.insertImage();
            return
        }
        if (u.indexOf("formatBlock") === 0) {
            const f = u.split(".")[1]
              , d = $(o.anchorNode);
            d.parents(f.toLowerCase()).length || d.is(f) ? r.execCommand("formatBlock", !1, "div") : r.execCommand("formatBlock", !1, f);
            return
        }
        r.execCommand(u, !1)
    }
    getSelectionRange() {
        const t = He()
          , n = Qe();
        if (t.getSelection) {
            const a = t.getSelection();
            if (a.getRangeAt && a.rangeCount)
                return a.getRangeAt(0)
        } else if (n.selection && n.selection.createRange)
            return n.selection.createRange();
        return null
    }
    setSelectionRange(t) {
        const n = He()
          , a = Qe();
        if (t)
            if (n.getSelection) {
                const r = n.getSelection();
                r.removeAllRanges(),
                r.addRange(t)
            } else
                a.selection && t.select && t.select()
    }
    renderButtons() {
        const t = this;
        let n = "";
        function a(r) {
            const o = t.app.theme === "md" ? "material-icons" : "f7-icons";
            if (t.params.customButtons && t.params.customButtons[r]) {
                const s = t.params.customButtons[r];
                return `<button type="button" class="text-editor-button" data-button="${r}">${s.content || ""}</button>`
            }
            if (!Vl[r])
                return "";
            const i = Vl[r][t.app.theme === "md" ? 1 : 0];
            return `<button type="button" class="text-editor-button" data-button="${r}">${i.indexOf("<") >= 0 ? i : `<i class="${o}">${i}</i>`}</button>`.trim()
        }
        return t.params.buttons.forEach( (r, o) => {
            Array.isArray(r) ? (r.forEach(i => {
                n += a(i)
            }
            ),
            o < t.params.buttons.length - 1 && t.params.dividers && (n += '<div class="text-editor-button-divider"></div>')) : n += a(r)
        }
        ),
        n
    }
    createToolbar() {
        const t = this;
        t.$el.prepend(`<div class="text-editor-toolbar">${t.renderButtons()}</div>`)
    }
    createKeyboardToolbar() {
        const t = this;
        t.$keyboardToolbarEl = $(`<div class="toolbar toolbar-bottom text-editor-keyboard-toolbar"><div class="toolbar-inner">${t.renderButtons()}</div></div>`)
    }
    createPopover() {
        const t = this;
        t.popover = t.app.popover.create({
            content: `
        <div class="popover dark text-editor-popover">
          <div class="popover-inner">${t.renderButtons()}</div>
        </div>
      `,
            closeByOutsideClick: !1,
            backdrop: !1
        })
    }
    openKeyboardToolbar() {
        const t = this;
        t.$keyboardToolbarEl.parent(t.app.$el).length || (t.$el.trigger("texteditor:keyboardopen"),
        t.emit("local::keyboardOpen textEditorKeyboardOpen", t),
        t.app.$el.append(t.$keyboardToolbarEl))
    }
    closeKeyboardToolbar() {
        const t = this;
        t.$keyboardToolbarEl.remove(),
        t.$el.trigger("texteditor:keyboardclose"),
        t.emit("local::keyboardClose textEditorKeyboardClose", t)
    }
    openPopover(t, n, a, r) {
        const o = this;
        o.popover && (Object.assign(o.popover.params, {
            targetX: t,
            targetY: n,
            targetWidth: a,
            targetHeight: r
        }),
        clearTimeout(o.popoverTimeout),
        o.popoverTimeout = setTimeout( () => {
            o.popover && (o.popover.opened ? o.popover.resize() : (o.$el.trigger("texteditor:popoveropen"),
            o.emit("local::popoverOpen textEditorPopoverOpen", o),
            o.popover.open()))
        }
        , 400))
    }
    closePopover() {
        const t = this;
        clearTimeout(t.popoverTimeout),
        !(!t.popover || !t.popover.opened) && (t.popoverTimeout = setTimeout( () => {
            t.popover && (t.$el.trigger("texteditor:popoverclose"),
            t.emit("local::popoverClose textEditorPopoverClose", t),
            t.popover.close())
        }
        , 400))
    }
    init() {
        const t = this;
        return t.value ? t.$contentEl.html(t.value) : t.value = t.$contentEl.html(),
        t.params.placeholder && t.value === "" && t.insertPlaceholder(),
        t.params.mode === "toolbar" ? t.createToolbar() : t.params.mode === "popover" ? t.createPopover() : t.params.mode === "keyboard-toolbar" && t.createKeyboardToolbar(),
        t.attachEvents(),
        t.$el.trigger("texteditor:init"),
        t.emit("local::init textEditorInit", t),
        t
    }
    destroy() {
        let t = this;
        t.$el.trigger("texteditor:beforedestroy"),
        t.emit("local::beforeDestroy textEditorBeforeDestroy", t),
        t.detachEvents(),
        t.params.mode === "keyboard-toolbar" && t.$keyboardToolbarEl && t.$keyboardToolbarEl.remove(),
        t.popover && (t.popover.close(!1),
        t.popover.destroy()),
        delete t.$el[0].f7TextEditor,
        Yt(t),
        t = null
    }
}
;
const Gj = {
    name: "textEditor",
    params: {
        textEditor: {
            el: null,
            mode: "toolbar",
            value: void 0,
            customButtons: null,
            buttons: [["bold", "italic", "underline", "strikeThrough"], ["orderedList", "unorderedList"], ["link", "image"], ["paragraph", "h1", "h2", "h3"], ["alignLeft", "alignCenter", "alignRight", "alignJustify"], ["subscript", "superscript"], ["indent", "outdent"]],
            dividers: !0,
            imageUrlText: "Insert image URL",
            linkUrlText: "Insert link URL",
            placeholder: null,
            clearFormattingOnPaste: !0
        }
    },
    create() {
        const e = this;
        e.textEditor = se(Gt({
            defaultSelector: ".text-editor",
            constructor: t0,
            app: e,
            domProp: "f7TextEditor"
        }))
    },
    static: {
        TextEditor: t0
    },
    on: {
        tabMounted(e) {
            const t = this;
            $(e).find(".text-editor-init").each(n => {
                const a = $(n).dataset();
                t.textEditor.create(se({
                    el: n
                }, a || {}))
            }
            )
        },
        tabBeforeRemove(e) {
            $(e).find(".text-editor-init").each(t => {
                t.f7TextEditor && t.f7TextEditor.destroy()
            }
            )
        },
        pageInit(e) {
            const t = this;
            e.$el.find(".text-editor-init").each(n => {
                const a = $(n).dataset();
                t.textEditor.create(se({
                    el: n
                }, a || {}))
            }
            )
        },
        pageBeforeRemove(e) {
            e.$el.find(".text-editor-init").each(t => {
                t.f7TextEditor && t.f7TextEditor.destroy()
            }
            )
        }
    },
    vnode: {
        "text-editor-init": {
            insert(e) {
                const t = this
                  , n = e.elm
                  , a = $(n).dataset();
                t.textEditor.create(se({
                    el: n
                }, a || {}))
            },
            destroy(e) {
                const t = e.elm;
                t.f7TextEditor && t.f7TextEditor.destroy()
            }
        }
    }
}
  , Xj = {}
  , Kj = {
    name: "breadrumbs",
    create() {
        hn(this, {
            breadrumbs: Xj
        })
    }
}
  , Zj = {
    name: "elevation"
}
  , Jj = {
    name: "typography"
};
an.use([_F, kF, SF, $F, EF, xF, TF, MF, zF, OF, LF, IF, BF, RF, DF, NF, HF, FF, qF, YF, GF, JF, QF, ej, tj, nj, aj, rj, oj, sj, lj, uj, dj, pj, mj, gj, bj, yj, Cj, wj, kj, Sj, $j, Ej, xj, Tj, zj, qj, Yj, Gj, Kj, Zj, Jj]);
ET.add(jT);
an.use(Z2);
const hd = q5(wF)
  , Qj = eb();
YE(hd);
b3.isScrollSupported && b3.enable();
hd.directive("debounce", qM({
    lock: !0
})).component("FontAwesomeIcon", FT).component("RecycleScroller", dc).use(Qj).use(DM, {
    attempt: 1,
    lazyComponent: !0,
    error: "./icons/tweakicon.png"
});
hd.mount("#app");
